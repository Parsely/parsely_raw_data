2018-01-04 21:04:06,764: Tracking: tracking
2018-01-04 21:04:06,765: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31321be10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31321bf90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31321bed0>], 'label': 'start'}
2018-01-04 21:04:06,975: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 21:04:07,042: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 21:04:07,064: Parsing core.sql
2018-01-04 21:04:07,115: Parsing etc/get_custom_schema.sql
2018-01-04 21:04:07,139: Parsing schema_tests/relationships.sql
2018-01-04 21:04:07,151: Parsing schema_tests/accepted_values.sql
2018-01-04 21:04:07,161: Parsing schema_tests/not_null.sql
2018-01-04 21:04:07,166: Parsing schema_tests/unique.sql
2018-01-04 21:04:07,175: Parsing materializations/wrapper.sql
2018-01-04 21:04:07,189: Parsing materializations/archive.sql
2018-01-04 21:04:07,293: Parsing materializations/table.sql
2018-01-04 21:04:07,347: Parsing materializations/helpers.sql
2018-01-04 21:04:07,396: Parsing materializations/bigquery.sql
2018-01-04 21:04:07,450: Parsing materializations/view.sql
2018-01-04 21:04:07,498: Parsing materializations/incremental.sql
2018-01-04 21:04:07,567: Parsing adapters/redshift.sql
2018-01-04 21:04:07,615: Parsing adapters/bigquery.sql
2018-01-04 21:04:07,633: Parsing adapters/postgres.sql
2018-01-04 21:04:07,643: Parsing adapters/common.sql
2018-01-04 21:04:07,873: Parsing model.parsely.parsely_audit
2018-01-04 21:04:07,876: Parsing model.parsely.parsely_video_content
2018-01-04 21:04:07,885: Parsing model.parsely.parsely_post_content
2018-01-04 21:04:07,893: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 21:04:07,898: Parsing model.parsely.parsely_rawdata
2018-01-04 21:04:07,910: Parsing model.parsely.calendar
2018-01-04 21:04:07,914: Parsing model.parsely.parsely_all_events
2018-01-04 21:04:07,931: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:04:07,931: Opening a new connection (0 currently allocated)
2018-01-04 21:04:07,954: Using redshift connection "parsely_all_events".
2018-01-04 21:04:07,955: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:07,981: SQL status: SELECT in 0.03 seconds
2018-01-04 21:04:07,994: Parsing model.parsely.parsely_event_ids
2018-01-04 21:04:07,999: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 21:04:08,012: Parsing model.parsely.parsely_base_events
2018-01-04 21:04:08,027: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:04:08,027: Re-using an available connection from the pool.
2018-01-04 21:04:08,027: Using redshift connection "parsely_base_events".
2018-01-04 21:04:08,028: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:08,052: SQL status: SELECT in 0.02 seconds
2018-01-04 21:04:08,053: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:04:08,071: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 21:04:08,082: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:04:08,086: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:04:08,090: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 21:04:08,101: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:04:08,116: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 21:04:08,137: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 21:04:08,151: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:04:08,151: Re-using an available connection from the pool.
2018-01-04 21:04:08,152: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:04:08,152: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:08,173: SQL status: SELECT in 0.02 seconds
2018-01-04 21:04:08,175: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 21:04:08,190: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 21:04:08,204: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:04:08,204: Re-using an available connection from the pool.
2018-01-04 21:04:08,204: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:04:08,204: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:08,227: SQL status: SELECT in 0.02 seconds
2018-01-04 21:04:08,229: Parsing model.parsely.parsely_incoming_users
2018-01-04 21:04:08,234: Parsing model.parsely.parsely_users
2018-01-04 21:04:08,244: Acquiring new redshift connection "parsely_users".
2018-01-04 21:04:08,244: Re-using an available connection from the pool.
2018-01-04 21:04:08,244: Using redshift connection "parsely_users".
2018-01-04 21:04:08,244: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:08,268: SQL status: SELECT in 0.02 seconds
2018-01-04 21:04:08,269: Parsing model.parsely.parsely_errors
2018-01-04 21:04:08,280: Parsing model.parsely.parsely_bot_traffic
2018-01-04 21:04:08,296: Parsing model.parsely.parsely_custom_events
2018-01-04 21:04:08,317: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 21:04:08,331: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 21:04:08,340: Parsing model.parsely.parsely_sessions
2018-01-04 21:04:08,357: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:04:08,357: Re-using an available connection from the pool.
2018-01-04 21:04:08,357: Using redshift connection "parsely_sessions".
2018-01-04 21:04:08,357: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:08,381: SQL status: SELECT in 0.02 seconds
2018-01-04 21:04:08,382: Parsing model.parsely.parsely_campaigns
2018-01-04 21:04:08,393: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:04:08,394: Re-using an available connection from the pool.
2018-01-04 21:04:08,394: Using redshift connection "parsely_campaigns".
2018-01-04 21:04:08,394: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:08,416: SQL status: SELECT in 0.02 seconds
2018-01-04 21:04:08,435: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 21:04:08,456: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 21:04:08,477: 
2018-01-04 21:04:08,484: Acquiring new redshift connection "master".
2018-01-04 21:04:08,484: Re-using an available connection from the pool.
2018-01-04 21:04:08,484: Using redshift connection "master".
2018-01-04 21:04:08,484: On master: select distinct nspname from pg_namespace
2018-01-04 21:04:08,487: SQL status: SELECT in 0.00 seconds
2018-01-04 21:04:08,493: Using redshift connection "master".
2018-01-04 21:04:08,493: On master: BEGIN
2018-01-04 21:04:08,495: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:04:08,495: On master: COMMIT
2018-01-04 21:04:08,495: Using redshift connection "master".
2018-01-04 21:04:08,495: On master: COMMIT
2018-01-04 21:04:08,497: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:04:08,509: 21:04:08 | Concurrency: 1 threads (target='dev')
2018-01-04 21:04:08,511: 21:04:08 | 
2018-01-04 21:04:08,511: Using redshift connection "master".
2018-01-04 21:04:08,511: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:08,533: SQL status: SELECT in 0.02 seconds
2018-01-04 21:04:08,735: 21:04:08 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 21:04:08,735: Compiling model.parsely.calendar
2018-01-04 21:04:08,744: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 21:04:08,751: Acquiring new redshift connection "calendar".
2018-01-04 21:04:08,751: Opening a new connection (1 currently allocated)
2018-01-04 21:04:08,776: Using redshift connection "calendar".
2018-01-04 21:04:08,776: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:08,803: SQL status: SELECT in 0.03 seconds
2018-01-04 21:04:08,806: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 21:04:08,816: Using redshift connection "calendar".
2018-01-04 21:04:08,816: On calendar: BEGIN
2018-01-04 21:04:08,818: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:04:08,818: Using redshift connection "calendar".
2018-01-04 21:04:08,818: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 21:04:08,852: SQL status: CREATE VIEW in 0.03 seconds
2018-01-04 21:04:08,852: On calendar: COMMIT
2018-01-04 21:04:08,853: Using redshift connection "calendar".
2018-01-04 21:04:08,853: On calendar: COMMIT
2018-01-04 21:04:09,193: SQL status: COMMIT in 0.34 seconds
2018-01-04 21:04:09,194: Using redshift connection "calendar".
2018-01-04 21:04:09,194: On calendar: BEGIN
2018-01-04 21:04:09,196: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:04:09,196: Using redshift connection "calendar".
2018-01-04 21:04:09,196: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 21:04:09,246: SQL status: DROP VIEW in 0.05 seconds
2018-01-04 21:04:09,246: On calendar: COMMIT
2018-01-04 21:04:09,246: Using redshift connection "calendar".
2018-01-04 21:04:09,246: On calendar: COMMIT
2018-01-04 21:04:09,594: SQL status: COMMIT in 0.35 seconds
2018-01-04 21:04:09,594: Using redshift connection "calendar".
2018-01-04 21:04:09,595: On calendar: BEGIN
2018-01-04 21:04:09,597: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:04:09,597: Using redshift connection "calendar".
2018-01-04 21:04:09,597: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 21:04:09,668: SQL status: ALTER TABLE in 0.07 seconds
2018-01-04 21:04:09,668: On calendar: COMMIT
2018-01-04 21:04:09,668: Using redshift connection "calendar".
2018-01-04 21:04:09,669: On calendar: COMMIT
2018-01-04 21:04:09,869: SQL status: COMMIT in 0.20 seconds
2018-01-04 21:04:09,870: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc313109bd0>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:04:09,919: 21:04:09 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.14s]
2018-01-04 21:04:09,923: 21:04:09 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 21:04:09,923: Compiling model.parsely.parsely_rawdata
2018-01-04 21:04:09,939: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:04:09,940: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 21:04:09,941: Re-using an available connection from the pool.
2018-01-04 21:04:09,941: Using redshift connection "parsely_rawdata".
2018-01-04 21:04:09,941: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:09,961: SQL status: SELECT in 0.02 seconds
2018-01-04 21:04:09,962: Using redshift connection "parsely_rawdata".
2018-01-04 21:04:09,962: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:04:09,972: SQL status: SELECT in 0.01 seconds
2018-01-04 21:04:09,974: Using redshift connection "parsely_rawdata".
2018-01-04 21:04:09,974: On parsely_rawdata: BEGIN
2018-01-04 21:04:09,976: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:04:09,976: Using redshift connection "parsely_rawdata".
2018-01-04 21:04:09,977: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:04:38,681: SQL status: SELECT in 28.70 seconds
2018-01-04 21:04:38,682: Using redshift connection "parsely_rawdata".
2018-01-04 21:04:38,682: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 21:04:38,900: SQL status: SELECT in 0.22 seconds
2018-01-04 21:04:38,901: Using redshift connection "parsely_rawdata".
2018-01-04 21:04:38,901: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:04:39,009: SQL status: SELECT in 0.11 seconds
2018-01-04 21:04:39,010: Using redshift connection "parsely_rawdata".
2018-01-04 21:04:39,011: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:04:39,123: SQL status: SELECT in 0.11 seconds
2018-01-04 21:04:39,130: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:04:39,135: Using redshift connection "parsely_rawdata".
2018-01-04 21:04:39,135: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 21:05:10,038: SQL status: INSERT 0 1019194 in 30.90 seconds
2018-01-04 21:05:10,039: On parsely_rawdata: COMMIT
2018-01-04 21:05:10,039: Using redshift connection "parsely_rawdata".
2018-01-04 21:05:10,039: On parsely_rawdata: COMMIT
2018-01-04 21:05:12,047: SQL status: COMMIT in 2.01 seconds
2018-01-04 21:05:12,048: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc313173b10>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:05:12,148: 21:05:12 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1019194 in 62.12s]
2018-01-04 21:05:12,148: 21:05:12 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 21:05:12,149: Compiling model.parsely.parsely_all_events
2018-01-04 21:05:12,179: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:05:12,179: Re-using an available connection from the pool.
2018-01-04 21:05:12,180: Using redshift connection "parsely_all_events".
2018-01-04 21:05:12,180: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:05:12,194: SQL status: SELECT in 0.01 seconds
2018-01-04 21:05:12,214: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:05:12,225: Using redshift connection "parsely_all_events".
2018-01-04 21:05:12,225: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:05:12,239: SQL status: SELECT in 0.01 seconds
2018-01-04 21:05:12,240: Using redshift connection "parsely_all_events".
2018-01-04 21:05:12,240: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:05:12,254: SQL status: SELECT in 0.01 seconds
2018-01-04 21:05:12,258: Using redshift connection "parsely_all_events".
2018-01-04 21:05:12,258: On parsely_all_events: BEGIN
2018-01-04 21:05:12,260: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:05:12,260: Using redshift connection "parsely_all_events".
2018-01-04 21:05:12,260: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:06:41,277: SQL status: SELECT in 89.02 seconds
2018-01-04 21:06:41,278: Using redshift connection "parsely_all_events".
2018-01-04 21:06:41,278: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 21:06:41,446: SQL status: SELECT in 0.17 seconds
2018-01-04 21:06:41,446: Using redshift connection "parsely_all_events".
2018-01-04 21:06:41,446: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:06:41,555: SQL status: SELECT in 0.11 seconds
2018-01-04 21:06:41,557: Using redshift connection "parsely_all_events".
2018-01-04 21:06:41,558: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:06:41,665: SQL status: SELECT in 0.11 seconds
2018-01-04 21:06:41,676: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:06:41,678: Using redshift connection "parsely_all_events".
2018-01-04 21:06:41,678: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 21:06:58,004: SQL status: INSERT 0 903704 in 16.33 seconds
2018-01-04 21:06:58,005: On parsely_all_events: COMMIT
2018-01-04 21:06:58,005: Using redshift connection "parsely_all_events".
2018-01-04 21:06:58,005: On parsely_all_events: COMMIT
2018-01-04 21:07:01,339: SQL status: COMMIT in 3.33 seconds
2018-01-04 21:07:01,340: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc3131c8810>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:07:01,435: 21:07:01 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 903704 in 109.19s]
2018-01-04 21:07:01,438: 21:07:01 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 21:07:01,438: Compiling model.parsely.parsely_bot_traffic
2018-01-04 21:07:01,464: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 21:07:01,486: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 21:07:01,486: Re-using an available connection from the pool.
2018-01-04 21:07:01,486: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:07:01,486: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:01,504: SQL status: SELECT in 0.02 seconds
2018-01-04 21:07:01,505: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:07:01,505: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:01,520: SQL status: SELECT in 0.01 seconds
2018-01-04 21:07:01,523: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:07:01,523: On parsely_bot_traffic: BEGIN
2018-01-04 21:07:01,525: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:07:01,526: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:07:01,526: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:07:12,656: SQL status: SELECT in 11.13 seconds
2018-01-04 21:07:12,656: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:07:12,656: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 21:07:12,860: SQL status: SELECT in 0.20 seconds
2018-01-04 21:07:12,861: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:07:12,861: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:12,974: SQL status: SELECT in 0.11 seconds
2018-01-04 21:07:12,976: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:07:12,976: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:13,089: SQL status: SELECT in 0.11 seconds
2018-01-04 21:07:13,097: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 21:07:13,119: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:07:13,119: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 21:07:14,441: SQL status: INSERT 0 4 in 1.32 seconds
2018-01-04 21:07:14,442: On parsely_bot_traffic: COMMIT
2018-01-04 21:07:14,442: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:07:14,442: On parsely_bot_traffic: COMMIT
2018-01-04 21:07:15,532: SQL status: COMMIT in 1.09 seconds
2018-01-04 21:07:15,533: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc313109c90>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:07:15,572: 21:07:15 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 14.09s]
2018-01-04 21:07:15,573: 21:07:15 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 21:07:15,573: Compiling model.parsely.parsely_custom_events
2018-01-04 21:07:15,597: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 21:07:15,602: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 21:07:15,602: Re-using an available connection from the pool.
2018-01-04 21:07:15,603: Using redshift connection "parsely_custom_events".
2018-01-04 21:07:15,603: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:15,618: SQL status: SELECT in 0.02 seconds
2018-01-04 21:07:15,619: Using redshift connection "parsely_custom_events".
2018-01-04 21:07:15,619: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:15,634: SQL status: SELECT in 0.01 seconds
2018-01-04 21:07:15,638: Using redshift connection "parsely_custom_events".
2018-01-04 21:07:15,638: On parsely_custom_events: BEGIN
2018-01-04 21:07:15,640: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:07:15,640: Using redshift connection "parsely_custom_events".
2018-01-04 21:07:15,640: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:07:26,678: SQL status: SELECT in 11.04 seconds
2018-01-04 21:07:26,678: Using redshift connection "parsely_custom_events".
2018-01-04 21:07:26,678: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 21:07:26,906: SQL status: SELECT in 0.23 seconds
2018-01-04 21:07:26,907: Using redshift connection "parsely_custom_events".
2018-01-04 21:07:26,907: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:27,028: SQL status: SELECT in 0.12 seconds
2018-01-04 21:07:27,029: Using redshift connection "parsely_custom_events".
2018-01-04 21:07:27,029: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:27,146: SQL status: SELECT in 0.12 seconds
2018-01-04 21:07:27,152: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 21:07:27,155: Using redshift connection "parsely_custom_events".
2018-01-04 21:07:27,155: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 21:07:27,452: SQL status: INSERT 0 0 in 0.30 seconds
2018-01-04 21:07:27,453: On parsely_custom_events: COMMIT
2018-01-04 21:07:27,453: Using redshift connection "parsely_custom_events".
2018-01-04 21:07:27,453: On parsely_custom_events: COMMIT
2018-01-04 21:07:27,876: SQL status: COMMIT in 0.42 seconds
2018-01-04 21:07:27,876: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc313109890>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:07:27,955: 21:07:27 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 12.30s]
2018-01-04 21:07:27,956: 21:07:27 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 21:07:27,958: Compiling model.parsely.parsely_errors
2018-01-04 21:07:27,993: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 21:07:27,999: Acquiring new redshift connection "parsely_errors".
2018-01-04 21:07:27,999: Re-using an available connection from the pool.
2018-01-04 21:07:28,000: Using redshift connection "parsely_errors".
2018-01-04 21:07:28,000: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:28,016: SQL status: SELECT in 0.02 seconds
2018-01-04 21:07:28,017: Using redshift connection "parsely_errors".
2018-01-04 21:07:28,017: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:28,033: SQL status: SELECT in 0.02 seconds
2018-01-04 21:07:28,036: Using redshift connection "parsely_errors".
2018-01-04 21:07:28,036: On parsely_errors: BEGIN
2018-01-04 21:07:28,039: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:07:28,039: Using redshift connection "parsely_errors".
2018-01-04 21:07:28,039: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:07:38,840: SQL status: SELECT in 10.80 seconds
2018-01-04 21:07:38,841: Using redshift connection "parsely_errors".
2018-01-04 21:07:38,841: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 21:07:39,101: SQL status: SELECT in 0.26 seconds
2018-01-04 21:07:39,102: Using redshift connection "parsely_errors".
2018-01-04 21:07:39,102: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:39,212: SQL status: SELECT in 0.11 seconds
2018-01-04 21:07:39,214: Using redshift connection "parsely_errors".
2018-01-04 21:07:39,214: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:39,323: SQL status: SELECT in 0.11 seconds
2018-01-04 21:07:39,329: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 21:07:39,331: Using redshift connection "parsely_errors".
2018-01-04 21:07:39,331: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 21:07:40,026: SQL status: INSERT 0 2 in 0.69 seconds
2018-01-04 21:07:40,027: On parsely_errors: COMMIT
2018-01-04 21:07:40,027: Using redshift connection "parsely_errors".
2018-01-04 21:07:40,027: On parsely_errors: COMMIT
2018-01-04 21:07:42,158: SQL status: COMMIT in 2.13 seconds
2018-01-04 21:07:42,159: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc3130ffbd0>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:07:42,203: 21:07:42 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 14.20s]
2018-01-04 21:07:42,204: 21:07:42 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 21:07:42,205: Compiling model.parsely.parsely_base_events
2018-01-04 21:07:42,223: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:07:42,224: Re-using an available connection from the pool.
2018-01-04 21:07:42,224: Using redshift connection "parsely_base_events".
2018-01-04 21:07:42,225: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:42,240: SQL status: SELECT in 0.02 seconds
2018-01-04 21:07:42,251: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 21:07:42,253: Using redshift connection "parsely_base_events".
2018-01-04 21:07:42,254: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:42,268: SQL status: SELECT in 0.01 seconds
2018-01-04 21:07:42,271: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 21:07:42,273: Using redshift connection "parsely_base_events".
2018-01-04 21:07:42,273: On parsely_base_events: BEGIN
2018-01-04 21:07:42,285: SQL status: BEGIN in 0.01 seconds
2018-01-04 21:07:42,285: Using redshift connection "parsely_base_events".
2018-01-04 21:07:42,285: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 21:07:44,837: SQL status: CREATE VIEW in 2.55 seconds
2018-01-04 21:07:44,837: On parsely_base_events: COMMIT
2018-01-04 21:07:44,838: Using redshift connection "parsely_base_events".
2018-01-04 21:07:44,838: On parsely_base_events: COMMIT
2018-01-04 21:07:45,561: SQL status: COMMIT in 0.72 seconds
2018-01-04 21:07:45,561: Using redshift connection "parsely_base_events".
2018-01-04 21:07:45,561: On parsely_base_events: BEGIN
2018-01-04 21:07:45,564: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:07:45,564: Using redshift connection "parsely_base_events".
2018-01-04 21:07:45,564: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 21:07:45,864: SQL status: DROP VIEW in 0.30 seconds
2018-01-04 21:07:45,864: On parsely_base_events: COMMIT
2018-01-04 21:07:45,864: Using redshift connection "parsely_base_events".
2018-01-04 21:07:45,864: On parsely_base_events: COMMIT
2018-01-04 21:07:46,561: SQL status: COMMIT in 0.70 seconds
2018-01-04 21:07:46,561: Using redshift connection "parsely_base_events".
2018-01-04 21:07:46,562: On parsely_base_events: BEGIN
2018-01-04 21:07:46,565: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:07:46,565: Using redshift connection "parsely_base_events".
2018-01-04 21:07:46,565: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 21:07:46,768: SQL status: ALTER TABLE in 0.20 seconds
2018-01-04 21:07:46,768: On parsely_base_events: COMMIT
2018-01-04 21:07:46,768: Using redshift connection "parsely_base_events".
2018-01-04 21:07:46,768: On parsely_base_events: COMMIT
2018-01-04 21:07:47,088: SQL status: COMMIT in 0.32 seconds
2018-01-04 21:07:47,089: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc313173890>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:07:47,128: 21:07:47 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 4.88s]
2018-01-04 21:07:47,128: 21:07:47 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 21:07:47,129: Compiling model.parsely.parsely_event_ids
2018-01-04 21:07:47,139: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 21:07:47,148: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 21:07:47,148: Re-using an available connection from the pool.
2018-01-04 21:07:47,148: Using redshift connection "parsely_event_ids".
2018-01-04 21:07:47,148: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:47,164: SQL status: SELECT in 0.02 seconds
2018-01-04 21:07:47,165: Using redshift connection "parsely_event_ids".
2018-01-04 21:07:47,165: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:47,178: SQL status: SELECT in 0.01 seconds
2018-01-04 21:07:47,180: Using redshift connection "parsely_event_ids".
2018-01-04 21:07:47,180: On parsely_event_ids: BEGIN
2018-01-04 21:07:47,182: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:07:47,182: Using redshift connection "parsely_event_ids".
2018-01-04 21:07:47,183: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:07:47,858: SQL status: SELECT in 0.68 seconds
2018-01-04 21:07:47,859: Using redshift connection "parsely_event_ids".
2018-01-04 21:07:47,859: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 21:07:48,348: SQL status: SELECT in 0.49 seconds
2018-01-04 21:07:48,348: Using redshift connection "parsely_event_ids".
2018-01-04 21:07:48,348: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:48,455: SQL status: SELECT in 0.11 seconds
2018-01-04 21:07:48,456: Using redshift connection "parsely_event_ids".
2018-01-04 21:07:48,456: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:48,559: SQL status: SELECT in 0.10 seconds
2018-01-04 21:07:48,561: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 21:07:48,562: Using redshift connection "parsely_event_ids".
2018-01-04 21:07:48,562: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 21:07:49,240: SQL status: INSERT 0 903700 in 0.68 seconds
2018-01-04 21:07:49,241: On parsely_event_ids: COMMIT
2018-01-04 21:07:49,241: Using redshift connection "parsely_event_ids".
2018-01-04 21:07:49,241: On parsely_event_ids: COMMIT
2018-01-04 21:07:49,552: SQL status: COMMIT in 0.31 seconds
2018-01-04 21:07:49,553: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc3131367d0>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:07:49,611: 21:07:49 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 903700 in 2.42s]
2018-01-04 21:07:49,612: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 21:07:49,630: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 21:07:49,635: 21:07:49 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 21:07:49,637: Compiling model.parsely.parsely_post_content
2018-01-04 21:07:49,657: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 21:07:49,663: Acquiring new redshift connection "parsely_post_content".
2018-01-04 21:07:49,663: Re-using an available connection from the pool.
2018-01-04 21:07:49,663: Using redshift connection "parsely_post_content".
2018-01-04 21:07:49,664: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:49,679: SQL status: SELECT in 0.01 seconds
2018-01-04 21:07:49,679: Using redshift connection "parsely_post_content".
2018-01-04 21:07:49,680: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:49,694: SQL status: SELECT in 0.01 seconds
2018-01-04 21:07:49,696: Using redshift connection "parsely_post_content".
2018-01-04 21:07:49,697: On parsely_post_content: BEGIN
2018-01-04 21:07:49,699: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:07:49,699: Using redshift connection "parsely_post_content".
2018-01-04 21:07:49,699: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:07:52,928: SQL status: SELECT in 3.23 seconds
2018-01-04 21:07:52,928: Using redshift connection "parsely_post_content".
2018-01-04 21:07:52,928: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 21:07:53,388: SQL status: SELECT in 0.46 seconds
2018-01-04 21:07:53,388: Using redshift connection "parsely_post_content".
2018-01-04 21:07:53,388: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:53,494: SQL status: SELECT in 0.11 seconds
2018-01-04 21:07:53,496: Using redshift connection "parsely_post_content".
2018-01-04 21:07:53,496: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:53,597: SQL status: SELECT in 0.10 seconds
2018-01-04 21:07:53,600: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 21:07:53,603: Using redshift connection "parsely_post_content".
2018-01-04 21:07:53,603: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 21:07:53,970: SQL status: INSERT 0 881 in 0.37 seconds
2018-01-04 21:07:53,971: On parsely_post_content: COMMIT
2018-01-04 21:07:53,971: Using redshift connection "parsely_post_content".
2018-01-04 21:07:53,971: On parsely_post_content: COMMIT
2018-01-04 21:07:56,233: SQL status: COMMIT in 2.26 seconds
2018-01-04 21:07:56,234: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31316aed0>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:07:56,293: 21:07:56 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 881 in 6.60s]
2018-01-04 21:07:56,293: 21:07:56 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 21:07:56,294: Compiling model.parsely.parsely_video_content
2018-01-04 21:07:56,310: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 21:07:56,329: Acquiring new redshift connection "parsely_video_content".
2018-01-04 21:07:56,329: Re-using an available connection from the pool.
2018-01-04 21:07:56,329: Using redshift connection "parsely_video_content".
2018-01-04 21:07:56,329: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:56,344: SQL status: SELECT in 0.01 seconds
2018-01-04 21:07:56,345: Using redshift connection "parsely_video_content".
2018-01-04 21:07:56,345: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:07:56,359: SQL status: SELECT in 0.01 seconds
2018-01-04 21:07:56,361: Using redshift connection "parsely_video_content".
2018-01-04 21:07:56,362: On parsely_video_content: BEGIN
2018-01-04 21:07:56,364: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:07:56,364: Using redshift connection "parsely_video_content".
2018-01-04 21:07:56,364: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:07:59,497: SQL status: SELECT in 3.13 seconds
2018-01-04 21:07:59,497: Using redshift connection "parsely_video_content".
2018-01-04 21:07:59,498: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 21:07:59,722: SQL status: SELECT in 0.22 seconds
2018-01-04 21:07:59,723: Using redshift connection "parsely_video_content".
2018-01-04 21:07:59,723: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:59,831: SQL status: SELECT in 0.11 seconds
2018-01-04 21:07:59,832: Using redshift connection "parsely_video_content".
2018-01-04 21:07:59,832: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:07:59,945: SQL status: SELECT in 0.11 seconds
2018-01-04 21:07:59,948: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 21:07:59,949: Using redshift connection "parsely_video_content".
2018-01-04 21:07:59,949: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 21:08:00,753: SQL status: INSERT 0 468 in 0.80 seconds
2018-01-04 21:08:00,754: On parsely_video_content: COMMIT
2018-01-04 21:08:00,754: Using redshift connection "parsely_video_content".
2018-01-04 21:08:00,754: On parsely_video_content: COMMIT
2018-01-04 21:08:01,612: SQL status: COMMIT in 0.86 seconds
2018-01-04 21:08:01,613: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31316aed0>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:08:01,674: 21:08:01 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 468 in 5.32s]
2018-01-04 21:08:01,675: 21:08:01 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 21:08:01,676: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 21:08:01,699: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 21:08:01,704: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 21:08:01,704: Re-using an available connection from the pool.
2018-01-04 21:08:01,705: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:08:01,705: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:01,720: SQL status: SELECT in 0.01 seconds
2018-01-04 21:08:01,724: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 21:08:01,727: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:08:01,728: On parsely_entry_exit_urls: BEGIN
2018-01-04 21:08:01,730: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:08:01,730: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:08:01,730: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 21:08:03,034: SQL status: CREATE VIEW in 1.30 seconds
2018-01-04 21:08:03,035: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:08:03,035: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 21:08:03,738: SQL status: ALTER TABLE in 0.70 seconds
2018-01-04 21:08:03,738: On parsely_entry_exit_urls: COMMIT
2018-01-04 21:08:03,738: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:08:03,738: On parsely_entry_exit_urls: COMMIT
2018-01-04 21:08:04,147: SQL status: COMMIT in 0.41 seconds
2018-01-04 21:08:04,148: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31316aed0>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:08:04,233: 21:08:04 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 2.47s]
2018-01-04 21:08:04,234: 21:08:04 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 21:08:04,234: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 21:08:04,264: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 21:08:04,281: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 21:08:04,281: Re-using an available connection from the pool.
2018-01-04 21:08:04,281: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:08:04,281: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:04,296: SQL status: SELECT in 0.01 seconds
2018-01-04 21:08:04,302: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 21:08:04,307: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:08:04,307: On parsely_incoming_videoviews: BEGIN
2018-01-04 21:08:04,309: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:08:04,309: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:08:04,309: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 21:08:05,354: SQL status: CREATE VIEW in 1.04 seconds
2018-01-04 21:08:05,355: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:08:05,355: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 21:08:05,359: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:08:05,359: On parsely_incoming_videoviews: COMMIT
2018-01-04 21:08:05,360: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:08:05,360: On parsely_incoming_videoviews: COMMIT
2018-01-04 21:08:05,899: SQL status: COMMIT in 0.54 seconds
2018-01-04 21:08:05,900: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31316aed0>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:08:05,937: 21:08:05 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.67s]
2018-01-04 21:08:05,938: 21:08:05 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 21:08:05,938: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 21:08:05,946: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:05,946: Re-using an available connection from the pool.
2018-01-04 21:08:05,946: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:05,946: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:05,962: SQL status: SELECT in 0.02 seconds
2018-01-04 21:08:05,969: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 21:08:05,970: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:05,970: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:05,984: SQL status: SELECT in 0.01 seconds
2018-01-04 21:08:05,984: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:05,985: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:05,998: SQL status: SELECT in 0.01 seconds
2018-01-04 21:08:06,002: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:06,002: On parsely_videoviews_sessionized: BEGIN
2018-01-04 21:08:06,004: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:08:06,004: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:06,004: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:08:21,826: SQL status: SELECT in 15.82 seconds
2018-01-04 21:08:21,827: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:21,827: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 21:08:22,322: SQL status: SELECT in 0.49 seconds
2018-01-04 21:08:22,323: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:22,323: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:08:22,429: SQL status: SELECT in 0.11 seconds
2018-01-04 21:08:22,431: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:22,431: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:08:22,535: SQL status: SELECT in 0.10 seconds
2018-01-04 21:08:22,542: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 21:08:22,545: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:22,546: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 21:08:24,640: SQL status: INSERT 0 142 in 2.09 seconds
2018-01-04 21:08:24,641: On parsely_videoviews_sessionized: COMMIT
2018-01-04 21:08:24,641: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:08:24,641: On parsely_videoviews_sessionized: COMMIT
2018-01-04 21:08:25,845: SQL status: COMMIT in 1.20 seconds
2018-01-04 21:08:25,845: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31316ae10>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:08:25,901: 21:08:25 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 142 in 19.91s]
2018-01-04 21:08:25,902: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 21:08:26,037: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 21:08:26,043: 21:08:26 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 21:08:26,043: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:08:26,088: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 21:08:26,093: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:08:26,093: Re-using an available connection from the pool.
2018-01-04 21:08:26,093: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:08:26,093: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:26,104: SQL status: SELECT in 0.01 seconds
2018-01-04 21:08:26,108: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 21:08:26,110: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:08:26,111: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 21:08:26,113: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:08:26,113: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:08:26,113: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 21:08:26,346: SQL status: CREATE VIEW in 0.23 seconds
2018-01-04 21:08:26,347: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:08:26,347: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 21:08:26,355: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 21:08:26,355: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 21:08:26,355: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:08:26,355: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 21:08:26,656: SQL status: COMMIT in 0.30 seconds
2018-01-04 21:08:26,657: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc3131d0dd0>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:08:26,721: 21:08:26 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.61s]
2018-01-04 21:08:26,722: 21:08:26 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 21:08:26,722: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:08:26,814: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 21:08:26,821: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:08:26,821: Re-using an available connection from the pool.
2018-01-04 21:08:26,821: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:08:26,822: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:26,833: SQL status: SELECT in 0.01 seconds
2018-01-04 21:08:26,838: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 21:08:26,840: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:08:26,840: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 21:08:26,842: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:08:26,843: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:08:26,843: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 21:08:27,830: SQL status: CREATE VIEW in 0.99 seconds
2018-01-04 21:08:27,831: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:08:27,831: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 21:08:27,938: SQL status: ALTER TABLE in 0.11 seconds
2018-01-04 21:08:27,939: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 21:08:27,939: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:08:27,939: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 21:08:28,589: SQL status: COMMIT in 0.65 seconds
2018-01-04 21:08:28,590: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc3130ff7d0>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:08:28,634: 21:08:28 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 1.87s]
2018-01-04 21:08:28,635: 21:08:28 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 21:08:28,635: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 21:08:28,669: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 21:08:28,680: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 21:08:28,681: Re-using an available connection from the pool.
2018-01-04 21:08:28,681: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:08:28,681: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:28,695: SQL status: SELECT in 0.01 seconds
2018-01-04 21:08:28,702: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 21:08:28,707: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:08:28,707: On parsely_incoming_pageviews: BEGIN
2018-01-04 21:08:28,709: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:08:28,709: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:08:28,709: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 21:08:29,353: SQL status: CREATE VIEW in 0.64 seconds
2018-01-04 21:08:29,354: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:08:29,354: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 21:08:29,359: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:08:29,360: On parsely_incoming_pageviews: COMMIT
2018-01-04 21:08:29,360: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:08:29,360: On parsely_incoming_pageviews: COMMIT
2018-01-04 21:08:29,639: SQL status: COMMIT in 0.28 seconds
2018-01-04 21:08:29,640: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc313202990>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:08:29,687: 21:08:29 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.00s]
2018-01-04 21:08:29,688: 21:08:29 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 21:08:29,688: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 21:08:29,703: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:08:29,703: Re-using an available connection from the pool.
2018-01-04 21:08:29,703: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:08:29,703: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:29,718: SQL status: SELECT in 0.01 seconds
2018-01-04 21:08:29,726: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 21:08:29,732: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:08:29,732: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:29,746: SQL status: SELECT in 0.01 seconds
2018-01-04 21:08:29,747: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:08:29,747: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:08:29,761: SQL status: SELECT in 0.01 seconds
2018-01-04 21:08:29,765: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:08:29,765: On parsely_pageviews_sessionized: BEGIN
2018-01-04 21:08:29,767: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:08:29,767: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:08:29,767: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:10:04,985: SQL status: SELECT in 95.22 seconds
2018-01-04 21:10:04,985: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:10:04,986: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 21:10:05,185: SQL status: SELECT in 0.20 seconds
2018-01-04 21:10:05,186: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:10:05,186: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:10:05,304: SQL status: SELECT in 0.12 seconds
2018-01-04 21:10:05,306: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:10:05,306: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:10:05,423: SQL status: SELECT in 0.12 seconds
2018-01-04 21:10:05,430: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 21:10:05,434: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:10:05,434: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 21:10:08,475: SQL status: INSERT 0 107750 in 3.04 seconds
2018-01-04 21:10:08,475: On parsely_pageviews_sessionized: COMMIT
2018-01-04 21:10:08,475: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:10:08,476: On parsely_pageviews_sessionized: COMMIT
2018-01-04 21:10:10,016: SQL status: COMMIT in 1.54 seconds
2018-01-04 21:10:10,017: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31316ae10>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:10:10,133: 21:10:10 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 107750 in 100.33s]
2018-01-04 21:10:10,134: 21:10:10 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 21:10:10,134: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 21:10:10,266: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 21:10:10,276: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:10:10,276: Re-using an available connection from the pool.
2018-01-04 21:10:10,276: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:10:10,276: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:10:10,299: SQL status: SELECT in 0.02 seconds
2018-01-04 21:10:10,304: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 21:10:10,306: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:10:10,306: On parsely_videoview_engagedtime: BEGIN
2018-01-04 21:10:10,308: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:10:10,308: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:10:10,308: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 21:10:11,644: SQL status: CREATE VIEW in 1.34 seconds
2018-01-04 21:10:11,645: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:10:11,645: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 21:10:11,649: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:10:11,649: On parsely_videoview_engagedtime: COMMIT
2018-01-04 21:10:11,649: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:10:11,649: On parsely_videoview_engagedtime: COMMIT
2018-01-04 21:10:12,074: SQL status: COMMIT in 0.42 seconds
2018-01-04 21:10:12,075: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31316ae10>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:10:12,137: 21:10:12 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.94s]
2018-01-04 21:10:12,138: 21:10:12 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 21:10:12,138: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:10:12,171: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 21:10:12,177: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:10:12,177: Re-using an available connection from the pool.
2018-01-04 21:10:12,177: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:10:12,177: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:10:12,200: SQL status: SELECT in 0.02 seconds
2018-01-04 21:10:12,200: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:10:12,201: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:10:12,223: SQL status: SELECT in 0.02 seconds
2018-01-04 21:10:12,226: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:10:12,227: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 21:10:12,229: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:10:12,229: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:10:12,229: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:10:52,991: SQL status: SELECT in 40.76 seconds
2018-01-04 21:10:52,992: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:10:52,992: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 21:10:53,360: SQL status: SELECT in 0.37 seconds
2018-01-04 21:10:53,361: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:10:53,361: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:10:53,477: SQL status: SELECT in 0.12 seconds
2018-01-04 21:10:53,479: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:10:53,479: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:10:53,594: SQL status: SELECT in 0.11 seconds
2018-01-04 21:10:53,601: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 21:10:53,607: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:10:53,607: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 21:10:55,956: SQL status: INSERT 0 141 in 2.35 seconds
2018-01-04 21:10:55,956: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 21:10:55,956: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:10:55,957: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 21:10:57,433: SQL status: COMMIT in 1.48 seconds
2018-01-04 21:10:57,434: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc313202990>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:10:57,499: 21:10:57 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 141 in 45.30s]
2018-01-04 21:10:57,500: 21:10:57 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 21:10:57,500: Compiling model.parsely.parsely_campaigns
2018-01-04 21:10:57,513: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:10:57,513: Re-using an available connection from the pool.
2018-01-04 21:10:57,514: Using redshift connection "parsely_campaigns".
2018-01-04 21:10:57,514: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:10:57,539: SQL status: SELECT in 0.02 seconds
2018-01-04 21:10:57,545: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 21:10:57,553: Using redshift connection "parsely_campaigns".
2018-01-04 21:10:57,553: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:10:57,575: SQL status: SELECT in 0.02 seconds
2018-01-04 21:10:57,576: Using redshift connection "parsely_campaigns".
2018-01-04 21:10:57,576: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:10:57,597: SQL status: SELECT in 0.02 seconds
2018-01-04 21:10:57,600: Using redshift connection "parsely_campaigns".
2018-01-04 21:10:57,600: On parsely_campaigns: BEGIN
2018-01-04 21:10:57,602: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:10:57,602: Using redshift connection "parsely_campaigns".
2018-01-04 21:10:57,603: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:10:59,501: SQL status: SELECT in 1.90 seconds
2018-01-04 21:10:59,501: Using redshift connection "parsely_campaigns".
2018-01-04 21:10:59,501: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 21:11:00,130: SQL status: SELECT in 0.63 seconds
2018-01-04 21:11:00,130: Using redshift connection "parsely_campaigns".
2018-01-04 21:11:00,131: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:11:00,244: SQL status: SELECT in 0.11 seconds
2018-01-04 21:11:00,244: Using redshift connection "parsely_campaigns".
2018-01-04 21:11:00,244: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:11:00,356: SQL status: SELECT in 0.11 seconds
2018-01-04 21:11:00,359: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 21:11:00,362: Using redshift connection "parsely_campaigns".
2018-01-04 21:11:00,362: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 21:11:00,582: SQL status: INSERT 0 386 in 0.22 seconds
2018-01-04 21:11:00,583: On parsely_campaigns: COMMIT
2018-01-04 21:11:00,583: Using redshift connection "parsely_campaigns".
2018-01-04 21:11:00,583: On parsely_campaigns: COMMIT
2018-01-04 21:11:01,556: SQL status: COMMIT in 0.97 seconds
2018-01-04 21:11:01,557: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc3131d0b50>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:11:01,602: 21:11:01 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 386 in 4.06s]
2018-01-04 21:11:01,603: Compiling model.parsely.parsely_incoming_users
2018-01-04 21:11:01,616: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 21:11:01,622: 21:11:01 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 21:11:01,622: Compiling model.parsely.parsely_users
2018-01-04 21:11:01,633: Acquiring new redshift connection "parsely_users".
2018-01-04 21:11:01,633: Re-using an available connection from the pool.
2018-01-04 21:11:01,633: Using redshift connection "parsely_users".
2018-01-04 21:11:01,633: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:11:01,655: SQL status: SELECT in 0.02 seconds
2018-01-04 21:11:01,814: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 21:11:01,817: Using redshift connection "parsely_users".
2018-01-04 21:11:01,817: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:11:01,839: SQL status: SELECT in 0.02 seconds
2018-01-04 21:11:01,840: Using redshift connection "parsely_users".
2018-01-04 21:11:01,840: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:11:01,862: SQL status: SELECT in 0.02 seconds
2018-01-04 21:11:01,866: Using redshift connection "parsely_users".
2018-01-04 21:11:01,866: On parsely_users: BEGIN
2018-01-04 21:11:01,868: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:11:01,869: Using redshift connection "parsely_users".
2018-01-04 21:11:01,869: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:11:03,983: SQL status: SELECT in 2.11 seconds
2018-01-04 21:11:03,983: Using redshift connection "parsely_users".
2018-01-04 21:11:03,983: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 21:11:04,268: SQL status: SELECT in 0.28 seconds
2018-01-04 21:11:04,269: Using redshift connection "parsely_users".
2018-01-04 21:11:04,269: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:11:04,381: SQL status: SELECT in 0.11 seconds
2018-01-04 21:11:04,382: Using redshift connection "parsely_users".
2018-01-04 21:11:04,382: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:11:04,495: SQL status: SELECT in 0.11 seconds
2018-01-04 21:11:04,497: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 21:11:04,500: Using redshift connection "parsely_users".
2018-01-04 21:11:04,501: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 21:11:04,771: SQL status: INSERT 0 52769 in 0.27 seconds
2018-01-04 21:11:04,771: On parsely_users: COMMIT
2018-01-04 21:11:04,771: Using redshift connection "parsely_users".
2018-01-04 21:11:04,772: On parsely_users: COMMIT
2018-01-04 21:11:05,243: SQL status: COMMIT in 0.47 seconds
2018-01-04 21:11:05,244: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc313173950>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:11:05,296: 21:11:05 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 52769 in 3.62s]
2018-01-04 21:11:05,297: 21:11:05 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 21:11:05,297: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 21:11:05,410: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 21:11:05,412: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:11:05,413: Re-using an available connection from the pool.
2018-01-04 21:11:05,413: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:11:05,413: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:11:05,435: SQL status: SELECT in 0.02 seconds
2018-01-04 21:11:05,439: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 21:11:05,441: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:11:05,441: On parsely_pageview_engagedtime: BEGIN
2018-01-04 21:11:05,443: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:11:05,443: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:11:05,443: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 21:11:05,534: SQL status: CREATE VIEW in 0.09 seconds
2018-01-04 21:11:05,535: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:11:05,535: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 21:11:05,539: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:11:05,539: On parsely_pageview_engagedtime: COMMIT
2018-01-04 21:11:05,540: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:11:05,540: On parsely_pageview_engagedtime: COMMIT
2018-01-04 21:11:06,276: SQL status: COMMIT in 0.74 seconds
2018-01-04 21:11:06,277: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc3131d0750>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:11:06,322: 21:11:06 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.98s]
2018-01-04 21:11:06,323: 21:11:06 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 21:11:06,324: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 21:11:06,342: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 21:11:06,344: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 21:11:06,344: Re-using an available connection from the pool.
2018-01-04 21:11:06,344: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:11:06,344: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:11:06,366: SQL status: SELECT in 0.02 seconds
2018-01-04 21:11:06,371: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 21:11:06,372: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:11:06,373: On parsely_incoming_sessions: BEGIN
2018-01-04 21:11:06,375: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:11:06,375: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:11:06,375: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 21:11:08,314: SQL status: CREATE VIEW in 1.94 seconds
2018-01-04 21:11:08,315: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:11:08,315: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 21:11:08,319: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:11:08,319: On parsely_incoming_sessions: COMMIT
2018-01-04 21:11:08,319: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:11:08,319: On parsely_incoming_sessions: COMMIT
2018-01-04 21:11:10,145: SQL status: COMMIT in 1.83 seconds
2018-01-04 21:11:10,146: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc3131d02d0>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:11:10,202: 21:11:10 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 3.82s]
2018-01-04 21:11:10,202: 21:11:10 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 21:11:10,202: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:11:10,228: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 21:11:10,235: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:11:10,235: Re-using an available connection from the pool.
2018-01-04 21:11:10,235: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:11:10,236: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:11:10,257: SQL status: SELECT in 0.02 seconds
2018-01-04 21:11:10,258: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:11:10,258: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:11:10,278: SQL status: SELECT in 0.02 seconds
2018-01-04 21:11:10,281: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:11:10,282: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 21:11:10,284: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:11:10,284: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:11:10,284: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:11:51,131: SQL status: SELECT in 40.85 seconds
2018-01-04 21:11:51,131: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:11:51,132: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 21:11:51,327: SQL status: SELECT in 0.20 seconds
2018-01-04 21:11:51,328: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:11:51,329: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:11:51,445: SQL status: SELECT in 0.12 seconds
2018-01-04 21:11:51,447: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:11:51,447: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:11:51,564: SQL status: SELECT in 0.12 seconds
2018-01-04 21:11:51,579: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 21:11:51,581: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:11:51,581: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 21:11:55,835: SQL status: INSERT 0 107790 in 4.25 seconds
2018-01-04 21:11:55,836: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 21:11:55,836: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:11:55,836: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 21:11:57,147: SQL status: COMMIT in 1.31 seconds
2018-01-04 21:11:57,148: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc3131d0b50>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:11:57,222: 21:11:57 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 107790 in 46.95s]
2018-01-04 21:11:57,223: 21:11:57 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 21:11:57,223: Compiling model.parsely.parsely_sessions
2018-01-04 21:11:57,255: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:11:57,255: Re-using an available connection from the pool.
2018-01-04 21:11:57,255: Using redshift connection "parsely_sessions".
2018-01-04 21:11:57,255: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:11:57,278: SQL status: SELECT in 0.02 seconds
2018-01-04 21:11:57,288: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 21:11:57,298: Using redshift connection "parsely_sessions".
2018-01-04 21:11:57,298: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:11:57,320: SQL status: SELECT in 0.02 seconds
2018-01-04 21:11:57,321: Using redshift connection "parsely_sessions".
2018-01-04 21:11:57,321: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:11:57,342: SQL status: SELECT in 0.02 seconds
2018-01-04 21:11:57,346: Using redshift connection "parsely_sessions".
2018-01-04 21:11:57,346: On parsely_sessions: BEGIN
2018-01-04 21:11:57,351: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:11:57,351: Using redshift connection "parsely_sessions".
2018-01-04 21:11:57,351: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:12:13,739: SQL status: SELECT in 16.39 seconds
2018-01-04 21:12:13,739: Using redshift connection "parsely_sessions".
2018-01-04 21:12:13,739: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 21:12:13,912: SQL status: SELECT in 0.17 seconds
2018-01-04 21:12:13,913: Using redshift connection "parsely_sessions".
2018-01-04 21:12:13,913: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:12:14,030: SQL status: SELECT in 0.12 seconds
2018-01-04 21:12:14,032: Using redshift connection "parsely_sessions".
2018-01-04 21:12:14,032: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:12:14,152: SQL status: SELECT in 0.12 seconds
2018-01-04 21:12:14,160: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 21:12:14,165: Using redshift connection "parsely_sessions".
2018-01-04 21:12:14,165: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 21:12:15,764: SQL status: INSERT 0 87516 in 1.60 seconds
2018-01-04 21:12:15,764: On parsely_sessions: COMMIT
2018-01-04 21:12:15,765: Using redshift connection "parsely_sessions".
2018-01-04 21:12:15,765: On parsely_sessions: COMMIT
2018-01-04 21:12:16,880: SQL status: COMMIT in 1.11 seconds
2018-01-04 21:12:16,880: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc313173810>], 'label': 'e13ab446-9da4-402b-aa88-527dbc777327'}
2018-01-04 21:12:16,971: 21:12:16 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 87516 in 19.66s]
2018-01-04 21:12:17,073: Using redshift connection "master".
2018-01-04 21:12:17,073: On master: BEGIN
2018-01-04 21:12:17,076: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:12:17,076: On master: COMMIT
2018-01-04 21:12:17,077: Using redshift connection "master".
2018-01-04 21:12:17,077: On master: COMMIT
2018-01-04 21:12:17,079: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:12:17,079: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 21:12:17,096: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 21:12:17,100: Using redshift connection "master".
2018-01-04 21:12:17,101: On master:  select 1 
2018-01-04 21:12:17,104: SQL status: SELECT in 0.00 seconds
2018-01-04 21:12:17,104: 21:12:17 | 
2018-01-04 21:12:17,104: 21:12:17 | Finished running 10 view models, 15 incremental models in 488.57s.
2018-01-04 21:12:17,106: 
2018-01-04 21:12:17,106: Completed successfully
2018-01-04 21:12:17,107: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 21:12:17,107: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31321be10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc31321bf90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc313202950>], 'label': 'end'}
2018-01-04 21:12:17,187: Flushing usage events
2018-01-04 21:12:25,454: Tracking: tracking
2018-01-04 21:12:25,455: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134daee10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134daef90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134daeed0>], 'label': 'start'}
2018-01-04 21:12:25,553: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 21:12:25,607: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 21:12:25,609: Parsing core.sql
2018-01-04 21:12:25,645: Parsing etc/get_custom_schema.sql
2018-01-04 21:12:25,660: Parsing schema_tests/relationships.sql
2018-01-04 21:12:25,665: Parsing schema_tests/accepted_values.sql
2018-01-04 21:12:25,677: Parsing schema_tests/not_null.sql
2018-01-04 21:12:25,681: Parsing schema_tests/unique.sql
2018-01-04 21:12:25,685: Parsing materializations/wrapper.sql
2018-01-04 21:12:25,694: Parsing materializations/archive.sql
2018-01-04 21:12:25,778: Parsing materializations/table.sql
2018-01-04 21:12:25,831: Parsing materializations/helpers.sql
2018-01-04 21:12:25,877: Parsing materializations/bigquery.sql
2018-01-04 21:12:25,915: Parsing materializations/view.sql
2018-01-04 21:12:25,947: Parsing materializations/incremental.sql
2018-01-04 21:12:26,021: Parsing adapters/redshift.sql
2018-01-04 21:12:26,081: Parsing adapters/bigquery.sql
2018-01-04 21:12:26,094: Parsing adapters/postgres.sql
2018-01-04 21:12:26,105: Parsing adapters/common.sql
2018-01-04 21:12:26,167: Parsing model.parsely.parsely_audit
2018-01-04 21:12:26,169: Parsing model.parsely.parsely_video_content
2018-01-04 21:12:26,180: Parsing model.parsely.parsely_post_content
2018-01-04 21:12:26,186: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 21:12:26,196: Parsing model.parsely.parsely_rawdata
2018-01-04 21:12:26,207: Parsing model.parsely.calendar
2018-01-04 21:12:26,210: Parsing model.parsely.parsely_all_events
2018-01-04 21:12:26,237: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:12:26,237: Opening a new connection (0 currently allocated)
2018-01-04 21:12:26,254: Using redshift connection "parsely_all_events".
2018-01-04 21:12:26,254: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:26,281: SQL status: SELECT in 0.03 seconds
2018-01-04 21:12:26,296: Parsing model.parsely.parsely_event_ids
2018-01-04 21:12:26,307: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 21:12:26,311: Parsing model.parsely.parsely_base_events
2018-01-04 21:12:26,331: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:12:26,331: Re-using an available connection from the pool.
2018-01-04 21:12:26,332: Using redshift connection "parsely_base_events".
2018-01-04 21:12:26,332: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:26,353: SQL status: SELECT in 0.02 seconds
2018-01-04 21:12:26,355: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:12:26,370: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 21:12:26,382: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:12:26,385: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:12:26,397: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 21:12:26,403: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:12:26,414: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 21:12:26,428: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 21:12:26,439: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:12:26,439: Re-using an available connection from the pool.
2018-01-04 21:12:26,439: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:12:26,439: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:26,461: SQL status: SELECT in 0.02 seconds
2018-01-04 21:12:26,462: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 21:12:26,479: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 21:12:26,494: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:12:26,494: Re-using an available connection from the pool.
2018-01-04 21:12:26,494: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:12:26,494: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:26,516: SQL status: SELECT in 0.02 seconds
2018-01-04 21:12:26,517: Parsing model.parsely.parsely_incoming_users
2018-01-04 21:12:26,523: Parsing model.parsely.parsely_users
2018-01-04 21:12:26,536: Acquiring new redshift connection "parsely_users".
2018-01-04 21:12:26,537: Re-using an available connection from the pool.
2018-01-04 21:12:26,537: Using redshift connection "parsely_users".
2018-01-04 21:12:26,537: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:26,558: SQL status: SELECT in 0.02 seconds
2018-01-04 21:12:26,560: Parsing model.parsely.parsely_errors
2018-01-04 21:12:26,569: Parsing model.parsely.parsely_bot_traffic
2018-01-04 21:12:26,580: Parsing model.parsely.parsely_custom_events
2018-01-04 21:12:26,596: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 21:12:26,609: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 21:12:26,620: Parsing model.parsely.parsely_sessions
2018-01-04 21:12:26,635: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:12:26,635: Re-using an available connection from the pool.
2018-01-04 21:12:26,636: Using redshift connection "parsely_sessions".
2018-01-04 21:12:26,639: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:26,661: SQL status: SELECT in 0.02 seconds
2018-01-04 21:12:26,662: Parsing model.parsely.parsely_campaigns
2018-01-04 21:12:26,670: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:12:26,670: Re-using an available connection from the pool.
2018-01-04 21:12:26,671: Using redshift connection "parsely_campaigns".
2018-01-04 21:12:26,671: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:26,692: SQL status: SELECT in 0.02 seconds
2018-01-04 21:12:26,710: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 21:12:26,725: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 21:12:26,741: 
2018-01-04 21:12:26,746: Acquiring new redshift connection "master".
2018-01-04 21:12:26,746: Re-using an available connection from the pool.
2018-01-04 21:12:26,746: Using redshift connection "master".
2018-01-04 21:12:26,746: On master: select distinct nspname from pg_namespace
2018-01-04 21:12:26,749: SQL status: SELECT in 0.00 seconds
2018-01-04 21:12:26,754: Using redshift connection "master".
2018-01-04 21:12:26,754: On master: BEGIN
2018-01-04 21:12:26,756: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:12:26,756: On master: COMMIT
2018-01-04 21:12:26,756: Using redshift connection "master".
2018-01-04 21:12:26,756: On master: COMMIT
2018-01-04 21:12:26,758: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:12:26,771: 21:12:26 | Concurrency: 1 threads (target='dev')
2018-01-04 21:12:26,775: 21:12:26 | 
2018-01-04 21:12:26,775: Using redshift connection "master".
2018-01-04 21:12:26,775: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:26,797: SQL status: SELECT in 0.02 seconds
2018-01-04 21:12:27,019: 21:12:27 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 21:12:27,020: Compiling model.parsely.calendar
2018-01-04 21:12:27,036: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 21:12:27,284: Acquiring new redshift connection "calendar".
2018-01-04 21:12:27,285: Opening a new connection (1 currently allocated)
2018-01-04 21:12:27,303: Using redshift connection "calendar".
2018-01-04 21:12:27,305: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:27,332: SQL status: SELECT in 0.03 seconds
2018-01-04 21:12:27,335: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 21:12:27,338: Using redshift connection "calendar".
2018-01-04 21:12:27,338: On calendar: BEGIN
2018-01-04 21:12:27,342: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:12:27,342: Using redshift connection "calendar".
2018-01-04 21:12:27,342: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 21:12:27,614: SQL status: CREATE VIEW in 0.27 seconds
2018-01-04 21:12:27,615: On calendar: COMMIT
2018-01-04 21:12:27,615: Using redshift connection "calendar".
2018-01-04 21:12:27,615: On calendar: COMMIT
2018-01-04 21:12:28,311: SQL status: COMMIT in 0.70 seconds
2018-01-04 21:12:28,311: Using redshift connection "calendar".
2018-01-04 21:12:28,311: On calendar: BEGIN
2018-01-04 21:12:28,313: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:12:28,313: Using redshift connection "calendar".
2018-01-04 21:12:28,314: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 21:12:28,366: SQL status: DROP VIEW in 0.05 seconds
2018-01-04 21:12:28,367: On calendar: COMMIT
2018-01-04 21:12:28,367: Using redshift connection "calendar".
2018-01-04 21:12:28,367: On calendar: COMMIT
2018-01-04 21:12:28,652: SQL status: COMMIT in 0.29 seconds
2018-01-04 21:12:28,653: Using redshift connection "calendar".
2018-01-04 21:12:28,653: On calendar: BEGIN
2018-01-04 21:12:28,655: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:12:28,655: Using redshift connection "calendar".
2018-01-04 21:12:28,656: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 21:12:28,660: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:12:28,660: On calendar: COMMIT
2018-01-04 21:12:28,661: Using redshift connection "calendar".
2018-01-04 21:12:28,661: On calendar: COMMIT
2018-01-04 21:12:29,251: SQL status: COMMIT in 0.59 seconds
2018-01-04 21:12:29,252: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134c9cbd0>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:12:29,319: 21:12:29 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 2.23s]
2018-01-04 21:12:29,319: 21:12:29 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 21:12:29,320: Compiling model.parsely.parsely_rawdata
2018-01-04 21:12:29,337: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:12:29,339: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 21:12:29,339: Re-using an available connection from the pool.
2018-01-04 21:12:29,340: Using redshift connection "parsely_rawdata".
2018-01-04 21:12:29,340: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:29,360: SQL status: SELECT in 0.02 seconds
2018-01-04 21:12:29,361: Using redshift connection "parsely_rawdata".
2018-01-04 21:12:29,361: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:12:29,372: SQL status: SELECT in 0.01 seconds
2018-01-04 21:12:29,373: Using redshift connection "parsely_rawdata".
2018-01-04 21:12:29,373: On parsely_rawdata: BEGIN
2018-01-04 21:12:29,376: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:12:29,376: Using redshift connection "parsely_rawdata".
2018-01-04 21:12:29,376: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:13:00,047: SQL status: SELECT in 30.67 seconds
2018-01-04 21:13:00,047: Using redshift connection "parsely_rawdata".
2018-01-04 21:13:00,048: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 21:13:00,252: SQL status: SELECT in 0.20 seconds
2018-01-04 21:13:00,253: Using redshift connection "parsely_rawdata".
2018-01-04 21:13:00,254: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:13:00,361: SQL status: SELECT in 0.11 seconds
2018-01-04 21:13:00,363: Using redshift connection "parsely_rawdata".
2018-01-04 21:13:00,363: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:13:00,470: SQL status: SELECT in 0.11 seconds
2018-01-04 21:13:00,475: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:13:00,478: Using redshift connection "parsely_rawdata".
2018-01-04 21:13:00,478: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 21:13:31,212: SQL status: INSERT 0 1020803 in 30.73 seconds
2018-01-04 21:13:31,212: On parsely_rawdata: COMMIT
2018-01-04 21:13:31,212: Using redshift connection "parsely_rawdata".
2018-01-04 21:13:31,213: On parsely_rawdata: COMMIT
2018-01-04 21:13:33,250: SQL status: COMMIT in 2.04 seconds
2018-01-04 21:13:33,251: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134d06b10>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:13:33,318: 21:13:33 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1020803 in 63.93s]
2018-01-04 21:13:33,319: 21:13:33 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 21:13:33,320: Compiling model.parsely.parsely_all_events
2018-01-04 21:13:33,361: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:13:33,361: Re-using an available connection from the pool.
2018-01-04 21:13:33,362: Using redshift connection "parsely_all_events".
2018-01-04 21:13:33,362: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:13:33,377: SQL status: SELECT in 0.01 seconds
2018-01-04 21:13:33,398: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:13:33,401: Using redshift connection "parsely_all_events".
2018-01-04 21:13:33,401: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:13:33,415: SQL status: SELECT in 0.01 seconds
2018-01-04 21:13:33,416: Using redshift connection "parsely_all_events".
2018-01-04 21:13:33,416: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:13:33,430: SQL status: SELECT in 0.01 seconds
2018-01-04 21:13:33,434: Using redshift connection "parsely_all_events".
2018-01-04 21:13:33,434: On parsely_all_events: BEGIN
2018-01-04 21:13:33,436: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:13:33,436: Using redshift connection "parsely_all_events".
2018-01-04 21:13:33,436: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:14:59,811: SQL status: SELECT in 86.37 seconds
2018-01-04 21:14:59,812: Using redshift connection "parsely_all_events".
2018-01-04 21:14:59,812: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 21:15:00,029: SQL status: SELECT in 0.22 seconds
2018-01-04 21:15:00,030: Using redshift connection "parsely_all_events".
2018-01-04 21:15:00,030: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:15:00,138: SQL status: SELECT in 0.11 seconds
2018-01-04 21:15:00,139: Using redshift connection "parsely_all_events".
2018-01-04 21:15:00,140: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:15:00,246: SQL status: SELECT in 0.11 seconds
2018-01-04 21:15:00,253: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:15:00,255: Using redshift connection "parsely_all_events".
2018-01-04 21:15:00,255: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 21:15:16,646: SQL status: INSERT 0 905313 in 16.39 seconds
2018-01-04 21:15:16,647: On parsely_all_events: COMMIT
2018-01-04 21:15:16,647: Using redshift connection "parsely_all_events".
2018-01-04 21:15:16,647: On parsely_all_events: COMMIT
2018-01-04 21:15:20,453: SQL status: COMMIT in 3.81 seconds
2018-01-04 21:15:20,454: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134d5b810>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:15:20,508: 21:15:20 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 905313 in 107.13s]
2018-01-04 21:15:20,511: 21:15:20 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 21:15:20,511: Compiling model.parsely.parsely_bot_traffic
2018-01-04 21:15:20,536: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 21:15:20,538: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 21:15:20,538: Re-using an available connection from the pool.
2018-01-04 21:15:20,539: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:15:20,539: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:15:20,561: SQL status: SELECT in 0.01 seconds
2018-01-04 21:15:20,562: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:15:20,562: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:15:20,576: SQL status: SELECT in 0.01 seconds
2018-01-04 21:15:20,579: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:15:20,579: On parsely_bot_traffic: BEGIN
2018-01-04 21:15:20,582: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:15:20,583: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:15:20,583: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:15:37,326: SQL status: SELECT in 16.74 seconds
2018-01-04 21:15:37,326: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:15:37,326: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 21:15:37,453: SQL status: SELECT in 0.13 seconds
2018-01-04 21:15:37,454: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:15:37,454: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:15:37,564: SQL status: SELECT in 0.11 seconds
2018-01-04 21:15:37,566: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:15:37,566: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:15:37,674: SQL status: SELECT in 0.11 seconds
2018-01-04 21:15:37,685: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 21:15:37,694: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:15:37,694: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 21:15:38,833: SQL status: INSERT 0 4 in 1.14 seconds
2018-01-04 21:15:38,833: On parsely_bot_traffic: COMMIT
2018-01-04 21:15:38,833: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:15:38,834: On parsely_bot_traffic: COMMIT
2018-01-04 21:15:39,979: SQL status: COMMIT in 1.15 seconds
2018-01-04 21:15:39,980: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134c9cc90>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:15:40,026: 21:15:40 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 19.47s]
2018-01-04 21:15:40,027: 21:15:40 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 21:15:40,027: Compiling model.parsely.parsely_custom_events
2018-01-04 21:15:40,046: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 21:15:40,055: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 21:15:40,055: Re-using an available connection from the pool.
2018-01-04 21:15:40,055: Using redshift connection "parsely_custom_events".
2018-01-04 21:15:40,055: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:15:40,073: SQL status: SELECT in 0.02 seconds
2018-01-04 21:15:40,073: Using redshift connection "parsely_custom_events".
2018-01-04 21:15:40,074: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:15:40,088: SQL status: SELECT in 0.01 seconds
2018-01-04 21:15:40,091: Using redshift connection "parsely_custom_events".
2018-01-04 21:15:40,091: On parsely_custom_events: BEGIN
2018-01-04 21:15:40,093: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:15:40,093: Using redshift connection "parsely_custom_events".
2018-01-04 21:15:40,093: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:15:56,605: SQL status: SELECT in 16.51 seconds
2018-01-04 21:15:56,605: Using redshift connection "parsely_custom_events".
2018-01-04 21:15:56,605: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 21:15:56,814: SQL status: SELECT in 0.21 seconds
2018-01-04 21:15:56,815: Using redshift connection "parsely_custom_events".
2018-01-04 21:15:56,815: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:15:56,925: SQL status: SELECT in 0.11 seconds
2018-01-04 21:15:56,927: Using redshift connection "parsely_custom_events".
2018-01-04 21:15:56,927: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:15:57,037: SQL status: SELECT in 0.11 seconds
2018-01-04 21:15:57,044: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 21:15:57,045: Using redshift connection "parsely_custom_events".
2018-01-04 21:15:57,046: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 21:15:57,313: SQL status: INSERT 0 0 in 0.27 seconds
2018-01-04 21:15:57,314: On parsely_custom_events: COMMIT
2018-01-04 21:15:57,314: Using redshift connection "parsely_custom_events".
2018-01-04 21:15:57,314: On parsely_custom_events: COMMIT
2018-01-04 21:15:57,602: SQL status: COMMIT in 0.29 seconds
2018-01-04 21:15:57,603: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134c9c150>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:15:57,649: 21:15:57 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 17.58s]
2018-01-04 21:15:57,649: 21:15:57 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 21:15:57,650: Compiling model.parsely.parsely_errors
2018-01-04 21:15:57,672: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 21:15:57,675: Acquiring new redshift connection "parsely_errors".
2018-01-04 21:15:57,675: Re-using an available connection from the pool.
2018-01-04 21:15:57,675: Using redshift connection "parsely_errors".
2018-01-04 21:15:57,675: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:15:57,691: SQL status: SELECT in 0.02 seconds
2018-01-04 21:15:57,691: Using redshift connection "parsely_errors".
2018-01-04 21:15:57,692: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:15:57,706: SQL status: SELECT in 0.01 seconds
2018-01-04 21:15:57,709: Using redshift connection "parsely_errors".
2018-01-04 21:15:57,709: On parsely_errors: BEGIN
2018-01-04 21:15:57,711: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:15:57,711: Using redshift connection "parsely_errors".
2018-01-04 21:15:57,711: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:16:13,781: SQL status: SELECT in 16.07 seconds
2018-01-04 21:16:13,782: Using redshift connection "parsely_errors".
2018-01-04 21:16:13,782: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 21:16:13,932: SQL status: SELECT in 0.15 seconds
2018-01-04 21:16:13,932: Using redshift connection "parsely_errors".
2018-01-04 21:16:13,933: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:16:14,043: SQL status: SELECT in 0.11 seconds
2018-01-04 21:16:14,045: Using redshift connection "parsely_errors".
2018-01-04 21:16:14,045: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:16:14,161: SQL status: SELECT in 0.12 seconds
2018-01-04 21:16:14,168: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 21:16:14,169: Using redshift connection "parsely_errors".
2018-01-04 21:16:14,170: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 21:16:15,317: SQL status: INSERT 0 2 in 1.15 seconds
2018-01-04 21:16:15,318: On parsely_errors: COMMIT
2018-01-04 21:16:15,318: Using redshift connection "parsely_errors".
2018-01-04 21:16:15,318: On parsely_errors: COMMIT
2018-01-04 21:16:16,199: SQL status: COMMIT in 0.88 seconds
2018-01-04 21:16:16,200: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134c92d90>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:16:16,342: 21:16:16 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 18.55s]
2018-01-04 21:16:16,343: 21:16:16 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 21:16:16,343: Compiling model.parsely.parsely_base_events
2018-01-04 21:16:16,351: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:16:16,351: Re-using an available connection from the pool.
2018-01-04 21:16:16,352: Using redshift connection "parsely_base_events".
2018-01-04 21:16:16,352: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:16,367: SQL status: SELECT in 0.02 seconds
2018-01-04 21:16:16,374: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 21:16:16,378: Using redshift connection "parsely_base_events".
2018-01-04 21:16:16,378: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:16,393: SQL status: SELECT in 0.01 seconds
2018-01-04 21:16:16,396: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 21:16:16,398: Using redshift connection "parsely_base_events".
2018-01-04 21:16:16,398: On parsely_base_events: BEGIN
2018-01-04 21:16:16,400: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:16,400: Using redshift connection "parsely_base_events".
2018-01-04 21:16:16,400: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 21:16:16,506: SQL status: CREATE VIEW in 0.11 seconds
2018-01-04 21:16:16,507: On parsely_base_events: COMMIT
2018-01-04 21:16:16,507: Using redshift connection "parsely_base_events".
2018-01-04 21:16:16,507: On parsely_base_events: COMMIT
2018-01-04 21:16:16,702: SQL status: COMMIT in 0.19 seconds
2018-01-04 21:16:16,702: Using redshift connection "parsely_base_events".
2018-01-04 21:16:16,702: On parsely_base_events: BEGIN
2018-01-04 21:16:16,705: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:16,705: Using redshift connection "parsely_base_events".
2018-01-04 21:16:16,705: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 21:16:16,806: SQL status: DROP VIEW in 0.10 seconds
2018-01-04 21:16:16,807: On parsely_base_events: COMMIT
2018-01-04 21:16:16,807: Using redshift connection "parsely_base_events".
2018-01-04 21:16:16,807: On parsely_base_events: COMMIT
2018-01-04 21:16:17,286: SQL status: COMMIT in 0.48 seconds
2018-01-04 21:16:17,286: Using redshift connection "parsely_base_events".
2018-01-04 21:16:17,286: On parsely_base_events: BEGIN
2018-01-04 21:16:17,289: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:17,289: Using redshift connection "parsely_base_events".
2018-01-04 21:16:17,289: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 21:16:17,429: SQL status: ALTER TABLE in 0.14 seconds
2018-01-04 21:16:17,429: On parsely_base_events: COMMIT
2018-01-04 21:16:17,430: Using redshift connection "parsely_base_events".
2018-01-04 21:16:17,430: On parsely_base_events: COMMIT
2018-01-04 21:16:18,218: SQL status: COMMIT in 0.79 seconds
2018-01-04 21:16:18,218: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134d06ed0>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:16:18,263: 21:16:18 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 1.87s]
2018-01-04 21:16:18,263: 21:16:18 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 21:16:18,264: Compiling model.parsely.parsely_event_ids
2018-01-04 21:16:18,275: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 21:16:18,281: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 21:16:18,281: Re-using an available connection from the pool.
2018-01-04 21:16:18,281: Using redshift connection "parsely_event_ids".
2018-01-04 21:16:18,281: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:18,296: SQL status: SELECT in 0.01 seconds
2018-01-04 21:16:18,297: Using redshift connection "parsely_event_ids".
2018-01-04 21:16:18,297: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:18,312: SQL status: SELECT in 0.01 seconds
2018-01-04 21:16:18,313: Using redshift connection "parsely_event_ids".
2018-01-04 21:16:18,313: On parsely_event_ids: BEGIN
2018-01-04 21:16:18,316: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:18,316: Using redshift connection "parsely_event_ids".
2018-01-04 21:16:18,316: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:16:19,020: SQL status: SELECT in 0.70 seconds
2018-01-04 21:16:19,020: Using redshift connection "parsely_event_ids".
2018-01-04 21:16:19,020: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 21:16:19,186: SQL status: SELECT in 0.17 seconds
2018-01-04 21:16:19,186: Using redshift connection "parsely_event_ids".
2018-01-04 21:16:19,186: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:16:19,292: SQL status: SELECT in 0.11 seconds
2018-01-04 21:16:19,293: Using redshift connection "parsely_event_ids".
2018-01-04 21:16:19,293: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:16:19,399: SQL status: SELECT in 0.11 seconds
2018-01-04 21:16:19,401: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 21:16:19,403: Using redshift connection "parsely_event_ids".
2018-01-04 21:16:19,403: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 21:16:20,184: SQL status: INSERT 0 905309 in 0.78 seconds
2018-01-04 21:16:20,185: On parsely_event_ids: COMMIT
2018-01-04 21:16:20,185: Using redshift connection "parsely_event_ids".
2018-01-04 21:16:20,185: On parsely_event_ids: COMMIT
2018-01-04 21:16:20,960: SQL status: COMMIT in 0.77 seconds
2018-01-04 21:16:20,961: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134cb27d0>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:16:21,042: 21:16:21 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 905309 in 2.70s]
2018-01-04 21:16:21,043: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 21:16:21,057: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 21:16:21,058: 21:16:21 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 21:16:21,059: Compiling model.parsely.parsely_post_content
2018-01-04 21:16:21,079: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 21:16:21,081: Acquiring new redshift connection "parsely_post_content".
2018-01-04 21:16:21,081: Re-using an available connection from the pool.
2018-01-04 21:16:21,081: Using redshift connection "parsely_post_content".
2018-01-04 21:16:21,081: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:21,100: SQL status: SELECT in 0.02 seconds
2018-01-04 21:16:21,101: Using redshift connection "parsely_post_content".
2018-01-04 21:16:21,101: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:21,116: SQL status: SELECT in 0.02 seconds
2018-01-04 21:16:21,119: Using redshift connection "parsely_post_content".
2018-01-04 21:16:21,119: On parsely_post_content: BEGIN
2018-01-04 21:16:21,121: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:21,121: Using redshift connection "parsely_post_content".
2018-01-04 21:16:21,121: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:16:24,651: SQL status: SELECT in 3.53 seconds
2018-01-04 21:16:24,651: Using redshift connection "parsely_post_content".
2018-01-04 21:16:24,651: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 21:16:24,842: SQL status: SELECT in 0.19 seconds
2018-01-04 21:16:24,842: Using redshift connection "parsely_post_content".
2018-01-04 21:16:24,843: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:16:24,952: SQL status: SELECT in 0.11 seconds
2018-01-04 21:16:24,953: Using redshift connection "parsely_post_content".
2018-01-04 21:16:24,953: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:16:25,061: SQL status: SELECT in 0.11 seconds
2018-01-04 21:16:25,064: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 21:16:25,066: Using redshift connection "parsely_post_content".
2018-01-04 21:16:25,066: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 21:16:25,433: SQL status: INSERT 0 881 in 0.37 seconds
2018-01-04 21:16:25,434: On parsely_post_content: COMMIT
2018-01-04 21:16:25,434: Using redshift connection "parsely_post_content".
2018-01-04 21:16:25,434: On parsely_post_content: COMMIT
2018-01-04 21:16:26,382: SQL status: COMMIT in 0.95 seconds
2018-01-04 21:16:26,383: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134cfded0>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:16:26,429: 21:16:26 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 881 in 5.32s]
2018-01-04 21:16:26,429: 21:16:26 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 21:16:26,429: Compiling model.parsely.parsely_video_content
2018-01-04 21:16:26,446: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 21:16:26,448: Acquiring new redshift connection "parsely_video_content".
2018-01-04 21:16:26,448: Re-using an available connection from the pool.
2018-01-04 21:16:26,449: Using redshift connection "parsely_video_content".
2018-01-04 21:16:26,449: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:26,464: SQL status: SELECT in 0.02 seconds
2018-01-04 21:16:26,465: Using redshift connection "parsely_video_content".
2018-01-04 21:16:26,465: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:26,479: SQL status: SELECT in 0.01 seconds
2018-01-04 21:16:26,481: Using redshift connection "parsely_video_content".
2018-01-04 21:16:26,481: On parsely_video_content: BEGIN
2018-01-04 21:16:26,483: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:26,483: Using redshift connection "parsely_video_content".
2018-01-04 21:16:26,483: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:16:29,602: SQL status: SELECT in 3.12 seconds
2018-01-04 21:16:29,603: Using redshift connection "parsely_video_content".
2018-01-04 21:16:29,603: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 21:16:29,848: SQL status: SELECT in 0.24 seconds
2018-01-04 21:16:29,848: Using redshift connection "parsely_video_content".
2018-01-04 21:16:29,848: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:16:29,955: SQL status: SELECT in 0.11 seconds
2018-01-04 21:16:29,956: Using redshift connection "parsely_video_content".
2018-01-04 21:16:29,956: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:16:30,064: SQL status: SELECT in 0.11 seconds
2018-01-04 21:16:30,067: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 21:16:30,069: Using redshift connection "parsely_video_content".
2018-01-04 21:16:30,069: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 21:16:30,476: SQL status: INSERT 0 468 in 0.41 seconds
2018-01-04 21:16:30,477: On parsely_video_content: COMMIT
2018-01-04 21:16:30,477: Using redshift connection "parsely_video_content".
2018-01-04 21:16:30,477: On parsely_video_content: COMMIT
2018-01-04 21:16:30,883: SQL status: COMMIT in 0.41 seconds
2018-01-04 21:16:30,883: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134da82d0>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:16:30,933: 21:16:30 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 468 in 4.45s]
2018-01-04 21:16:30,934: 21:16:30 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 21:16:30,934: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 21:16:30,953: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 21:16:30,955: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 21:16:30,956: Re-using an available connection from the pool.
2018-01-04 21:16:30,956: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:16:30,956: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:30,971: SQL status: SELECT in 0.01 seconds
2018-01-04 21:16:30,975: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 21:16:30,976: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:16:30,977: On parsely_entry_exit_urls: BEGIN
2018-01-04 21:16:30,979: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:30,979: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:16:30,979: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 21:16:31,064: SQL status: CREATE VIEW in 0.08 seconds
2018-01-04 21:16:31,065: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:16:31,065: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 21:16:31,069: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:16:31,070: On parsely_entry_exit_urls: COMMIT
2018-01-04 21:16:31,070: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:16:31,070: On parsely_entry_exit_urls: COMMIT
2018-01-04 21:16:31,408: SQL status: COMMIT in 0.34 seconds
2018-01-04 21:16:31,409: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134da82d0>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:16:31,460: 21:16:31 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.47s]
2018-01-04 21:16:31,461: 21:16:31 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 21:16:31,461: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 21:16:31,487: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 21:16:31,496: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 21:16:31,496: Re-using an available connection from the pool.
2018-01-04 21:16:31,496: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:16:31,496: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:31,514: SQL status: SELECT in 0.02 seconds
2018-01-04 21:16:31,521: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 21:16:31,527: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:16:31,527: On parsely_incoming_videoviews: BEGIN
2018-01-04 21:16:31,529: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:31,529: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:16:31,530: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 21:16:32,476: SQL status: CREATE VIEW in 0.95 seconds
2018-01-04 21:16:32,477: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:16:32,477: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 21:16:32,482: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:16:32,482: On parsely_incoming_videoviews: COMMIT
2018-01-04 21:16:32,482: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:16:32,482: On parsely_incoming_videoviews: COMMIT
2018-01-04 21:16:33,325: SQL status: COMMIT in 0.84 seconds
2018-01-04 21:16:33,325: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134da82d0>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:16:33,379: 21:16:33 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.86s]
2018-01-04 21:16:33,379: 21:16:33 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 21:16:33,380: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 21:16:33,392: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:33,392: Re-using an available connection from the pool.
2018-01-04 21:16:33,392: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:33,392: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:33,407: SQL status: SELECT in 0.01 seconds
2018-01-04 21:16:33,414: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 21:16:33,416: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:33,416: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:33,431: SQL status: SELECT in 0.01 seconds
2018-01-04 21:16:33,432: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:33,432: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:33,447: SQL status: SELECT in 0.01 seconds
2018-01-04 21:16:33,450: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:33,450: On parsely_videoviews_sessionized: BEGIN
2018-01-04 21:16:33,452: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:33,453: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:33,453: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:16:54,270: SQL status: SELECT in 20.82 seconds
2018-01-04 21:16:54,270: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:54,270: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 21:16:54,444: SQL status: SELECT in 0.17 seconds
2018-01-04 21:16:54,445: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:54,445: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:16:54,551: SQL status: SELECT in 0.11 seconds
2018-01-04 21:16:54,553: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:54,553: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:16:54,660: SQL status: SELECT in 0.11 seconds
2018-01-04 21:16:54,665: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 21:16:54,666: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:54,667: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 21:16:57,155: SQL status: INSERT 0 142 in 2.49 seconds
2018-01-04 21:16:57,156: On parsely_videoviews_sessionized: COMMIT
2018-01-04 21:16:57,156: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:16:57,156: On parsely_videoviews_sessionized: COMMIT
2018-01-04 21:16:58,554: SQL status: COMMIT in 1.40 seconds
2018-01-04 21:16:58,554: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134c9ced0>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:16:58,616: 21:16:58 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 142 in 25.17s]
2018-01-04 21:16:58,616: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 21:16:58,741: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 21:16:58,743: 21:16:58 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 21:16:58,744: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:16:58,769: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 21:16:58,771: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:16:58,771: Re-using an available connection from the pool.
2018-01-04 21:16:58,771: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:16:58,772: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:58,784: SQL status: SELECT in 0.01 seconds
2018-01-04 21:16:58,788: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 21:16:58,790: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:16:58,790: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 21:16:58,795: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:58,795: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:16:58,795: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 21:16:58,900: SQL status: CREATE VIEW in 0.11 seconds
2018-01-04 21:16:58,901: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:16:58,902: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 21:16:58,907: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:16:58,907: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 21:16:58,907: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:16:58,907: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 21:16:59,113: SQL status: COMMIT in 0.21 seconds
2018-01-04 21:16:59,113: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134cb2390>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:16:59,180: 21:16:59 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.37s]
2018-01-04 21:16:59,183: 21:16:59 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 21:16:59,183: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:16:59,330: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 21:16:59,336: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:16:59,337: Re-using an available connection from the pool.
2018-01-04 21:16:59,337: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:16:59,337: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:16:59,352: SQL status: SELECT in 0.01 seconds
2018-01-04 21:16:59,357: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 21:16:59,359: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:16:59,361: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 21:16:59,364: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:16:59,364: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:16:59,364: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 21:16:59,829: SQL status: CREATE VIEW in 0.47 seconds
2018-01-04 21:16:59,830: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:16:59,830: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 21:16:59,834: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:16:59,835: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 21:16:59,835: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:16:59,835: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 21:17:00,552: SQL status: COMMIT in 0.72 seconds
2018-01-04 21:17:00,553: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134cfded0>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:17:00,596: 21:17:00 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 1.37s]
2018-01-04 21:17:00,597: 21:17:00 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 21:17:00,597: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 21:17:00,634: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 21:17:00,647: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 21:17:00,647: Re-using an available connection from the pool.
2018-01-04 21:17:00,647: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:17:00,647: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:17:00,663: SQL status: SELECT in 0.01 seconds
2018-01-04 21:17:00,673: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 21:17:00,683: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:17:00,683: On parsely_incoming_pageviews: BEGIN
2018-01-04 21:17:00,686: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:17:00,687: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:17:00,687: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 21:17:01,253: SQL status: CREATE VIEW in 0.57 seconds
2018-01-04 21:17:01,254: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:17:01,254: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 21:17:01,259: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 21:17:01,259: On parsely_incoming_pageviews: COMMIT
2018-01-04 21:17:01,260: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:17:01,260: On parsely_incoming_pageviews: COMMIT
2018-01-04 21:17:01,446: SQL status: COMMIT in 0.19 seconds
2018-01-04 21:17:01,447: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134cfded0>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:17:01,500: 21:17:01 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.85s]
2018-01-04 21:17:01,503: 21:17:01 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 21:17:01,503: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 21:17:01,518: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:17:01,519: Re-using an available connection from the pool.
2018-01-04 21:17:01,519: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:17:01,525: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:17:01,540: SQL status: SELECT in 0.02 seconds
2018-01-04 21:17:01,556: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 21:17:01,564: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:17:01,564: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:17:01,579: SQL status: SELECT in 0.01 seconds
2018-01-04 21:17:01,580: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:17:01,580: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:17:01,595: SQL status: SELECT in 0.01 seconds
2018-01-04 21:17:01,598: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:17:01,599: On parsely_pageviews_sessionized: BEGIN
2018-01-04 21:17:01,601: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:17:01,601: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:17:01,601: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:18:58,595: SQL status: SELECT in 116.99 seconds
2018-01-04 21:18:58,596: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:18:58,596: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 21:18:58,755: SQL status: SELECT in 0.16 seconds
2018-01-04 21:18:58,756: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:18:58,756: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:18:58,873: SQL status: SELECT in 0.12 seconds
2018-01-04 21:18:58,875: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:18:58,875: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:18:58,991: SQL status: SELECT in 0.12 seconds
2018-01-04 21:18:59,001: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 21:18:59,002: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:18:59,002: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 21:19:02,190: SQL status: INSERT 0 107947 in 3.19 seconds
2018-01-04 21:19:02,191: On parsely_pageviews_sessionized: COMMIT
2018-01-04 21:19:02,191: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:19:02,191: On parsely_pageviews_sessionized: COMMIT
2018-01-04 21:19:03,610: SQL status: COMMIT in 1.42 seconds
2018-01-04 21:19:03,611: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134d63950>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:19:03,690: 21:19:03 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 107947 in 122.11s]
2018-01-04 21:19:03,693: 21:19:03 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 21:19:03,693: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 21:19:03,839: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 21:19:03,841: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:19:03,842: Re-using an available connection from the pool.
2018-01-04 21:19:03,842: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:19:03,842: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:19:03,865: SQL status: SELECT in 0.02 seconds
2018-01-04 21:19:03,870: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 21:19:03,873: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:19:03,873: On parsely_videoview_engagedtime: BEGIN
2018-01-04 21:19:03,875: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:19:03,875: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:19:03,875: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 21:19:04,001: SQL status: CREATE VIEW in 0.12 seconds
2018-01-04 21:19:04,001: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:19:04,002: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 21:19:04,006: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:19:04,006: On parsely_videoview_engagedtime: COMMIT
2018-01-04 21:19:04,006: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:19:04,006: On parsely_videoview_engagedtime: COMMIT
2018-01-04 21:19:05,027: SQL status: COMMIT in 1.02 seconds
2018-01-04 21:19:05,028: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134d63950>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:19:05,088: 21:19:05 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.33s]
2018-01-04 21:19:05,089: 21:19:05 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 21:19:05,089: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:19:05,130: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 21:19:05,136: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:19:05,136: Re-using an available connection from the pool.
2018-01-04 21:19:05,136: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:19:05,137: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:19:05,161: SQL status: SELECT in 0.02 seconds
2018-01-04 21:19:05,162: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:19:05,162: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:19:05,185: SQL status: SELECT in 0.02 seconds
2018-01-04 21:19:05,189: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:19:05,189: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 21:19:05,191: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:19:05,192: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:19:05,192: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:20:02,038: SQL status: SELECT in 56.85 seconds
2018-01-04 21:20:02,039: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:20:02,039: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 21:20:02,258: SQL status: SELECT in 0.22 seconds
2018-01-04 21:20:02,259: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:20:02,259: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:20:02,378: SQL status: SELECT in 0.12 seconds
2018-01-04 21:20:02,380: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:20:02,380: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:20:02,499: SQL status: SELECT in 0.12 seconds
2018-01-04 21:20:02,506: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 21:20:02,511: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:20:02,511: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 21:20:03,769: SQL status: INSERT 0 141 in 1.26 seconds
2018-01-04 21:20:03,770: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 21:20:03,770: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:20:03,770: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 21:20:05,077: SQL status: COMMIT in 1.31 seconds
2018-01-04 21:20:05,078: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134da8150>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:20:05,153: 21:20:05 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 141 in 59.99s]
2018-01-04 21:20:05,154: 21:20:05 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 21:20:05,154: Compiling model.parsely.parsely_campaigns
2018-01-04 21:20:05,173: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:20:05,173: Re-using an available connection from the pool.
2018-01-04 21:20:05,173: Using redshift connection "parsely_campaigns".
2018-01-04 21:20:05,173: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:20:05,197: SQL status: SELECT in 0.02 seconds
2018-01-04 21:20:05,202: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 21:20:05,211: Using redshift connection "parsely_campaigns".
2018-01-04 21:20:05,211: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:20:05,234: SQL status: SELECT in 0.02 seconds
2018-01-04 21:20:05,235: Using redshift connection "parsely_campaigns".
2018-01-04 21:20:05,235: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:20:05,257: SQL status: SELECT in 0.02 seconds
2018-01-04 21:20:05,260: Using redshift connection "parsely_campaigns".
2018-01-04 21:20:05,260: On parsely_campaigns: BEGIN
2018-01-04 21:20:05,262: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:20:05,262: Using redshift connection "parsely_campaigns".
2018-01-04 21:20:05,262: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:20:06,484: SQL status: SELECT in 1.22 seconds
2018-01-04 21:20:06,485: Using redshift connection "parsely_campaigns".
2018-01-04 21:20:06,485: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 21:20:06,777: SQL status: SELECT in 0.29 seconds
2018-01-04 21:20:06,778: Using redshift connection "parsely_campaigns".
2018-01-04 21:20:06,778: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:20:06,893: SQL status: SELECT in 0.11 seconds
2018-01-04 21:20:06,894: Using redshift connection "parsely_campaigns".
2018-01-04 21:20:06,894: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:20:07,010: SQL status: SELECT in 0.12 seconds
2018-01-04 21:20:07,012: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 21:20:07,014: Using redshift connection "parsely_campaigns".
2018-01-04 21:20:07,014: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 21:20:07,162: SQL status: INSERT 0 387 in 0.15 seconds
2018-01-04 21:20:07,163: On parsely_campaigns: COMMIT
2018-01-04 21:20:07,163: Using redshift connection "parsely_campaigns".
2018-01-04 21:20:07,163: On parsely_campaigns: COMMIT
2018-01-04 21:20:08,062: SQL status: COMMIT in 0.90 seconds
2018-01-04 21:20:08,062: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134d63d10>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:20:08,110: 21:20:08 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 387 in 2.91s]
2018-01-04 21:20:08,110: Compiling model.parsely.parsely_incoming_users
2018-01-04 21:20:08,123: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 21:20:08,131: 21:20:08 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 21:20:08,131: Compiling model.parsely.parsely_users
2018-01-04 21:20:08,149: Acquiring new redshift connection "parsely_users".
2018-01-04 21:20:08,149: Re-using an available connection from the pool.
2018-01-04 21:20:08,149: Using redshift connection "parsely_users".
2018-01-04 21:20:08,149: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:20:08,173: SQL status: SELECT in 0.02 seconds
2018-01-04 21:20:08,319: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 21:20:08,322: Using redshift connection "parsely_users".
2018-01-04 21:20:08,322: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:20:08,345: SQL status: SELECT in 0.02 seconds
2018-01-04 21:20:08,345: Using redshift connection "parsely_users".
2018-01-04 21:20:08,346: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:20:08,368: SQL status: SELECT in 0.02 seconds
2018-01-04 21:20:08,371: Using redshift connection "parsely_users".
2018-01-04 21:20:08,371: On parsely_users: BEGIN
2018-01-04 21:20:08,374: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:20:08,374: Using redshift connection "parsely_users".
2018-01-04 21:20:08,374: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:20:12,741: SQL status: SELECT in 4.37 seconds
2018-01-04 21:20:12,741: Using redshift connection "parsely_users".
2018-01-04 21:20:12,741: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 21:20:12,893: SQL status: SELECT in 0.15 seconds
2018-01-04 21:20:12,893: Using redshift connection "parsely_users".
2018-01-04 21:20:12,893: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:20:13,009: SQL status: SELECT in 0.12 seconds
2018-01-04 21:20:13,010: Using redshift connection "parsely_users".
2018-01-04 21:20:13,010: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:20:13,125: SQL status: SELECT in 0.12 seconds
2018-01-04 21:20:13,128: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 21:20:13,129: Using redshift connection "parsely_users".
2018-01-04 21:20:13,130: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 21:20:14,988: SQL status: INSERT 0 52872 in 1.86 seconds
2018-01-04 21:20:14,988: On parsely_users: COMMIT
2018-01-04 21:20:14,988: Using redshift connection "parsely_users".
2018-01-04 21:20:14,989: On parsely_users: COMMIT
2018-01-04 21:20:15,383: SQL status: COMMIT in 0.39 seconds
2018-01-04 21:20:15,384: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134d95e90>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:20:15,433: 21:20:15 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 52872 in 7.25s]
2018-01-04 21:20:15,434: 21:20:15 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 21:20:15,434: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 21:20:15,575: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 21:20:15,577: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:20:15,578: Re-using an available connection from the pool.
2018-01-04 21:20:15,578: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:20:15,578: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:20:15,601: SQL status: SELECT in 0.02 seconds
2018-01-04 21:20:15,604: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 21:20:15,606: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:20:15,606: On parsely_pageview_engagedtime: BEGIN
2018-01-04 21:20:15,609: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:20:15,609: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:20:15,609: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 21:20:17,372: SQL status: CREATE VIEW in 1.76 seconds
2018-01-04 21:20:17,373: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:20:17,373: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 21:20:17,377: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:20:17,377: On parsely_pageview_engagedtime: COMMIT
2018-01-04 21:20:17,378: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:20:17,378: On parsely_pageview_engagedtime: COMMIT
2018-01-04 21:20:17,649: SQL status: COMMIT in 0.27 seconds
2018-01-04 21:20:17,650: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134da8150>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:20:17,704: 21:20:17 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 2.22s]
2018-01-04 21:20:17,705: 21:20:17 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 21:20:17,706: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 21:20:17,735: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 21:20:17,739: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 21:20:17,739: Re-using an available connection from the pool.
2018-01-04 21:20:17,740: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:20:17,740: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:20:17,766: SQL status: SELECT in 0.03 seconds
2018-01-04 21:20:17,770: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 21:20:17,781: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:20:17,781: On parsely_incoming_sessions: BEGIN
2018-01-04 21:20:17,783: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:20:17,783: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:20:17,784: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 21:20:18,321: SQL status: CREATE VIEW in 0.54 seconds
2018-01-04 21:20:18,322: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:20:18,322: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 21:20:18,462: SQL status: ALTER TABLE in 0.14 seconds
2018-01-04 21:20:18,463: On parsely_incoming_sessions: COMMIT
2018-01-04 21:20:18,463: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:20:18,463: On parsely_incoming_sessions: COMMIT
2018-01-04 21:20:19,038: SQL status: COMMIT in 0.57 seconds
2018-01-04 21:20:19,039: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134d06110>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:20:19,096: 21:20:19 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 1.33s]
2018-01-04 21:20:19,097: 21:20:19 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 21:20:19,097: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:20:19,154: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 21:20:19,170: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:20:19,170: Re-using an available connection from the pool.
2018-01-04 21:20:19,170: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:20:19,170: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:20:19,193: SQL status: SELECT in 0.02 seconds
2018-01-04 21:20:19,193: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:20:19,194: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:20:19,215: SQL status: SELECT in 0.02 seconds
2018-01-04 21:20:19,219: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:20:19,219: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 21:20:19,221: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:20:19,221: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:20:19,221: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:21:11,212: SQL status: SELECT in 51.99 seconds
2018-01-04 21:21:11,212: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:21:11,212: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 21:21:11,430: SQL status: SELECT in 0.22 seconds
2018-01-04 21:21:11,431: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:21:11,431: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:21:11,549: SQL status: SELECT in 0.12 seconds
2018-01-04 21:21:11,550: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:21:11,550: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:21:11,668: SQL status: SELECT in 0.12 seconds
2018-01-04 21:21:11,675: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 21:21:11,676: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:21:11,676: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 21:21:15,549: SQL status: INSERT 0 107978 in 3.87 seconds
2018-01-04 21:21:15,550: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 21:21:15,550: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:21:15,550: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 21:21:17,230: SQL status: COMMIT in 1.68 seconds
2018-01-04 21:21:17,230: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134d63610>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:21:17,369: 21:21:17 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 107978 in 58.13s]
2018-01-04 21:21:17,370: 21:21:17 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 21:21:17,370: Compiling model.parsely.parsely_sessions
2018-01-04 21:21:17,386: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:21:17,386: Re-using an available connection from the pool.
2018-01-04 21:21:17,386: Using redshift connection "parsely_sessions".
2018-01-04 21:21:17,387: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:17,409: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:17,416: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 21:21:17,418: Using redshift connection "parsely_sessions".
2018-01-04 21:21:17,418: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:17,445: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:17,446: Using redshift connection "parsely_sessions".
2018-01-04 21:21:17,446: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:17,467: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:17,472: Using redshift connection "parsely_sessions".
2018-01-04 21:21:17,472: On parsely_sessions: BEGIN
2018-01-04 21:21:17,474: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:21:17,475: Using redshift connection "parsely_sessions".
2018-01-04 21:21:17,475: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:21:32,961: SQL status: SELECT in 15.49 seconds
2018-01-04 21:21:32,961: Using redshift connection "parsely_sessions".
2018-01-04 21:21:32,962: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 21:21:33,146: SQL status: SELECT in 0.18 seconds
2018-01-04 21:21:33,147: Using redshift connection "parsely_sessions".
2018-01-04 21:21:33,147: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:21:33,267: SQL status: SELECT in 0.12 seconds
2018-01-04 21:21:33,268: Using redshift connection "parsely_sessions".
2018-01-04 21:21:33,268: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:21:33,386: SQL status: SELECT in 0.12 seconds
2018-01-04 21:21:33,391: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 21:21:33,393: Using redshift connection "parsely_sessions".
2018-01-04 21:21:33,393: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 21:21:35,164: SQL status: INSERT 0 87688 in 1.77 seconds
2018-01-04 21:21:35,164: On parsely_sessions: COMMIT
2018-01-04 21:21:35,165: Using redshift connection "parsely_sessions".
2018-01-04 21:21:35,165: On parsely_sessions: COMMIT
2018-01-04 21:21:36,469: SQL status: COMMIT in 1.30 seconds
2018-01-04 21:21:36,470: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134da8150>], 'label': '228c900a-03c2-42cf-b4d0-71d8a23d6028'}
2018-01-04 21:21:36,520: 21:21:36 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 87688 in 19.10s]
2018-01-04 21:21:36,538: Using redshift connection "master".
2018-01-04 21:21:36,538: On master: BEGIN
2018-01-04 21:21:36,541: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:21:36,541: On master: COMMIT
2018-01-04 21:21:36,541: Using redshift connection "master".
2018-01-04 21:21:36,541: On master: COMMIT
2018-01-04 21:21:36,543: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:21:36,543: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 21:21:36,558: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 21:21:36,560: Using redshift connection "master".
2018-01-04 21:21:36,560: On master:  select 1 
2018-01-04 21:21:36,564: SQL status: SELECT in 0.00 seconds
2018-01-04 21:21:36,564: 21:21:36 | 
2018-01-04 21:21:36,564: 21:21:36 | Finished running 10 view models, 15 incremental models in 549.77s.
2018-01-04 21:21:36,565: 
2018-01-04 21:21:36,566: Completed successfully
2018-01-04 21:21:36,566: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 21:21:36,567: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134daee10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134daef90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5134d95950>], 'label': 'end'}
2018-01-04 21:21:36,624: Flushing usage events
2018-01-04 21:21:45,015: Tracking: tracking
2018-01-04 21:21:45,019: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada493e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada493f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada493ed0>], 'label': 'start'}
2018-01-04 21:21:45,081: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 21:21:45,119: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 21:21:45,122: Parsing core.sql
2018-01-04 21:21:45,155: Parsing etc/get_custom_schema.sql
2018-01-04 21:21:45,169: Parsing schema_tests/relationships.sql
2018-01-04 21:21:45,174: Parsing schema_tests/accepted_values.sql
2018-01-04 21:21:45,183: Parsing schema_tests/not_null.sql
2018-01-04 21:21:45,186: Parsing schema_tests/unique.sql
2018-01-04 21:21:45,189: Parsing materializations/wrapper.sql
2018-01-04 21:21:45,195: Parsing materializations/archive.sql
2018-01-04 21:21:45,268: Parsing materializations/table.sql
2018-01-04 21:21:45,326: Parsing materializations/helpers.sql
2018-01-04 21:21:45,375: Parsing materializations/bigquery.sql
2018-01-04 21:21:45,421: Parsing materializations/view.sql
2018-01-04 21:21:45,461: Parsing materializations/incremental.sql
2018-01-04 21:21:45,544: Parsing adapters/redshift.sql
2018-01-04 21:21:45,593: Parsing adapters/bigquery.sql
2018-01-04 21:21:45,607: Parsing adapters/postgres.sql
2018-01-04 21:21:45,613: Parsing adapters/common.sql
2018-01-04 21:21:45,662: Parsing model.parsely.parsely_audit
2018-01-04 21:21:45,665: Parsing model.parsely.parsely_video_content
2018-01-04 21:21:45,672: Parsing model.parsely.parsely_post_content
2018-01-04 21:21:45,678: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 21:21:45,684: Parsing model.parsely.parsely_rawdata
2018-01-04 21:21:45,689: Parsing model.parsely.calendar
2018-01-04 21:21:45,691: Parsing model.parsely.parsely_all_events
2018-01-04 21:21:45,709: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:21:45,709: Opening a new connection (0 currently allocated)
2018-01-04 21:21:45,730: Using redshift connection "parsely_all_events".
2018-01-04 21:21:45,730: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:45,757: SQL status: SELECT in 0.03 seconds
2018-01-04 21:21:45,772: Parsing model.parsely.parsely_event_ids
2018-01-04 21:21:45,780: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 21:21:45,788: Parsing model.parsely.parsely_base_events
2018-01-04 21:21:45,800: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:21:45,800: Re-using an available connection from the pool.
2018-01-04 21:21:45,801: Using redshift connection "parsely_base_events".
2018-01-04 21:21:45,801: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:45,822: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:45,823: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:21:45,837: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 21:21:45,845: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:21:45,854: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:21:45,858: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 21:21:45,867: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:21:45,880: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 21:21:45,898: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 21:21:45,915: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:21:45,915: Re-using an available connection from the pool.
2018-01-04 21:21:45,915: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:21:45,915: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:45,936: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:45,938: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 21:21:45,968: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 21:21:45,993: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:21:45,994: Re-using an available connection from the pool.
2018-01-04 21:21:45,994: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:21:45,994: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:46,015: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:46,016: Parsing model.parsely.parsely_incoming_users
2018-01-04 21:21:46,027: Parsing model.parsely.parsely_users
2018-01-04 21:21:46,044: Acquiring new redshift connection "parsely_users".
2018-01-04 21:21:46,044: Re-using an available connection from the pool.
2018-01-04 21:21:46,044: Using redshift connection "parsely_users".
2018-01-04 21:21:46,045: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:46,066: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:46,067: Parsing model.parsely.parsely_errors
2018-01-04 21:21:46,089: Parsing model.parsely.parsely_bot_traffic
2018-01-04 21:21:46,105: Parsing model.parsely.parsely_custom_events
2018-01-04 21:21:46,133: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 21:21:46,146: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 21:21:46,163: Parsing model.parsely.parsely_sessions
2018-01-04 21:21:46,178: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:21:46,179: Re-using an available connection from the pool.
2018-01-04 21:21:46,179: Using redshift connection "parsely_sessions".
2018-01-04 21:21:46,179: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:46,201: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:46,202: Parsing model.parsely.parsely_campaigns
2018-01-04 21:21:46,213: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:21:46,213: Re-using an available connection from the pool.
2018-01-04 21:21:46,214: Using redshift connection "parsely_campaigns".
2018-01-04 21:21:46,214: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:46,236: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:46,250: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 21:21:46,264: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 21:21:46,287: 
2018-01-04 21:21:46,296: Acquiring new redshift connection "master".
2018-01-04 21:21:46,296: Re-using an available connection from the pool.
2018-01-04 21:21:46,296: Using redshift connection "master".
2018-01-04 21:21:46,297: On master: select distinct nspname from pg_namespace
2018-01-04 21:21:46,299: SQL status: SELECT in 0.00 seconds
2018-01-04 21:21:46,307: Using redshift connection "master".
2018-01-04 21:21:46,307: On master: BEGIN
2018-01-04 21:21:46,309: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:21:46,309: On master: COMMIT
2018-01-04 21:21:46,309: Using redshift connection "master".
2018-01-04 21:21:46,310: On master: COMMIT
2018-01-04 21:21:46,311: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:21:46,324: 21:21:46 | Concurrency: 1 threads (target='dev')
2018-01-04 21:21:46,325: 21:21:46 | 
2018-01-04 21:21:46,325: Using redshift connection "master".
2018-01-04 21:21:46,326: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:46,348: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:46,572: 21:21:46 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 21:21:46,572: Compiling model.parsely.calendar
2018-01-04 21:21:46,587: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 21:21:46,590: Acquiring new redshift connection "calendar".
2018-01-04 21:21:46,590: Opening a new connection (1 currently allocated)
2018-01-04 21:21:46,604: Using redshift connection "calendar".
2018-01-04 21:21:46,604: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:46,630: SQL status: SELECT in 0.03 seconds
2018-01-04 21:21:46,634: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 21:21:46,635: Using redshift connection "calendar".
2018-01-04 21:21:46,635: On calendar: BEGIN
2018-01-04 21:21:46,638: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:21:46,638: Using redshift connection "calendar".
2018-01-04 21:21:46,638: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 21:21:46,698: SQL status: CREATE VIEW in 0.06 seconds
2018-01-04 21:21:46,698: On calendar: COMMIT
2018-01-04 21:21:46,699: Using redshift connection "calendar".
2018-01-04 21:21:46,699: On calendar: COMMIT
2018-01-04 21:21:47,073: SQL status: COMMIT in 0.37 seconds
2018-01-04 21:21:47,073: Using redshift connection "calendar".
2018-01-04 21:21:47,073: On calendar: BEGIN
2018-01-04 21:21:47,075: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:21:47,076: Using redshift connection "calendar".
2018-01-04 21:21:47,076: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 21:21:47,229: SQL status: DROP VIEW in 0.15 seconds
2018-01-04 21:21:47,229: On calendar: COMMIT
2018-01-04 21:21:47,229: Using redshift connection "calendar".
2018-01-04 21:21:47,229: On calendar: COMMIT
2018-01-04 21:21:48,139: SQL status: COMMIT in 0.91 seconds
2018-01-04 21:21:48,140: Using redshift connection "calendar".
2018-01-04 21:21:48,140: On calendar: BEGIN
2018-01-04 21:21:48,142: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:21:48,142: Using redshift connection "calendar".
2018-01-04 21:21:48,142: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 21:21:48,327: SQL status: ALTER TABLE in 0.18 seconds
2018-01-04 21:21:48,327: On calendar: COMMIT
2018-01-04 21:21:48,327: Using redshift connection "calendar".
2018-01-04 21:21:48,327: On calendar: COMMIT
2018-01-04 21:21:48,756: SQL status: COMMIT in 0.43 seconds
2018-01-04 21:21:48,757: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada381bd0>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:21:48,811: 21:21:48 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 2.18s]
2018-01-04 21:21:48,811: 21:21:48 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 21:21:48,812: Compiling model.parsely.parsely_rawdata
2018-01-04 21:21:48,829: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:21:48,831: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 21:21:48,831: Re-using an available connection from the pool.
2018-01-04 21:21:48,831: Using redshift connection "parsely_rawdata".
2018-01-04 21:21:48,832: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:48,852: SQL status: SELECT in 0.02 seconds
2018-01-04 21:21:48,853: Using redshift connection "parsely_rawdata".
2018-01-04 21:21:48,853: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:21:48,864: SQL status: SELECT in 0.01 seconds
2018-01-04 21:21:48,865: Using redshift connection "parsely_rawdata".
2018-01-04 21:21:48,865: On parsely_rawdata: BEGIN
2018-01-04 21:21:48,867: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:21:48,868: Using redshift connection "parsely_rawdata".
2018-01-04 21:21:48,868: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:22:21,863: SQL status: SELECT in 32.99 seconds
2018-01-04 21:22:21,863: Using redshift connection "parsely_rawdata".
2018-01-04 21:22:21,863: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 21:22:22,062: SQL status: SELECT in 0.20 seconds
2018-01-04 21:22:22,064: Using redshift connection "parsely_rawdata".
2018-01-04 21:22:22,064: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:22:22,169: SQL status: SELECT in 0.11 seconds
2018-01-04 21:22:22,171: Using redshift connection "parsely_rawdata".
2018-01-04 21:22:22,171: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:22:22,276: SQL status: SELECT in 0.10 seconds
2018-01-04 21:22:22,282: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:22:22,286: Using redshift connection "parsely_rawdata".
2018-01-04 21:22:22,286: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 21:22:55,497: SQL status: INSERT 0 1021805 in 33.21 seconds
2018-01-04 21:22:55,498: On parsely_rawdata: COMMIT
2018-01-04 21:22:55,498: Using redshift connection "parsely_rawdata".
2018-01-04 21:22:55,498: On parsely_rawdata: COMMIT
2018-01-04 21:22:57,909: SQL status: COMMIT in 2.41 seconds
2018-01-04 21:22:57,910: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada3ebb10>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:22:57,956: 21:22:57 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1021805 in 69.10s]
2018-01-04 21:22:57,957: 21:22:57 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 21:22:57,957: Compiling model.parsely.parsely_all_events
2018-01-04 21:22:57,979: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:22:57,979: Re-using an available connection from the pool.
2018-01-04 21:22:57,979: Using redshift connection "parsely_all_events".
2018-01-04 21:22:57,979: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:22:57,995: SQL status: SELECT in 0.02 seconds
2018-01-04 21:22:58,021: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:22:58,024: Using redshift connection "parsely_all_events".
2018-01-04 21:22:58,024: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:22:58,046: SQL status: SELECT in 0.02 seconds
2018-01-04 21:22:58,047: Using redshift connection "parsely_all_events".
2018-01-04 21:22:58,047: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:22:58,062: SQL status: SELECT in 0.02 seconds
2018-01-04 21:22:58,066: Using redshift connection "parsely_all_events".
2018-01-04 21:22:58,067: On parsely_all_events: BEGIN
2018-01-04 21:22:58,069: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:22:58,069: Using redshift connection "parsely_all_events".
2018-01-04 21:22:58,069: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:25:35,640: SQL status: SELECT in 157.57 seconds
2018-01-04 21:25:35,640: Using redshift connection "parsely_all_events".
2018-01-04 21:25:35,640: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 21:25:35,825: SQL status: SELECT in 0.18 seconds
2018-01-04 21:25:35,826: Using redshift connection "parsely_all_events".
2018-01-04 21:25:35,826: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:25:35,941: SQL status: SELECT in 0.11 seconds
2018-01-04 21:25:35,943: Using redshift connection "parsely_all_events".
2018-01-04 21:25:35,943: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:25:36,057: SQL status: SELECT in 0.11 seconds
2018-01-04 21:25:36,064: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:25:36,066: Using redshift connection "parsely_all_events".
2018-01-04 21:25:36,066: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 21:25:52,846: SQL status: INSERT 0 906315 in 16.78 seconds
2018-01-04 21:25:52,847: On parsely_all_events: COMMIT
2018-01-04 21:25:52,847: Using redshift connection "parsely_all_events".
2018-01-04 21:25:52,847: On parsely_all_events: COMMIT
2018-01-04 21:25:55,272: SQL status: COMMIT in 2.43 seconds
2018-01-04 21:25:55,273: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada440810>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:25:55,348: 21:25:55 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 906315 in 177.32s]
2018-01-04 21:25:55,349: 21:25:55 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 21:25:55,349: Compiling model.parsely.parsely_bot_traffic
2018-01-04 21:25:55,367: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 21:25:55,369: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 21:25:55,369: Re-using an available connection from the pool.
2018-01-04 21:25:55,370: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:25:55,370: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:25:55,384: SQL status: SELECT in 0.01 seconds
2018-01-04 21:25:55,385: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:25:55,385: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:25:55,399: SQL status: SELECT in 0.01 seconds
2018-01-04 21:25:55,402: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:25:55,402: On parsely_bot_traffic: BEGIN
2018-01-04 21:25:55,404: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:25:55,404: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:25:55,405: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:26:17,893: SQL status: SELECT in 22.49 seconds
2018-01-04 21:26:17,894: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:26:17,894: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 21:26:18,093: SQL status: SELECT in 0.20 seconds
2018-01-04 21:26:18,094: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:26:18,094: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:26:18,204: SQL status: SELECT in 0.11 seconds
2018-01-04 21:26:18,206: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:26:18,206: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:26:18,317: SQL status: SELECT in 0.11 seconds
2018-01-04 21:26:18,326: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 21:26:18,328: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:26:18,328: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 21:26:19,656: SQL status: INSERT 0 4 in 1.33 seconds
2018-01-04 21:26:19,656: On parsely_bot_traffic: COMMIT
2018-01-04 21:26:19,656: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:26:19,657: On parsely_bot_traffic: COMMIT
2018-01-04 21:26:20,809: SQL status: COMMIT in 1.15 seconds
2018-01-04 21:26:20,809: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada381c90>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:26:20,854: 21:26:20 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 25.46s]
2018-01-04 21:26:20,854: 21:26:20 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 21:26:20,855: Compiling model.parsely.parsely_custom_events
2018-01-04 21:26:20,876: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 21:26:20,882: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 21:26:20,882: Re-using an available connection from the pool.
2018-01-04 21:26:20,882: Using redshift connection "parsely_custom_events".
2018-01-04 21:26:20,882: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:26:20,899: SQL status: SELECT in 0.02 seconds
2018-01-04 21:26:20,900: Using redshift connection "parsely_custom_events".
2018-01-04 21:26:20,900: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:26:20,914: SQL status: SELECT in 0.01 seconds
2018-01-04 21:26:20,917: Using redshift connection "parsely_custom_events".
2018-01-04 21:26:20,918: On parsely_custom_events: BEGIN
2018-01-04 21:26:20,920: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:26:20,921: Using redshift connection "parsely_custom_events".
2018-01-04 21:26:20,921: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:26:41,509: SQL status: SELECT in 20.59 seconds
2018-01-04 21:26:41,509: Using redshift connection "parsely_custom_events".
2018-01-04 21:26:41,509: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 21:26:41,645: SQL status: SELECT in 0.14 seconds
2018-01-04 21:26:41,645: Using redshift connection "parsely_custom_events".
2018-01-04 21:26:41,645: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:26:41,756: SQL status: SELECT in 0.11 seconds
2018-01-04 21:26:41,757: Using redshift connection "parsely_custom_events".
2018-01-04 21:26:41,757: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:26:41,868: SQL status: SELECT in 0.11 seconds
2018-01-04 21:26:41,875: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 21:26:41,882: Using redshift connection "parsely_custom_events".
2018-01-04 21:26:41,882: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 21:26:42,147: SQL status: INSERT 0 0 in 0.26 seconds
2018-01-04 21:26:42,148: On parsely_custom_events: COMMIT
2018-01-04 21:26:42,148: Using redshift connection "parsely_custom_events".
2018-01-04 21:26:42,148: On parsely_custom_events: COMMIT
2018-01-04 21:26:42,688: SQL status: COMMIT in 0.54 seconds
2018-01-04 21:26:42,689: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada381150>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:26:42,760: 21:26:42 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 21.83s]
2018-01-04 21:26:42,761: 21:26:42 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 21:26:42,761: Compiling model.parsely.parsely_errors
2018-01-04 21:26:42,779: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 21:26:42,794: Acquiring new redshift connection "parsely_errors".
2018-01-04 21:26:42,794: Re-using an available connection from the pool.
2018-01-04 21:26:42,794: Using redshift connection "parsely_errors".
2018-01-04 21:26:42,795: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:26:42,810: SQL status: SELECT in 0.01 seconds
2018-01-04 21:26:42,810: Using redshift connection "parsely_errors".
2018-01-04 21:26:42,811: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:26:42,825: SQL status: SELECT in 0.01 seconds
2018-01-04 21:26:42,828: Using redshift connection "parsely_errors".
2018-01-04 21:26:42,828: On parsely_errors: BEGIN
2018-01-04 21:26:42,830: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:26:42,830: Using redshift connection "parsely_errors".
2018-01-04 21:26:42,830: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:27:04,363: SQL status: SELECT in 21.53 seconds
2018-01-04 21:27:04,363: Using redshift connection "parsely_errors".
2018-01-04 21:27:04,363: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 21:27:04,498: SQL status: SELECT in 0.13 seconds
2018-01-04 21:27:04,499: Using redshift connection "parsely_errors".
2018-01-04 21:27:04,499: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:27:04,611: SQL status: SELECT in 0.11 seconds
2018-01-04 21:27:04,613: Using redshift connection "parsely_errors".
2018-01-04 21:27:04,613: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:27:04,724: SQL status: SELECT in 0.11 seconds
2018-01-04 21:27:04,731: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 21:27:04,732: Using redshift connection "parsely_errors".
2018-01-04 21:27:04,732: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 21:27:05,522: SQL status: INSERT 0 2 in 0.79 seconds
2018-01-04 21:27:05,522: On parsely_errors: COMMIT
2018-01-04 21:27:05,522: Using redshift connection "parsely_errors".
2018-01-04 21:27:05,523: On parsely_errors: COMMIT
2018-01-04 21:27:06,703: SQL status: COMMIT in 1.18 seconds
2018-01-04 21:27:06,704: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada377d90>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:27:06,799: 21:27:06 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 23.94s]
2018-01-04 21:27:06,800: 21:27:06 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 21:27:06,800: Compiling model.parsely.parsely_base_events
2018-01-04 21:27:06,812: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:27:06,812: Re-using an available connection from the pool.
2018-01-04 21:27:06,812: Using redshift connection "parsely_base_events".
2018-01-04 21:27:06,812: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:06,827: SQL status: SELECT in 0.02 seconds
2018-01-04 21:27:06,835: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 21:27:06,844: Using redshift connection "parsely_base_events".
2018-01-04 21:27:06,844: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:06,859: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:06,863: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 21:27:06,864: Using redshift connection "parsely_base_events".
2018-01-04 21:27:06,864: On parsely_base_events: BEGIN
2018-01-04 21:27:06,866: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:27:06,866: Using redshift connection "parsely_base_events".
2018-01-04 21:27:06,866: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 21:27:06,969: SQL status: CREATE VIEW in 0.10 seconds
2018-01-04 21:27:06,970: On parsely_base_events: COMMIT
2018-01-04 21:27:06,970: Using redshift connection "parsely_base_events".
2018-01-04 21:27:06,970: On parsely_base_events: COMMIT
2018-01-04 21:27:07,253: SQL status: COMMIT in 0.28 seconds
2018-01-04 21:27:07,253: Using redshift connection "parsely_base_events".
2018-01-04 21:27:07,254: On parsely_base_events: BEGIN
2018-01-04 21:27:07,256: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:27:07,256: Using redshift connection "parsely_base_events".
2018-01-04 21:27:07,256: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 21:27:07,829: SQL status: DROP VIEW in 0.57 seconds
2018-01-04 21:27:07,829: On parsely_base_events: COMMIT
2018-01-04 21:27:07,829: Using redshift connection "parsely_base_events".
2018-01-04 21:27:07,830: On parsely_base_events: COMMIT
2018-01-04 21:27:08,765: SQL status: COMMIT in 0.93 seconds
2018-01-04 21:27:08,765: Using redshift connection "parsely_base_events".
2018-01-04 21:27:08,765: On parsely_base_events: BEGIN
2018-01-04 21:27:08,768: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:27:08,768: Using redshift connection "parsely_base_events".
2018-01-04 21:27:08,768: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 21:27:08,779: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 21:27:08,779: On parsely_base_events: COMMIT
2018-01-04 21:27:08,779: Using redshift connection "parsely_base_events".
2018-01-04 21:27:08,780: On parsely_base_events: COMMIT
2018-01-04 21:27:09,264: SQL status: COMMIT in 0.48 seconds
2018-01-04 21:27:09,265: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada3ebed0>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:27:09,311: 21:27:09 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 2.46s]
2018-01-04 21:27:09,312: 21:27:09 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 21:27:09,312: Compiling model.parsely.parsely_event_ids
2018-01-04 21:27:09,331: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 21:27:09,336: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 21:27:09,336: Re-using an available connection from the pool.
2018-01-04 21:27:09,337: Using redshift connection "parsely_event_ids".
2018-01-04 21:27:09,337: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:09,352: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:09,352: Using redshift connection "parsely_event_ids".
2018-01-04 21:27:09,352: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:09,367: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:09,368: Using redshift connection "parsely_event_ids".
2018-01-04 21:27:09,368: On parsely_event_ids: BEGIN
2018-01-04 21:27:09,370: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:27:09,371: Using redshift connection "parsely_event_ids".
2018-01-04 21:27:09,371: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:27:10,316: SQL status: SELECT in 0.95 seconds
2018-01-04 21:27:10,317: Using redshift connection "parsely_event_ids".
2018-01-04 21:27:10,317: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 21:27:10,500: SQL status: SELECT in 0.18 seconds
2018-01-04 21:27:10,501: Using redshift connection "parsely_event_ids".
2018-01-04 21:27:10,501: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:27:10,605: SQL status: SELECT in 0.10 seconds
2018-01-04 21:27:10,605: Using redshift connection "parsely_event_ids".
2018-01-04 21:27:10,605: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:27:10,712: SQL status: SELECT in 0.11 seconds
2018-01-04 21:27:10,714: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 21:27:10,716: Using redshift connection "parsely_event_ids".
2018-01-04 21:27:10,716: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 21:27:11,607: SQL status: INSERT 0 906311 in 0.89 seconds
2018-01-04 21:27:11,607: On parsely_event_ids: COMMIT
2018-01-04 21:27:11,607: Using redshift connection "parsely_event_ids".
2018-01-04 21:27:11,608: On parsely_event_ids: COMMIT
2018-01-04 21:27:12,136: SQL status: COMMIT in 0.53 seconds
2018-01-04 21:27:12,137: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada3ac7d0>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:27:12,180: 21:27:12 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 906311 in 2.82s]
2018-01-04 21:27:12,181: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 21:27:12,191: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 21:27:12,193: 21:27:12 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 21:27:12,193: Compiling model.parsely.parsely_post_content
2018-01-04 21:27:12,205: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 21:27:12,207: Acquiring new redshift connection "parsely_post_content".
2018-01-04 21:27:12,207: Re-using an available connection from the pool.
2018-01-04 21:27:12,207: Using redshift connection "parsely_post_content".
2018-01-04 21:27:12,208: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:12,222: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:12,223: Using redshift connection "parsely_post_content".
2018-01-04 21:27:12,223: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:12,238: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:12,240: Using redshift connection "parsely_post_content".
2018-01-04 21:27:12,241: On parsely_post_content: BEGIN
2018-01-04 21:27:12,243: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:27:12,243: Using redshift connection "parsely_post_content".
2018-01-04 21:27:12,243: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:27:17,381: SQL status: SELECT in 5.14 seconds
2018-01-04 21:27:17,382: Using redshift connection "parsely_post_content".
2018-01-04 21:27:17,382: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 21:27:17,530: SQL status: SELECT in 0.15 seconds
2018-01-04 21:27:17,531: Using redshift connection "parsely_post_content".
2018-01-04 21:27:17,531: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:27:17,636: SQL status: SELECT in 0.11 seconds
2018-01-04 21:27:17,638: Using redshift connection "parsely_post_content".
2018-01-04 21:27:17,638: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:27:17,744: SQL status: SELECT in 0.11 seconds
2018-01-04 21:27:17,747: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 21:27:17,748: Using redshift connection "parsely_post_content".
2018-01-04 21:27:17,748: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 21:27:18,139: SQL status: INSERT 0 881 in 0.39 seconds
2018-01-04 21:27:18,140: On parsely_post_content: COMMIT
2018-01-04 21:27:18,140: Using redshift connection "parsely_post_content".
2018-01-04 21:27:18,140: On parsely_post_content: COMMIT
2018-01-04 21:27:18,622: SQL status: COMMIT in 0.48 seconds
2018-01-04 21:27:18,623: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada3e2ed0>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:27:18,673: 21:27:18 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 881 in 6.43s]
2018-01-04 21:27:18,673: 21:27:18 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 21:27:18,674: Compiling model.parsely.parsely_video_content
2018-01-04 21:27:18,694: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 21:27:18,697: Acquiring new redshift connection "parsely_video_content".
2018-01-04 21:27:18,697: Re-using an available connection from the pool.
2018-01-04 21:27:18,697: Using redshift connection "parsely_video_content".
2018-01-04 21:27:18,697: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:18,712: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:18,713: Using redshift connection "parsely_video_content".
2018-01-04 21:27:18,713: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:18,727: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:18,729: Using redshift connection "parsely_video_content".
2018-01-04 21:27:18,729: On parsely_video_content: BEGIN
2018-01-04 21:27:18,731: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:27:18,732: Using redshift connection "parsely_video_content".
2018-01-04 21:27:18,732: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:27:22,741: SQL status: SELECT in 4.01 seconds
2018-01-04 21:27:22,742: Using redshift connection "parsely_video_content".
2018-01-04 21:27:22,742: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 21:27:22,903: SQL status: SELECT in 0.16 seconds
2018-01-04 21:27:22,903: Using redshift connection "parsely_video_content".
2018-01-04 21:27:22,904: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:27:23,009: SQL status: SELECT in 0.10 seconds
2018-01-04 21:27:23,009: Using redshift connection "parsely_video_content".
2018-01-04 21:27:23,010: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:27:23,115: SQL status: SELECT in 0.11 seconds
2018-01-04 21:27:23,118: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 21:27:23,119: Using redshift connection "parsely_video_content".
2018-01-04 21:27:23,120: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 21:27:23,464: SQL status: INSERT 0 468 in 0.34 seconds
2018-01-04 21:27:23,465: On parsely_video_content: COMMIT
2018-01-04 21:27:23,465: Using redshift connection "parsely_video_content".
2018-01-04 21:27:23,465: On parsely_video_content: COMMIT
2018-01-04 21:27:23,914: SQL status: COMMIT in 0.45 seconds
2018-01-04 21:27:23,915: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada48d150>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:27:23,965: 21:27:23 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 468 in 5.24s]
2018-01-04 21:27:23,965: 21:27:23 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 21:27:23,966: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 21:27:23,985: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 21:27:23,987: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 21:27:23,988: Re-using an available connection from the pool.
2018-01-04 21:27:23,988: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:27:23,988: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:24,004: SQL status: SELECT in 0.02 seconds
2018-01-04 21:27:24,008: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 21:27:24,010: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:27:24,010: On parsely_entry_exit_urls: BEGIN
2018-01-04 21:27:24,015: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:27:24,015: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:27:24,015: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 21:27:24,446: SQL status: CREATE VIEW in 0.43 seconds
2018-01-04 21:27:24,447: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:27:24,447: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 21:27:24,452: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:27:24,452: On parsely_entry_exit_urls: COMMIT
2018-01-04 21:27:24,452: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:27:24,452: On parsely_entry_exit_urls: COMMIT
2018-01-04 21:27:24,980: SQL status: COMMIT in 0.53 seconds
2018-01-04 21:27:24,980: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada48d150>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:27:25,033: 21:27:25 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 1.01s]
2018-01-04 21:27:25,034: 21:27:25 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 21:27:25,034: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 21:27:25,065: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 21:27:25,068: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 21:27:25,068: Re-using an available connection from the pool.
2018-01-04 21:27:25,068: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:27:25,069: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:25,083: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:25,088: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 21:27:25,090: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:27:25,091: On parsely_incoming_videoviews: BEGIN
2018-01-04 21:27:25,093: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:27:25,093: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:27:25,093: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 21:27:27,044: SQL status: CREATE VIEW in 1.95 seconds
2018-01-04 21:27:27,045: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:27:27,045: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 21:27:27,049: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:27:27,049: On parsely_incoming_videoviews: COMMIT
2018-01-04 21:27:27,049: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:27:27,049: On parsely_incoming_videoviews: COMMIT
2018-01-04 21:27:27,339: SQL status: COMMIT in 0.29 seconds
2018-01-04 21:27:27,339: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada48d150>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:27:27,383: 21:27:27 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 2.31s]
2018-01-04 21:27:27,384: 21:27:27 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 21:27:27,384: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 21:27:27,394: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:27,394: Re-using an available connection from the pool.
2018-01-04 21:27:27,395: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:27,395: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:27,417: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:27,430: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 21:27:27,432: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:27,433: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:27,446: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:27,447: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:27,447: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:27,460: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:27,464: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:27,464: On parsely_videoviews_sessionized: BEGIN
2018-01-04 21:27:27,467: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:27:27,467: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:27,467: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:27:55,581: SQL status: SELECT in 28.11 seconds
2018-01-04 21:27:55,582: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:55,582: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 21:27:55,784: SQL status: SELECT in 0.20 seconds
2018-01-04 21:27:55,786: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:55,786: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:27:55,891: SQL status: SELECT in 0.11 seconds
2018-01-04 21:27:55,892: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:55,893: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:27:55,998: SQL status: SELECT in 0.11 seconds
2018-01-04 21:27:56,005: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 21:27:56,006: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:56,006: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 21:27:57,253: SQL status: INSERT 0 142 in 1.25 seconds
2018-01-04 21:27:57,253: On parsely_videoviews_sessionized: COMMIT
2018-01-04 21:27:57,254: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:27:57,254: On parsely_videoviews_sessionized: COMMIT
2018-01-04 21:27:58,358: SQL status: COMMIT in 1.10 seconds
2018-01-04 21:27:58,359: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada3e2e10>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:27:58,417: 21:27:58 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 142 in 30.97s]
2018-01-04 21:27:58,418: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 21:27:58,498: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 21:27:58,500: 21:27:58 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 21:27:58,501: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:27:58,567: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 21:27:58,569: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:27:58,569: Re-using an available connection from the pool.
2018-01-04 21:27:58,569: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:27:58,569: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:27:58,583: SQL status: SELECT in 0.01 seconds
2018-01-04 21:27:58,586: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 21:27:58,587: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:27:58,587: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 21:27:58,590: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:27:58,590: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:27:58,590: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 21:27:59,500: SQL status: CREATE VIEW in 0.91 seconds
2018-01-04 21:27:59,501: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:27:59,501: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 21:27:59,508: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 21:27:59,508: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 21:27:59,508: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:27:59,508: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 21:28:00,136: SQL status: COMMIT in 0.63 seconds
2018-01-04 21:28:00,136: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada3ac910>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:28:00,186: 21:28:00 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.64s]
2018-01-04 21:28:00,187: 21:28:00 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 21:28:00,187: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:28:00,285: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 21:28:00,287: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:28:00,287: Re-using an available connection from the pool.
2018-01-04 21:28:00,287: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:28:00,287: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:28:00,302: SQL status: SELECT in 0.01 seconds
2018-01-04 21:28:00,307: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 21:28:00,311: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:28:00,311: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 21:28:00,313: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:28:00,313: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:28:00,313: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 21:28:00,827: SQL status: CREATE VIEW in 0.51 seconds
2018-01-04 21:28:00,828: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:28:00,828: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 21:28:00,833: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 21:28:00,834: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 21:28:00,834: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:28:00,834: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 21:28:01,208: SQL status: COMMIT in 0.37 seconds
2018-01-04 21:28:01,209: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada377cd0>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:28:01,250: 21:28:01 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 1.02s]
2018-01-04 21:28:01,251: 21:28:01 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 21:28:01,251: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 21:28:01,274: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 21:28:01,280: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 21:28:01,280: Re-using an available connection from the pool.
2018-01-04 21:28:01,280: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:28:01,280: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:28:01,295: SQL status: SELECT in 0.01 seconds
2018-01-04 21:28:01,302: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 21:28:01,310: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:28:01,310: On parsely_incoming_pageviews: BEGIN
2018-01-04 21:28:01,312: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:28:01,312: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:28:01,312: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 21:28:01,600: SQL status: CREATE VIEW in 0.29 seconds
2018-01-04 21:28:01,601: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:28:01,601: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 21:28:01,748: SQL status: ALTER TABLE in 0.15 seconds
2018-01-04 21:28:01,748: On parsely_incoming_pageviews: COMMIT
2018-01-04 21:28:01,748: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:28:01,748: On parsely_incoming_pageviews: COMMIT
2018-01-04 21:28:02,391: SQL status: COMMIT in 0.64 seconds
2018-01-04 21:28:02,392: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada48d210>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:28:02,435: 21:28:02 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.14s]
2018-01-04 21:28:02,436: 21:28:02 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 21:28:02,436: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 21:28:02,447: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:28:02,447: Re-using an available connection from the pool.
2018-01-04 21:28:02,448: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:28:02,448: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:28:02,463: SQL status: SELECT in 0.02 seconds
2018-01-04 21:28:02,471: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 21:28:02,474: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:28:02,474: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:28:02,488: SQL status: SELECT in 0.01 seconds
2018-01-04 21:28:02,489: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:28:02,489: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:28:02,503: SQL status: SELECT in 0.01 seconds
2018-01-04 21:28:02,507: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:28:02,507: On parsely_pageviews_sessionized: BEGIN
2018-01-04 21:28:02,509: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:28:02,509: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:28:02,510: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:30:14,939: SQL status: SELECT in 132.43 seconds
2018-01-04 21:30:14,939: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:30:14,940: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 21:30:15,080: SQL status: SELECT in 0.14 seconds
2018-01-04 21:30:15,081: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:30:15,081: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:30:15,196: SQL status: SELECT in 0.12 seconds
2018-01-04 21:30:15,198: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:30:15,198: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:30:15,315: SQL status: SELECT in 0.12 seconds
2018-01-04 21:30:15,322: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 21:30:15,323: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:30:15,324: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 21:30:18,459: SQL status: INSERT 0 108091 in 3.14 seconds
2018-01-04 21:30:18,460: On parsely_pageviews_sessionized: COMMIT
2018-01-04 21:30:18,460: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:30:18,460: On parsely_pageviews_sessionized: COMMIT
2018-01-04 21:30:20,627: SQL status: COMMIT in 2.17 seconds
2018-01-04 21:30:20,628: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada3e2e10>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:30:20,704: 21:30:20 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 108091 in 138.19s]
2018-01-04 21:30:20,704: 21:30:20 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 21:30:20,707: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 21:30:20,928: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 21:30:20,939: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:30:20,939: Re-using an available connection from the pool.
2018-01-04 21:30:20,939: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:30:20,939: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:30:20,962: SQL status: SELECT in 0.02 seconds
2018-01-04 21:30:20,967: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 21:30:20,968: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:30:20,969: On parsely_videoview_engagedtime: BEGIN
2018-01-04 21:30:20,971: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:30:20,971: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:30:20,971: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 21:30:21,454: SQL status: CREATE VIEW in 0.48 seconds
2018-01-04 21:30:21,455: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:30:21,455: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 21:30:21,460: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:30:21,460: On parsely_videoview_engagedtime: COMMIT
2018-01-04 21:30:21,460: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:30:21,460: On parsely_videoview_engagedtime: COMMIT
2018-01-04 21:30:22,255: SQL status: COMMIT in 0.79 seconds
2018-01-04 21:30:22,255: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada3e2e10>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:30:22,323: 21:30:22 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.55s]
2018-01-04 21:30:22,324: 21:30:22 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 21:30:22,324: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:30:22,357: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 21:30:22,360: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:30:22,360: Re-using an available connection from the pool.
2018-01-04 21:30:22,360: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:30:22,360: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:30:22,383: SQL status: SELECT in 0.02 seconds
2018-01-04 21:30:22,384: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:30:22,384: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:30:22,406: SQL status: SELECT in 0.02 seconds
2018-01-04 21:30:22,410: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:30:22,410: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 21:30:22,412: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:30:22,412: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:30:22,413: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:31:32,054: SQL status: SELECT in 69.64 seconds
2018-01-04 21:31:32,055: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:31:32,055: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 21:31:32,214: SQL status: SELECT in 0.16 seconds
2018-01-04 21:31:32,215: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:31:32,215: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:31:32,329: SQL status: SELECT in 0.11 seconds
2018-01-04 21:31:32,330: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:31:32,330: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:31:32,443: SQL status: SELECT in 0.11 seconds
2018-01-04 21:31:32,449: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 21:31:32,451: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:31:32,451: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 21:31:33,532: SQL status: INSERT 0 141 in 1.08 seconds
2018-01-04 21:31:33,533: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 21:31:33,533: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:31:33,533: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 21:31:34,668: SQL status: COMMIT in 1.13 seconds
2018-01-04 21:31:34,668: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada47a990>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:31:34,744: 21:31:34 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 141 in 72.34s]
2018-01-04 21:31:34,744: 21:31:34 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 21:31:34,745: Compiling model.parsely.parsely_campaigns
2018-01-04 21:31:34,760: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:31:34,761: Re-using an available connection from the pool.
2018-01-04 21:31:34,761: Using redshift connection "parsely_campaigns".
2018-01-04 21:31:34,761: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:31:34,784: SQL status: SELECT in 0.02 seconds
2018-01-04 21:31:34,791: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 21:31:34,797: Using redshift connection "parsely_campaigns".
2018-01-04 21:31:34,797: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:31:34,820: SQL status: SELECT in 0.02 seconds
2018-01-04 21:31:34,821: Using redshift connection "parsely_campaigns".
2018-01-04 21:31:34,821: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:31:34,843: SQL status: SELECT in 0.02 seconds
2018-01-04 21:31:34,845: Using redshift connection "parsely_campaigns".
2018-01-04 21:31:34,846: On parsely_campaigns: BEGIN
2018-01-04 21:31:34,848: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:31:34,848: Using redshift connection "parsely_campaigns".
2018-01-04 21:31:34,848: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:31:35,953: SQL status: SELECT in 1.10 seconds
2018-01-04 21:31:35,953: Using redshift connection "parsely_campaigns".
2018-01-04 21:31:35,954: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 21:31:36,324: SQL status: SELECT in 0.37 seconds
2018-01-04 21:31:36,325: Using redshift connection "parsely_campaigns".
2018-01-04 21:31:36,325: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:31:36,435: SQL status: SELECT in 0.11 seconds
2018-01-04 21:31:36,436: Using redshift connection "parsely_campaigns".
2018-01-04 21:31:36,436: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:31:36,545: SQL status: SELECT in 0.11 seconds
2018-01-04 21:31:36,548: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 21:31:36,549: Using redshift connection "parsely_campaigns".
2018-01-04 21:31:36,549: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 21:31:36,695: SQL status: INSERT 0 388 in 0.15 seconds
2018-01-04 21:31:36,696: On parsely_campaigns: COMMIT
2018-01-04 21:31:36,696: Using redshift connection "parsely_campaigns".
2018-01-04 21:31:36,696: On parsely_campaigns: COMMIT
2018-01-04 21:31:37,211: SQL status: COMMIT in 0.51 seconds
2018-01-04 21:31:37,212: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada4486d0>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:31:37,265: 21:31:37 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 388 in 2.47s]
2018-01-04 21:31:37,266: Compiling model.parsely.parsely_incoming_users
2018-01-04 21:31:37,292: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 21:31:37,294: 21:31:37 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 21:31:37,294: Compiling model.parsely.parsely_users
2018-01-04 21:31:37,316: Acquiring new redshift connection "parsely_users".
2018-01-04 21:31:37,317: Re-using an available connection from the pool.
2018-01-04 21:31:37,317: Using redshift connection "parsely_users".
2018-01-04 21:31:37,317: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:31:37,339: SQL status: SELECT in 0.02 seconds
2018-01-04 21:31:37,514: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 21:31:37,517: Using redshift connection "parsely_users".
2018-01-04 21:31:37,517: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:31:37,537: SQL status: SELECT in 0.02 seconds
2018-01-04 21:31:37,538: Using redshift connection "parsely_users".
2018-01-04 21:31:37,539: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:31:37,557: SQL status: SELECT in 0.02 seconds
2018-01-04 21:31:37,561: Using redshift connection "parsely_users".
2018-01-04 21:31:37,561: On parsely_users: BEGIN
2018-01-04 21:31:37,566: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:31:37,566: Using redshift connection "parsely_users".
2018-01-04 21:31:37,566: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:31:39,241: SQL status: SELECT in 1.68 seconds
2018-01-04 21:31:39,242: Using redshift connection "parsely_users".
2018-01-04 21:31:39,242: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 21:31:39,526: SQL status: SELECT in 0.28 seconds
2018-01-04 21:31:39,526: Using redshift connection "parsely_users".
2018-01-04 21:31:39,526: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:31:39,635: SQL status: SELECT in 0.11 seconds
2018-01-04 21:31:39,636: Using redshift connection "parsely_users".
2018-01-04 21:31:39,636: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:31:39,746: SQL status: SELECT in 0.11 seconds
2018-01-04 21:31:39,748: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 21:31:39,749: Using redshift connection "parsely_users".
2018-01-04 21:31:39,750: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 21:31:40,015: SQL status: INSERT 0 52938 in 0.26 seconds
2018-01-04 21:31:40,015: On parsely_users: COMMIT
2018-01-04 21:31:40,016: Using redshift connection "parsely_users".
2018-01-04 21:31:40,016: On parsely_users: COMMIT
2018-01-04 21:31:40,493: SQL status: COMMIT in 0.48 seconds
2018-01-04 21:31:40,494: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada3ebb10>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:31:40,542: 21:31:40 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 52938 in 3.20s]
2018-01-04 21:31:40,544: 21:31:40 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 21:31:40,544: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 21:31:40,674: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 21:31:40,684: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:31:40,684: Re-using an available connection from the pool.
2018-01-04 21:31:40,684: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:31:40,684: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:31:40,707: SQL status: SELECT in 0.02 seconds
2018-01-04 21:31:40,711: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 21:31:40,712: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:31:40,712: On parsely_pageview_engagedtime: BEGIN
2018-01-04 21:31:40,715: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:31:40,717: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:31:40,717: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 21:31:41,312: SQL status: CREATE VIEW in 0.59 seconds
2018-01-04 21:31:41,312: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:31:41,313: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 21:31:41,317: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:31:41,317: On parsely_pageview_engagedtime: COMMIT
2018-01-04 21:31:41,317: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:31:41,317: On parsely_pageview_engagedtime: COMMIT
2018-01-04 21:31:41,552: SQL status: COMMIT in 0.23 seconds
2018-01-04 21:31:41,552: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada440d10>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:31:41,604: 21:31:41 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 1.01s]
2018-01-04 21:31:41,605: 21:31:41 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 21:31:41,606: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 21:31:41,634: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 21:31:41,636: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 21:31:41,636: Re-using an available connection from the pool.
2018-01-04 21:31:41,636: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:31:41,637: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:31:41,658: SQL status: SELECT in 0.02 seconds
2018-01-04 21:31:41,663: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 21:31:41,664: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:31:41,664: On parsely_incoming_sessions: BEGIN
2018-01-04 21:31:41,667: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:31:41,667: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:31:41,667: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 21:31:41,959: SQL status: CREATE VIEW in 0.29 seconds
2018-01-04 21:31:41,960: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:31:41,960: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 21:31:41,964: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:31:41,965: On parsely_incoming_sessions: COMMIT
2018-01-04 21:31:41,965: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:31:41,965: On parsely_incoming_sessions: COMMIT
2018-01-04 21:31:42,294: SQL status: COMMIT in 0.33 seconds
2018-01-04 21:31:42,295: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada440810>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:31:42,356: 21:31:42 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.69s]
2018-01-04 21:31:42,357: 21:31:42 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 21:31:42,359: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:31:42,398: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 21:31:42,400: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:31:42,401: Re-using an available connection from the pool.
2018-01-04 21:31:42,401: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:31:42,401: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:31:42,426: SQL status: SELECT in 0.02 seconds
2018-01-04 21:31:42,426: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:31:42,426: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:31:42,446: SQL status: SELECT in 0.02 seconds
2018-01-04 21:31:42,449: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:31:42,449: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 21:31:42,451: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:31:42,451: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:31:42,452: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:32:40,454: SQL status: SELECT in 58.00 seconds
2018-01-04 21:32:40,455: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:32:40,455: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 21:32:40,658: SQL status: SELECT in 0.20 seconds
2018-01-04 21:32:40,659: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:32:40,659: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:32:40,774: SQL status: SELECT in 0.12 seconds
2018-01-04 21:32:40,776: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:32:40,776: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:32:40,892: SQL status: SELECT in 0.12 seconds
2018-01-04 21:32:40,898: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 21:32:40,904: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:32:40,904: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 21:32:44,390: SQL status: INSERT 0 108112 in 3.49 seconds
2018-01-04 21:32:44,391: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 21:32:44,391: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:32:44,391: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 21:32:45,694: SQL status: COMMIT in 1.30 seconds
2018-01-04 21:32:45,694: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada440810>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:32:45,763: 21:32:45 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 108112 in 63.34s]
2018-01-04 21:32:45,764: 21:32:45 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 21:32:45,764: Compiling model.parsely.parsely_sessions
2018-01-04 21:32:45,782: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:32:45,782: Re-using an available connection from the pool.
2018-01-04 21:32:45,782: Using redshift connection "parsely_sessions".
2018-01-04 21:32:45,782: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:32:45,805: SQL status: SELECT in 0.02 seconds
2018-01-04 21:32:45,812: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 21:32:45,814: Using redshift connection "parsely_sessions".
2018-01-04 21:32:45,814: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:32:45,835: SQL status: SELECT in 0.02 seconds
2018-01-04 21:32:45,836: Using redshift connection "parsely_sessions".
2018-01-04 21:32:45,837: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:32:45,856: SQL status: SELECT in 0.02 seconds
2018-01-04 21:32:45,861: Using redshift connection "parsely_sessions".
2018-01-04 21:32:45,861: On parsely_sessions: BEGIN
2018-01-04 21:32:45,863: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:32:45,863: Using redshift connection "parsely_sessions".
2018-01-04 21:32:45,863: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:33:03,997: SQL status: SELECT in 18.13 seconds
2018-01-04 21:33:03,997: Using redshift connection "parsely_sessions".
2018-01-04 21:33:03,998: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 21:33:04,167: SQL status: SELECT in 0.17 seconds
2018-01-04 21:33:04,167: Using redshift connection "parsely_sessions".
2018-01-04 21:33:04,168: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:33:04,283: SQL status: SELECT in 0.11 seconds
2018-01-04 21:33:04,284: Using redshift connection "parsely_sessions".
2018-01-04 21:33:04,284: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:33:04,398: SQL status: SELECT in 0.11 seconds
2018-01-04 21:33:04,404: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 21:33:04,405: Using redshift connection "parsely_sessions".
2018-01-04 21:33:04,405: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 21:33:05,954: SQL status: INSERT 0 87824 in 1.55 seconds
2018-01-04 21:33:05,954: On parsely_sessions: COMMIT
2018-01-04 21:33:05,955: Using redshift connection "parsely_sessions".
2018-01-04 21:33:05,955: On parsely_sessions: COMMIT
2018-01-04 21:33:07,083: SQL status: COMMIT in 1.13 seconds
2018-01-04 21:33:07,084: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada448b50>], 'label': 'f039de04-a169-4bef-996e-d53506befe12'}
2018-01-04 21:33:07,138: 21:33:07 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 87824 in 21.32s]
2018-01-04 21:33:07,169: Using redshift connection "master".
2018-01-04 21:33:07,170: On master: BEGIN
2018-01-04 21:33:07,173: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:33:07,174: On master: COMMIT
2018-01-04 21:33:07,174: Using redshift connection "master".
2018-01-04 21:33:07,174: On master: COMMIT
2018-01-04 21:33:07,176: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:33:07,176: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 21:33:07,195: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 21:33:07,196: Using redshift connection "master".
2018-01-04 21:33:07,196: On master:  select 1 
2018-01-04 21:33:07,199: SQL status: SELECT in 0.00 seconds
2018-01-04 21:33:07,199: 21:33:07 | 
2018-01-04 21:33:07,199: 21:33:07 | Finished running 10 view models, 15 incremental models in 680.85s.
2018-01-04 21:33:07,200: 
2018-01-04 21:33:07,200: Completed successfully
2018-01-04 21:33:07,201: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 21:33:07,201: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada493e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada493f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ffada47a950>], 'label': 'end'}
2018-01-04 21:33:07,264: Flushing usage events
2018-01-04 21:33:15,971: Tracking: tracking
2018-01-04 21:33:15,971: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e780e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e780f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e780ed0>], 'label': 'start'}
2018-01-04 21:33:16,029: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 21:33:16,075: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 21:33:16,081: Parsing core.sql
2018-01-04 21:33:16,117: Parsing etc/get_custom_schema.sql
2018-01-04 21:33:16,136: Parsing schema_tests/relationships.sql
2018-01-04 21:33:16,143: Parsing schema_tests/accepted_values.sql
2018-01-04 21:33:16,152: Parsing schema_tests/not_null.sql
2018-01-04 21:33:16,155: Parsing schema_tests/unique.sql
2018-01-04 21:33:16,163: Parsing materializations/wrapper.sql
2018-01-04 21:33:16,169: Parsing materializations/archive.sql
2018-01-04 21:33:16,271: Parsing materializations/table.sql
2018-01-04 21:33:16,331: Parsing materializations/helpers.sql
2018-01-04 21:33:16,382: Parsing materializations/bigquery.sql
2018-01-04 21:33:16,428: Parsing materializations/view.sql
2018-01-04 21:33:16,467: Parsing materializations/incremental.sql
2018-01-04 21:33:16,525: Parsing adapters/redshift.sql
2018-01-04 21:33:16,569: Parsing adapters/bigquery.sql
2018-01-04 21:33:16,579: Parsing adapters/postgres.sql
2018-01-04 21:33:16,604: Parsing adapters/common.sql
2018-01-04 21:33:16,721: Parsing model.parsely.parsely_audit
2018-01-04 21:33:16,727: Parsing model.parsely.parsely_video_content
2018-01-04 21:33:16,734: Parsing model.parsely.parsely_post_content
2018-01-04 21:33:16,745: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 21:33:16,759: Parsing model.parsely.parsely_rawdata
2018-01-04 21:33:16,768: Parsing model.parsely.calendar
2018-01-04 21:33:16,771: Parsing model.parsely.parsely_all_events
2018-01-04 21:33:16,799: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:33:16,799: Opening a new connection (0 currently allocated)
2018-01-04 21:33:16,815: Using redshift connection "parsely_all_events".
2018-01-04 21:33:16,815: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:16,840: SQL status: SELECT in 0.03 seconds
2018-01-04 21:33:16,851: Parsing model.parsely.parsely_event_ids
2018-01-04 21:33:16,856: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 21:33:16,861: Parsing model.parsely.parsely_base_events
2018-01-04 21:33:16,874: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:33:16,874: Re-using an available connection from the pool.
2018-01-04 21:33:16,874: Using redshift connection "parsely_base_events".
2018-01-04 21:33:16,875: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:16,893: SQL status: SELECT in 0.02 seconds
2018-01-04 21:33:16,895: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:33:16,911: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 21:33:16,927: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:33:16,936: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:33:16,940: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 21:33:16,953: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:33:16,970: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 21:33:16,995: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 21:33:17,007: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:33:17,008: Re-using an available connection from the pool.
2018-01-04 21:33:17,008: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:33:17,008: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:17,027: SQL status: SELECT in 0.02 seconds
2018-01-04 21:33:17,029: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 21:33:17,050: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 21:33:17,067: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:33:17,067: Re-using an available connection from the pool.
2018-01-04 21:33:17,067: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:33:17,067: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:17,086: SQL status: SELECT in 0.02 seconds
2018-01-04 21:33:17,087: Parsing model.parsely.parsely_incoming_users
2018-01-04 21:33:17,093: Parsing model.parsely.parsely_users
2018-01-04 21:33:17,106: Acquiring new redshift connection "parsely_users".
2018-01-04 21:33:17,106: Re-using an available connection from the pool.
2018-01-04 21:33:17,106: Using redshift connection "parsely_users".
2018-01-04 21:33:17,112: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:17,130: SQL status: SELECT in 0.02 seconds
2018-01-04 21:33:17,132: Parsing model.parsely.parsely_errors
2018-01-04 21:33:17,142: Parsing model.parsely.parsely_bot_traffic
2018-01-04 21:33:17,154: Parsing model.parsely.parsely_custom_events
2018-01-04 21:33:17,168: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 21:33:17,182: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 21:33:17,193: Parsing model.parsely.parsely_sessions
2018-01-04 21:33:17,208: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:33:17,211: Re-using an available connection from the pool.
2018-01-04 21:33:17,211: Using redshift connection "parsely_sessions".
2018-01-04 21:33:17,211: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:17,229: SQL status: SELECT in 0.02 seconds
2018-01-04 21:33:17,230: Parsing model.parsely.parsely_campaigns
2018-01-04 21:33:17,237: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:33:17,237: Re-using an available connection from the pool.
2018-01-04 21:33:17,238: Using redshift connection "parsely_campaigns".
2018-01-04 21:33:17,238: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:17,255: SQL status: SELECT in 0.02 seconds
2018-01-04 21:33:17,272: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 21:33:17,291: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 21:33:17,314: 
2018-01-04 21:33:17,328: Acquiring new redshift connection "master".
2018-01-04 21:33:17,328: Re-using an available connection from the pool.
2018-01-04 21:33:17,328: Using redshift connection "master".
2018-01-04 21:33:17,328: On master: select distinct nspname from pg_namespace
2018-01-04 21:33:17,330: SQL status: SELECT in 0.00 seconds
2018-01-04 21:33:17,336: Using redshift connection "master".
2018-01-04 21:33:17,337: On master: BEGIN
2018-01-04 21:33:17,338: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:33:17,338: On master: COMMIT
2018-01-04 21:33:17,338: Using redshift connection "master".
2018-01-04 21:33:17,339: On master: COMMIT
2018-01-04 21:33:17,340: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:33:17,355: 21:33:17 | Concurrency: 1 threads (target='dev')
2018-01-04 21:33:17,356: 21:33:17 | 
2018-01-04 21:33:17,356: Using redshift connection "master".
2018-01-04 21:33:17,356: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:17,375: SQL status: SELECT in 0.02 seconds
2018-01-04 21:33:17,532: 21:33:17 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 21:33:17,533: Compiling model.parsely.calendar
2018-01-04 21:33:17,541: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 21:33:17,543: Acquiring new redshift connection "calendar".
2018-01-04 21:33:17,544: Opening a new connection (1 currently allocated)
2018-01-04 21:33:17,558: Using redshift connection "calendar".
2018-01-04 21:33:17,558: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:17,584: SQL status: SELECT in 0.02 seconds
2018-01-04 21:33:17,587: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 21:33:17,588: Using redshift connection "calendar".
2018-01-04 21:33:17,588: On calendar: BEGIN
2018-01-04 21:33:17,590: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:33:17,590: Using redshift connection "calendar".
2018-01-04 21:33:17,590: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 21:33:17,655: SQL status: CREATE VIEW in 0.06 seconds
2018-01-04 21:33:17,656: On calendar: COMMIT
2018-01-04 21:33:17,656: Using redshift connection "calendar".
2018-01-04 21:33:17,656: On calendar: COMMIT
2018-01-04 21:33:17,896: SQL status: COMMIT in 0.24 seconds
2018-01-04 21:33:17,896: Using redshift connection "calendar".
2018-01-04 21:33:17,896: On calendar: BEGIN
2018-01-04 21:33:17,898: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:33:17,899: Using redshift connection "calendar".
2018-01-04 21:33:17,899: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 21:33:17,906: SQL status: DROP VIEW in 0.01 seconds
2018-01-04 21:33:17,906: On calendar: COMMIT
2018-01-04 21:33:17,906: Using redshift connection "calendar".
2018-01-04 21:33:17,906: On calendar: COMMIT
2018-01-04 21:33:18,123: SQL status: COMMIT in 0.22 seconds
2018-01-04 21:33:18,124: Using redshift connection "calendar".
2018-01-04 21:33:18,124: On calendar: BEGIN
2018-01-04 21:33:18,126: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:33:18,126: Using redshift connection "calendar".
2018-01-04 21:33:18,126: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 21:33:18,131: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:33:18,131: On calendar: COMMIT
2018-01-04 21:33:18,131: Using redshift connection "calendar".
2018-01-04 21:33:18,132: On calendar: COMMIT
2018-01-04 21:33:18,324: SQL status: COMMIT in 0.19 seconds
2018-01-04 21:33:18,325: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e66e810>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:33:18,382: 21:33:18 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 0.79s]
2018-01-04 21:33:18,382: 21:33:18 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 21:33:18,382: Compiling model.parsely.parsely_rawdata
2018-01-04 21:33:18,394: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:33:18,397: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 21:33:18,397: Re-using an available connection from the pool.
2018-01-04 21:33:18,397: Using redshift connection "parsely_rawdata".
2018-01-04 21:33:18,397: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:18,416: SQL status: SELECT in 0.02 seconds
2018-01-04 21:33:18,417: Using redshift connection "parsely_rawdata".
2018-01-04 21:33:18,417: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:33:18,427: SQL status: SELECT in 0.01 seconds
2018-01-04 21:33:18,428: Using redshift connection "parsely_rawdata".
2018-01-04 21:33:18,428: On parsely_rawdata: BEGIN
2018-01-04 21:33:18,430: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:33:18,430: Using redshift connection "parsely_rawdata".
2018-01-04 21:33:18,431: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:33:46,660: SQL status: SELECT in 28.23 seconds
2018-01-04 21:33:46,661: Using redshift connection "parsely_rawdata".
2018-01-04 21:33:46,661: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 21:33:46,827: SQL status: SELECT in 0.17 seconds
2018-01-04 21:33:46,828: Using redshift connection "parsely_rawdata".
2018-01-04 21:33:46,829: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:33:46,931: SQL status: SELECT in 0.10 seconds
2018-01-04 21:33:46,933: Using redshift connection "parsely_rawdata".
2018-01-04 21:33:46,933: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:33:47,035: SQL status: SELECT in 0.10 seconds
2018-01-04 21:33:47,045: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:33:47,046: Using redshift connection "parsely_rawdata".
2018-01-04 21:33:47,047: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 21:34:17,996: SQL status: INSERT 0 1022824 in 30.95 seconds
2018-01-04 21:34:17,996: On parsely_rawdata: COMMIT
2018-01-04 21:34:17,996: Using redshift connection "parsely_rawdata".
2018-01-04 21:34:17,996: On parsely_rawdata: COMMIT
2018-01-04 21:34:19,923: SQL status: COMMIT in 1.93 seconds
2018-01-04 21:34:19,924: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e6cff10>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:34:19,995: 21:34:19 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1022824 in 61.54s]
2018-01-04 21:34:19,996: 21:34:19 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 21:34:19,996: Compiling model.parsely.parsely_all_events
2018-01-04 21:34:20,029: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:34:20,029: Re-using an available connection from the pool.
2018-01-04 21:34:20,035: Using redshift connection "parsely_all_events".
2018-01-04 21:34:20,035: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:34:20,050: SQL status: SELECT in 0.01 seconds
2018-01-04 21:34:20,087: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:34:20,089: Using redshift connection "parsely_all_events".
2018-01-04 21:34:20,089: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:34:20,103: SQL status: SELECT in 0.01 seconds
2018-01-04 21:34:20,104: Using redshift connection "parsely_all_events".
2018-01-04 21:34:20,104: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:34:20,118: SQL status: SELECT in 0.01 seconds
2018-01-04 21:34:20,121: Using redshift connection "parsely_all_events".
2018-01-04 21:34:20,121: On parsely_all_events: BEGIN
2018-01-04 21:34:20,123: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:34:20,123: Using redshift connection "parsely_all_events".
2018-01-04 21:34:20,124: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:35:59,621: SQL status: SELECT in 99.50 seconds
2018-01-04 21:35:59,622: Using redshift connection "parsely_all_events".
2018-01-04 21:35:59,622: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 21:35:59,771: SQL status: SELECT in 0.15 seconds
2018-01-04 21:35:59,772: Using redshift connection "parsely_all_events".
2018-01-04 21:35:59,772: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:35:59,875: SQL status: SELECT in 0.10 seconds
2018-01-04 21:35:59,877: Using redshift connection "parsely_all_events".
2018-01-04 21:35:59,877: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:35:59,981: SQL status: SELECT in 0.10 seconds
2018-01-04 21:35:59,992: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:35:59,994: Using redshift connection "parsely_all_events".
2018-01-04 21:35:59,994: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 21:36:16,248: SQL status: INSERT 0 907334 in 16.25 seconds
2018-01-04 21:36:16,249: On parsely_all_events: COMMIT
2018-01-04 21:36:16,249: Using redshift connection "parsely_all_events".
2018-01-04 21:36:16,249: On parsely_all_events: COMMIT
2018-01-04 21:36:19,228: SQL status: COMMIT in 2.98 seconds
2018-01-04 21:36:19,229: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e6e80d0>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:36:19,340: 21:36:19 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 907334 in 119.23s]
2018-01-04 21:36:19,341: 21:36:19 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 21:36:19,341: Compiling model.parsely.parsely_bot_traffic
2018-01-04 21:36:19,367: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 21:36:19,369: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 21:36:19,369: Re-using an available connection from the pool.
2018-01-04 21:36:19,370: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:36:19,370: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:36:19,384: SQL status: SELECT in 0.01 seconds
2018-01-04 21:36:19,386: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:36:19,386: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:36:19,399: SQL status: SELECT in 0.01 seconds
2018-01-04 21:36:19,402: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:36:19,402: On parsely_bot_traffic: BEGIN
2018-01-04 21:36:19,404: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:36:19,404: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:36:19,405: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:36:46,254: SQL status: SELECT in 26.85 seconds
2018-01-04 21:36:46,255: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:36:46,255: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 21:36:46,405: SQL status: SELECT in 0.15 seconds
2018-01-04 21:36:46,405: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:36:46,405: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:36:46,514: SQL status: SELECT in 0.11 seconds
2018-01-04 21:36:46,515: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:36:46,516: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:36:46,620: SQL status: SELECT in 0.10 seconds
2018-01-04 21:36:46,626: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 21:36:46,632: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:36:46,632: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 21:36:47,732: SQL status: INSERT 0 4 in 1.10 seconds
2018-01-04 21:36:47,732: On parsely_bot_traffic: COMMIT
2018-01-04 21:36:47,733: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:36:47,733: On parsely_bot_traffic: COMMIT
2018-01-04 21:36:48,888: SQL status: COMMIT in 1.16 seconds
2018-01-04 21:36:48,889: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e6cff10>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:36:48,942: 21:36:48 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 29.55s]
2018-01-04 21:36:48,943: 21:36:48 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 21:36:48,943: Compiling model.parsely.parsely_custom_events
2018-01-04 21:36:48,978: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 21:36:48,986: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 21:36:48,986: Re-using an available connection from the pool.
2018-01-04 21:36:48,986: Using redshift connection "parsely_custom_events".
2018-01-04 21:36:48,986: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:36:49,001: SQL status: SELECT in 0.01 seconds
2018-01-04 21:36:49,001: Using redshift connection "parsely_custom_events".
2018-01-04 21:36:49,002: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:36:49,015: SQL status: SELECT in 0.01 seconds
2018-01-04 21:36:49,018: Using redshift connection "parsely_custom_events".
2018-01-04 21:36:49,019: On parsely_custom_events: BEGIN
2018-01-04 21:36:49,021: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:36:49,021: Using redshift connection "parsely_custom_events".
2018-01-04 21:36:49,021: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:37:14,736: SQL status: SELECT in 25.71 seconds
2018-01-04 21:37:14,736: Using redshift connection "parsely_custom_events".
2018-01-04 21:37:14,737: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 21:37:14,879: SQL status: SELECT in 0.14 seconds
2018-01-04 21:37:14,880: Using redshift connection "parsely_custom_events".
2018-01-04 21:37:14,880: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:37:14,988: SQL status: SELECT in 0.11 seconds
2018-01-04 21:37:14,990: Using redshift connection "parsely_custom_events".
2018-01-04 21:37:14,990: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:37:15,094: SQL status: SELECT in 0.10 seconds
2018-01-04 21:37:15,101: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 21:37:15,102: Using redshift connection "parsely_custom_events".
2018-01-04 21:37:15,102: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 21:37:15,560: SQL status: INSERT 0 0 in 0.46 seconds
2018-01-04 21:37:15,560: On parsely_custom_events: COMMIT
2018-01-04 21:37:15,561: Using redshift connection "parsely_custom_events".
2018-01-04 21:37:15,561: On parsely_custom_events: COMMIT
2018-01-04 21:37:16,240: SQL status: COMMIT in 0.68 seconds
2018-01-04 21:37:16,241: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e735610>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:37:16,316: 21:37:16 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 27.30s]
2018-01-04 21:37:16,317: 21:37:16 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 21:37:16,317: Compiling model.parsely.parsely_errors
2018-01-04 21:37:16,434: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 21:37:16,436: Acquiring new redshift connection "parsely_errors".
2018-01-04 21:37:16,437: Re-using an available connection from the pool.
2018-01-04 21:37:16,437: Using redshift connection "parsely_errors".
2018-01-04 21:37:16,437: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:37:16,453: SQL status: SELECT in 0.02 seconds
2018-01-04 21:37:16,454: Using redshift connection "parsely_errors".
2018-01-04 21:37:16,454: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:37:16,466: SQL status: SELECT in 0.01 seconds
2018-01-04 21:37:16,469: Using redshift connection "parsely_errors".
2018-01-04 21:37:16,469: On parsely_errors: BEGIN
2018-01-04 21:37:16,472: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:37:16,472: Using redshift connection "parsely_errors".
2018-01-04 21:37:16,472: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:37:40,814: SQL status: SELECT in 24.34 seconds
2018-01-04 21:37:40,814: Using redshift connection "parsely_errors".
2018-01-04 21:37:40,814: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 21:37:40,987: SQL status: SELECT in 0.17 seconds
2018-01-04 21:37:40,988: Using redshift connection "parsely_errors".
2018-01-04 21:37:40,988: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:37:41,103: SQL status: SELECT in 0.11 seconds
2018-01-04 21:37:41,105: Using redshift connection "parsely_errors".
2018-01-04 21:37:41,105: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:37:41,213: SQL status: SELECT in 0.11 seconds
2018-01-04 21:37:41,223: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 21:37:41,224: Using redshift connection "parsely_errors".
2018-01-04 21:37:41,224: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 21:37:41,897: SQL status: INSERT 0 2 in 0.67 seconds
2018-01-04 21:37:41,898: On parsely_errors: COMMIT
2018-01-04 21:37:41,898: Using redshift connection "parsely_errors".
2018-01-04 21:37:41,898: On parsely_errors: COMMIT
2018-01-04 21:37:44,404: SQL status: COMMIT in 2.51 seconds
2018-01-04 21:37:44,405: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e693110>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:37:44,515: 21:37:44 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 28.09s]
2018-01-04 21:37:44,516: 21:37:44 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 21:37:44,516: Compiling model.parsely.parsely_base_events
2018-01-04 21:37:44,529: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:37:44,529: Re-using an available connection from the pool.
2018-01-04 21:37:44,530: Using redshift connection "parsely_base_events".
2018-01-04 21:37:44,530: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:37:44,544: SQL status: SELECT in 0.01 seconds
2018-01-04 21:37:44,551: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 21:37:44,553: Using redshift connection "parsely_base_events".
2018-01-04 21:37:44,553: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:37:44,566: SQL status: SELECT in 0.01 seconds
2018-01-04 21:37:44,569: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 21:37:44,571: Using redshift connection "parsely_base_events".
2018-01-04 21:37:44,571: On parsely_base_events: BEGIN
2018-01-04 21:37:44,575: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:37:44,575: Using redshift connection "parsely_base_events".
2018-01-04 21:37:44,575: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 21:37:45,947: SQL status: CREATE VIEW in 1.37 seconds
2018-01-04 21:37:45,947: On parsely_base_events: COMMIT
2018-01-04 21:37:45,948: Using redshift connection "parsely_base_events".
2018-01-04 21:37:45,948: On parsely_base_events: COMMIT
2018-01-04 21:37:46,291: SQL status: COMMIT in 0.34 seconds
2018-01-04 21:37:46,291: Using redshift connection "parsely_base_events".
2018-01-04 21:37:46,292: On parsely_base_events: BEGIN
2018-01-04 21:37:46,294: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:37:46,294: Using redshift connection "parsely_base_events".
2018-01-04 21:37:46,294: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 21:37:46,398: SQL status: DROP VIEW in 0.10 seconds
2018-01-04 21:37:46,398: On parsely_base_events: COMMIT
2018-01-04 21:37:46,398: Using redshift connection "parsely_base_events".
2018-01-04 21:37:46,398: On parsely_base_events: COMMIT
2018-01-04 21:37:47,683: SQL status: COMMIT in 1.28 seconds
2018-01-04 21:37:47,683: Using redshift connection "parsely_base_events".
2018-01-04 21:37:47,683: On parsely_base_events: BEGIN
2018-01-04 21:37:47,686: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:37:47,686: Using redshift connection "parsely_base_events".
2018-01-04 21:37:47,686: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 21:37:48,076: SQL status: ALTER TABLE in 0.39 seconds
2018-01-04 21:37:48,076: On parsely_base_events: COMMIT
2018-01-04 21:37:48,076: Using redshift connection "parsely_base_events".
2018-01-04 21:37:48,077: On parsely_base_events: COMMIT
2018-01-04 21:37:48,835: SQL status: COMMIT in 0.76 seconds
2018-01-04 21:37:48,836: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e6d89d0>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:37:48,902: 21:37:48 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 4.32s]
2018-01-04 21:37:48,902: 21:37:48 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 21:37:48,904: Compiling model.parsely.parsely_event_ids
2018-01-04 21:37:48,923: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 21:37:48,933: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 21:37:48,933: Re-using an available connection from the pool.
2018-01-04 21:37:48,933: Using redshift connection "parsely_event_ids".
2018-01-04 21:37:48,933: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:37:48,946: SQL status: SELECT in 0.01 seconds
2018-01-04 21:37:48,947: Using redshift connection "parsely_event_ids".
2018-01-04 21:37:48,947: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:37:48,961: SQL status: SELECT in 0.01 seconds
2018-01-04 21:37:48,962: Using redshift connection "parsely_event_ids".
2018-01-04 21:37:48,962: On parsely_event_ids: BEGIN
2018-01-04 21:37:48,965: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:37:48,965: Using redshift connection "parsely_event_ids".
2018-01-04 21:37:48,965: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:37:49,995: SQL status: SELECT in 1.03 seconds
2018-01-04 21:37:49,996: Using redshift connection "parsely_event_ids".
2018-01-04 21:37:49,996: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 21:37:50,140: SQL status: SELECT in 0.14 seconds
2018-01-04 21:37:50,141: Using redshift connection "parsely_event_ids".
2018-01-04 21:37:50,141: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:37:50,244: SQL status: SELECT in 0.10 seconds
2018-01-04 21:37:50,245: Using redshift connection "parsely_event_ids".
2018-01-04 21:37:50,245: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:37:50,348: SQL status: SELECT in 0.10 seconds
2018-01-04 21:37:50,350: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 21:37:50,351: Using redshift connection "parsely_event_ids".
2018-01-04 21:37:50,351: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 21:37:51,292: SQL status: INSERT 0 907330 in 0.94 seconds
2018-01-04 21:37:51,293: On parsely_event_ids: COMMIT
2018-01-04 21:37:51,293: Using redshift connection "parsely_event_ids".
2018-01-04 21:37:51,293: On parsely_event_ids: COMMIT
2018-01-04 21:37:51,907: SQL status: COMMIT in 0.61 seconds
2018-01-04 21:37:51,908: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e6d8110>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:37:51,957: 21:37:51 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 907330 in 3.00s]
2018-01-04 21:37:51,959: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 21:37:51,980: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 21:37:51,989: 21:37:51 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 21:37:51,990: Compiling model.parsely.parsely_post_content
2018-01-04 21:37:52,006: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 21:37:52,019: Acquiring new redshift connection "parsely_post_content".
2018-01-04 21:37:52,019: Re-using an available connection from the pool.
2018-01-04 21:37:52,020: Using redshift connection "parsely_post_content".
2018-01-04 21:37:52,020: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:37:52,034: SQL status: SELECT in 0.01 seconds
2018-01-04 21:37:52,034: Using redshift connection "parsely_post_content".
2018-01-04 21:37:52,034: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:37:52,048: SQL status: SELECT in 0.01 seconds
2018-01-04 21:37:52,050: Using redshift connection "parsely_post_content".
2018-01-04 21:37:52,050: On parsely_post_content: BEGIN
2018-01-04 21:37:52,052: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:37:52,052: Using redshift connection "parsely_post_content".
2018-01-04 21:37:52,052: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:37:57,411: SQL status: SELECT in 5.36 seconds
2018-01-04 21:37:57,412: Using redshift connection "parsely_post_content".
2018-01-04 21:37:57,412: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 21:37:57,577: SQL status: SELECT in 0.17 seconds
2018-01-04 21:37:57,578: Using redshift connection "parsely_post_content".
2018-01-04 21:37:57,578: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:37:57,688: SQL status: SELECT in 0.11 seconds
2018-01-04 21:37:57,689: Using redshift connection "parsely_post_content".
2018-01-04 21:37:57,689: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:37:57,790: SQL status: SELECT in 0.10 seconds
2018-01-04 21:37:57,793: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 21:37:57,794: Using redshift connection "parsely_post_content".
2018-01-04 21:37:57,794: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 21:37:58,155: SQL status: INSERT 0 881 in 0.36 seconds
2018-01-04 21:37:58,156: On parsely_post_content: COMMIT
2018-01-04 21:37:58,156: Using redshift connection "parsely_post_content".
2018-01-04 21:37:58,156: On parsely_post_content: COMMIT
2018-01-04 21:37:58,997: SQL status: COMMIT in 0.84 seconds
2018-01-04 21:37:58,998: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e77a210>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:37:59,042: 21:37:59 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 881 in 7.01s]
2018-01-04 21:37:59,043: 21:37:59 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 21:37:59,043: Compiling model.parsely.parsely_video_content
2018-01-04 21:37:59,062: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 21:37:59,064: Acquiring new redshift connection "parsely_video_content".
2018-01-04 21:37:59,064: Re-using an available connection from the pool.
2018-01-04 21:37:59,065: Using redshift connection "parsely_video_content".
2018-01-04 21:37:59,065: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:37:59,080: SQL status: SELECT in 0.02 seconds
2018-01-04 21:37:59,082: Using redshift connection "parsely_video_content".
2018-01-04 21:37:59,082: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:37:59,097: SQL status: SELECT in 0.01 seconds
2018-01-04 21:37:59,099: Using redshift connection "parsely_video_content".
2018-01-04 21:37:59,099: On parsely_video_content: BEGIN
2018-01-04 21:37:59,102: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:37:59,102: Using redshift connection "parsely_video_content".
2018-01-04 21:37:59,102: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:38:03,579: SQL status: SELECT in 4.48 seconds
2018-01-04 21:38:03,579: Using redshift connection "parsely_video_content".
2018-01-04 21:38:03,580: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 21:38:03,745: SQL status: SELECT in 0.17 seconds
2018-01-04 21:38:03,746: Using redshift connection "parsely_video_content".
2018-01-04 21:38:03,746: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:38:03,853: SQL status: SELECT in 0.11 seconds
2018-01-04 21:38:03,854: Using redshift connection "parsely_video_content".
2018-01-04 21:38:03,854: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:38:03,956: SQL status: SELECT in 0.10 seconds
2018-01-04 21:38:03,959: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 21:38:03,959: Using redshift connection "parsely_video_content".
2018-01-04 21:38:03,959: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 21:38:04,311: SQL status: INSERT 0 468 in 0.35 seconds
2018-01-04 21:38:04,312: On parsely_video_content: COMMIT
2018-01-04 21:38:04,312: Using redshift connection "parsely_video_content".
2018-01-04 21:38:04,312: On parsely_video_content: COMMIT
2018-01-04 21:38:04,795: SQL status: COMMIT in 0.48 seconds
2018-01-04 21:38:04,796: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e6cfbd0>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:38:04,848: 21:38:04 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 468 in 5.75s]
2018-01-04 21:38:04,848: 21:38:04 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 21:38:04,849: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 21:38:04,868: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 21:38:04,873: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 21:38:04,873: Re-using an available connection from the pool.
2018-01-04 21:38:04,874: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:38:04,874: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:04,888: SQL status: SELECT in 0.01 seconds
2018-01-04 21:38:04,892: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 21:38:04,894: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:38:04,894: On parsely_entry_exit_urls: BEGIN
2018-01-04 21:38:04,896: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:38:04,897: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:38:04,897: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 21:38:05,792: SQL status: CREATE VIEW in 0.90 seconds
2018-01-04 21:38:05,793: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:38:05,793: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 21:38:05,796: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:38:05,796: On parsely_entry_exit_urls: COMMIT
2018-01-04 21:38:05,797: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:38:05,797: On parsely_entry_exit_urls: COMMIT
2018-01-04 21:38:06,012: SQL status: COMMIT in 0.21 seconds
2018-01-04 21:38:06,012: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e6cfbd0>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:38:06,058: 21:38:06 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 1.16s]
2018-01-04 21:38:06,059: 21:38:06 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 21:38:06,059: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 21:38:06,084: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 21:38:06,087: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 21:38:06,087: Re-using an available connection from the pool.
2018-01-04 21:38:06,087: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:38:06,087: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:06,101: SQL status: SELECT in 0.01 seconds
2018-01-04 21:38:06,107: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 21:38:06,109: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:38:06,109: On parsely_incoming_videoviews: BEGIN
2018-01-04 21:38:06,112: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:38:06,112: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:38:06,112: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 21:38:06,387: SQL status: CREATE VIEW in 0.28 seconds
2018-01-04 21:38:06,388: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:38:06,388: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 21:38:06,393: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:38:06,393: On parsely_incoming_videoviews: COMMIT
2018-01-04 21:38:06,393: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:38:06,393: On parsely_incoming_videoviews: COMMIT
2018-01-04 21:38:06,704: SQL status: COMMIT in 0.31 seconds
2018-01-04 21:38:06,705: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e6cfbd0>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:38:06,749: 21:38:06 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.65s]
2018-01-04 21:38:06,750: 21:38:06 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 21:38:06,751: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 21:38:06,770: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:06,770: Re-using an available connection from the pool.
2018-01-04 21:38:06,771: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:06,771: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:06,789: SQL status: SELECT in 0.02 seconds
2018-01-04 21:38:06,797: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 21:38:06,802: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:06,803: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:06,817: SQL status: SELECT in 0.01 seconds
2018-01-04 21:38:06,818: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:06,818: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:06,832: SQL status: SELECT in 0.01 seconds
2018-01-04 21:38:06,836: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:06,836: On parsely_videoviews_sessionized: BEGIN
2018-01-04 21:38:06,838: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:38:06,838: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:06,839: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:38:39,267: SQL status: SELECT in 32.43 seconds
2018-01-04 21:38:39,268: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:39,268: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 21:38:39,916: SQL status: SELECT in 0.65 seconds
2018-01-04 21:38:39,917: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:39,917: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:38:40,027: SQL status: SELECT in 0.11 seconds
2018-01-04 21:38:40,029: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:40,029: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:38:40,139: SQL status: SELECT in 0.11 seconds
2018-01-04 21:38:40,150: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 21:38:40,177: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:40,177: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 21:38:41,376: SQL status: INSERT 0 142 in 1.20 seconds
2018-01-04 21:38:41,376: On parsely_videoviews_sessionized: COMMIT
2018-01-04 21:38:41,376: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:38:41,377: On parsely_videoviews_sessionized: COMMIT
2018-01-04 21:38:42,618: SQL status: COMMIT in 1.24 seconds
2018-01-04 21:38:42,619: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e6d8950>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:38:42,684: 21:38:42 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 142 in 35.87s]
2018-01-04 21:38:42,685: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 21:38:42,767: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 21:38:42,769: 21:38:42 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 21:38:42,769: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:38:42,810: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 21:38:42,812: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:38:42,812: Re-using an available connection from the pool.
2018-01-04 21:38:42,812: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:38:42,812: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:42,831: SQL status: SELECT in 0.02 seconds
2018-01-04 21:38:42,835: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 21:38:42,836: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:38:42,836: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 21:38:42,838: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:38:42,838: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:38:42,838: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 21:38:43,426: SQL status: CREATE VIEW in 0.59 seconds
2018-01-04 21:38:43,427: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:38:43,427: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 21:38:43,430: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:38:43,431: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 21:38:43,431: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:38:43,431: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 21:38:43,852: SQL status: COMMIT in 0.42 seconds
2018-01-04 21:38:43,853: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e66ea90>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:38:43,891: 21:38:43 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.08s]
2018-01-04 21:38:43,894: 21:38:43 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 21:38:43,894: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:38:43,966: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 21:38:43,967: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:38:43,967: Re-using an available connection from the pool.
2018-01-04 21:38:43,967: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:38:43,967: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:43,985: SQL status: SELECT in 0.02 seconds
2018-01-04 21:38:43,990: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 21:38:43,990: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:38:43,991: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 21:38:43,997: SQL status: BEGIN in 0.01 seconds
2018-01-04 21:38:43,997: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:38:43,997: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 21:38:44,075: SQL status: CREATE VIEW in 0.08 seconds
2018-01-04 21:38:44,075: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:38:44,076: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 21:38:44,079: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:38:44,080: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 21:38:44,080: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:38:44,080: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 21:38:44,246: SQL status: COMMIT in 0.17 seconds
2018-01-04 21:38:44,247: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e767990>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:38:44,307: 21:38:44 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.35s]
2018-01-04 21:38:44,308: 21:38:44 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 21:38:44,308: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 21:38:44,330: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 21:38:44,332: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 21:38:44,333: Re-using an available connection from the pool.
2018-01-04 21:38:44,333: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:38:44,333: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:44,350: SQL status: SELECT in 0.02 seconds
2018-01-04 21:38:44,356: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 21:38:44,357: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:38:44,359: On parsely_incoming_pageviews: BEGIN
2018-01-04 21:38:44,361: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:38:44,361: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:38:44,361: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 21:38:44,448: SQL status: CREATE VIEW in 0.09 seconds
2018-01-04 21:38:44,449: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:38:44,449: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 21:38:44,454: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:38:44,454: On parsely_incoming_pageviews: COMMIT
2018-01-04 21:38:44,454: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:38:44,454: On parsely_incoming_pageviews: COMMIT
2018-01-04 21:38:44,795: SQL status: COMMIT in 0.34 seconds
2018-01-04 21:38:44,796: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e66e810>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:38:44,838: 21:38:44 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.49s]
2018-01-04 21:38:44,840: 21:38:44 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 21:38:44,840: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 21:38:44,858: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:38:44,858: Re-using an available connection from the pool.
2018-01-04 21:38:44,858: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:38:44,858: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:44,875: SQL status: SELECT in 0.02 seconds
2018-01-04 21:38:44,883: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 21:38:44,889: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:38:44,889: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:44,906: SQL status: SELECT in 0.02 seconds
2018-01-04 21:38:44,907: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:38:44,907: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:38:44,923: SQL status: SELECT in 0.02 seconds
2018-01-04 21:38:44,926: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:38:44,927: On parsely_pageviews_sessionized: BEGIN
2018-01-04 21:38:44,929: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:38:44,929: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:38:44,929: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:41:07,672: SQL status: SELECT in 142.74 seconds
2018-01-04 21:41:07,672: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:41:07,673: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 21:41:07,927: SQL status: SELECT in 0.25 seconds
2018-01-04 21:41:07,928: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:41:07,928: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:41:08,042: SQL status: SELECT in 0.11 seconds
2018-01-04 21:41:08,044: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:41:08,044: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:41:08,158: SQL status: SELECT in 0.11 seconds
2018-01-04 21:41:08,165: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 21:41:08,167: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:41:08,175: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 21:41:11,105: SQL status: INSERT 0 108200 in 2.93 seconds
2018-01-04 21:41:11,106: On parsely_pageviews_sessionized: COMMIT
2018-01-04 21:41:11,106: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:41:11,106: On parsely_pageviews_sessionized: COMMIT
2018-01-04 21:41:12,534: SQL status: COMMIT in 1.43 seconds
2018-01-04 21:41:12,535: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e735f90>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:41:12,608: 21:41:12 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 108200 in 147.70s]
2018-01-04 21:41:12,609: 21:41:12 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 21:41:12,609: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 21:41:12,717: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 21:41:12,720: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:41:12,720: Re-using an available connection from the pool.
2018-01-04 21:41:12,720: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:41:12,720: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:41:12,743: SQL status: SELECT in 0.02 seconds
2018-01-04 21:41:12,747: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 21:41:12,749: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:41:12,749: On parsely_videoview_engagedtime: BEGIN
2018-01-04 21:41:12,751: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:41:12,751: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:41:12,751: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 21:41:14,233: SQL status: CREATE VIEW in 1.48 seconds
2018-01-04 21:41:14,234: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:41:14,234: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 21:41:14,238: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:41:14,239: On parsely_videoview_engagedtime: COMMIT
2018-01-04 21:41:14,239: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:41:14,239: On parsely_videoview_engagedtime: COMMIT
2018-01-04 21:41:15,345: SQL status: COMMIT in 1.11 seconds
2018-01-04 21:41:15,346: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e735f90>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:41:15,388: 21:41:15 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 2.74s]
2018-01-04 21:41:15,389: 21:41:15 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 21:41:15,389: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:41:15,425: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 21:41:15,434: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:41:15,434: Re-using an available connection from the pool.
2018-01-04 21:41:15,434: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:41:15,434: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:41:15,456: SQL status: SELECT in 0.02 seconds
2018-01-04 21:41:15,457: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:41:15,457: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:41:15,479: SQL status: SELECT in 0.02 seconds
2018-01-04 21:41:15,482: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:41:15,483: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 21:41:15,485: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:41:15,485: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:41:15,485: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:42:40,435: SQL status: SELECT in 84.95 seconds
2018-01-04 21:42:40,435: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:42:40,436: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 21:42:40,597: SQL status: SELECT in 0.16 seconds
2018-01-04 21:42:40,597: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:42:40,598: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:42:40,715: SQL status: SELECT in 0.12 seconds
2018-01-04 21:42:40,716: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:42:40,716: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:42:40,833: SQL status: SELECT in 0.12 seconds
2018-01-04 21:42:40,841: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 21:42:40,843: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:42:40,843: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 21:42:42,001: SQL status: INSERT 0 141 in 1.16 seconds
2018-01-04 21:42:42,001: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 21:42:42,001: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:42:42,002: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 21:42:43,637: SQL status: COMMIT in 1.64 seconds
2018-01-04 21:42:43,638: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e767990>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:42:43,726: 21:42:43 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 141 in 88.25s]
2018-01-04 21:42:43,727: 21:42:43 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 21:42:43,728: Compiling model.parsely.parsely_campaigns
2018-01-04 21:42:43,742: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:42:43,742: Re-using an available connection from the pool.
2018-01-04 21:42:43,743: Using redshift connection "parsely_campaigns".
2018-01-04 21:42:43,743: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:42:43,765: SQL status: SELECT in 0.02 seconds
2018-01-04 21:42:43,772: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 21:42:43,780: Using redshift connection "parsely_campaigns".
2018-01-04 21:42:43,780: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:42:43,801: SQL status: SELECT in 0.02 seconds
2018-01-04 21:42:43,803: Using redshift connection "parsely_campaigns".
2018-01-04 21:42:43,803: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:42:43,824: SQL status: SELECT in 0.02 seconds
2018-01-04 21:42:43,826: Using redshift connection "parsely_campaigns".
2018-01-04 21:42:43,826: On parsely_campaigns: BEGIN
2018-01-04 21:42:43,829: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:42:43,829: Using redshift connection "parsely_campaigns".
2018-01-04 21:42:43,829: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:42:44,927: SQL status: SELECT in 1.10 seconds
2018-01-04 21:42:44,927: Using redshift connection "parsely_campaigns".
2018-01-04 21:42:44,928: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 21:42:45,090: SQL status: SELECT in 0.16 seconds
2018-01-04 21:42:45,090: Using redshift connection "parsely_campaigns".
2018-01-04 21:42:45,091: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:42:45,201: SQL status: SELECT in 0.11 seconds
2018-01-04 21:42:45,202: Using redshift connection "parsely_campaigns".
2018-01-04 21:42:45,202: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:42:45,314: SQL status: SELECT in 0.11 seconds
2018-01-04 21:42:45,316: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 21:42:45,317: Using redshift connection "parsely_campaigns".
2018-01-04 21:42:45,317: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 21:42:45,477: SQL status: INSERT 0 388 in 0.16 seconds
2018-01-04 21:42:45,478: On parsely_campaigns: COMMIT
2018-01-04 21:42:45,478: Using redshift connection "parsely_campaigns".
2018-01-04 21:42:45,478: On parsely_campaigns: COMMIT
2018-01-04 21:42:45,976: SQL status: COMMIT in 0.50 seconds
2018-01-04 21:42:45,977: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e664a90>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:42:46,023: 21:42:46 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 388 in 2.25s]
2018-01-04 21:42:46,023: Compiling model.parsely.parsely_incoming_users
2018-01-04 21:42:46,037: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 21:42:46,042: 21:42:46 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 21:42:46,043: Compiling model.parsely.parsely_users
2018-01-04 21:42:46,059: Acquiring new redshift connection "parsely_users".
2018-01-04 21:42:46,060: Re-using an available connection from the pool.
2018-01-04 21:42:46,060: Using redshift connection "parsely_users".
2018-01-04 21:42:46,060: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:42:46,082: SQL status: SELECT in 0.02 seconds
2018-01-04 21:42:46,238: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 21:42:46,244: Using redshift connection "parsely_users".
2018-01-04 21:42:46,244: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:42:46,265: SQL status: SELECT in 0.02 seconds
2018-01-04 21:42:46,266: Using redshift connection "parsely_users".
2018-01-04 21:42:46,267: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:42:46,287: SQL status: SELECT in 0.02 seconds
2018-01-04 21:42:46,291: Using redshift connection "parsely_users".
2018-01-04 21:42:46,291: On parsely_users: BEGIN
2018-01-04 21:42:46,293: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:42:46,293: Using redshift connection "parsely_users".
2018-01-04 21:42:46,293: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:42:48,111: SQL status: SELECT in 1.82 seconds
2018-01-04 21:42:48,111: Using redshift connection "parsely_users".
2018-01-04 21:42:48,111: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 21:42:48,283: SQL status: SELECT in 0.17 seconds
2018-01-04 21:42:48,283: Using redshift connection "parsely_users".
2018-01-04 21:42:48,283: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:42:48,395: SQL status: SELECT in 0.11 seconds
2018-01-04 21:42:48,396: Using redshift connection "parsely_users".
2018-01-04 21:42:48,396: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:42:48,506: SQL status: SELECT in 0.11 seconds
2018-01-04 21:42:48,508: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 21:42:48,510: Using redshift connection "parsely_users".
2018-01-04 21:42:48,510: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 21:42:48,781: SQL status: INSERT 0 52998 in 0.27 seconds
2018-01-04 21:42:48,782: On parsely_users: COMMIT
2018-01-04 21:42:48,782: Using redshift connection "parsely_users".
2018-01-04 21:42:48,782: On parsely_users: COMMIT
2018-01-04 21:42:49,558: SQL status: COMMIT in 0.78 seconds
2018-01-04 21:42:49,559: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e664210>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:42:49,618: 21:42:49 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 52998 in 3.52s]
2018-01-04 21:42:49,620: 21:42:49 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 21:42:49,620: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 21:42:49,717: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 21:42:49,721: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:42:49,721: Re-using an available connection from the pool.
2018-01-04 21:42:49,721: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:42:49,722: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:42:49,743: SQL status: SELECT in 0.02 seconds
2018-01-04 21:42:49,747: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 21:42:49,748: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:42:49,748: On parsely_pageview_engagedtime: BEGIN
2018-01-04 21:42:49,750: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:42:49,750: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:42:49,751: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 21:42:50,022: SQL status: CREATE VIEW in 0.27 seconds
2018-01-04 21:42:50,023: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:42:50,023: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 21:42:50,029: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 21:42:50,030: On parsely_pageview_engagedtime: COMMIT
2018-01-04 21:42:50,030: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:42:50,030: On parsely_pageview_engagedtime: COMMIT
2018-01-04 21:42:50,242: SQL status: COMMIT in 0.21 seconds
2018-01-04 21:42:50,243: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e664fd0>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:42:50,296: 21:42:50 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.62s]
2018-01-04 21:42:50,297: 21:42:50 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 21:42:50,297: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 21:42:50,315: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 21:42:50,320: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 21:42:50,321: Re-using an available connection from the pool.
2018-01-04 21:42:50,321: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:42:50,321: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:42:50,344: SQL status: SELECT in 0.02 seconds
2018-01-04 21:42:50,348: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 21:42:50,349: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:42:50,349: On parsely_incoming_sessions: BEGIN
2018-01-04 21:42:50,351: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:42:50,352: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:42:50,352: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 21:42:50,555: SQL status: CREATE VIEW in 0.20 seconds
2018-01-04 21:42:50,556: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:42:50,556: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 21:42:50,559: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:42:50,560: On parsely_incoming_sessions: COMMIT
2018-01-04 21:42:50,560: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:42:50,560: On parsely_incoming_sessions: COMMIT
2018-01-04 21:42:50,834: SQL status: COMMIT in 0.27 seconds
2018-01-04 21:42:50,835: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e7356d0>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:42:50,881: 21:42:50 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.54s]
2018-01-04 21:42:50,882: 21:42:50 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 21:42:50,882: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:42:50,906: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 21:42:50,909: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:42:50,909: Re-using an available connection from the pool.
2018-01-04 21:42:50,909: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:42:50,910: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:42:50,932: SQL status: SELECT in 0.02 seconds
2018-01-04 21:42:50,933: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:42:50,933: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:42:50,954: SQL status: SELECT in 0.02 seconds
2018-01-04 21:42:50,957: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:42:50,957: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 21:42:50,960: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:42:50,960: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:42:50,960: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:43:58,736: SQL status: SELECT in 67.78 seconds
2018-01-04 21:43:58,737: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:43:58,737: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 21:43:58,913: SQL status: SELECT in 0.18 seconds
2018-01-04 21:43:58,915: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:43:58,915: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:43:59,029: SQL status: SELECT in 0.11 seconds
2018-01-04 21:43:59,030: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:43:59,031: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:43:59,151: SQL status: SELECT in 0.12 seconds
2018-01-04 21:43:59,158: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 21:43:59,166: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:43:59,166: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 21:44:02,488: SQL status: INSERT 0 108213 in 3.32 seconds
2018-01-04 21:44:02,489: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 21:44:02,489: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:44:02,489: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 21:44:04,010: SQL status: COMMIT in 1.52 seconds
2018-01-04 21:44:04,010: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e7356d0>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:44:04,074: 21:44:04 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 108213 in 73.13s]
2018-01-04 21:44:04,075: 21:44:04 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 21:44:04,075: Compiling model.parsely.parsely_sessions
2018-01-04 21:44:04,091: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:44:04,091: Re-using an available connection from the pool.
2018-01-04 21:44:04,091: Using redshift connection "parsely_sessions".
2018-01-04 21:44:04,091: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:04,115: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:04,122: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 21:44:04,124: Using redshift connection "parsely_sessions".
2018-01-04 21:44:04,125: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:04,146: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:04,147: Using redshift connection "parsely_sessions".
2018-01-04 21:44:04,147: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:04,167: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:04,172: Using redshift connection "parsely_sessions".
2018-01-04 21:44:04,172: On parsely_sessions: BEGIN
2018-01-04 21:44:04,174: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:44:04,174: Using redshift connection "parsely_sessions".
2018-01-04 21:44:04,174: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:44:23,237: SQL status: SELECT in 19.06 seconds
2018-01-04 21:44:23,237: Using redshift connection "parsely_sessions".
2018-01-04 21:44:23,237: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 21:44:23,410: SQL status: SELECT in 0.17 seconds
2018-01-04 21:44:23,411: Using redshift connection "parsely_sessions".
2018-01-04 21:44:23,411: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:44:23,525: SQL status: SELECT in 0.11 seconds
2018-01-04 21:44:23,527: Using redshift connection "parsely_sessions".
2018-01-04 21:44:23,527: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:44:23,641: SQL status: SELECT in 0.11 seconds
2018-01-04 21:44:23,648: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 21:44:23,649: Using redshift connection "parsely_sessions".
2018-01-04 21:44:23,649: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 21:44:25,514: SQL status: INSERT 0 87929 in 1.86 seconds
2018-01-04 21:44:25,515: On parsely_sessions: COMMIT
2018-01-04 21:44:25,515: Using redshift connection "parsely_sessions".
2018-01-04 21:44:25,515: On parsely_sessions: COMMIT
2018-01-04 21:44:26,817: SQL status: COMMIT in 1.30 seconds
2018-01-04 21:44:26,818: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e6d8110>], 'label': '92ccac33-46c0-4c59-bd44-139e9e5e3ce4'}
2018-01-04 21:44:26,859: 21:44:26 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 87929 in 22.74s]
2018-01-04 21:44:26,880: Using redshift connection "master".
2018-01-04 21:44:26,880: On master: BEGIN
2018-01-04 21:44:26,883: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:44:26,883: On master: COMMIT
2018-01-04 21:44:26,883: Using redshift connection "master".
2018-01-04 21:44:26,883: On master: COMMIT
2018-01-04 21:44:26,885: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:44:26,885: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 21:44:26,895: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 21:44:26,900: Using redshift connection "master".
2018-01-04 21:44:26,900: On master:  select 1 
2018-01-04 21:44:26,902: SQL status: SELECT in 0.00 seconds
2018-01-04 21:44:26,902: 21:44:26 | 
2018-01-04 21:44:26,902: 21:44:26 | Finished running 10 view models, 15 incremental models in 669.53s.
2018-01-04 21:44:26,903: 
2018-01-04 21:44:26,904: Completed successfully
2018-01-04 21:44:26,904: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 21:44:26,904: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e780e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e780f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f341e767950>], 'label': 'end'}
2018-01-04 21:44:26,954: Flushing usage events
2018-01-04 21:44:36,827: Tracking: tracking
2018-01-04 21:44:36,833: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fed25e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fed25f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fed25ed0>], 'label': 'start'}
2018-01-04 21:44:36,897: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 21:44:36,949: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 21:44:36,951: Parsing core.sql
2018-01-04 21:44:36,985: Parsing etc/get_custom_schema.sql
2018-01-04 21:44:37,000: Parsing schema_tests/relationships.sql
2018-01-04 21:44:37,010: Parsing schema_tests/accepted_values.sql
2018-01-04 21:44:37,016: Parsing schema_tests/not_null.sql
2018-01-04 21:44:37,023: Parsing schema_tests/unique.sql
2018-01-04 21:44:37,030: Parsing materializations/wrapper.sql
2018-01-04 21:44:37,036: Parsing materializations/archive.sql
2018-01-04 21:44:37,128: Parsing materializations/table.sql
2018-01-04 21:44:37,167: Parsing materializations/helpers.sql
2018-01-04 21:44:37,200: Parsing materializations/bigquery.sql
2018-01-04 21:44:37,228: Parsing materializations/view.sql
2018-01-04 21:44:37,258: Parsing materializations/incremental.sql
2018-01-04 21:44:37,318: Parsing adapters/redshift.sql
2018-01-04 21:44:37,387: Parsing adapters/bigquery.sql
2018-01-04 21:44:37,397: Parsing adapters/postgres.sql
2018-01-04 21:44:37,403: Parsing adapters/common.sql
2018-01-04 21:44:37,454: Parsing model.parsely.parsely_audit
2018-01-04 21:44:37,457: Parsing model.parsely.parsely_video_content
2018-01-04 21:44:37,467: Parsing model.parsely.parsely_post_content
2018-01-04 21:44:37,478: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 21:44:37,487: Parsing model.parsely.parsely_rawdata
2018-01-04 21:44:37,492: Parsing model.parsely.calendar
2018-01-04 21:44:37,498: Parsing model.parsely.parsely_all_events
2018-01-04 21:44:37,528: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:44:37,528: Opening a new connection (0 currently allocated)
2018-01-04 21:44:37,547: Using redshift connection "parsely_all_events".
2018-01-04 21:44:37,547: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:37,573: SQL status: SELECT in 0.03 seconds
2018-01-04 21:44:37,583: Parsing model.parsely.parsely_event_ids
2018-01-04 21:44:37,589: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 21:44:37,594: Parsing model.parsely.parsely_base_events
2018-01-04 21:44:37,604: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:44:37,604: Re-using an available connection from the pool.
2018-01-04 21:44:37,604: Using redshift connection "parsely_base_events".
2018-01-04 21:44:37,605: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:37,624: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:37,626: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:44:37,639: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 21:44:37,653: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:44:37,657: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:44:37,664: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 21:44:37,670: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:44:37,690: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 21:44:37,707: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 21:44:37,724: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:44:37,724: Re-using an available connection from the pool.
2018-01-04 21:44:37,724: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:44:37,724: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:37,743: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:37,745: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 21:44:37,762: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 21:44:37,777: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:44:37,777: Re-using an available connection from the pool.
2018-01-04 21:44:37,777: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:44:37,777: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:37,795: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:37,796: Parsing model.parsely.parsely_incoming_users
2018-01-04 21:44:37,801: Parsing model.parsely.parsely_users
2018-01-04 21:44:37,813: Acquiring new redshift connection "parsely_users".
2018-01-04 21:44:37,814: Re-using an available connection from the pool.
2018-01-04 21:44:37,814: Using redshift connection "parsely_users".
2018-01-04 21:44:37,814: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:37,832: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:37,833: Parsing model.parsely.parsely_errors
2018-01-04 21:44:37,841: Parsing model.parsely.parsely_bot_traffic
2018-01-04 21:44:37,852: Parsing model.parsely.parsely_custom_events
2018-01-04 21:44:37,867: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 21:44:37,876: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 21:44:37,882: Parsing model.parsely.parsely_sessions
2018-01-04 21:44:37,901: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:44:37,901: Re-using an available connection from the pool.
2018-01-04 21:44:37,901: Using redshift connection "parsely_sessions".
2018-01-04 21:44:37,901: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:37,919: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:37,920: Parsing model.parsely.parsely_campaigns
2018-01-04 21:44:37,931: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:44:37,932: Re-using an available connection from the pool.
2018-01-04 21:44:37,932: Using redshift connection "parsely_campaigns".
2018-01-04 21:44:37,932: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:37,952: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:37,964: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 21:44:37,980: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 21:44:38,001: 
2018-01-04 21:44:38,008: Acquiring new redshift connection "master".
2018-01-04 21:44:38,008: Re-using an available connection from the pool.
2018-01-04 21:44:38,008: Using redshift connection "master".
2018-01-04 21:44:38,008: On master: select distinct nspname from pg_namespace
2018-01-04 21:44:38,011: SQL status: SELECT in 0.00 seconds
2018-01-04 21:44:38,016: Using redshift connection "master".
2018-01-04 21:44:38,016: On master: BEGIN
2018-01-04 21:44:38,018: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:44:38,019: On master: COMMIT
2018-01-04 21:44:38,019: Using redshift connection "master".
2018-01-04 21:44:38,019: On master: COMMIT
2018-01-04 21:44:38,021: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:44:38,033: 21:44:38 | Concurrency: 1 threads (target='dev')
2018-01-04 21:44:38,035: 21:44:38 | 
2018-01-04 21:44:38,035: Using redshift connection "master".
2018-01-04 21:44:38,035: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:38,057: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:38,236: 21:44:38 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 21:44:38,236: Compiling model.parsely.calendar
2018-01-04 21:44:38,247: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 21:44:38,249: Acquiring new redshift connection "calendar".
2018-01-04 21:44:38,249: Opening a new connection (1 currently allocated)
2018-01-04 21:44:38,265: Using redshift connection "calendar".
2018-01-04 21:44:38,265: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:38,290: SQL status: SELECT in 0.03 seconds
2018-01-04 21:44:38,294: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 21:44:38,295: Using redshift connection "calendar".
2018-01-04 21:44:38,295: On calendar: BEGIN
2018-01-04 21:44:38,298: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:44:38,298: Using redshift connection "calendar".
2018-01-04 21:44:38,299: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 21:44:38,546: SQL status: CREATE VIEW in 0.25 seconds
2018-01-04 21:44:38,546: On calendar: COMMIT
2018-01-04 21:44:38,547: Using redshift connection "calendar".
2018-01-04 21:44:38,547: On calendar: COMMIT
2018-01-04 21:44:38,813: SQL status: COMMIT in 0.27 seconds
2018-01-04 21:44:38,813: Using redshift connection "calendar".
2018-01-04 21:44:38,814: On calendar: BEGIN
2018-01-04 21:44:38,817: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:44:38,817: Using redshift connection "calendar".
2018-01-04 21:44:38,817: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 21:44:38,824: SQL status: DROP VIEW in 0.01 seconds
2018-01-04 21:44:38,824: On calendar: COMMIT
2018-01-04 21:44:38,825: Using redshift connection "calendar".
2018-01-04 21:44:38,825: On calendar: COMMIT
2018-01-04 21:44:39,039: SQL status: COMMIT in 0.21 seconds
2018-01-04 21:44:39,039: Using redshift connection "calendar".
2018-01-04 21:44:39,039: On calendar: BEGIN
2018-01-04 21:44:39,041: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:44:39,042: Using redshift connection "calendar".
2018-01-04 21:44:39,042: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 21:44:39,046: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:44:39,046: On calendar: COMMIT
2018-01-04 21:44:39,046: Using redshift connection "calendar".
2018-01-04 21:44:39,046: On calendar: COMMIT
2018-01-04 21:44:39,397: SQL status: COMMIT in 0.35 seconds
2018-01-04 21:44:39,398: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec13810>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:44:39,455: 21:44:39 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.16s]
2018-01-04 21:44:39,456: 21:44:39 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 21:44:39,456: Compiling model.parsely.parsely_rawdata
2018-01-04 21:44:39,483: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:44:39,485: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 21:44:39,486: Re-using an available connection from the pool.
2018-01-04 21:44:39,486: Using redshift connection "parsely_rawdata".
2018-01-04 21:44:39,486: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:39,505: SQL status: SELECT in 0.02 seconds
2018-01-04 21:44:39,506: Using redshift connection "parsely_rawdata".
2018-01-04 21:44:39,506: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:44:39,515: SQL status: SELECT in 0.01 seconds
2018-01-04 21:44:39,517: Using redshift connection "parsely_rawdata".
2018-01-04 21:44:39,517: On parsely_rawdata: BEGIN
2018-01-04 21:44:39,519: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:44:39,519: Using redshift connection "parsely_rawdata".
2018-01-04 21:44:39,519: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:45:08,425: SQL status: SELECT in 28.91 seconds
2018-01-04 21:45:08,426: Using redshift connection "parsely_rawdata".
2018-01-04 21:45:08,426: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 21:45:08,610: SQL status: SELECT in 0.18 seconds
2018-01-04 21:45:08,611: Using redshift connection "parsely_rawdata".
2018-01-04 21:45:08,611: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:45:08,721: SQL status: SELECT in 0.11 seconds
2018-01-04 21:45:08,722: Using redshift connection "parsely_rawdata".
2018-01-04 21:45:08,722: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:45:08,831: SQL status: SELECT in 0.11 seconds
2018-01-04 21:45:08,838: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:45:08,843: Using redshift connection "parsely_rawdata".
2018-01-04 21:45:08,843: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 21:45:45,577: SQL status: INSERT 0 1024581 in 36.73 seconds
2018-01-04 21:45:45,577: On parsely_rawdata: COMMIT
2018-01-04 21:45:45,578: Using redshift connection "parsely_rawdata".
2018-01-04 21:45:45,578: On parsely_rawdata: COMMIT
2018-01-04 21:45:48,602: SQL status: COMMIT in 3.02 seconds
2018-01-04 21:45:48,603: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec74f10>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:45:48,660: 21:45:48 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1024581 in 69.15s]
2018-01-04 21:45:48,661: 21:45:48 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 21:45:48,661: Compiling model.parsely.parsely_all_events
2018-01-04 21:45:48,701: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:45:48,701: Re-using an available connection from the pool.
2018-01-04 21:45:48,701: Using redshift connection "parsely_all_events".
2018-01-04 21:45:48,701: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:45:48,716: SQL status: SELECT in 0.01 seconds
2018-01-04 21:45:48,764: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:45:48,766: Using redshift connection "parsely_all_events".
2018-01-04 21:45:48,767: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:45:48,782: SQL status: SELECT in 0.01 seconds
2018-01-04 21:45:48,783: Using redshift connection "parsely_all_events".
2018-01-04 21:45:48,783: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:45:48,796: SQL status: SELECT in 0.01 seconds
2018-01-04 21:45:48,800: Using redshift connection "parsely_all_events".
2018-01-04 21:45:48,800: On parsely_all_events: BEGIN
2018-01-04 21:45:48,802: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:45:48,803: Using redshift connection "parsely_all_events".
2018-01-04 21:45:48,803: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:47:36,900: SQL status: SELECT in 108.10 seconds
2018-01-04 21:47:36,900: Using redshift connection "parsely_all_events".
2018-01-04 21:47:36,900: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 21:47:37,118: SQL status: SELECT in 0.22 seconds
2018-01-04 21:47:37,119: Using redshift connection "parsely_all_events".
2018-01-04 21:47:37,119: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:47:37,227: SQL status: SELECT in 0.11 seconds
2018-01-04 21:47:37,229: Using redshift connection "parsely_all_events".
2018-01-04 21:47:37,229: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:47:37,337: SQL status: SELECT in 0.11 seconds
2018-01-04 21:47:37,346: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:47:37,348: Using redshift connection "parsely_all_events".
2018-01-04 21:47:37,348: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 21:47:54,231: SQL status: INSERT 0 909091 in 16.88 seconds
2018-01-04 21:47:54,232: On parsely_all_events: COMMIT
2018-01-04 21:47:54,232: Using redshift connection "parsely_all_events".
2018-01-04 21:47:54,232: On parsely_all_events: COMMIT
2018-01-04 21:47:57,035: SQL status: COMMIT in 2.80 seconds
2018-01-04 21:47:57,036: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec8d0d0>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:47:57,130: 21:47:57 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 909091 in 128.37s]
2018-01-04 21:47:57,131: 21:47:57 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 21:47:57,134: Compiling model.parsely.parsely_bot_traffic
2018-01-04 21:47:57,184: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 21:47:57,188: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 21:47:57,188: Re-using an available connection from the pool.
2018-01-04 21:47:57,191: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:47:57,191: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:47:57,206: SQL status: SELECT in 0.01 seconds
2018-01-04 21:47:57,207: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:47:57,208: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:47:57,223: SQL status: SELECT in 0.02 seconds
2018-01-04 21:47:57,228: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:47:57,228: On parsely_bot_traffic: BEGIN
2018-01-04 21:47:57,231: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:47:57,231: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:47:57,231: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:48:39,622: SQL status: SELECT in 42.39 seconds
2018-01-04 21:48:39,622: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:48:39,622: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 21:48:40,048: SQL status: SELECT in 0.43 seconds
2018-01-04 21:48:40,049: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:48:40,049: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:48:40,344: SQL status: SELECT in 0.29 seconds
2018-01-04 21:48:40,345: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:48:40,345: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:48:40,692: SQL status: SELECT in 0.35 seconds
2018-01-04 21:48:40,699: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 21:48:40,704: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:48:40,704: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 21:48:43,190: SQL status: INSERT 0 4 in 2.49 seconds
2018-01-04 21:48:43,191: On parsely_bot_traffic: COMMIT
2018-01-04 21:48:43,191: Using redshift connection "parsely_bot_traffic".
2018-01-04 21:48:43,191: On parsely_bot_traffic: COMMIT
2018-01-04 21:48:45,468: SQL status: COMMIT in 2.28 seconds
2018-01-04 21:48:45,469: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec74f10>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:48:45,514: 21:48:45 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 48.33s]
2018-01-04 21:48:45,515: 21:48:45 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 21:48:45,515: Compiling model.parsely.parsely_custom_events
2018-01-04 21:48:45,539: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 21:48:45,542: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 21:48:45,542: Re-using an available connection from the pool.
2018-01-04 21:48:45,543: Using redshift connection "parsely_custom_events".
2018-01-04 21:48:45,543: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:48:45,629: SQL status: SELECT in 0.09 seconds
2018-01-04 21:48:45,630: Using redshift connection "parsely_custom_events".
2018-01-04 21:48:45,630: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:48:45,673: SQL status: SELECT in 0.04 seconds
2018-01-04 21:48:45,676: Using redshift connection "parsely_custom_events".
2018-01-04 21:48:45,677: On parsely_custom_events: BEGIN
2018-01-04 21:48:45,701: SQL status: BEGIN in 0.02 seconds
2018-01-04 21:48:45,701: Using redshift connection "parsely_custom_events".
2018-01-04 21:48:45,701: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:50:01,090: SQL status: SELECT in 75.39 seconds
2018-01-04 21:50:01,091: Using redshift connection "parsely_custom_events".
2018-01-04 21:50:01,091: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 21:50:01,289: SQL status: SELECT in 0.20 seconds
2018-01-04 21:50:01,289: Using redshift connection "parsely_custom_events".
2018-01-04 21:50:01,290: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:50:01,402: SQL status: SELECT in 0.11 seconds
2018-01-04 21:50:01,404: Using redshift connection "parsely_custom_events".
2018-01-04 21:50:01,404: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:50:01,532: SQL status: SELECT in 0.13 seconds
2018-01-04 21:50:01,542: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 21:50:01,551: Using redshift connection "parsely_custom_events".
2018-01-04 21:50:01,551: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 21:50:01,818: SQL status: INSERT 0 0 in 0.27 seconds
2018-01-04 21:50:01,819: On parsely_custom_events: COMMIT
2018-01-04 21:50:01,819: Using redshift connection "parsely_custom_events".
2018-01-04 21:50:01,819: On parsely_custom_events: COMMIT
2018-01-04 21:50:02,722: SQL status: COMMIT in 0.90 seconds
2018-01-04 21:50:02,723: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fecda610>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:50:02,802: 21:50:02 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 77.21s]
2018-01-04 21:50:02,802: 21:50:02 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 21:50:02,803: Compiling model.parsely.parsely_errors
2018-01-04 21:50:02,825: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 21:50:02,828: Acquiring new redshift connection "parsely_errors".
2018-01-04 21:50:02,828: Re-using an available connection from the pool.
2018-01-04 21:50:02,829: Using redshift connection "parsely_errors".
2018-01-04 21:50:02,829: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:02,847: SQL status: SELECT in 0.02 seconds
2018-01-04 21:50:02,847: Using redshift connection "parsely_errors".
2018-01-04 21:50:02,847: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:02,862: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:02,865: Using redshift connection "parsely_errors".
2018-01-04 21:50:02,865: On parsely_errors: BEGIN
2018-01-04 21:50:02,867: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:50:02,867: Using redshift connection "parsely_errors".
2018-01-04 21:50:02,867: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:50:34,333: SQL status: SELECT in 31.47 seconds
2018-01-04 21:50:34,333: Using redshift connection "parsely_errors".
2018-01-04 21:50:34,334: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 21:50:34,486: SQL status: SELECT in 0.15 seconds
2018-01-04 21:50:34,486: Using redshift connection "parsely_errors".
2018-01-04 21:50:34,487: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:50:34,597: SQL status: SELECT in 0.11 seconds
2018-01-04 21:50:34,599: Using redshift connection "parsely_errors".
2018-01-04 21:50:34,599: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:50:34,708: SQL status: SELECT in 0.11 seconds
2018-01-04 21:50:34,715: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 21:50:34,719: Using redshift connection "parsely_errors".
2018-01-04 21:50:34,719: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 21:50:35,421: SQL status: INSERT 0 2 in 0.70 seconds
2018-01-04 21:50:35,422: On parsely_errors: COMMIT
2018-01-04 21:50:35,422: Using redshift connection "parsely_errors".
2018-01-04 21:50:35,422: On parsely_errors: COMMIT
2018-01-04 21:50:37,045: SQL status: COMMIT in 1.62 seconds
2018-01-04 21:50:37,046: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec23a10>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:50:37,099: 21:50:37 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 34.24s]
2018-01-04 21:50:37,099: 21:50:37 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 21:50:37,100: Compiling model.parsely.parsely_base_events
2018-01-04 21:50:37,111: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:50:37,111: Re-using an available connection from the pool.
2018-01-04 21:50:37,111: Using redshift connection "parsely_base_events".
2018-01-04 21:50:37,111: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:37,126: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:37,133: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 21:50:37,139: Using redshift connection "parsely_base_events".
2018-01-04 21:50:37,139: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:37,153: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:37,156: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 21:50:37,157: Using redshift connection "parsely_base_events".
2018-01-04 21:50:37,158: On parsely_base_events: BEGIN
2018-01-04 21:50:37,160: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:50:37,160: Using redshift connection "parsely_base_events".
2018-01-04 21:50:37,160: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 21:50:37,992: SQL status: CREATE VIEW in 0.83 seconds
2018-01-04 21:50:37,993: On parsely_base_events: COMMIT
2018-01-04 21:50:37,993: Using redshift connection "parsely_base_events".
2018-01-04 21:50:37,993: On parsely_base_events: COMMIT
2018-01-04 21:50:38,279: SQL status: COMMIT in 0.29 seconds
2018-01-04 21:50:38,279: Using redshift connection "parsely_base_events".
2018-01-04 21:50:38,279: On parsely_base_events: BEGIN
2018-01-04 21:50:38,281: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:50:38,281: Using redshift connection "parsely_base_events".
2018-01-04 21:50:38,282: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 21:50:38,663: SQL status: DROP VIEW in 0.38 seconds
2018-01-04 21:50:38,663: On parsely_base_events: COMMIT
2018-01-04 21:50:38,664: Using redshift connection "parsely_base_events".
2018-01-04 21:50:38,664: On parsely_base_events: COMMIT
2018-01-04 21:50:38,862: SQL status: COMMIT in 0.20 seconds
2018-01-04 21:50:38,863: Using redshift connection "parsely_base_events".
2018-01-04 21:50:38,863: On parsely_base_events: BEGIN
2018-01-04 21:50:38,865: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:50:38,865: Using redshift connection "parsely_base_events".
2018-01-04 21:50:38,866: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 21:50:38,882: SQL status: ALTER TABLE in 0.02 seconds
2018-01-04 21:50:38,882: On parsely_base_events: COMMIT
2018-01-04 21:50:38,883: Using redshift connection "parsely_base_events".
2018-01-04 21:50:38,883: On parsely_base_events: COMMIT
2018-01-04 21:50:39,346: SQL status: COMMIT in 0.46 seconds
2018-01-04 21:50:39,347: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec230d0>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:50:39,397: 21:50:39 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 2.25s]
2018-01-04 21:50:39,398: 21:50:39 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 21:50:39,398: Compiling model.parsely.parsely_event_ids
2018-01-04 21:50:39,409: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 21:50:39,416: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 21:50:39,417: Re-using an available connection from the pool.
2018-01-04 21:50:39,417: Using redshift connection "parsely_event_ids".
2018-01-04 21:50:39,417: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:39,431: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:39,432: Using redshift connection "parsely_event_ids".
2018-01-04 21:50:39,432: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:39,446: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:39,447: Using redshift connection "parsely_event_ids".
2018-01-04 21:50:39,448: On parsely_event_ids: BEGIN
2018-01-04 21:50:39,450: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:50:39,450: Using redshift connection "parsely_event_ids".
2018-01-04 21:50:39,450: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:50:40,434: SQL status: SELECT in 0.98 seconds
2018-01-04 21:50:40,434: Using redshift connection "parsely_event_ids".
2018-01-04 21:50:40,434: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 21:50:40,585: SQL status: SELECT in 0.15 seconds
2018-01-04 21:50:40,585: Using redshift connection "parsely_event_ids".
2018-01-04 21:50:40,585: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:50:40,691: SQL status: SELECT in 0.11 seconds
2018-01-04 21:50:40,692: Using redshift connection "parsely_event_ids".
2018-01-04 21:50:40,692: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:50:40,805: SQL status: SELECT in 0.11 seconds
2018-01-04 21:50:40,807: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 21:50:40,809: Using redshift connection "parsely_event_ids".
2018-01-04 21:50:40,809: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 21:50:41,805: SQL status: INSERT 0 909087 in 1.00 seconds
2018-01-04 21:50:41,806: On parsely_event_ids: COMMIT
2018-01-04 21:50:41,806: Using redshift connection "parsely_event_ids".
2018-01-04 21:50:41,806: On parsely_event_ids: COMMIT
2018-01-04 21:50:42,204: SQL status: COMMIT in 0.40 seconds
2018-01-04 21:50:42,204: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec230d0>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:50:42,250: 21:50:42 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 909087 in 2.81s]
2018-01-04 21:50:42,250: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 21:50:42,268: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 21:50:42,270: 21:50:42 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 21:50:42,270: Compiling model.parsely.parsely_post_content
2018-01-04 21:50:42,289: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 21:50:42,295: Acquiring new redshift connection "parsely_post_content".
2018-01-04 21:50:42,296: Re-using an available connection from the pool.
2018-01-04 21:50:42,296: Using redshift connection "parsely_post_content".
2018-01-04 21:50:42,296: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:42,311: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:42,311: Using redshift connection "parsely_post_content".
2018-01-04 21:50:42,311: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:42,326: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:42,328: Using redshift connection "parsely_post_content".
2018-01-04 21:50:42,328: On parsely_post_content: BEGIN
2018-01-04 21:50:42,330: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:50:42,330: Using redshift connection "parsely_post_content".
2018-01-04 21:50:42,330: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:50:49,551: SQL status: SELECT in 7.22 seconds
2018-01-04 21:50:49,552: Using redshift connection "parsely_post_content".
2018-01-04 21:50:49,552: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 21:50:49,730: SQL status: SELECT in 0.18 seconds
2018-01-04 21:50:49,730: Using redshift connection "parsely_post_content".
2018-01-04 21:50:49,730: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:50:49,836: SQL status: SELECT in 0.11 seconds
2018-01-04 21:50:49,837: Using redshift connection "parsely_post_content".
2018-01-04 21:50:49,837: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:50:49,940: SQL status: SELECT in 0.10 seconds
2018-01-04 21:50:49,943: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 21:50:49,944: Using redshift connection "parsely_post_content".
2018-01-04 21:50:49,944: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 21:50:50,320: SQL status: INSERT 0 881 in 0.38 seconds
2018-01-04 21:50:50,321: On parsely_post_content: COMMIT
2018-01-04 21:50:50,321: Using redshift connection "parsely_post_content".
2018-01-04 21:50:50,321: On parsely_post_content: COMMIT
2018-01-04 21:50:50,868: SQL status: COMMIT in 0.55 seconds
2018-01-04 21:50:50,869: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec74bd0>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:50:50,915: 21:50:50 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 881 in 8.60s]
2018-01-04 21:50:50,916: 21:50:50 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 21:50:50,916: Compiling model.parsely.parsely_video_content
2018-01-04 21:50:50,931: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 21:50:50,939: Acquiring new redshift connection "parsely_video_content".
2018-01-04 21:50:50,939: Re-using an available connection from the pool.
2018-01-04 21:50:50,939: Using redshift connection "parsely_video_content".
2018-01-04 21:50:50,940: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:50,955: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:50,956: Using redshift connection "parsely_video_content".
2018-01-04 21:50:50,956: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:50,970: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:50,972: Using redshift connection "parsely_video_content".
2018-01-04 21:50:50,972: On parsely_video_content: BEGIN
2018-01-04 21:50:50,974: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:50:50,974: Using redshift connection "parsely_video_content".
2018-01-04 21:50:50,975: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:50:56,866: SQL status: SELECT in 5.89 seconds
2018-01-04 21:50:56,867: Using redshift connection "parsely_video_content".
2018-01-04 21:50:56,867: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 21:50:57,035: SQL status: SELECT in 0.17 seconds
2018-01-04 21:50:57,036: Using redshift connection "parsely_video_content".
2018-01-04 21:50:57,036: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:50:57,141: SQL status: SELECT in 0.11 seconds
2018-01-04 21:50:57,142: Using redshift connection "parsely_video_content".
2018-01-04 21:50:57,142: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:50:57,245: SQL status: SELECT in 0.10 seconds
2018-01-04 21:50:57,247: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 21:50:57,249: Using redshift connection "parsely_video_content".
2018-01-04 21:50:57,249: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 21:50:57,598: SQL status: INSERT 0 468 in 0.35 seconds
2018-01-04 21:50:57,599: On parsely_video_content: COMMIT
2018-01-04 21:50:57,599: Using redshift connection "parsely_video_content".
2018-01-04 21:50:57,599: On parsely_video_content: COMMIT
2018-01-04 21:50:58,231: SQL status: COMMIT in 0.63 seconds
2018-01-04 21:50:58,232: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec74bd0>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:50:58,293: 21:50:58 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 468 in 7.32s]
2018-01-04 21:50:58,294: 21:50:58 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 21:50:58,295: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 21:50:58,315: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 21:50:58,317: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 21:50:58,317: Re-using an available connection from the pool.
2018-01-04 21:50:58,317: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:50:58,318: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:58,332: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:58,336: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 21:50:58,337: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:50:58,337: On parsely_entry_exit_urls: BEGIN
2018-01-04 21:50:58,340: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:50:58,340: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:50:58,340: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 21:50:58,802: SQL status: CREATE VIEW in 0.46 seconds
2018-01-04 21:50:58,803: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:50:58,803: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 21:50:58,806: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:50:58,806: On parsely_entry_exit_urls: COMMIT
2018-01-04 21:50:58,806: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 21:50:58,807: On parsely_entry_exit_urls: COMMIT
2018-01-04 21:50:59,049: SQL status: COMMIT in 0.24 seconds
2018-01-04 21:50:59,049: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec74bd0>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:50:59,093: 21:50:59 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.75s]
2018-01-04 21:50:59,094: 21:50:59 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 21:50:59,094: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 21:50:59,116: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 21:50:59,119: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 21:50:59,119: Re-using an available connection from the pool.
2018-01-04 21:50:59,119: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:50:59,119: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:59,137: SQL status: SELECT in 0.02 seconds
2018-01-04 21:50:59,143: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 21:50:59,145: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:50:59,145: On parsely_incoming_videoviews: BEGIN
2018-01-04 21:50:59,153: SQL status: BEGIN in 0.01 seconds
2018-01-04 21:50:59,153: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:50:59,153: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 21:50:59,287: SQL status: CREATE VIEW in 0.13 seconds
2018-01-04 21:50:59,288: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:50:59,288: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 21:50:59,293: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:50:59,293: On parsely_incoming_videoviews: COMMIT
2018-01-04 21:50:59,293: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 21:50:59,293: On parsely_incoming_videoviews: COMMIT
2018-01-04 21:50:59,491: SQL status: COMMIT in 0.20 seconds
2018-01-04 21:50:59,492: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec74bd0>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:50:59,550: 21:50:59 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.40s]
2018-01-04 21:50:59,551: 21:50:59 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 21:50:59,552: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 21:50:59,568: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:50:59,568: Re-using an available connection from the pool.
2018-01-04 21:50:59,569: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:50:59,569: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:59,583: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:59,591: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 21:50:59,594: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:50:59,594: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:59,608: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:59,608: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:50:59,609: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:50:59,623: SQL status: SELECT in 0.01 seconds
2018-01-04 21:50:59,628: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:50:59,628: On parsely_videoviews_sessionized: BEGIN
2018-01-04 21:50:59,630: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:50:59,630: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:50:59,631: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:51:38,230: SQL status: SELECT in 38.60 seconds
2018-01-04 21:51:38,230: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:51:38,230: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 21:51:38,572: SQL status: SELECT in 0.34 seconds
2018-01-04 21:51:38,574: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:51:38,574: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:51:38,682: SQL status: SELECT in 0.11 seconds
2018-01-04 21:51:38,684: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:51:38,684: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:51:38,793: SQL status: SELECT in 0.11 seconds
2018-01-04 21:51:38,802: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 21:51:38,805: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:51:38,805: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 21:51:39,938: SQL status: INSERT 0 142 in 1.13 seconds
2018-01-04 21:51:39,938: On parsely_videoviews_sessionized: COMMIT
2018-01-04 21:51:39,939: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:51:39,939: On parsely_videoviews_sessionized: COMMIT
2018-01-04 21:51:43,370: SQL status: COMMIT in 3.43 seconds
2018-01-04 21:51:43,370: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fed1f2d0>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:51:43,428: 21:51:43 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 142 in 43.82s]
2018-01-04 21:51:43,429: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 21:51:43,519: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 21:51:43,531: 21:51:43 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 21:51:43,531: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:51:43,586: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 21:51:43,592: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:51:43,592: Re-using an available connection from the pool.
2018-01-04 21:51:43,592: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:51:43,592: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:51:43,611: SQL status: SELECT in 0.02 seconds
2018-01-04 21:51:43,614: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 21:51:43,616: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:51:43,616: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 21:51:43,618: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:51:43,618: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:51:43,618: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 21:51:45,781: SQL status: CREATE VIEW in 2.16 seconds
2018-01-04 21:51:45,782: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:51:45,782: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 21:51:45,787: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:51:45,787: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 21:51:45,787: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 21:51:45,788: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 21:51:46,808: SQL status: COMMIT in 1.02 seconds
2018-01-04 21:51:46,808: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec139d0>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:51:46,858: 21:51:46 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 3.28s]
2018-01-04 21:51:46,860: 21:51:46 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 21:51:46,861: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:51:47,063: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 21:51:47,066: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:51:47,066: Re-using an available connection from the pool.
2018-01-04 21:51:47,067: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:51:47,075: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:51:47,089: SQL status: SELECT in 0.01 seconds
2018-01-04 21:51:47,094: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 21:51:47,096: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:51:47,096: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 21:51:47,098: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:51:47,099: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:51:47,099: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 21:51:48,010: SQL status: CREATE VIEW in 0.91 seconds
2018-01-04 21:51:48,011: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:51:48,012: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 21:51:48,016: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:51:48,016: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 21:51:48,016: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 21:51:48,016: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 21:51:48,501: SQL status: COMMIT in 0.48 seconds
2018-01-04 21:51:48,502: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fed0c990>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:51:48,550: 21:51:48 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 1.64s]
2018-01-04 21:51:48,551: 21:51:48 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 21:51:48,551: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 21:51:48,603: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 21:51:48,606: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 21:51:48,607: Re-using an available connection from the pool.
2018-01-04 21:51:48,607: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:51:48,607: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:51:48,620: SQL status: SELECT in 0.01 seconds
2018-01-04 21:51:48,626: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 21:51:48,633: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:51:48,633: On parsely_incoming_pageviews: BEGIN
2018-01-04 21:51:48,635: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:51:48,635: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:51:48,636: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 21:51:48,728: SQL status: CREATE VIEW in 0.09 seconds
2018-01-04 21:51:48,729: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:51:48,729: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 21:51:48,735: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 21:51:48,735: On parsely_incoming_pageviews: COMMIT
2018-01-04 21:51:48,735: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 21:51:48,736: On parsely_incoming_pageviews: COMMIT
2018-01-04 21:51:48,968: SQL status: COMMIT in 0.23 seconds
2018-01-04 21:51:48,969: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fed0c990>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:51:49,016: 21:51:49 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.42s]
2018-01-04 21:51:49,017: 21:51:49 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 21:51:49,017: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 21:51:49,038: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:51:49,038: Re-using an available connection from the pool.
2018-01-04 21:51:49,038: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:51:49,039: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:51:49,055: SQL status: SELECT in 0.02 seconds
2018-01-04 21:51:49,062: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 21:51:49,068: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:51:49,068: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:51:49,082: SQL status: SELECT in 0.01 seconds
2018-01-04 21:51:49,083: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:51:49,083: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:51:49,097: SQL status: SELECT in 0.01 seconds
2018-01-04 21:51:49,100: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:51:49,100: On parsely_pageviews_sessionized: BEGIN
2018-01-04 21:51:49,103: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:51:49,103: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:51:49,103: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:54:31,509: SQL status: SELECT in 162.41 seconds
2018-01-04 21:54:31,509: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:54:31,509: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 21:54:31,715: SQL status: SELECT in 0.21 seconds
2018-01-04 21:54:31,715: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:54:31,716: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:54:31,831: SQL status: SELECT in 0.12 seconds
2018-01-04 21:54:31,834: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:54:31,834: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:54:31,951: SQL status: SELECT in 0.12 seconds
2018-01-04 21:54:31,958: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 21:54:31,959: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:54:31,959: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 21:54:35,348: SQL status: INSERT 0 108429 in 3.39 seconds
2018-01-04 21:54:35,349: On parsely_pageviews_sessionized: COMMIT
2018-01-04 21:54:35,349: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:54:35,349: On parsely_pageviews_sessionized: COMMIT
2018-01-04 21:54:36,928: SQL status: COMMIT in 1.58 seconds
2018-01-04 21:54:36,929: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec13a50>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:54:37,001: 21:54:36 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 108429 in 167.91s]
2018-01-04 21:54:37,002: 21:54:36 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 21:54:37,002: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 21:54:37,141: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 21:54:37,147: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:54:37,147: Re-using an available connection from the pool.
2018-01-04 21:54:37,148: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:54:37,148: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:54:37,170: SQL status: SELECT in 0.02 seconds
2018-01-04 21:54:37,174: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 21:54:37,176: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:54:37,176: On parsely_videoview_engagedtime: BEGIN
2018-01-04 21:54:37,178: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:54:37,178: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:54:37,178: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 21:54:37,883: SQL status: CREATE VIEW in 0.70 seconds
2018-01-04 21:54:37,884: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:54:37,884: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 21:54:37,889: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 21:54:37,890: On parsely_videoview_engagedtime: COMMIT
2018-01-04 21:54:37,890: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 21:54:37,890: On parsely_videoview_engagedtime: COMMIT
2018-01-04 21:54:38,153: SQL status: COMMIT in 0.26 seconds
2018-01-04 21:54:38,154: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec13f50>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:54:38,207: 21:54:38 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.15s]
2018-01-04 21:54:38,208: 21:54:38 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 21:54:38,208: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:54:38,233: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 21:54:38,235: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:54:38,236: Re-using an available connection from the pool.
2018-01-04 21:54:38,236: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:54:38,236: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:54:38,258: SQL status: SELECT in 0.02 seconds
2018-01-04 21:54:38,258: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:54:38,258: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:54:38,277: SQL status: SELECT in 0.02 seconds
2018-01-04 21:54:38,281: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:54:38,281: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 21:54:38,284: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:54:38,284: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:54:38,284: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:56:18,865: SQL status: SELECT in 100.58 seconds
2018-01-04 21:56:18,865: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:56:18,865: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 21:56:19,025: SQL status: SELECT in 0.16 seconds
2018-01-04 21:56:19,025: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:56:19,025: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:56:19,139: SQL status: SELECT in 0.11 seconds
2018-01-04 21:56:19,141: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:56:19,141: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:56:19,259: SQL status: SELECT in 0.12 seconds
2018-01-04 21:56:19,265: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 21:56:19,267: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:56:19,267: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 21:56:20,366: SQL status: INSERT 0 141 in 1.10 seconds
2018-01-04 21:56:20,366: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 21:56:20,366: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 21:56:20,367: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 21:56:21,320: SQL status: COMMIT in 0.95 seconds
2018-01-04 21:56:21,321: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fed0c990>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:56:21,439: 21:56:21 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 141 in 103.11s]
2018-01-04 21:56:21,439: 21:56:21 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 21:56:21,440: Compiling model.parsely.parsely_campaigns
2018-01-04 21:56:21,458: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:56:21,458: Re-using an available connection from the pool.
2018-01-04 21:56:21,458: Using redshift connection "parsely_campaigns".
2018-01-04 21:56:21,459: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:56:21,480: SQL status: SELECT in 0.02 seconds
2018-01-04 21:56:21,486: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 21:56:21,489: Using redshift connection "parsely_campaigns".
2018-01-04 21:56:21,489: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:56:21,508: SQL status: SELECT in 0.02 seconds
2018-01-04 21:56:21,509: Using redshift connection "parsely_campaigns".
2018-01-04 21:56:21,509: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:56:21,528: SQL status: SELECT in 0.02 seconds
2018-01-04 21:56:21,530: Using redshift connection "parsely_campaigns".
2018-01-04 21:56:21,530: On parsely_campaigns: BEGIN
2018-01-04 21:56:21,532: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:56:21,532: Using redshift connection "parsely_campaigns".
2018-01-04 21:56:21,532: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:56:22,577: SQL status: SELECT in 1.04 seconds
2018-01-04 21:56:22,578: Using redshift connection "parsely_campaigns".
2018-01-04 21:56:22,578: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 21:56:22,778: SQL status: SELECT in 0.20 seconds
2018-01-04 21:56:22,778: Using redshift connection "parsely_campaigns".
2018-01-04 21:56:22,779: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:56:22,890: SQL status: SELECT in 0.11 seconds
2018-01-04 21:56:22,891: Using redshift connection "parsely_campaigns".
2018-01-04 21:56:22,891: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:56:23,002: SQL status: SELECT in 0.11 seconds
2018-01-04 21:56:23,004: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 21:56:23,005: Using redshift connection "parsely_campaigns".
2018-01-04 21:56:23,005: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 21:56:23,154: SQL status: INSERT 0 388 in 0.15 seconds
2018-01-04 21:56:23,155: On parsely_campaigns: COMMIT
2018-01-04 21:56:23,155: Using redshift connection "parsely_campaigns".
2018-01-04 21:56:23,155: On parsely_campaigns: COMMIT
2018-01-04 21:56:23,761: SQL status: COMMIT in 0.61 seconds
2018-01-04 21:56:23,762: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f82096ea410>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:56:23,828: 21:56:23 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 388 in 2.32s]
2018-01-04 21:56:23,828: Compiling model.parsely.parsely_incoming_users
2018-01-04 21:56:23,850: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 21:56:23,860: 21:56:23 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 21:56:23,860: Compiling model.parsely.parsely_users
2018-01-04 21:56:23,885: Acquiring new redshift connection "parsely_users".
2018-01-04 21:56:23,885: Re-using an available connection from the pool.
2018-01-04 21:56:23,885: Using redshift connection "parsely_users".
2018-01-04 21:56:23,885: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:56:23,907: SQL status: SELECT in 0.02 seconds
2018-01-04 21:56:24,073: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 21:56:24,080: Using redshift connection "parsely_users".
2018-01-04 21:56:24,080: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:56:24,101: SQL status: SELECT in 0.02 seconds
2018-01-04 21:56:24,102: Using redshift connection "parsely_users".
2018-01-04 21:56:24,102: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:56:24,124: SQL status: SELECT in 0.02 seconds
2018-01-04 21:56:24,127: Using redshift connection "parsely_users".
2018-01-04 21:56:24,128: On parsely_users: BEGIN
2018-01-04 21:56:24,130: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:56:24,130: Using redshift connection "parsely_users".
2018-01-04 21:56:24,130: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:56:26,356: SQL status: SELECT in 2.23 seconds
2018-01-04 21:56:26,357: Using redshift connection "parsely_users".
2018-01-04 21:56:26,357: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 21:56:26,542: SQL status: SELECT in 0.18 seconds
2018-01-04 21:56:26,542: Using redshift connection "parsely_users".
2018-01-04 21:56:26,542: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:56:26,657: SQL status: SELECT in 0.11 seconds
2018-01-04 21:56:26,657: Using redshift connection "parsely_users".
2018-01-04 21:56:26,657: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:56:26,769: SQL status: SELECT in 0.11 seconds
2018-01-04 21:56:26,772: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 21:56:26,773: Using redshift connection "parsely_users".
2018-01-04 21:56:26,773: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 21:56:27,053: SQL status: INSERT 0 53089 in 0.28 seconds
2018-01-04 21:56:27,054: On parsely_users: COMMIT
2018-01-04 21:56:27,054: Using redshift connection "parsely_users".
2018-01-04 21:56:27,054: On parsely_users: COMMIT
2018-01-04 21:56:27,402: SQL status: COMMIT in 0.35 seconds
2018-01-04 21:56:27,402: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec7da50>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:56:27,451: 21:56:27 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 53089 in 3.54s]
2018-01-04 21:56:27,454: 21:56:27 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 21:56:27,455: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 21:56:27,565: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 21:56:27,567: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:56:27,568: Re-using an available connection from the pool.
2018-01-04 21:56:27,568: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:56:27,568: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:56:27,590: SQL status: SELECT in 0.02 seconds
2018-01-04 21:56:27,594: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 21:56:27,595: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:56:27,595: On parsely_pageview_engagedtime: BEGIN
2018-01-04 21:56:27,597: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:56:27,597: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:56:27,598: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 21:56:27,877: SQL status: CREATE VIEW in 0.28 seconds
2018-01-04 21:56:27,878: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:56:27,878: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 21:56:27,882: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 21:56:27,882: On parsely_pageview_engagedtime: COMMIT
2018-01-04 21:56:27,882: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 21:56:27,882: On parsely_pageview_engagedtime: COMMIT
2018-01-04 21:56:28,302: SQL status: COMMIT in 0.42 seconds
2018-01-04 21:56:28,302: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec7d110>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:56:28,347: 21:56:28 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.85s]
2018-01-04 21:56:28,347: 21:56:28 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 21:56:28,348: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 21:56:28,367: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 21:56:28,369: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 21:56:28,369: Re-using an available connection from the pool.
2018-01-04 21:56:28,369: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:56:28,376: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:56:28,399: SQL status: SELECT in 0.02 seconds
2018-01-04 21:56:28,403: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 21:56:28,405: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:56:28,405: On parsely_incoming_sessions: BEGIN
2018-01-04 21:56:28,407: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:56:28,407: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:56:28,407: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 21:56:28,490: SQL status: CREATE VIEW in 0.08 seconds
2018-01-04 21:56:28,490: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:56:28,491: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 21:56:28,496: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 21:56:28,496: On parsely_incoming_sessions: COMMIT
2018-01-04 21:56:28,496: Using redshift connection "parsely_incoming_sessions".
2018-01-04 21:56:28,496: On parsely_incoming_sessions: COMMIT
2018-01-04 21:56:28,803: SQL status: COMMIT in 0.31 seconds
2018-01-04 21:56:28,804: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f82096ea410>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:56:28,886: 21:56:28 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.46s]
2018-01-04 21:56:28,887: 21:56:28 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 21:56:28,887: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:56:28,920: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 21:56:28,925: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:56:28,925: Re-using an available connection from the pool.
2018-01-04 21:56:28,925: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:56:28,926: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:56:28,947: SQL status: SELECT in 0.02 seconds
2018-01-04 21:56:28,948: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:56:28,948: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:56:28,966: SQL status: SELECT in 0.02 seconds
2018-01-04 21:56:28,969: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:56:28,970: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 21:56:28,979: SQL status: BEGIN in 0.01 seconds
2018-01-04 21:56:28,979: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:56:28,979: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:57:49,793: SQL status: SELECT in 80.81 seconds
2018-01-04 21:57:49,793: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:57:49,794: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 21:57:49,969: SQL status: SELECT in 0.18 seconds
2018-01-04 21:57:49,970: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:57:49,971: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:57:50,087: SQL status: SELECT in 0.12 seconds
2018-01-04 21:57:50,088: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:57:50,089: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:57:50,204: SQL status: SELECT in 0.12 seconds
2018-01-04 21:57:50,221: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 21:57:50,222: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:57:50,222: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 21:57:53,619: SQL status: INSERT 0 108437 in 3.40 seconds
2018-01-04 21:57:53,620: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 21:57:53,620: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 21:57:53,620: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 21:57:55,003: SQL status: COMMIT in 1.38 seconds
2018-01-04 21:57:55,004: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fecd2810>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:57:55,069: 21:57:55 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 108437 in 86.12s]
2018-01-04 21:57:55,070: 21:57:55 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 21:57:55,070: Compiling model.parsely.parsely_sessions
2018-01-04 21:57:55,092: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:57:55,092: Re-using an available connection from the pool.
2018-01-04 21:57:55,092: Using redshift connection "parsely_sessions".
2018-01-04 21:57:55,092: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:57:55,116: SQL status: SELECT in 0.02 seconds
2018-01-04 21:57:55,129: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 21:57:55,132: Using redshift connection "parsely_sessions".
2018-01-04 21:57:55,132: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:57:55,152: SQL status: SELECT in 0.02 seconds
2018-01-04 21:57:55,153: Using redshift connection "parsely_sessions".
2018-01-04 21:57:55,153: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:57:55,172: SQL status: SELECT in 0.02 seconds
2018-01-04 21:57:55,177: Using redshift connection "parsely_sessions".
2018-01-04 21:57:55,177: On parsely_sessions: BEGIN
2018-01-04 21:57:55,183: SQL status: BEGIN in 0.01 seconds
2018-01-04 21:57:55,183: Using redshift connection "parsely_sessions".
2018-01-04 21:57:55,183: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:58:16,423: SQL status: SELECT in 21.24 seconds
2018-01-04 21:58:16,423: Using redshift connection "parsely_sessions".
2018-01-04 21:58:16,423: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 21:58:16,591: SQL status: SELECT in 0.17 seconds
2018-01-04 21:58:16,592: Using redshift connection "parsely_sessions".
2018-01-04 21:58:16,592: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:58:16,708: SQL status: SELECT in 0.12 seconds
2018-01-04 21:58:16,709: Using redshift connection "parsely_sessions".
2018-01-04 21:58:16,709: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:58:16,827: SQL status: SELECT in 0.12 seconds
2018-01-04 21:58:16,833: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 21:58:16,834: Using redshift connection "parsely_sessions".
2018-01-04 21:58:16,835: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 21:58:18,873: SQL status: INSERT 0 88137 in 2.04 seconds
2018-01-04 21:58:18,874: On parsely_sessions: COMMIT
2018-01-04 21:58:18,874: Using redshift connection "parsely_sessions".
2018-01-04 21:58:18,874: On parsely_sessions: COMMIT
2018-01-04 21:58:19,851: SQL status: COMMIT in 0.98 seconds
2018-01-04 21:58:19,852: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fec7d110>], 'label': '7a80747f-4b96-40a7-baa2-fa7368b91246'}
2018-01-04 21:58:19,902: 21:58:19 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 88137 in 24.78s]
2018-01-04 21:58:19,991: Using redshift connection "master".
2018-01-04 21:58:19,992: On master: BEGIN
2018-01-04 21:58:19,994: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:58:19,994: On master: COMMIT
2018-01-04 21:58:19,995: Using redshift connection "master".
2018-01-04 21:58:19,995: On master: COMMIT
2018-01-04 21:58:19,997: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:58:19,997: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 21:58:20,011: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 21:58:20,012: Using redshift connection "master".
2018-01-04 21:58:20,013: On master:  select 1 
2018-01-04 21:58:20,015: SQL status: SELECT in 0.00 seconds
2018-01-04 21:58:20,015: 21:58:20 | 
2018-01-04 21:58:20,016: 21:58:20 | Finished running 10 view models, 15 incremental models in 821.97s.
2018-01-04 21:58:20,017: 
2018-01-04 21:58:20,017: Completed successfully
2018-01-04 21:58:20,017: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 21:58:20,018: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fed25e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fed25f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f81fed0c950>], 'label': 'end'}
2018-01-04 21:58:20,071: Flushing usage events
2018-01-04 21:58:29,640: Tracking: tracking
2018-01-04 21:58:29,641: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f39e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f39f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f39ed0>], 'label': 'start'}
2018-01-04 21:58:29,717: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 21:58:29,769: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 21:58:29,771: Parsing core.sql
2018-01-04 21:58:29,808: Parsing etc/get_custom_schema.sql
2018-01-04 21:58:29,824: Parsing schema_tests/relationships.sql
2018-01-04 21:58:29,833: Parsing schema_tests/accepted_values.sql
2018-01-04 21:58:29,842: Parsing schema_tests/not_null.sql
2018-01-04 21:58:29,845: Parsing schema_tests/unique.sql
2018-01-04 21:58:29,849: Parsing materializations/wrapper.sql
2018-01-04 21:58:29,864: Parsing materializations/archive.sql
2018-01-04 21:58:29,940: Parsing materializations/table.sql
2018-01-04 21:58:29,978: Parsing materializations/helpers.sql
2018-01-04 21:58:30,012: Parsing materializations/bigquery.sql
2018-01-04 21:58:30,039: Parsing materializations/view.sql
2018-01-04 21:58:30,090: Parsing materializations/incremental.sql
2018-01-04 21:58:30,172: Parsing adapters/redshift.sql
2018-01-04 21:58:30,229: Parsing adapters/bigquery.sql
2018-01-04 21:58:30,245: Parsing adapters/postgres.sql
2018-01-04 21:58:30,250: Parsing adapters/common.sql
2018-01-04 21:58:30,316: Parsing model.parsely.parsely_audit
2018-01-04 21:58:30,319: Parsing model.parsely.parsely_video_content
2018-01-04 21:58:30,328: Parsing model.parsely.parsely_post_content
2018-01-04 21:58:30,336: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 21:58:30,342: Parsing model.parsely.parsely_rawdata
2018-01-04 21:58:30,353: Parsing model.parsely.calendar
2018-01-04 21:58:30,356: Parsing model.parsely.parsely_all_events
2018-01-04 21:58:30,382: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:58:30,382: Opening a new connection (0 currently allocated)
2018-01-04 21:58:30,412: Using redshift connection "parsely_all_events".
2018-01-04 21:58:30,412: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:30,439: SQL status: SELECT in 0.03 seconds
2018-01-04 21:58:30,465: Parsing model.parsely.parsely_event_ids
2018-01-04 21:58:30,471: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 21:58:30,479: Parsing model.parsely.parsely_base_events
2018-01-04 21:58:30,492: Acquiring new redshift connection "parsely_base_events".
2018-01-04 21:58:30,492: Re-using an available connection from the pool.
2018-01-04 21:58:30,493: Using redshift connection "parsely_base_events".
2018-01-04 21:58:30,493: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:30,514: SQL status: SELECT in 0.02 seconds
2018-01-04 21:58:30,516: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 21:58:30,535: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 21:58:30,549: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 21:58:30,553: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 21:58:30,563: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 21:58:30,569: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 21:58:30,589: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 21:58:30,610: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 21:58:30,627: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:58:30,627: Re-using an available connection from the pool.
2018-01-04 21:58:30,627: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 21:58:30,628: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:30,650: SQL status: SELECT in 0.02 seconds
2018-01-04 21:58:30,652: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 21:58:30,669: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 21:58:30,683: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:58:30,683: Re-using an available connection from the pool.
2018-01-04 21:58:30,683: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 21:58:30,683: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:30,704: SQL status: SELECT in 0.02 seconds
2018-01-04 21:58:30,706: Parsing model.parsely.parsely_incoming_users
2018-01-04 21:58:30,712: Parsing model.parsely.parsely_users
2018-01-04 21:58:30,722: Acquiring new redshift connection "parsely_users".
2018-01-04 21:58:30,722: Re-using an available connection from the pool.
2018-01-04 21:58:30,722: Using redshift connection "parsely_users".
2018-01-04 21:58:30,723: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:30,751: SQL status: SELECT in 0.03 seconds
2018-01-04 21:58:30,753: Parsing model.parsely.parsely_errors
2018-01-04 21:58:30,780: Parsing model.parsely.parsely_bot_traffic
2018-01-04 21:58:30,797: Parsing model.parsely.parsely_custom_events
2018-01-04 21:58:30,838: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 21:58:30,845: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 21:58:30,852: Parsing model.parsely.parsely_sessions
2018-01-04 21:58:30,866: Acquiring new redshift connection "parsely_sessions".
2018-01-04 21:58:30,866: Re-using an available connection from the pool.
2018-01-04 21:58:30,866: Using redshift connection "parsely_sessions".
2018-01-04 21:58:30,866: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:30,889: SQL status: SELECT in 0.02 seconds
2018-01-04 21:58:30,889: Parsing model.parsely.parsely_campaigns
2018-01-04 21:58:30,897: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 21:58:30,897: Re-using an available connection from the pool.
2018-01-04 21:58:30,897: Using redshift connection "parsely_campaigns".
2018-01-04 21:58:30,897: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:30,918: SQL status: SELECT in 0.02 seconds
2018-01-04 21:58:30,934: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 21:58:30,962: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 21:58:30,977: 
2018-01-04 21:58:30,982: Acquiring new redshift connection "master".
2018-01-04 21:58:30,982: Re-using an available connection from the pool.
2018-01-04 21:58:30,982: Using redshift connection "master".
2018-01-04 21:58:30,982: On master: select distinct nspname from pg_namespace
2018-01-04 21:58:30,985: SQL status: SELECT in 0.00 seconds
2018-01-04 21:58:30,990: Using redshift connection "master".
2018-01-04 21:58:30,991: On master: BEGIN
2018-01-04 21:58:30,999: SQL status: BEGIN in 0.01 seconds
2018-01-04 21:58:30,999: On master: COMMIT
2018-01-04 21:58:30,999: Using redshift connection "master".
2018-01-04 21:58:31,000: On master: COMMIT
2018-01-04 21:58:31,001: SQL status: COMMIT in 0.00 seconds
2018-01-04 21:58:31,017: 21:58:31 | Concurrency: 1 threads (target='dev')
2018-01-04 21:58:31,018: 21:58:31 | 
2018-01-04 21:58:31,018: Using redshift connection "master".
2018-01-04 21:58:31,018: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:31,040: SQL status: SELECT in 0.02 seconds
2018-01-04 21:58:31,263: 21:58:31 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 21:58:31,263: Compiling model.parsely.calendar
2018-01-04 21:58:31,281: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 21:58:31,284: Acquiring new redshift connection "calendar".
2018-01-04 21:58:31,284: Opening a new connection (1 currently allocated)
2018-01-04 21:58:31,300: Using redshift connection "calendar".
2018-01-04 21:58:31,300: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:31,326: SQL status: SELECT in 0.03 seconds
2018-01-04 21:58:31,330: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 21:58:31,332: Using redshift connection "calendar".
2018-01-04 21:58:31,333: On calendar: BEGIN
2018-01-04 21:58:31,335: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:58:31,335: Using redshift connection "calendar".
2018-01-04 21:58:31,335: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 21:58:31,404: SQL status: CREATE VIEW in 0.07 seconds
2018-01-04 21:58:31,405: On calendar: COMMIT
2018-01-04 21:58:31,405: Using redshift connection "calendar".
2018-01-04 21:58:31,406: On calendar: COMMIT
2018-01-04 21:58:31,672: SQL status: COMMIT in 0.27 seconds
2018-01-04 21:58:31,672: Using redshift connection "calendar".
2018-01-04 21:58:31,672: On calendar: BEGIN
2018-01-04 21:58:31,675: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:58:31,675: Using redshift connection "calendar".
2018-01-04 21:58:31,675: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 21:58:31,722: SQL status: DROP VIEW in 0.05 seconds
2018-01-04 21:58:31,722: On calendar: COMMIT
2018-01-04 21:58:31,722: Using redshift connection "calendar".
2018-01-04 21:58:31,722: On calendar: COMMIT
2018-01-04 21:58:32,582: SQL status: COMMIT in 0.86 seconds
2018-01-04 21:58:32,583: Using redshift connection "calendar".
2018-01-04 21:58:32,583: On calendar: BEGIN
2018-01-04 21:58:32,585: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:58:32,585: Using redshift connection "calendar".
2018-01-04 21:58:32,585: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 21:58:32,674: SQL status: ALTER TABLE in 0.09 seconds
2018-01-04 21:58:32,675: On calendar: COMMIT
2018-01-04 21:58:32,675: Using redshift connection "calendar".
2018-01-04 21:58:32,675: On calendar: COMMIT
2018-01-04 21:58:33,116: SQL status: COMMIT in 0.44 seconds
2018-01-04 21:58:33,116: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e27810>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 21:58:33,168: 21:58:33 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.85s]
2018-01-04 21:58:33,169: 21:58:33 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 21:58:33,169: Compiling model.parsely.parsely_rawdata
2018-01-04 21:58:33,184: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:58:33,186: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 21:58:33,191: Re-using an available connection from the pool.
2018-01-04 21:58:33,191: Using redshift connection "parsely_rawdata".
2018-01-04 21:58:33,191: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:33,213: SQL status: SELECT in 0.02 seconds
2018-01-04 21:58:33,214: Using redshift connection "parsely_rawdata".
2018-01-04 21:58:33,214: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:58:33,235: SQL status: SELECT in 0.02 seconds
2018-01-04 21:58:33,237: Using redshift connection "parsely_rawdata".
2018-01-04 21:58:33,237: On parsely_rawdata: BEGIN
2018-01-04 21:58:33,240: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:58:33,240: Using redshift connection "parsely_rawdata".
2018-01-04 21:58:33,240: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 21:59:02,572: SQL status: SELECT in 29.33 seconds
2018-01-04 21:59:02,573: Using redshift connection "parsely_rawdata".
2018-01-04 21:59:02,573: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 21:59:02,730: SQL status: SELECT in 0.16 seconds
2018-01-04 21:59:02,731: Using redshift connection "parsely_rawdata".
2018-01-04 21:59:02,732: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:59:02,851: SQL status: SELECT in 0.12 seconds
2018-01-04 21:59:02,852: Using redshift connection "parsely_rawdata".
2018-01-04 21:59:02,852: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 21:59:02,970: SQL status: SELECT in 0.12 seconds
2018-01-04 21:59:02,976: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 21:59:02,977: Using redshift connection "parsely_rawdata".
2018-01-04 21:59:02,978: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 21:59:35,501: SQL status: INSERT 0 1028623 in 32.52 seconds
2018-01-04 21:59:35,502: On parsely_rawdata: COMMIT
2018-01-04 21:59:35,502: Using redshift connection "parsely_rawdata".
2018-01-04 21:59:35,502: On parsely_rawdata: COMMIT
2018-01-04 21:59:38,121: SQL status: COMMIT in 2.62 seconds
2018-01-04 21:59:38,122: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e91b10>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 21:59:38,214: 21:59:38 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1028623 in 64.95s]
2018-01-04 21:59:38,215: 21:59:38 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 21:59:38,215: Compiling model.parsely.parsely_all_events
2018-01-04 21:59:38,234: Acquiring new redshift connection "parsely_all_events".
2018-01-04 21:59:38,234: Re-using an available connection from the pool.
2018-01-04 21:59:38,234: Using redshift connection "parsely_all_events".
2018-01-04 21:59:38,234: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:59:38,255: SQL status: SELECT in 0.02 seconds
2018-01-04 21:59:38,282: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 21:59:38,285: Using redshift connection "parsely_all_events".
2018-01-04 21:59:38,285: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:59:38,307: SQL status: SELECT in 0.02 seconds
2018-01-04 21:59:38,307: Using redshift connection "parsely_all_events".
2018-01-04 21:59:38,307: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 21:59:38,329: SQL status: SELECT in 0.02 seconds
2018-01-04 21:59:38,333: Using redshift connection "parsely_all_events".
2018-01-04 21:59:38,333: On parsely_all_events: BEGIN
2018-01-04 21:59:38,335: SQL status: BEGIN in 0.00 seconds
2018-01-04 21:59:38,335: Using redshift connection "parsely_all_events".
2018-01-04 21:59:38,335: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:01:32,395: SQL status: SELECT in 114.06 seconds
2018-01-04 22:01:32,395: Using redshift connection "parsely_all_events".
2018-01-04 22:01:32,395: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 22:01:32,660: SQL status: SELECT in 0.26 seconds
2018-01-04 22:01:32,660: Using redshift connection "parsely_all_events".
2018-01-04 22:01:32,661: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:01:32,779: SQL status: SELECT in 0.12 seconds
2018-01-04 22:01:32,781: Using redshift connection "parsely_all_events".
2018-01-04 22:01:32,781: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:01:32,900: SQL status: SELECT in 0.12 seconds
2018-01-04 22:01:32,907: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 22:01:32,908: Using redshift connection "parsely_all_events".
2018-01-04 22:01:32,908: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 22:01:50,185: SQL status: INSERT 0 913133 in 17.28 seconds
2018-01-04 22:01:50,185: On parsely_all_events: COMMIT
2018-01-04 22:01:50,185: Using redshift connection "parsely_all_events".
2018-01-04 22:01:50,186: On parsely_all_events: COMMIT
2018-01-04 22:01:53,566: SQL status: COMMIT in 3.38 seconds
2018-01-04 22:01:53,567: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035ee6810>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:01:53,681: 22:01:53 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 913133 in 135.35s]
2018-01-04 22:01:53,682: 22:01:53 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 22:01:53,682: Compiling model.parsely.parsely_bot_traffic
2018-01-04 22:01:53,705: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 22:01:53,708: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 22:01:53,708: Re-using an available connection from the pool.
2018-01-04 22:01:53,708: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:01:53,708: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:01:53,730: SQL status: SELECT in 0.02 seconds
2018-01-04 22:01:53,731: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:01:53,732: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:01:53,753: SQL status: SELECT in 0.02 seconds
2018-01-04 22:01:53,756: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:01:53,756: On parsely_bot_traffic: BEGIN
2018-01-04 22:01:53,758: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:01:53,758: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:01:53,758: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:02:31,979: SQL status: SELECT in 38.22 seconds
2018-01-04 22:02:31,979: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:02:31,979: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 22:02:32,359: SQL status: SELECT in 0.38 seconds
2018-01-04 22:02:32,360: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:02:32,360: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:02:32,478: SQL status: SELECT in 0.12 seconds
2018-01-04 22:02:32,480: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:02:32,480: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:02:32,598: SQL status: SELECT in 0.12 seconds
2018-01-04 22:02:32,604: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 22:02:32,609: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:02:32,609: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 22:02:33,693: SQL status: INSERT 0 4 in 1.08 seconds
2018-01-04 22:02:33,693: On parsely_bot_traffic: COMMIT
2018-01-04 22:02:33,693: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:02:33,694: On parsely_bot_traffic: COMMIT
2018-01-04 22:02:34,776: SQL status: COMMIT in 1.08 seconds
2018-01-04 22:02:34,777: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e27c90>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:02:34,829: 22:02:34 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 41.09s]
2018-01-04 22:02:34,830: 22:02:34 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 22:02:34,830: Compiling model.parsely.parsely_custom_events
2018-01-04 22:02:34,859: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 22:02:34,863: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 22:02:34,863: Re-using an available connection from the pool.
2018-01-04 22:02:34,863: Using redshift connection "parsely_custom_events".
2018-01-04 22:02:34,863: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:02:34,884: SQL status: SELECT in 0.02 seconds
2018-01-04 22:02:34,885: Using redshift connection "parsely_custom_events".
2018-01-04 22:02:34,885: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:02:34,906: SQL status: SELECT in 0.02 seconds
2018-01-04 22:02:34,909: Using redshift connection "parsely_custom_events".
2018-01-04 22:02:34,909: On parsely_custom_events: BEGIN
2018-01-04 22:02:34,911: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:02:34,912: Using redshift connection "parsely_custom_events".
2018-01-04 22:02:34,912: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:03:10,873: SQL status: SELECT in 35.96 seconds
2018-01-04 22:03:10,873: Using redshift connection "parsely_custom_events".
2018-01-04 22:03:10,873: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 22:03:11,060: SQL status: SELECT in 0.19 seconds
2018-01-04 22:03:11,061: Using redshift connection "parsely_custom_events".
2018-01-04 22:03:11,061: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:03:11,180: SQL status: SELECT in 0.12 seconds
2018-01-04 22:03:11,182: Using redshift connection "parsely_custom_events".
2018-01-04 22:03:11,183: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:03:11,301: SQL status: SELECT in 0.12 seconds
2018-01-04 22:03:11,307: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 22:03:11,311: Using redshift connection "parsely_custom_events".
2018-01-04 22:03:11,311: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 22:03:11,578: SQL status: INSERT 0 0 in 0.27 seconds
2018-01-04 22:03:11,579: On parsely_custom_events: COMMIT
2018-01-04 22:03:11,579: Using redshift connection "parsely_custom_events".
2018-01-04 22:03:11,579: On parsely_custom_events: COMMIT
2018-01-04 22:03:11,890: SQL status: COMMIT in 0.31 seconds
2018-01-04 22:03:11,891: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e27210>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:03:11,952: 22:03:11 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 37.06s]
2018-01-04 22:03:11,953: 22:03:11 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 22:03:11,953: Compiling model.parsely.parsely_errors
2018-01-04 22:03:11,975: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 22:03:11,977: Acquiring new redshift connection "parsely_errors".
2018-01-04 22:03:11,978: Re-using an available connection from the pool.
2018-01-04 22:03:11,978: Using redshift connection "parsely_errors".
2018-01-04 22:03:11,978: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:03:12,000: SQL status: SELECT in 0.02 seconds
2018-01-04 22:03:12,001: Using redshift connection "parsely_errors".
2018-01-04 22:03:12,001: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:03:12,022: SQL status: SELECT in 0.02 seconds
2018-01-04 22:03:12,025: Using redshift connection "parsely_errors".
2018-01-04 22:03:12,025: On parsely_errors: BEGIN
2018-01-04 22:03:12,027: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:03:12,027: Using redshift connection "parsely_errors".
2018-01-04 22:03:12,028: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:03:46,662: SQL status: SELECT in 34.63 seconds
2018-01-04 22:03:46,663: Using redshift connection "parsely_errors".
2018-01-04 22:03:46,663: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 22:03:46,814: SQL status: SELECT in 0.15 seconds
2018-01-04 22:03:46,815: Using redshift connection "parsely_errors".
2018-01-04 22:03:46,815: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:03:46,934: SQL status: SELECT in 0.12 seconds
2018-01-04 22:03:46,936: Using redshift connection "parsely_errors".
2018-01-04 22:03:46,936: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:03:47,056: SQL status: SELECT in 0.12 seconds
2018-01-04 22:03:47,062: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 22:03:47,067: Using redshift connection "parsely_errors".
2018-01-04 22:03:47,067: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 22:03:47,829: SQL status: INSERT 0 2 in 0.76 seconds
2018-01-04 22:03:47,830: On parsely_errors: COMMIT
2018-01-04 22:03:47,830: Using redshift connection "parsely_errors".
2018-01-04 22:03:47,830: On parsely_errors: COMMIT
2018-01-04 22:03:48,445: SQL status: COMMIT in 0.61 seconds
2018-01-04 22:03:48,446: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e1df10>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:03:48,496: 22:03:48 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 36.49s]
2018-01-04 22:03:48,497: 22:03:48 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 22:03:48,497: Compiling model.parsely.parsely_base_events
2018-01-04 22:03:48,509: Acquiring new redshift connection "parsely_base_events".
2018-01-04 22:03:48,509: Re-using an available connection from the pool.
2018-01-04 22:03:48,509: Using redshift connection "parsely_base_events".
2018-01-04 22:03:48,510: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:03:48,533: SQL status: SELECT in 0.02 seconds
2018-01-04 22:03:48,540: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 22:03:48,542: Using redshift connection "parsely_base_events".
2018-01-04 22:03:48,542: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:03:48,564: SQL status: SELECT in 0.02 seconds
2018-01-04 22:03:48,567: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 22:03:48,569: Using redshift connection "parsely_base_events".
2018-01-04 22:03:48,569: On parsely_base_events: BEGIN
2018-01-04 22:03:48,571: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:03:48,571: Using redshift connection "parsely_base_events".
2018-01-04 22:03:48,571: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 22:03:49,923: SQL status: CREATE VIEW in 1.35 seconds
2018-01-04 22:03:49,924: On parsely_base_events: COMMIT
2018-01-04 22:03:49,924: Using redshift connection "parsely_base_events".
2018-01-04 22:03:49,924: On parsely_base_events: COMMIT
2018-01-04 22:03:50,395: SQL status: COMMIT in 0.47 seconds
2018-01-04 22:03:50,395: Using redshift connection "parsely_base_events".
2018-01-04 22:03:50,395: On parsely_base_events: BEGIN
2018-01-04 22:03:50,397: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:03:50,397: Using redshift connection "parsely_base_events".
2018-01-04 22:03:50,398: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 22:03:50,591: SQL status: DROP VIEW in 0.19 seconds
2018-01-04 22:03:50,591: On parsely_base_events: COMMIT
2018-01-04 22:03:50,591: Using redshift connection "parsely_base_events".
2018-01-04 22:03:50,591: On parsely_base_events: COMMIT
2018-01-04 22:03:50,828: SQL status: COMMIT in 0.24 seconds
2018-01-04 22:03:50,829: Using redshift connection "parsely_base_events".
2018-01-04 22:03:50,829: On parsely_base_events: BEGIN
2018-01-04 22:03:50,831: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:03:50,831: Using redshift connection "parsely_base_events".
2018-01-04 22:03:50,832: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 22:03:50,837: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:03:50,837: On parsely_base_events: COMMIT
2018-01-04 22:03:50,837: Using redshift connection "parsely_base_events".
2018-01-04 22:03:50,837: On parsely_base_events: COMMIT
2018-01-04 22:03:51,045: SQL status: COMMIT in 0.21 seconds
2018-01-04 22:03:51,046: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e91ed0>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:03:51,098: 22:03:51 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 2.55s]
2018-01-04 22:03:51,099: 22:03:51 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 22:03:51,099: Compiling model.parsely.parsely_event_ids
2018-01-04 22:03:51,114: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 22:03:51,117: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 22:03:51,118: Re-using an available connection from the pool.
2018-01-04 22:03:51,118: Using redshift connection "parsely_event_ids".
2018-01-04 22:03:51,118: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:03:51,140: SQL status: SELECT in 0.02 seconds
2018-01-04 22:03:51,140: Using redshift connection "parsely_event_ids".
2018-01-04 22:03:51,141: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:03:51,161: SQL status: SELECT in 0.02 seconds
2018-01-04 22:03:51,162: Using redshift connection "parsely_event_ids".
2018-01-04 22:03:51,163: On parsely_event_ids: BEGIN
2018-01-04 22:03:51,165: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:03:51,165: Using redshift connection "parsely_event_ids".
2018-01-04 22:03:51,165: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:03:52,728: SQL status: SELECT in 1.56 seconds
2018-01-04 22:03:52,729: Using redshift connection "parsely_event_ids".
2018-01-04 22:03:52,729: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 22:03:53,083: SQL status: SELECT in 0.35 seconds
2018-01-04 22:03:53,083: Using redshift connection "parsely_event_ids".
2018-01-04 22:03:53,084: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:03:53,198: SQL status: SELECT in 0.11 seconds
2018-01-04 22:03:53,198: Using redshift connection "parsely_event_ids".
2018-01-04 22:03:53,199: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:03:53,314: SQL status: SELECT in 0.11 seconds
2018-01-04 22:03:53,316: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 22:03:53,317: Using redshift connection "parsely_event_ids".
2018-01-04 22:03:53,317: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 22:03:54,396: SQL status: INSERT 0 913129 in 1.08 seconds
2018-01-04 22:03:54,397: On parsely_event_ids: COMMIT
2018-01-04 22:03:54,397: Using redshift connection "parsely_event_ids".
2018-01-04 22:03:54,397: On parsely_event_ids: COMMIT
2018-01-04 22:03:54,928: SQL status: COMMIT in 0.53 seconds
2018-01-04 22:03:54,929: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e3e7d0>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:03:54,976: 22:03:54 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 913129 in 3.83s]
2018-01-04 22:03:54,976: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 22:03:54,992: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 22:03:54,994: 22:03:54 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 22:03:54,997: Compiling model.parsely.parsely_post_content
2018-01-04 22:03:55,016: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 22:03:55,018: Acquiring new redshift connection "parsely_post_content".
2018-01-04 22:03:55,019: Re-using an available connection from the pool.
2018-01-04 22:03:55,019: Using redshift connection "parsely_post_content".
2018-01-04 22:03:55,022: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:03:55,044: SQL status: SELECT in 0.02 seconds
2018-01-04 22:03:55,044: Using redshift connection "parsely_post_content".
2018-01-04 22:03:55,045: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:03:55,067: SQL status: SELECT in 0.02 seconds
2018-01-04 22:03:55,069: Using redshift connection "parsely_post_content".
2018-01-04 22:03:55,069: On parsely_post_content: BEGIN
2018-01-04 22:03:55,071: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:03:55,072: Using redshift connection "parsely_post_content".
2018-01-04 22:03:55,072: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:04:02,440: SQL status: SELECT in 7.37 seconds
2018-01-04 22:04:02,440: Using redshift connection "parsely_post_content".
2018-01-04 22:04:02,440: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 22:04:02,678: SQL status: SELECT in 0.24 seconds
2018-01-04 22:04:02,679: Using redshift connection "parsely_post_content".
2018-01-04 22:04:02,679: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:04:02,797: SQL status: SELECT in 0.12 seconds
2018-01-04 22:04:02,798: Using redshift connection "parsely_post_content".
2018-01-04 22:04:02,798: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:04:02,914: SQL status: SELECT in 0.12 seconds
2018-01-04 22:04:02,917: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 22:04:02,919: Using redshift connection "parsely_post_content".
2018-01-04 22:04:02,919: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 22:04:03,303: SQL status: INSERT 0 886 in 0.38 seconds
2018-01-04 22:04:03,304: On parsely_post_content: COMMIT
2018-01-04 22:04:03,304: Using redshift connection "parsely_post_content".
2018-01-04 22:04:03,304: On parsely_post_content: COMMIT
2018-01-04 22:04:03,774: SQL status: COMMIT in 0.47 seconds
2018-01-04 22:04:03,775: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e88ed0>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:04:03,822: 22:04:03 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 886 in 8.78s]
2018-01-04 22:04:03,823: 22:04:03 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 22:04:03,823: Compiling model.parsely.parsely_video_content
2018-01-04 22:04:03,838: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 22:04:03,841: Acquiring new redshift connection "parsely_video_content".
2018-01-04 22:04:03,841: Re-using an available connection from the pool.
2018-01-04 22:04:03,841: Using redshift connection "parsely_video_content".
2018-01-04 22:04:03,841: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:04:03,864: SQL status: SELECT in 0.02 seconds
2018-01-04 22:04:03,865: Using redshift connection "parsely_video_content".
2018-01-04 22:04:03,865: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:04:03,887: SQL status: SELECT in 0.02 seconds
2018-01-04 22:04:03,889: Using redshift connection "parsely_video_content".
2018-01-04 22:04:03,889: On parsely_video_content: BEGIN
2018-01-04 22:04:03,892: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:04:03,892: Using redshift connection "parsely_video_content".
2018-01-04 22:04:03,892: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:04:10,584: SQL status: SELECT in 6.69 seconds
2018-01-04 22:04:10,585: Using redshift connection "parsely_video_content".
2018-01-04 22:04:10,585: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 22:04:10,746: SQL status: SELECT in 0.16 seconds
2018-01-04 22:04:10,746: Using redshift connection "parsely_video_content".
2018-01-04 22:04:10,747: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:04:10,860: SQL status: SELECT in 0.11 seconds
2018-01-04 22:04:10,860: Using redshift connection "parsely_video_content".
2018-01-04 22:04:10,861: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:04:10,974: SQL status: SELECT in 0.11 seconds
2018-01-04 22:04:10,977: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 22:04:10,979: Using redshift connection "parsely_video_content".
2018-01-04 22:04:10,979: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 22:04:11,326: SQL status: INSERT 0 469 in 0.35 seconds
2018-01-04 22:04:11,327: On parsely_video_content: COMMIT
2018-01-04 22:04:11,327: Using redshift connection "parsely_video_content".
2018-01-04 22:04:11,327: On parsely_video_content: COMMIT
2018-01-04 22:04:11,880: SQL status: COMMIT in 0.55 seconds
2018-01-04 22:04:11,881: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f332d0>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:04:11,946: 22:04:11 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 469 in 8.06s]
2018-01-04 22:04:11,946: 22:04:11 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 22:04:11,946: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 22:04:11,963: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 22:04:11,965: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 22:04:11,965: Re-using an available connection from the pool.
2018-01-04 22:04:11,965: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:04:11,965: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:04:11,987: SQL status: SELECT in 0.02 seconds
2018-01-04 22:04:11,991: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 22:04:11,992: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:04:11,992: On parsely_entry_exit_urls: BEGIN
2018-01-04 22:04:11,994: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:04:11,995: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:04:11,995: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 22:04:12,161: SQL status: CREATE VIEW in 0.17 seconds
2018-01-04 22:04:12,162: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:04:12,162: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 22:04:12,165: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:04:12,165: On parsely_entry_exit_urls: COMMIT
2018-01-04 22:04:12,165: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:04:12,165: On parsely_entry_exit_urls: COMMIT
2018-01-04 22:04:12,914: SQL status: COMMIT in 0.75 seconds
2018-01-04 22:04:12,915: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f332d0>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:04:12,968: 22:04:12 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.97s]
2018-01-04 22:04:12,968: 22:04:12 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 22:04:12,969: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 22:04:12,993: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 22:04:12,996: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 22:04:12,997: Re-using an available connection from the pool.
2018-01-04 22:04:12,997: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:04:12,997: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:04:13,018: SQL status: SELECT in 0.02 seconds
2018-01-04 22:04:13,025: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 22:04:13,031: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:04:13,031: On parsely_incoming_videoviews: BEGIN
2018-01-04 22:04:13,033: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:04:13,033: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:04:13,033: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 22:04:14,180: SQL status: CREATE VIEW in 1.15 seconds
2018-01-04 22:04:14,181: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:04:14,181: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 22:04:14,294: SQL status: ALTER TABLE in 0.11 seconds
2018-01-04 22:04:14,294: On parsely_incoming_videoviews: COMMIT
2018-01-04 22:04:14,294: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:04:14,294: On parsely_incoming_videoviews: COMMIT
2018-01-04 22:04:14,889: SQL status: COMMIT in 0.59 seconds
2018-01-04 22:04:14,889: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f332d0>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:04:14,938: 22:04:14 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.92s]
2018-01-04 22:04:14,939: 22:04:14 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 22:04:14,939: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 22:04:14,958: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:04:14,958: Re-using an available connection from the pool.
2018-01-04 22:04:14,958: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:04:14,958: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:04:14,979: SQL status: SELECT in 0.02 seconds
2018-01-04 22:04:14,986: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 22:04:14,991: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:04:14,991: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:04:15,012: SQL status: SELECT in 0.02 seconds
2018-01-04 22:04:15,013: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:04:15,013: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:04:15,033: SQL status: SELECT in 0.02 seconds
2018-01-04 22:04:15,037: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:04:15,037: On parsely_videoviews_sessionized: BEGIN
2018-01-04 22:04:15,039: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:04:15,039: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:04:15,039: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:05:00,194: SQL status: SELECT in 45.15 seconds
2018-01-04 22:05:00,194: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:05:00,194: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 22:05:00,438: SQL status: SELECT in 0.24 seconds
2018-01-04 22:05:00,439: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:05:00,439: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:05:00,553: SQL status: SELECT in 0.11 seconds
2018-01-04 22:05:00,554: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:05:00,555: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:05:00,668: SQL status: SELECT in 0.11 seconds
2018-01-04 22:05:00,675: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 22:05:00,681: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:05:00,681: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 22:05:01,836: SQL status: INSERT 0 143 in 1.15 seconds
2018-01-04 22:05:01,836: On parsely_videoviews_sessionized: COMMIT
2018-01-04 22:05:01,836: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:05:01,837: On parsely_videoviews_sessionized: COMMIT
2018-01-04 22:05:03,220: SQL status: COMMIT in 1.38 seconds
2018-01-04 22:05:03,221: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e27890>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:05:03,266: 22:05:03 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 143 in 48.28s]
2018-01-04 22:05:03,267: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 22:05:03,348: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 22:05:03,355: 22:05:03 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 22:05:03,355: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 22:05:03,387: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 22:05:03,389: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:05:03,390: Re-using an available connection from the pool.
2018-01-04 22:05:03,390: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:05:03,390: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:05:03,409: SQL status: SELECT in 0.02 seconds
2018-01-04 22:05:03,413: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 22:05:03,414: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:05:03,414: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 22:05:03,416: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:05:03,416: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:05:03,417: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 22:05:03,480: SQL status: CREATE VIEW in 0.06 seconds
2018-01-04 22:05:03,482: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:05:03,482: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 22:05:03,485: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:05:03,485: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 22:05:03,485: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:05:03,486: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 22:05:03,979: SQL status: COMMIT in 0.49 seconds
2018-01-04 22:05:03,980: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e3ee50>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:05:04,029: 22:05:04 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.62s]
2018-01-04 22:05:04,029: 22:05:04 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 22:05:04,030: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 22:05:04,122: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 22:05:04,127: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:05:04,128: Re-using an available connection from the pool.
2018-01-04 22:05:04,128: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:05:04,128: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:05:04,149: SQL status: SELECT in 0.02 seconds
2018-01-04 22:05:04,154: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 22:05:04,156: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:05:04,156: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 22:05:04,159: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:05:04,159: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:05:04,159: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 22:05:04,340: SQL status: CREATE VIEW in 0.18 seconds
2018-01-04 22:05:04,341: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:05:04,341: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 22:05:04,345: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:05:04,345: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 22:05:04,345: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:05:04,345: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 22:05:05,096: SQL status: COMMIT in 0.75 seconds
2018-01-04 22:05:05,097: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e88ed0>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:05:05,142: 22:05:05 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 1.07s]
2018-01-04 22:05:05,142: 22:05:05 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 22:05:05,142: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 22:05:05,168: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 22:05:05,174: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 22:05:05,175: Re-using an available connection from the pool.
2018-01-04 22:05:05,180: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:05:05,180: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:05:05,203: SQL status: SELECT in 0.02 seconds
2018-01-04 22:05:05,209: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 22:05:05,215: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:05:05,216: On parsely_incoming_pageviews: BEGIN
2018-01-04 22:05:05,218: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:05:05,218: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:05:05,218: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 22:05:05,842: SQL status: CREATE VIEW in 0.62 seconds
2018-01-04 22:05:05,843: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:05:05,843: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 22:05:05,848: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:05:05,849: On parsely_incoming_pageviews: COMMIT
2018-01-04 22:05:05,849: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:05:05,849: On parsely_incoming_pageviews: COMMIT
2018-01-04 22:05:06,463: SQL status: COMMIT in 0.61 seconds
2018-01-04 22:05:06,464: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f20990>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:05:06,515: 22:05:06 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.32s]
2018-01-04 22:05:06,516: 22:05:06 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 22:05:06,516: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 22:05:06,529: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:05:06,530: Re-using an available connection from the pool.
2018-01-04 22:05:06,530: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:05:06,530: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:05:06,552: SQL status: SELECT in 0.02 seconds
2018-01-04 22:05:06,563: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 22:05:06,565: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:05:06,565: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:05:06,587: SQL status: SELECT in 0.02 seconds
2018-01-04 22:05:06,587: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:05:06,587: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:05:06,608: SQL status: SELECT in 0.02 seconds
2018-01-04 22:05:06,611: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:05:06,612: On parsely_pageviews_sessionized: BEGIN
2018-01-04 22:05:06,617: SQL status: BEGIN in 0.01 seconds
2018-01-04 22:05:06,618: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:05:06,618: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:08:04,484: SQL status: SELECT in 177.87 seconds
2018-01-04 22:08:04,484: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:08:04,485: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 22:08:04,767: SQL status: SELECT in 0.28 seconds
2018-01-04 22:08:04,768: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:08:04,768: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:08:04,888: SQL status: SELECT in 0.12 seconds
2018-01-04 22:08:04,890: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:08:04,890: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:08:05,008: SQL status: SELECT in 0.12 seconds
2018-01-04 22:08:05,019: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 22:08:05,021: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:08:05,021: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 22:08:08,105: SQL status: INSERT 0 108901 in 3.08 seconds
2018-01-04 22:08:08,106: On parsely_pageviews_sessionized: COMMIT
2018-01-04 22:08:08,106: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:08:08,106: On parsely_pageviews_sessionized: COMMIT
2018-01-04 22:08:09,764: SQL status: COMMIT in 1.66 seconds
2018-01-04 22:08:09,765: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e91950>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:08:09,860: 22:08:09 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 108901 in 183.25s]
2018-01-04 22:08:09,860: 22:08:09 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 22:08:09,860: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 22:08:10,047: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 22:08:10,050: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:08:10,050: Re-using an available connection from the pool.
2018-01-04 22:08:10,050: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:08:10,051: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:08:10,073: SQL status: SELECT in 0.02 seconds
2018-01-04 22:08:10,078: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 22:08:10,079: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:08:10,079: On parsely_videoview_engagedtime: BEGIN
2018-01-04 22:08:10,081: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:08:10,081: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:08:10,082: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 22:08:10,569: SQL status: CREATE VIEW in 0.49 seconds
2018-01-04 22:08:10,570: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:08:10,570: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 22:08:10,575: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:08:10,575: On parsely_videoview_engagedtime: COMMIT
2018-01-04 22:08:10,575: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:08:10,575: On parsely_videoview_engagedtime: COMMIT
2018-01-04 22:08:11,239: SQL status: COMMIT in 0.66 seconds
2018-01-04 22:08:11,240: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e91950>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:08:11,280: 22:08:11 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.38s]
2018-01-04 22:08:11,280: 22:08:11 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 22:08:11,280: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 22:08:11,301: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 22:08:11,303: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:08:11,303: Re-using an available connection from the pool.
2018-01-04 22:08:11,304: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:08:11,304: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:08:11,327: SQL status: SELECT in 0.02 seconds
2018-01-04 22:08:11,328: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:08:11,328: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:08:11,350: SQL status: SELECT in 0.02 seconds
2018-01-04 22:08:11,354: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:08:11,354: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 22:08:11,356: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:08:11,356: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:08:11,357: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:10:03,303: SQL status: SELECT in 111.95 seconds
2018-01-04 22:10:03,304: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:10:03,304: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 22:10:03,606: SQL status: SELECT in 0.30 seconds
2018-01-04 22:10:03,606: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:10:03,606: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:10:03,725: SQL status: SELECT in 0.12 seconds
2018-01-04 22:10:03,726: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:10:03,726: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:10:03,847: SQL status: SELECT in 0.12 seconds
2018-01-04 22:10:03,853: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 22:10:03,855: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:10:03,855: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 22:10:04,941: SQL status: INSERT 0 142 in 1.09 seconds
2018-01-04 22:10:04,942: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 22:10:04,942: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:10:04,942: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 22:10:06,132: SQL status: COMMIT in 1.19 seconds
2018-01-04 22:10:06,132: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e88ed0>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:10:06,211: 22:10:06 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 142 in 114.85s]
2018-01-04 22:10:06,212: 22:10:06 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 22:10:06,212: Compiling model.parsely.parsely_campaigns
2018-01-04 22:10:06,229: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 22:10:06,229: Re-using an available connection from the pool.
2018-01-04 22:10:06,229: Using redshift connection "parsely_campaigns".
2018-01-04 22:10:06,229: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:10:06,252: SQL status: SELECT in 0.02 seconds
2018-01-04 22:10:06,264: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 22:10:06,265: Using redshift connection "parsely_campaigns".
2018-01-04 22:10:06,265: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:10:06,288: SQL status: SELECT in 0.02 seconds
2018-01-04 22:10:06,290: Using redshift connection "parsely_campaigns".
2018-01-04 22:10:06,290: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:10:06,312: SQL status: SELECT in 0.02 seconds
2018-01-04 22:10:06,316: Using redshift connection "parsely_campaigns".
2018-01-04 22:10:06,316: On parsely_campaigns: BEGIN
2018-01-04 22:10:06,318: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:10:06,319: Using redshift connection "parsely_campaigns".
2018-01-04 22:10:06,319: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:10:07,345: SQL status: SELECT in 1.03 seconds
2018-01-04 22:10:07,346: Using redshift connection "parsely_campaigns".
2018-01-04 22:10:07,346: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 22:10:08,069: SQL status: SELECT in 0.72 seconds
2018-01-04 22:10:08,069: Using redshift connection "parsely_campaigns".
2018-01-04 22:10:08,070: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:10:08,183: SQL status: SELECT in 0.11 seconds
2018-01-04 22:10:08,184: Using redshift connection "parsely_campaigns".
2018-01-04 22:10:08,184: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:10:08,297: SQL status: SELECT in 0.11 seconds
2018-01-04 22:10:08,300: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 22:10:08,301: Using redshift connection "parsely_campaigns".
2018-01-04 22:10:08,302: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 22:10:08,451: SQL status: INSERT 0 388 in 0.15 seconds
2018-01-04 22:10:08,452: On parsely_campaigns: COMMIT
2018-01-04 22:10:08,452: Using redshift connection "parsely_campaigns".
2018-01-04 22:10:08,452: On parsely_campaigns: COMMIT
2018-01-04 22:10:09,066: SQL status: COMMIT in 0.61 seconds
2018-01-04 22:10:09,066: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035eee050>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:10:09,112: 22:10:09 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 388 in 2.85s]
2018-01-04 22:10:09,112: Compiling model.parsely.parsely_incoming_users
2018-01-04 22:10:09,125: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 22:10:09,126: 22:10:09 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 22:10:09,131: Compiling model.parsely.parsely_users
2018-01-04 22:10:09,143: Acquiring new redshift connection "parsely_users".
2018-01-04 22:10:09,143: Re-using an available connection from the pool.
2018-01-04 22:10:09,143: Using redshift connection "parsely_users".
2018-01-04 22:10:09,143: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:10:09,166: SQL status: SELECT in 0.02 seconds
2018-01-04 22:10:09,314: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 22:10:09,321: Using redshift connection "parsely_users".
2018-01-04 22:10:09,321: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:10:09,342: SQL status: SELECT in 0.02 seconds
2018-01-04 22:10:09,343: Using redshift connection "parsely_users".
2018-01-04 22:10:09,344: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:10:09,364: SQL status: SELECT in 0.02 seconds
2018-01-04 22:10:09,368: Using redshift connection "parsely_users".
2018-01-04 22:10:09,369: On parsely_users: BEGIN
2018-01-04 22:10:09,371: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:10:09,371: Using redshift connection "parsely_users".
2018-01-04 22:10:09,371: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:10:11,406: SQL status: SELECT in 2.04 seconds
2018-01-04 22:10:11,407: Using redshift connection "parsely_users".
2018-01-04 22:10:11,407: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 22:10:11,576: SQL status: SELECT in 0.17 seconds
2018-01-04 22:10:11,577: Using redshift connection "parsely_users".
2018-01-04 22:10:11,577: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:10:11,690: SQL status: SELECT in 0.11 seconds
2018-01-04 22:10:11,691: Using redshift connection "parsely_users".
2018-01-04 22:10:11,691: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:10:11,804: SQL status: SELECT in 0.11 seconds
2018-01-04 22:10:11,807: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 22:10:11,812: Using redshift connection "parsely_users".
2018-01-04 22:10:11,812: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 22:10:12,097: SQL status: INSERT 0 53306 in 0.29 seconds
2018-01-04 22:10:12,098: On parsely_users: COMMIT
2018-01-04 22:10:12,098: Using redshift connection "parsely_users".
2018-01-04 22:10:12,098: On parsely_users: COMMIT
2018-01-04 22:10:12,565: SQL status: COMMIT in 0.47 seconds
2018-01-04 22:10:12,566: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e91110>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:10:12,619: 22:10:12 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 53306 in 3.44s]
2018-01-04 22:10:12,619: 22:10:12 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 22:10:12,625: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 22:10:12,752: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 22:10:12,754: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:10:12,759: Re-using an available connection from the pool.
2018-01-04 22:10:12,759: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:10:12,759: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:10:12,782: SQL status: SELECT in 0.02 seconds
2018-01-04 22:10:12,786: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 22:10:12,788: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:10:12,788: On parsely_pageview_engagedtime: BEGIN
2018-01-04 22:10:12,790: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:10:12,790: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:10:12,790: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 22:10:13,115: SQL status: CREATE VIEW in 0.33 seconds
2018-01-04 22:10:13,116: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:10:13,117: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 22:10:13,121: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:10:13,121: On parsely_pageview_engagedtime: COMMIT
2018-01-04 22:10:13,122: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:10:13,122: On parsely_pageview_engagedtime: COMMIT
2018-01-04 22:10:13,440: SQL status: COMMIT in 0.32 seconds
2018-01-04 22:10:13,440: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e88ed0>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:10:13,489: 22:10:13 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.82s]
2018-01-04 22:10:13,490: 22:10:13 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 22:10:13,490: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 22:10:13,512: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 22:10:13,520: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 22:10:13,520: Re-using an available connection from the pool.
2018-01-04 22:10:13,520: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:10:13,520: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:10:13,542: SQL status: SELECT in 0.02 seconds
2018-01-04 22:10:13,547: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 22:10:13,549: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:10:13,549: On parsely_incoming_sessions: BEGIN
2018-01-04 22:10:13,553: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:10:13,553: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:10:13,553: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 22:10:13,781: SQL status: CREATE VIEW in 0.23 seconds
2018-01-04 22:10:13,782: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:10:13,782: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 22:10:13,786: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:10:13,786: On parsely_incoming_sessions: COMMIT
2018-01-04 22:10:13,786: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:10:13,786: On parsely_incoming_sessions: COMMIT
2018-01-04 22:10:14,309: SQL status: COMMIT in 0.52 seconds
2018-01-04 22:10:14,309: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035eee610>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:10:14,361: 22:10:14 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.82s]
2018-01-04 22:10:14,361: 22:10:14 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 22:10:14,361: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 22:10:14,385: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 22:10:14,387: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:10:14,388: Re-using an available connection from the pool.
2018-01-04 22:10:14,388: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:10:14,388: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:10:14,411: SQL status: SELECT in 0.02 seconds
2018-01-04 22:10:14,412: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:10:14,412: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:10:14,433: SQL status: SELECT in 0.02 seconds
2018-01-04 22:10:14,437: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:10:14,437: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 22:10:14,439: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:10:14,439: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:10:14,439: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:11:42,541: SQL status: SELECT in 88.10 seconds
2018-01-04 22:11:42,541: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:11:42,541: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 22:11:42,918: SQL status: SELECT in 0.38 seconds
2018-01-04 22:11:42,919: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:11:42,919: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:11:43,036: SQL status: SELECT in 0.12 seconds
2018-01-04 22:11:43,037: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:11:43,037: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:11:43,155: SQL status: SELECT in 0.12 seconds
2018-01-04 22:11:43,162: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 22:11:43,167: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:11:43,167: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 22:11:46,487: SQL status: INSERT 0 108904 in 3.32 seconds
2018-01-04 22:11:46,487: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 22:11:46,487: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:11:46,488: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 22:11:48,381: SQL status: COMMIT in 1.89 seconds
2018-01-04 22:11:48,382: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f33210>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:11:48,444: 22:11:48 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 108904 in 94.02s]
2018-01-04 22:11:48,444: 22:11:48 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 22:11:48,444: Compiling model.parsely.parsely_sessions
2018-01-04 22:11:48,459: Acquiring new redshift connection "parsely_sessions".
2018-01-04 22:11:48,459: Re-using an available connection from the pool.
2018-01-04 22:11:48,460: Using redshift connection "parsely_sessions".
2018-01-04 22:11:48,460: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:11:48,482: SQL status: SELECT in 0.02 seconds
2018-01-04 22:11:48,489: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 22:11:48,495: Using redshift connection "parsely_sessions".
2018-01-04 22:11:48,495: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:11:48,514: SQL status: SELECT in 0.02 seconds
2018-01-04 22:11:48,515: Using redshift connection "parsely_sessions".
2018-01-04 22:11:48,515: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:11:48,534: SQL status: SELECT in 0.02 seconds
2018-01-04 22:11:48,539: Using redshift connection "parsely_sessions".
2018-01-04 22:11:48,539: On parsely_sessions: BEGIN
2018-01-04 22:11:48,542: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:11:48,543: Using redshift connection "parsely_sessions".
2018-01-04 22:11:48,543: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:12:10,290: SQL status: SELECT in 21.75 seconds
2018-01-04 22:12:10,290: Using redshift connection "parsely_sessions".
2018-01-04 22:12:10,290: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 22:12:10,430: SQL status: SELECT in 0.14 seconds
2018-01-04 22:12:10,431: Using redshift connection "parsely_sessions".
2018-01-04 22:12:10,431: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:12:10,548: SQL status: SELECT in 0.12 seconds
2018-01-04 22:12:10,550: Using redshift connection "parsely_sessions".
2018-01-04 22:12:10,550: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:12:10,668: SQL status: SELECT in 0.12 seconds
2018-01-04 22:12:10,673: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 22:12:10,679: Using redshift connection "parsely_sessions".
2018-01-04 22:12:10,679: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 22:12:12,481: SQL status: INSERT 0 88488 in 1.80 seconds
2018-01-04 22:12:12,482: On parsely_sessions: COMMIT
2018-01-04 22:12:12,482: Using redshift connection "parsely_sessions".
2018-01-04 22:12:12,482: On parsely_sessions: COMMIT
2018-01-04 22:12:13,468: SQL status: COMMIT in 0.99 seconds
2018-01-04 22:12:13,468: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035e88ed0>], 'label': '7ce7a3db-58cf-497e-86d8-616132c7c206'}
2018-01-04 22:12:13,525: 22:12:13 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 88488 in 25.02s]
2018-01-04 22:12:13,595: Using redshift connection "master".
2018-01-04 22:12:13,595: On master: BEGIN
2018-01-04 22:12:13,598: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:12:13,598: On master: COMMIT
2018-01-04 22:12:13,598: Using redshift connection "master".
2018-01-04 22:12:13,598: On master: COMMIT
2018-01-04 22:12:13,600: SQL status: COMMIT in 0.00 seconds
2018-01-04 22:12:13,600: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 22:12:13,614: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 22:12:13,616: Using redshift connection "master".
2018-01-04 22:12:13,616: On master:  select 1 
2018-01-04 22:12:13,619: SQL status: SELECT in 0.00 seconds
2018-01-04 22:12:13,619: 22:12:13 | 
2018-01-04 22:12:13,619: 22:12:13 | Finished running 10 view models, 15 incremental models in 822.59s.
2018-01-04 22:12:13,620: 
2018-01-04 22:12:13,621: Completed successfully
2018-01-04 22:12:13,623: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 22:12:13,623: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f39e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f39f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f5035f20950>], 'label': 'end'}
2018-01-04 22:12:13,669: Flushing usage events
2018-01-04 22:12:23,975: Tracking: tracking
2018-01-04 22:12:23,976: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15717e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15717f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15717ed0>], 'label': 'start'}
2018-01-04 22:12:24,041: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 22:12:24,110: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 22:12:24,121: Parsing core.sql
2018-01-04 22:12:24,167: Parsing etc/get_custom_schema.sql
2018-01-04 22:12:24,181: Parsing schema_tests/relationships.sql
2018-01-04 22:12:24,191: Parsing schema_tests/accepted_values.sql
2018-01-04 22:12:24,199: Parsing schema_tests/not_null.sql
2018-01-04 22:12:24,206: Parsing schema_tests/unique.sql
2018-01-04 22:12:24,210: Parsing materializations/wrapper.sql
2018-01-04 22:12:24,223: Parsing materializations/archive.sql
2018-01-04 22:12:24,321: Parsing materializations/table.sql
2018-01-04 22:12:24,374: Parsing materializations/helpers.sql
2018-01-04 22:12:24,424: Parsing materializations/bigquery.sql
2018-01-04 22:12:24,462: Parsing materializations/view.sql
2018-01-04 22:12:24,502: Parsing materializations/incremental.sql
2018-01-04 22:12:24,574: Parsing adapters/redshift.sql
2018-01-04 22:12:24,618: Parsing adapters/bigquery.sql
2018-01-04 22:12:24,627: Parsing adapters/postgres.sql
2018-01-04 22:12:24,634: Parsing adapters/common.sql
2018-01-04 22:12:24,685: Parsing model.parsely.parsely_audit
2018-01-04 22:12:24,693: Parsing model.parsely.parsely_video_content
2018-01-04 22:12:24,703: Parsing model.parsely.parsely_post_content
2018-01-04 22:12:24,709: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 22:12:24,718: Parsing model.parsely.parsely_rawdata
2018-01-04 22:12:24,728: Parsing model.parsely.calendar
2018-01-04 22:12:24,730: Parsing model.parsely.parsely_all_events
2018-01-04 22:12:24,757: Acquiring new redshift connection "parsely_all_events".
2018-01-04 22:12:24,757: Opening a new connection (0 currently allocated)
2018-01-04 22:12:24,774: Using redshift connection "parsely_all_events".
2018-01-04 22:12:24,774: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:24,800: SQL status: SELECT in 0.03 seconds
2018-01-04 22:12:24,815: Parsing model.parsely.parsely_event_ids
2018-01-04 22:12:24,825: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 22:12:24,830: Parsing model.parsely.parsely_base_events
2018-01-04 22:12:24,846: Acquiring new redshift connection "parsely_base_events".
2018-01-04 22:12:24,846: Re-using an available connection from the pool.
2018-01-04 22:12:24,847: Using redshift connection "parsely_base_events".
2018-01-04 22:12:24,847: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:24,865: SQL status: SELECT in 0.02 seconds
2018-01-04 22:12:24,867: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 22:12:24,884: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 22:12:24,896: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 22:12:24,904: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 22:12:24,908: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 22:12:24,920: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 22:12:24,939: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 22:12:24,958: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 22:12:24,974: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:12:24,974: Re-using an available connection from the pool.
2018-01-04 22:12:24,974: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:12:24,974: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:24,995: SQL status: SELECT in 0.02 seconds
2018-01-04 22:12:24,997: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 22:12:25,017: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 22:12:25,036: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:12:25,037: Re-using an available connection from the pool.
2018-01-04 22:12:25,037: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:12:25,037: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:25,057: SQL status: SELECT in 0.02 seconds
2018-01-04 22:12:25,059: Parsing model.parsely.parsely_incoming_users
2018-01-04 22:12:25,065: Parsing model.parsely.parsely_users
2018-01-04 22:12:25,084: Acquiring new redshift connection "parsely_users".
2018-01-04 22:12:25,084: Re-using an available connection from the pool.
2018-01-04 22:12:25,084: Using redshift connection "parsely_users".
2018-01-04 22:12:25,085: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:25,102: SQL status: SELECT in 0.02 seconds
2018-01-04 22:12:25,104: Parsing model.parsely.parsely_errors
2018-01-04 22:12:25,115: Parsing model.parsely.parsely_bot_traffic
2018-01-04 22:12:25,130: Parsing model.parsely.parsely_custom_events
2018-01-04 22:12:25,149: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 22:12:25,162: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 22:12:25,168: Parsing model.parsely.parsely_sessions
2018-01-04 22:12:25,181: Acquiring new redshift connection "parsely_sessions".
2018-01-04 22:12:25,181: Re-using an available connection from the pool.
2018-01-04 22:12:25,181: Using redshift connection "parsely_sessions".
2018-01-04 22:12:25,181: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:25,199: SQL status: SELECT in 0.02 seconds
2018-01-04 22:12:25,200: Parsing model.parsely.parsely_campaigns
2018-01-04 22:12:25,207: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 22:12:25,207: Re-using an available connection from the pool.
2018-01-04 22:12:25,208: Using redshift connection "parsely_campaigns".
2018-01-04 22:12:25,208: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:25,227: SQL status: SELECT in 0.02 seconds
2018-01-04 22:12:25,244: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 22:12:25,258: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 22:12:25,280: 
2018-01-04 22:12:25,285: Acquiring new redshift connection "master".
2018-01-04 22:12:25,285: Re-using an available connection from the pool.
2018-01-04 22:12:25,285: Using redshift connection "master".
2018-01-04 22:12:25,285: On master: select distinct nspname from pg_namespace
2018-01-04 22:12:25,288: SQL status: SELECT in 0.00 seconds
2018-01-04 22:12:25,295: Using redshift connection "master".
2018-01-04 22:12:25,295: On master: BEGIN
2018-01-04 22:12:25,297: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:12:25,297: On master: COMMIT
2018-01-04 22:12:25,297: Using redshift connection "master".
2018-01-04 22:12:25,297: On master: COMMIT
2018-01-04 22:12:25,299: SQL status: COMMIT in 0.00 seconds
2018-01-04 22:12:25,312: 22:12:25 | Concurrency: 1 threads (target='dev')
2018-01-04 22:12:25,314: 22:12:25 | 
2018-01-04 22:12:25,314: Using redshift connection "master".
2018-01-04 22:12:25,315: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:25,336: SQL status: SELECT in 0.02 seconds
2018-01-04 22:12:25,532: 22:12:25 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 22:12:25,534: Compiling model.parsely.calendar
2018-01-04 22:12:25,542: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 22:12:25,544: Acquiring new redshift connection "calendar".
2018-01-04 22:12:25,544: Opening a new connection (1 currently allocated)
2018-01-04 22:12:25,558: Using redshift connection "calendar".
2018-01-04 22:12:25,558: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:25,584: SQL status: SELECT in 0.03 seconds
2018-01-04 22:12:25,588: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 22:12:25,589: Using redshift connection "calendar".
2018-01-04 22:12:25,589: On calendar: BEGIN
2018-01-04 22:12:25,591: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:12:25,591: Using redshift connection "calendar".
2018-01-04 22:12:25,591: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 22:12:25,837: SQL status: CREATE VIEW in 0.25 seconds
2018-01-04 22:12:25,838: On calendar: COMMIT
2018-01-04 22:12:25,838: Using redshift connection "calendar".
2018-01-04 22:12:25,838: On calendar: COMMIT
2018-01-04 22:12:26,088: SQL status: COMMIT in 0.25 seconds
2018-01-04 22:12:26,089: Using redshift connection "calendar".
2018-01-04 22:12:26,089: On calendar: BEGIN
2018-01-04 22:12:26,091: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:12:26,091: Using redshift connection "calendar".
2018-01-04 22:12:26,091: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 22:12:26,099: SQL status: DROP VIEW in 0.01 seconds
2018-01-04 22:12:26,099: On calendar: COMMIT
2018-01-04 22:12:26,099: Using redshift connection "calendar".
2018-01-04 22:12:26,099: On calendar: COMMIT
2018-01-04 22:12:26,339: SQL status: COMMIT in 0.24 seconds
2018-01-04 22:12:26,339: Using redshift connection "calendar".
2018-01-04 22:12:26,339: On calendar: BEGIN
2018-01-04 22:12:26,341: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:12:26,342: Using redshift connection "calendar".
2018-01-04 22:12:26,342: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 22:12:26,347: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:12:26,347: On calendar: COMMIT
2018-01-04 22:12:26,347: Using redshift connection "calendar".
2018-01-04 22:12:26,347: On calendar: COMMIT
2018-01-04 22:12:26,523: SQL status: COMMIT in 0.18 seconds
2018-01-04 22:12:26,523: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15605810>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:12:26,578: 22:12:26 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 0.99s]
2018-01-04 22:12:26,578: 22:12:26 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 22:12:26,579: Compiling model.parsely.parsely_rawdata
2018-01-04 22:12:26,599: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 22:12:26,607: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 22:12:26,607: Re-using an available connection from the pool.
2018-01-04 22:12:26,608: Using redshift connection "parsely_rawdata".
2018-01-04 22:12:26,608: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:26,629: SQL status: SELECT in 0.02 seconds
2018-01-04 22:12:26,629: Using redshift connection "parsely_rawdata".
2018-01-04 22:12:26,630: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:12:26,649: SQL status: SELECT in 0.02 seconds
2018-01-04 22:12:26,651: Using redshift connection "parsely_rawdata".
2018-01-04 22:12:26,651: On parsely_rawdata: BEGIN
2018-01-04 22:12:26,653: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:12:26,653: Using redshift connection "parsely_rawdata".
2018-01-04 22:12:26,653: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:12:56,475: SQL status: SELECT in 29.82 seconds
2018-01-04 22:12:56,475: Using redshift connection "parsely_rawdata".
2018-01-04 22:12:56,476: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 22:12:56,752: SQL status: SELECT in 0.28 seconds
2018-01-04 22:12:56,753: Using redshift connection "parsely_rawdata".
2018-01-04 22:12:56,753: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:12:56,870: SQL status: SELECT in 0.12 seconds
2018-01-04 22:12:56,872: Using redshift connection "parsely_rawdata".
2018-01-04 22:12:56,872: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:12:56,990: SQL status: SELECT in 0.12 seconds
2018-01-04 22:12:56,995: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 22:12:56,997: Using redshift connection "parsely_rawdata".
2018-01-04 22:12:56,997: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 22:13:30,012: SQL status: INSERT 0 1031442 in 33.02 seconds
2018-01-04 22:13:30,013: On parsely_rawdata: COMMIT
2018-01-04 22:13:30,013: Using redshift connection "parsely_rawdata".
2018-01-04 22:13:30,013: On parsely_rawdata: COMMIT
2018-01-04 22:13:32,046: SQL status: COMMIT in 2.03 seconds
2018-01-04 22:13:32,046: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15666f10>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:13:32,128: 22:13:32 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1031442 in 65.47s]
2018-01-04 22:13:32,129: 22:13:32 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 22:13:32,130: Compiling model.parsely.parsely_all_events
2018-01-04 22:13:32,171: Acquiring new redshift connection "parsely_all_events".
2018-01-04 22:13:32,172: Re-using an available connection from the pool.
2018-01-04 22:13:32,172: Using redshift connection "parsely_all_events".
2018-01-04 22:13:32,172: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:13:32,193: SQL status: SELECT in 0.02 seconds
2018-01-04 22:13:32,216: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 22:13:32,219: Using redshift connection "parsely_all_events".
2018-01-04 22:13:32,219: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:13:32,248: SQL status: SELECT in 0.02 seconds
2018-01-04 22:13:32,248: Using redshift connection "parsely_all_events".
2018-01-04 22:13:32,249: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:13:32,269: SQL status: SELECT in 0.02 seconds
2018-01-04 22:13:32,273: Using redshift connection "parsely_all_events".
2018-01-04 22:13:32,273: On parsely_all_events: BEGIN
2018-01-04 22:13:32,275: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:13:32,275: Using redshift connection "parsely_all_events".
2018-01-04 22:13:32,275: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:15:23,676: SQL status: SELECT in 111.40 seconds
2018-01-04 22:15:23,677: Using redshift connection "parsely_all_events".
2018-01-04 22:15:23,677: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 22:15:23,908: SQL status: SELECT in 0.23 seconds
2018-01-04 22:15:23,908: Using redshift connection "parsely_all_events".
2018-01-04 22:15:23,909: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:15:24,027: SQL status: SELECT in 0.12 seconds
2018-01-04 22:15:24,029: Using redshift connection "parsely_all_events".
2018-01-04 22:15:24,030: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:15:24,150: SQL status: SELECT in 0.12 seconds
2018-01-04 22:15:24,157: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 22:15:24,159: Using redshift connection "parsely_all_events".
2018-01-04 22:15:24,159: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 22:15:40,939: SQL status: INSERT 0 915952 in 16.78 seconds
2018-01-04 22:15:40,940: On parsely_all_events: COMMIT
2018-01-04 22:15:40,940: Using redshift connection "parsely_all_events".
2018-01-04 22:15:40,940: On parsely_all_events: COMMIT
2018-01-04 22:15:43,493: SQL status: COMMIT in 2.55 seconds
2018-01-04 22:15:43,494: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf1567fc50>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:15:43,575: 22:15:43 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 915952 in 131.36s]
2018-01-04 22:15:43,575: 22:15:43 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 22:15:43,576: Compiling model.parsely.parsely_bot_traffic
2018-01-04 22:15:43,599: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 22:15:43,602: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 22:15:43,602: Re-using an available connection from the pool.
2018-01-04 22:15:43,602: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:15:43,602: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:15:43,624: SQL status: SELECT in 0.02 seconds
2018-01-04 22:15:43,625: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:15:43,625: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:15:43,647: SQL status: SELECT in 0.02 seconds
2018-01-04 22:15:43,650: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:15:43,650: On parsely_bot_traffic: BEGIN
2018-01-04 22:15:43,652: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:15:43,652: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:15:43,652: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:16:26,105: SQL status: SELECT in 42.45 seconds
2018-01-04 22:16:26,106: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:16:26,106: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 22:16:26,444: SQL status: SELECT in 0.34 seconds
2018-01-04 22:16:26,445: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:16:26,445: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:16:26,567: SQL status: SELECT in 0.12 seconds
2018-01-04 22:16:26,568: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:16:26,569: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:16:26,690: SQL status: SELECT in 0.12 seconds
2018-01-04 22:16:26,697: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 22:16:26,698: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:16:26,698: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 22:16:27,898: SQL status: INSERT 0 4 in 1.20 seconds
2018-01-04 22:16:27,898: On parsely_bot_traffic: COMMIT
2018-01-04 22:16:27,899: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:16:27,899: On parsely_bot_traffic: COMMIT
2018-01-04 22:16:28,918: SQL status: COMMIT in 1.02 seconds
2018-01-04 22:16:28,918: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15666f10>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:16:28,968: 22:16:28 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 45.34s]
2018-01-04 22:16:28,968: 22:16:28 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 22:16:28,969: Compiling model.parsely.parsely_custom_events
2018-01-04 22:16:28,993: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 22:16:29,004: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 22:16:29,004: Re-using an available connection from the pool.
2018-01-04 22:16:29,004: Using redshift connection "parsely_custom_events".
2018-01-04 22:16:29,004: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:16:29,026: SQL status: SELECT in 0.02 seconds
2018-01-04 22:16:29,027: Using redshift connection "parsely_custom_events".
2018-01-04 22:16:29,027: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:16:29,049: SQL status: SELECT in 0.02 seconds
2018-01-04 22:16:29,053: Using redshift connection "parsely_custom_events".
2018-01-04 22:16:29,053: On parsely_custom_events: BEGIN
2018-01-04 22:16:29,055: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:16:29,055: Using redshift connection "parsely_custom_events".
2018-01-04 22:16:29,055: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:17:09,798: SQL status: SELECT in 40.74 seconds
2018-01-04 22:17:09,799: Using redshift connection "parsely_custom_events".
2018-01-04 22:17:09,799: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 22:17:09,996: SQL status: SELECT in 0.20 seconds
2018-01-04 22:17:09,997: Using redshift connection "parsely_custom_events".
2018-01-04 22:17:09,997: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:17:10,118: SQL status: SELECT in 0.12 seconds
2018-01-04 22:17:10,120: Using redshift connection "parsely_custom_events".
2018-01-04 22:17:10,120: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:17:10,240: SQL status: SELECT in 0.12 seconds
2018-01-04 22:17:10,251: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 22:17:10,253: Using redshift connection "parsely_custom_events".
2018-01-04 22:17:10,253: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 22:17:10,518: SQL status: INSERT 0 0 in 0.26 seconds
2018-01-04 22:17:10,518: On parsely_custom_events: COMMIT
2018-01-04 22:17:10,519: Using redshift connection "parsely_custom_events".
2018-01-04 22:17:10,519: On parsely_custom_events: COMMIT
2018-01-04 22:17:10,737: SQL status: COMMIT in 0.22 seconds
2018-01-04 22:17:10,738: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156cc950>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:17:10,817: 22:17:10 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 41.77s]
2018-01-04 22:17:10,818: 22:17:10 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 22:17:10,819: Compiling model.parsely.parsely_errors
2018-01-04 22:17:10,850: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 22:17:10,853: Acquiring new redshift connection "parsely_errors".
2018-01-04 22:17:10,854: Re-using an available connection from the pool.
2018-01-04 22:17:10,854: Using redshift connection "parsely_errors".
2018-01-04 22:17:10,854: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:17:10,876: SQL status: SELECT in 0.02 seconds
2018-01-04 22:17:10,877: Using redshift connection "parsely_errors".
2018-01-04 22:17:10,877: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:17:10,897: SQL status: SELECT in 0.02 seconds
2018-01-04 22:17:10,900: Using redshift connection "parsely_errors".
2018-01-04 22:17:10,900: On parsely_errors: BEGIN
2018-01-04 22:17:10,903: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:17:10,903: Using redshift connection "parsely_errors".
2018-01-04 22:17:10,903: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:17:50,936: SQL status: SELECT in 40.03 seconds
2018-01-04 22:17:50,936: Using redshift connection "parsely_errors".
2018-01-04 22:17:50,936: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 22:17:51,212: SQL status: SELECT in 0.28 seconds
2018-01-04 22:17:51,213: Using redshift connection "parsely_errors".
2018-01-04 22:17:51,214: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:17:51,335: SQL status: SELECT in 0.12 seconds
2018-01-04 22:17:51,337: Using redshift connection "parsely_errors".
2018-01-04 22:17:51,337: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:17:51,458: SQL status: SELECT in 0.12 seconds
2018-01-04 22:17:51,468: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 22:17:51,469: Using redshift connection "parsely_errors".
2018-01-04 22:17:51,469: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 22:17:52,140: SQL status: INSERT 0 2 in 0.67 seconds
2018-01-04 22:17:52,140: On parsely_errors: COMMIT
2018-01-04 22:17:52,141: Using redshift connection "parsely_errors".
2018-01-04 22:17:52,141: On parsely_errors: COMMIT
2018-01-04 22:17:52,855: SQL status: COMMIT in 0.71 seconds
2018-01-04 22:17:52,856: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15629a10>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:17:52,897: 22:17:52 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 42.04s]
2018-01-04 22:17:52,898: 22:17:52 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 22:17:52,898: Compiling model.parsely.parsely_base_events
2018-01-04 22:17:52,912: Acquiring new redshift connection "parsely_base_events".
2018-01-04 22:17:52,912: Re-using an available connection from the pool.
2018-01-04 22:17:52,912: Using redshift connection "parsely_base_events".
2018-01-04 22:17:52,912: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:17:52,936: SQL status: SELECT in 0.02 seconds
2018-01-04 22:17:52,947: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 22:17:52,949: Using redshift connection "parsely_base_events".
2018-01-04 22:17:52,949: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:17:52,970: SQL status: SELECT in 0.02 seconds
2018-01-04 22:17:52,973: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 22:17:52,974: Using redshift connection "parsely_base_events".
2018-01-04 22:17:52,975: On parsely_base_events: BEGIN
2018-01-04 22:17:52,977: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:17:52,977: Using redshift connection "parsely_base_events".
2018-01-04 22:17:52,977: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 22:17:54,092: SQL status: CREATE VIEW in 1.11 seconds
2018-01-04 22:17:54,092: On parsely_base_events: COMMIT
2018-01-04 22:17:54,093: Using redshift connection "parsely_base_events".
2018-01-04 22:17:54,093: On parsely_base_events: COMMIT
2018-01-04 22:17:54,388: SQL status: COMMIT in 0.30 seconds
2018-01-04 22:17:54,388: Using redshift connection "parsely_base_events".
2018-01-04 22:17:54,389: On parsely_base_events: BEGIN
2018-01-04 22:17:54,391: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:17:54,391: Using redshift connection "parsely_base_events".
2018-01-04 22:17:54,391: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 22:17:55,275: SQL status: DROP VIEW in 0.88 seconds
2018-01-04 22:17:55,275: On parsely_base_events: COMMIT
2018-01-04 22:17:55,275: Using redshift connection "parsely_base_events".
2018-01-04 22:17:55,275: On parsely_base_events: COMMIT
2018-01-04 22:17:55,463: SQL status: COMMIT in 0.19 seconds
2018-01-04 22:17:55,464: Using redshift connection "parsely_base_events".
2018-01-04 22:17:55,464: On parsely_base_events: BEGIN
2018-01-04 22:17:55,466: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:17:55,466: Using redshift connection "parsely_base_events".
2018-01-04 22:17:55,466: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 22:17:55,472: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 22:17:55,472: On parsely_base_events: COMMIT
2018-01-04 22:17:55,472: Using redshift connection "parsely_base_events".
2018-01-04 22:17:55,472: On parsely_base_events: COMMIT
2018-01-04 22:17:55,664: SQL status: COMMIT in 0.19 seconds
2018-01-04 22:17:55,664: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156290d0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:17:55,708: 22:17:55 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 2.77s]
2018-01-04 22:17:55,708: 22:17:55 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 22:17:55,708: Compiling model.parsely.parsely_event_ids
2018-01-04 22:17:55,722: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 22:17:55,732: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 22:17:55,732: Re-using an available connection from the pool.
2018-01-04 22:17:55,732: Using redshift connection "parsely_event_ids".
2018-01-04 22:17:55,732: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:17:55,753: SQL status: SELECT in 0.02 seconds
2018-01-04 22:17:55,754: Using redshift connection "parsely_event_ids".
2018-01-04 22:17:55,754: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:17:55,774: SQL status: SELECT in 0.02 seconds
2018-01-04 22:17:55,776: Using redshift connection "parsely_event_ids".
2018-01-04 22:17:55,776: On parsely_event_ids: BEGIN
2018-01-04 22:17:55,778: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:17:55,778: Using redshift connection "parsely_event_ids".
2018-01-04 22:17:55,778: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:17:56,908: SQL status: SELECT in 1.13 seconds
2018-01-04 22:17:56,908: Using redshift connection "parsely_event_ids".
2018-01-04 22:17:56,908: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 22:17:57,059: SQL status: SELECT in 0.15 seconds
2018-01-04 22:17:57,060: Using redshift connection "parsely_event_ids".
2018-01-04 22:17:57,060: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:17:57,174: SQL status: SELECT in 0.11 seconds
2018-01-04 22:17:57,175: Using redshift connection "parsely_event_ids".
2018-01-04 22:17:57,175: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:17:57,289: SQL status: SELECT in 0.11 seconds
2018-01-04 22:17:57,291: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 22:17:57,293: Using redshift connection "parsely_event_ids".
2018-01-04 22:17:57,293: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 22:17:58,434: SQL status: INSERT 0 915948 in 1.14 seconds
2018-01-04 22:17:58,435: On parsely_event_ids: COMMIT
2018-01-04 22:17:58,435: Using redshift connection "parsely_event_ids".
2018-01-04 22:17:58,435: On parsely_event_ids: COMMIT
2018-01-04 22:17:59,276: SQL status: COMMIT in 0.84 seconds
2018-01-04 22:17:59,277: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156290d0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:17:59,334: 22:17:59 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 915948 in 3.57s]
2018-01-04 22:17:59,335: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 22:17:59,352: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 22:17:59,360: 22:17:59 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 22:17:59,360: Compiling model.parsely.parsely_post_content
2018-01-04 22:17:59,394: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 22:17:59,400: Acquiring new redshift connection "parsely_post_content".
2018-01-04 22:17:59,400: Re-using an available connection from the pool.
2018-01-04 22:17:59,400: Using redshift connection "parsely_post_content".
2018-01-04 22:17:59,400: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:17:59,422: SQL status: SELECT in 0.02 seconds
2018-01-04 22:17:59,423: Using redshift connection "parsely_post_content".
2018-01-04 22:17:59,423: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:17:59,444: SQL status: SELECT in 0.02 seconds
2018-01-04 22:17:59,446: Using redshift connection "parsely_post_content".
2018-01-04 22:17:59,447: On parsely_post_content: BEGIN
2018-01-04 22:17:59,449: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:17:59,449: Using redshift connection "parsely_post_content".
2018-01-04 22:17:59,449: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:18:07,631: SQL status: SELECT in 8.18 seconds
2018-01-04 22:18:07,631: Using redshift connection "parsely_post_content".
2018-01-04 22:18:07,631: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 22:18:07,827: SQL status: SELECT in 0.20 seconds
2018-01-04 22:18:07,827: Using redshift connection "parsely_post_content".
2018-01-04 22:18:07,827: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:18:07,945: SQL status: SELECT in 0.12 seconds
2018-01-04 22:18:07,947: Using redshift connection "parsely_post_content".
2018-01-04 22:18:07,947: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:18:08,066: SQL status: SELECT in 0.12 seconds
2018-01-04 22:18:08,068: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 22:18:08,070: Using redshift connection "parsely_post_content".
2018-01-04 22:18:08,070: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 22:18:08,432: SQL status: INSERT 0 886 in 0.36 seconds
2018-01-04 22:18:08,432: On parsely_post_content: COMMIT
2018-01-04 22:18:08,433: Using redshift connection "parsely_post_content".
2018-01-04 22:18:08,433: On parsely_post_content: COMMIT
2018-01-04 22:18:08,973: SQL status: COMMIT in 0.54 seconds
2018-01-04 22:18:08,974: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15666bd0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:18:09,017: 22:18:09 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 886 in 9.61s]
2018-01-04 22:18:09,018: 22:18:09 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 22:18:09,018: Compiling model.parsely.parsely_video_content
2018-01-04 22:18:09,034: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 22:18:09,036: Acquiring new redshift connection "parsely_video_content".
2018-01-04 22:18:09,037: Re-using an available connection from the pool.
2018-01-04 22:18:09,037: Using redshift connection "parsely_video_content".
2018-01-04 22:18:09,037: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:18:09,059: SQL status: SELECT in 0.02 seconds
2018-01-04 22:18:09,060: Using redshift connection "parsely_video_content".
2018-01-04 22:18:09,060: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:18:09,081: SQL status: SELECT in 0.02 seconds
2018-01-04 22:18:09,083: Using redshift connection "parsely_video_content".
2018-01-04 22:18:09,083: On parsely_video_content: BEGIN
2018-01-04 22:18:09,085: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:18:09,086: Using redshift connection "parsely_video_content".
2018-01-04 22:18:09,086: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:18:17,329: SQL status: SELECT in 8.24 seconds
2018-01-04 22:18:17,329: Using redshift connection "parsely_video_content".
2018-01-04 22:18:17,329: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 22:18:17,478: SQL status: SELECT in 0.15 seconds
2018-01-04 22:18:17,478: Using redshift connection "parsely_video_content".
2018-01-04 22:18:17,478: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:18:17,617: SQL status: SELECT in 0.14 seconds
2018-01-04 22:18:17,618: Using redshift connection "parsely_video_content".
2018-01-04 22:18:17,618: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:18:17,735: SQL status: SELECT in 0.12 seconds
2018-01-04 22:18:17,738: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 22:18:17,739: Using redshift connection "parsely_video_content".
2018-01-04 22:18:17,739: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 22:18:18,082: SQL status: INSERT 0 469 in 0.34 seconds
2018-01-04 22:18:18,083: On parsely_video_content: COMMIT
2018-01-04 22:18:18,083: Using redshift connection "parsely_video_content".
2018-01-04 22:18:18,083: On parsely_video_content: COMMIT
2018-01-04 22:18:18,686: SQL status: COMMIT in 0.60 seconds
2018-01-04 22:18:18,686: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15666bd0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:18:18,749: 22:18:18 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 469 in 9.67s]
2018-01-04 22:18:18,749: 22:18:18 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 22:18:18,750: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 22:18:18,765: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 22:18:18,774: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 22:18:18,774: Re-using an available connection from the pool.
2018-01-04 22:18:18,774: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:18:18,774: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:18:18,796: SQL status: SELECT in 0.02 seconds
2018-01-04 22:18:18,799: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 22:18:18,800: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:18:18,801: On parsely_entry_exit_urls: BEGIN
2018-01-04 22:18:18,803: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:18:18,803: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:18:18,803: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 22:18:20,266: SQL status: CREATE VIEW in 1.46 seconds
2018-01-04 22:18:20,267: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:18:20,269: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 22:18:20,272: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:18:20,272: On parsely_entry_exit_urls: COMMIT
2018-01-04 22:18:20,273: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:18:20,273: On parsely_entry_exit_urls: COMMIT
2018-01-04 22:18:20,783: SQL status: COMMIT in 0.51 seconds
2018-01-04 22:18:20,784: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15666bd0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:18:20,836: 22:18:20 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 2.03s]
2018-01-04 22:18:20,836: 22:18:20 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 22:18:20,837: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 22:18:20,873: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 22:18:20,876: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 22:18:20,876: Re-using an available connection from the pool.
2018-01-04 22:18:20,876: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:18:20,876: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:18:20,898: SQL status: SELECT in 0.02 seconds
2018-01-04 22:18:20,904: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 22:18:20,906: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:18:20,906: On parsely_incoming_videoviews: BEGIN
2018-01-04 22:18:20,915: SQL status: BEGIN in 0.01 seconds
2018-01-04 22:18:20,915: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:18:20,915: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 22:18:21,831: SQL status: CREATE VIEW in 0.92 seconds
2018-01-04 22:18:21,832: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:18:21,832: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 22:18:21,836: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:18:21,836: On parsely_incoming_videoviews: COMMIT
2018-01-04 22:18:21,837: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:18:21,837: On parsely_incoming_videoviews: COMMIT
2018-01-04 22:18:22,044: SQL status: COMMIT in 0.21 seconds
2018-01-04 22:18:22,044: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15666bd0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:18:22,095: 22:18:22 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.21s]
2018-01-04 22:18:22,096: 22:18:22 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 22:18:22,096: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 22:18:22,113: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:18:22,113: Re-using an available connection from the pool.
2018-01-04 22:18:22,114: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:18:22,114: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:18:22,136: SQL status: SELECT in 0.02 seconds
2018-01-04 22:18:22,143: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 22:18:22,152: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:18:22,152: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:18:22,173: SQL status: SELECT in 0.02 seconds
2018-01-04 22:18:22,174: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:18:22,174: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:18:22,195: SQL status: SELECT in 0.02 seconds
2018-01-04 22:18:22,199: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:18:22,199: On parsely_videoviews_sessionized: BEGIN
2018-01-04 22:18:22,201: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:18:22,201: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:18:22,202: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:20:05,746: SQL status: SELECT in 103.54 seconds
2018-01-04 22:20:05,747: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:20:05,747: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 22:20:05,954: SQL status: SELECT in 0.21 seconds
2018-01-04 22:20:05,955: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:20:05,955: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:20:06,063: SQL status: SELECT in 0.11 seconds
2018-01-04 22:20:06,065: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:20:06,065: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:20:06,172: SQL status: SELECT in 0.11 seconds
2018-01-04 22:20:06,178: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 22:20:06,184: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:20:06,184: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 22:20:07,357: SQL status: INSERT 0 143 in 1.17 seconds
2018-01-04 22:20:07,358: On parsely_videoviews_sessionized: COMMIT
2018-01-04 22:20:07,358: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:20:07,358: On parsely_videoviews_sessionized: COMMIT
2018-01-04 22:20:09,032: SQL status: COMMIT in 1.67 seconds
2018-01-04 22:20:09,032: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf157112d0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:20:09,091: 22:20:09 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 143 in 106.94s]
2018-01-04 22:20:09,091: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 22:20:09,176: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 22:20:09,178: 22:20:09 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 22:20:09,180: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 22:20:09,225: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 22:20:09,227: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:20:09,227: Re-using an available connection from the pool.
2018-01-04 22:20:09,227: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:20:09,227: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:20:09,241: SQL status: SELECT in 0.01 seconds
2018-01-04 22:20:09,244: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 22:20:09,245: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:20:09,245: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 22:20:09,247: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:20:09,247: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:20:09,248: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 22:20:10,102: SQL status: CREATE VIEW in 0.85 seconds
2018-01-04 22:20:10,103: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:20:10,103: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 22:20:10,195: SQL status: ALTER TABLE in 0.09 seconds
2018-01-04 22:20:10,195: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 22:20:10,195: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:20:10,195: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 22:20:10,942: SQL status: COMMIT in 0.75 seconds
2018-01-04 22:20:10,942: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15605110>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:20:11,003: 22:20:11 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.76s]
2018-01-04 22:20:11,004: 22:20:11 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 22:20:11,005: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 22:20:11,129: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 22:20:11,140: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:20:11,140: Re-using an available connection from the pool.
2018-01-04 22:20:11,140: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:20:11,140: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:20:11,155: SQL status: SELECT in 0.01 seconds
2018-01-04 22:20:11,160: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 22:20:11,162: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:20:11,162: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 22:20:11,164: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:20:11,165: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:20:11,165: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 22:20:11,196: SQL status: CREATE VIEW in 0.03 seconds
2018-01-04 22:20:11,197: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:20:11,197: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 22:20:11,268: SQL status: ALTER TABLE in 0.07 seconds
2018-01-04 22:20:11,268: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 22:20:11,268: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:20:11,269: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 22:20:11,750: SQL status: COMMIT in 0.48 seconds
2018-01-04 22:20:11,751: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156fe990>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:20:11,798: 22:20:11 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.75s]
2018-01-04 22:20:11,799: 22:20:11 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 22:20:11,799: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 22:20:11,839: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 22:20:11,850: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 22:20:11,850: Re-using an available connection from the pool.
2018-01-04 22:20:11,850: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:20:11,850: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:20:11,865: SQL status: SELECT in 0.01 seconds
2018-01-04 22:20:11,875: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 22:20:11,877: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:20:11,877: On parsely_incoming_pageviews: BEGIN
2018-01-04 22:20:11,880: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:20:11,880: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:20:11,880: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 22:20:13,729: SQL status: CREATE VIEW in 1.85 seconds
2018-01-04 22:20:13,730: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:20:13,730: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 22:20:13,735: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:20:13,735: On parsely_incoming_pageviews: COMMIT
2018-01-04 22:20:13,736: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:20:13,736: On parsely_incoming_pageviews: COMMIT
2018-01-04 22:20:14,083: SQL status: COMMIT in 0.35 seconds
2018-01-04 22:20:14,084: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15605bd0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:20:14,139: 22:20:14 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 2.28s]
2018-01-04 22:20:14,143: 22:20:14 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 22:20:14,143: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 22:20:14,162: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:20:14,162: Re-using an available connection from the pool.
2018-01-04 22:20:14,162: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:20:14,162: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:20:14,189: SQL status: SELECT in 0.03 seconds
2018-01-04 22:20:14,203: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 22:20:14,208: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:20:14,208: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:20:14,233: SQL status: SELECT in 0.02 seconds
2018-01-04 22:20:14,234: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:20:14,234: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:20:14,255: SQL status: SELECT in 0.02 seconds
2018-01-04 22:20:14,263: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:20:14,263: On parsely_pageviews_sessionized: BEGIN
2018-01-04 22:20:14,265: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:20:14,265: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:20:14,266: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:23:25,260: SQL status: SELECT in 190.99 seconds
2018-01-04 22:23:25,260: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:23:25,260: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 22:23:25,424: SQL status: SELECT in 0.16 seconds
2018-01-04 22:23:25,425: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:23:25,425: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:23:25,543: SQL status: SELECT in 0.12 seconds
2018-01-04 22:23:25,545: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:23:25,545: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:23:25,663: SQL status: SELECT in 0.12 seconds
2018-01-04 22:23:25,670: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 22:23:25,675: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:23:25,675: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 22:23:28,773: SQL status: INSERT 0 109312 in 3.10 seconds
2018-01-04 22:23:28,774: On parsely_pageviews_sessionized: COMMIT
2018-01-04 22:23:28,774: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:23:28,774: On parsely_pageviews_sessionized: COMMIT
2018-01-04 22:23:30,533: SQL status: COMMIT in 1.76 seconds
2018-01-04 22:23:30,534: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156ccdd0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:23:30,595: 22:23:30 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 109312 in 196.39s]
2018-01-04 22:23:30,595: 22:23:30 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 22:23:30,597: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 22:23:30,752: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 22:23:30,754: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:23:30,755: Re-using an available connection from the pool.
2018-01-04 22:23:30,755: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:23:30,762: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:23:30,785: SQL status: SELECT in 0.02 seconds
2018-01-04 22:23:30,790: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 22:23:30,793: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:23:30,793: On parsely_videoview_engagedtime: BEGIN
2018-01-04 22:23:30,797: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:23:30,798: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:23:30,798: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 22:23:31,784: SQL status: CREATE VIEW in 0.99 seconds
2018-01-04 22:23:31,785: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:23:31,785: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 22:23:31,789: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:23:31,789: On parsely_videoview_engagedtime: COMMIT
2018-01-04 22:23:31,790: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:23:31,790: On parsely_videoview_engagedtime: COMMIT
2018-01-04 22:23:32,350: SQL status: COMMIT in 0.56 seconds
2018-01-04 22:23:32,350: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156ccdd0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:23:32,404: 22:23:32 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.75s]
2018-01-04 22:23:32,405: 22:23:32 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 22:23:32,406: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 22:23:32,446: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 22:23:32,451: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:23:32,452: Re-using an available connection from the pool.
2018-01-04 22:23:32,452: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:23:32,452: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:23:32,475: SQL status: SELECT in 0.02 seconds
2018-01-04 22:23:32,475: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:23:32,475: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:23:32,497: SQL status: SELECT in 0.02 seconds
2018-01-04 22:23:32,501: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:23:32,501: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 22:23:32,503: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:23:32,503: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:23:32,503: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:25:41,104: SQL status: SELECT in 128.60 seconds
2018-01-04 22:25:41,104: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:25:41,104: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 22:25:41,342: SQL status: SELECT in 0.24 seconds
2018-01-04 22:25:41,343: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:25:41,343: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:25:41,461: SQL status: SELECT in 0.12 seconds
2018-01-04 22:25:41,463: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:25:41,463: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:25:41,581: SQL status: SELECT in 0.12 seconds
2018-01-04 22:25:41,591: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 22:25:41,593: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:25:41,593: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 22:25:43,107: SQL status: INSERT 0 142 in 1.51 seconds
2018-01-04 22:25:43,108: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 22:25:43,108: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:25:43,108: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 22:25:44,799: SQL status: COMMIT in 1.69 seconds
2018-01-04 22:25:44,799: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156fe990>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:25:44,871: 22:25:44 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 142 in 132.39s]
2018-01-04 22:25:44,872: 22:25:44 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 22:25:44,872: Compiling model.parsely.parsely_campaigns
2018-01-04 22:25:44,886: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 22:25:44,887: Re-using an available connection from the pool.
2018-01-04 22:25:44,887: Using redshift connection "parsely_campaigns".
2018-01-04 22:25:44,888: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:25:44,911: SQL status: SELECT in 0.02 seconds
2018-01-04 22:25:44,916: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 22:25:44,918: Using redshift connection "parsely_campaigns".
2018-01-04 22:25:44,919: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:25:44,955: SQL status: SELECT in 0.02 seconds
2018-01-04 22:25:44,956: Using redshift connection "parsely_campaigns".
2018-01-04 22:25:44,956: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:25:44,977: SQL status: SELECT in 0.02 seconds
2018-01-04 22:25:44,979: Using redshift connection "parsely_campaigns".
2018-01-04 22:25:44,979: On parsely_campaigns: BEGIN
2018-01-04 22:25:44,982: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:25:44,982: Using redshift connection "parsely_campaigns".
2018-01-04 22:25:44,982: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:25:46,666: SQL status: SELECT in 1.68 seconds
2018-01-04 22:25:46,667: Using redshift connection "parsely_campaigns".
2018-01-04 22:25:46,667: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 22:25:46,894: SQL status: SELECT in 0.23 seconds
2018-01-04 22:25:46,894: Using redshift connection "parsely_campaigns".
2018-01-04 22:25:46,894: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:25:47,009: SQL status: SELECT in 0.11 seconds
2018-01-04 22:25:47,010: Using redshift connection "parsely_campaigns".
2018-01-04 22:25:47,010: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:25:47,126: SQL status: SELECT in 0.12 seconds
2018-01-04 22:25:47,130: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 22:25:47,479: Using redshift connection "parsely_campaigns".
2018-01-04 22:25:47,480: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 22:25:47,632: SQL status: INSERT 0 389 in 0.15 seconds
2018-01-04 22:25:47,632: On parsely_campaigns: COMMIT
2018-01-04 22:25:47,632: Using redshift connection "parsely_campaigns".
2018-01-04 22:25:47,633: On parsely_campaigns: COMMIT
2018-01-04 22:25:48,203: SQL status: COMMIT in 0.57 seconds
2018-01-04 22:25:48,203: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156fe990>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:25:48,253: 22:25:48 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 389 in 3.33s]
2018-01-04 22:25:48,253: Compiling model.parsely.parsely_incoming_users
2018-01-04 22:25:48,274: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 22:25:48,275: 22:25:48 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 22:25:48,275: Compiling model.parsely.parsely_users
2018-01-04 22:25:48,289: Acquiring new redshift connection "parsely_users".
2018-01-04 22:25:48,289: Re-using an available connection from the pool.
2018-01-04 22:25:48,289: Using redshift connection "parsely_users".
2018-01-04 22:25:48,291: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:25:48,314: SQL status: SELECT in 0.02 seconds
2018-01-04 22:25:48,511: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 22:25:48,514: Using redshift connection "parsely_users".
2018-01-04 22:25:48,514: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:25:48,536: SQL status: SELECT in 0.02 seconds
2018-01-04 22:25:48,537: Using redshift connection "parsely_users".
2018-01-04 22:25:48,537: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:25:48,559: SQL status: SELECT in 0.02 seconds
2018-01-04 22:25:48,563: Using redshift connection "parsely_users".
2018-01-04 22:25:48,563: On parsely_users: BEGIN
2018-01-04 22:25:48,565: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:25:48,566: Using redshift connection "parsely_users".
2018-01-04 22:25:48,566: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:25:50,612: SQL status: SELECT in 2.05 seconds
2018-01-04 22:25:50,613: Using redshift connection "parsely_users".
2018-01-04 22:25:50,613: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 22:25:50,998: SQL status: SELECT in 0.39 seconds
2018-01-04 22:25:50,999: Using redshift connection "parsely_users".
2018-01-04 22:25:50,999: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:25:51,115: SQL status: SELECT in 0.12 seconds
2018-01-04 22:25:51,115: Using redshift connection "parsely_users".
2018-01-04 22:25:51,115: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:25:51,231: SQL status: SELECT in 0.12 seconds
2018-01-04 22:25:51,234: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 22:25:51,235: Using redshift connection "parsely_users".
2018-01-04 22:25:51,235: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 22:25:51,524: SQL status: INSERT 0 53451 in 0.29 seconds
2018-01-04 22:25:51,525: On parsely_users: COMMIT
2018-01-04 22:25:51,525: Using redshift connection "parsely_users".
2018-01-04 22:25:51,525: On parsely_users: COMMIT
2018-01-04 22:25:51,955: SQL status: COMMIT in 0.43 seconds
2018-01-04 22:25:51,956: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf155fb510>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:25:52,001: 22:25:51 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 53451 in 3.68s]
2018-01-04 22:25:52,006: 22:25:51 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 22:25:52,006: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 22:25:52,149: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 22:25:52,152: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:25:52,152: Re-using an available connection from the pool.
2018-01-04 22:25:52,153: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:25:52,153: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:25:52,175: SQL status: SELECT in 0.02 seconds
2018-01-04 22:25:52,179: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 22:25:52,181: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:25:52,181: On parsely_pageview_engagedtime: BEGIN
2018-01-04 22:25:52,185: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:25:52,185: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:25:52,186: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 22:25:53,962: SQL status: CREATE VIEW in 1.78 seconds
2018-01-04 22:25:53,962: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:25:53,963: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 22:25:53,970: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 22:25:53,970: On parsely_pageview_engagedtime: COMMIT
2018-01-04 22:25:53,970: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:25:53,970: On parsely_pageview_engagedtime: COMMIT
2018-01-04 22:25:54,496: SQL status: COMMIT in 0.53 seconds
2018-01-04 22:25:54,497: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156cccd0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:25:54,552: 22:25:54 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 2.49s]
2018-01-04 22:25:54,553: 22:25:54 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 22:25:54,554: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 22:25:54,581: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 22:25:54,586: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 22:25:54,586: Re-using an available connection from the pool.
2018-01-04 22:25:54,587: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:25:54,587: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:25:54,610: SQL status: SELECT in 0.02 seconds
2018-01-04 22:25:54,617: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 22:25:54,619: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:25:54,619: On parsely_incoming_sessions: BEGIN
2018-01-04 22:25:54,622: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:25:54,622: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:25:54,622: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 22:25:56,215: SQL status: CREATE VIEW in 1.59 seconds
2018-01-04 22:25:56,216: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:25:56,216: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 22:25:56,669: SQL status: ALTER TABLE in 0.45 seconds
2018-01-04 22:25:56,670: On parsely_incoming_sessions: COMMIT
2018-01-04 22:25:56,670: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:25:56,670: On parsely_incoming_sessions: COMMIT
2018-01-04 22:25:56,888: SQL status: COMMIT in 0.22 seconds
2018-01-04 22:25:56,889: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156fe990>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:25:56,948: 22:25:56 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 2.33s]
2018-01-04 22:25:56,948: 22:25:56 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 22:25:56,951: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 22:25:56,986: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 22:25:56,989: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:25:56,997: Re-using an available connection from the pool.
2018-01-04 22:25:56,997: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:25:56,997: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:25:57,019: SQL status: SELECT in 0.02 seconds
2018-01-04 22:25:57,020: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:25:57,020: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:25:57,042: SQL status: SELECT in 0.02 seconds
2018-01-04 22:25:57,045: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:25:57,046: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 22:25:57,048: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:25:57,048: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:25:57,048: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:27:36,974: SQL status: SELECT in 99.93 seconds
2018-01-04 22:27:36,975: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:27:36,975: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 22:27:37,295: SQL status: SELECT in 0.32 seconds
2018-01-04 22:27:37,296: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:27:37,296: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:27:37,414: SQL status: SELECT in 0.12 seconds
2018-01-04 22:27:37,415: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:27:37,416: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:27:37,534: SQL status: SELECT in 0.12 seconds
2018-01-04 22:27:37,542: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 22:27:37,548: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:27:37,548: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 22:27:40,801: SQL status: INSERT 0 109313 in 3.25 seconds
2018-01-04 22:27:40,801: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 22:27:40,801: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:27:40,802: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 22:27:42,045: SQL status: COMMIT in 1.24 seconds
2018-01-04 22:27:42,046: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156fe990>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:27:42,107: 22:27:42 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 109313 in 105.10s]
2018-01-04 22:27:42,111: 22:27:42 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 22:27:42,111: Compiling model.parsely.parsely_sessions
2018-01-04 22:27:42,143: Acquiring new redshift connection "parsely_sessions".
2018-01-04 22:27:42,143: Re-using an available connection from the pool.
2018-01-04 22:27:42,144: Using redshift connection "parsely_sessions".
2018-01-04 22:27:42,144: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:27:42,166: SQL status: SELECT in 0.02 seconds
2018-01-04 22:27:42,172: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 22:27:42,175: Using redshift connection "parsely_sessions".
2018-01-04 22:27:42,175: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:27:42,194: SQL status: SELECT in 0.02 seconds
2018-01-04 22:27:42,195: Using redshift connection "parsely_sessions".
2018-01-04 22:27:42,195: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:27:42,217: SQL status: SELECT in 0.02 seconds
2018-01-04 22:27:42,222: Using redshift connection "parsely_sessions".
2018-01-04 22:27:42,222: On parsely_sessions: BEGIN
2018-01-04 22:27:42,224: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:27:42,225: Using redshift connection "parsely_sessions".
2018-01-04 22:27:42,225: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:28:06,700: SQL status: SELECT in 24.47 seconds
2018-01-04 22:28:06,700: Using redshift connection "parsely_sessions".
2018-01-04 22:28:06,700: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 22:28:06,925: SQL status: SELECT in 0.22 seconds
2018-01-04 22:28:06,926: Using redshift connection "parsely_sessions".
2018-01-04 22:28:06,926: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:28:07,043: SQL status: SELECT in 0.12 seconds
2018-01-04 22:28:07,045: Using redshift connection "parsely_sessions".
2018-01-04 22:28:07,045: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:28:07,162: SQL status: SELECT in 0.12 seconds
2018-01-04 22:28:07,167: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 22:28:07,169: Using redshift connection "parsely_sessions".
2018-01-04 22:28:07,169: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 22:28:08,961: SQL status: INSERT 0 88796 in 1.79 seconds
2018-01-04 22:28:08,962: On parsely_sessions: COMMIT
2018-01-04 22:28:08,962: Using redshift connection "parsely_sessions".
2018-01-04 22:28:08,962: On parsely_sessions: COMMIT
2018-01-04 22:28:10,157: SQL status: COMMIT in 1.19 seconds
2018-01-04 22:28:10,158: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15629cd0>], 'label': '57b59bbb-d3b1-4a3c-949e-2bcb91dce655'}
2018-01-04 22:28:10,327: 22:28:10 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 88796 in 28.05s]
2018-01-04 22:28:10,338: Using redshift connection "master".
2018-01-04 22:28:10,338: On master: BEGIN
2018-01-04 22:28:10,341: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:28:10,341: On master: COMMIT
2018-01-04 22:28:10,341: Using redshift connection "master".
2018-01-04 22:28:10,341: On master: COMMIT
2018-01-04 22:28:10,343: SQL status: COMMIT in 0.00 seconds
2018-01-04 22:28:10,343: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 22:28:10,353: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 22:28:10,354: Using redshift connection "master".
2018-01-04 22:28:10,355: On master:  select 1 
2018-01-04 22:28:10,357: SQL status: SELECT in 0.00 seconds
2018-01-04 22:28:10,357: 22:28:10 | 
2018-01-04 22:28:10,358: 22:28:10 | Finished running 10 view models, 15 incremental models in 945.03s.
2018-01-04 22:28:10,359: 
2018-01-04 22:28:10,360: Completed successfully
2018-01-04 22:28:10,360: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 22:28:10,361: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15717e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf15717f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fbf156fe950>], 'label': 'end'}
2018-01-04 22:28:10,409: Flushing usage events
2018-01-04 22:28:19,387: Tracking: tracking
2018-01-04 22:28:19,387: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574449e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574449f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574449ed0>], 'label': 'start'}
2018-01-04 22:28:19,470: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 22:28:19,505: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 22:28:19,507: Parsing core.sql
2018-01-04 22:28:19,532: Parsing etc/get_custom_schema.sql
2018-01-04 22:28:19,546: Parsing schema_tests/relationships.sql
2018-01-04 22:28:19,551: Parsing schema_tests/accepted_values.sql
2018-01-04 22:28:19,557: Parsing schema_tests/not_null.sql
2018-01-04 22:28:19,560: Parsing schema_tests/unique.sql
2018-01-04 22:28:19,564: Parsing materializations/wrapper.sql
2018-01-04 22:28:19,575: Parsing materializations/archive.sql
2018-01-04 22:28:19,681: Parsing materializations/table.sql
2018-01-04 22:28:19,737: Parsing materializations/helpers.sql
2018-01-04 22:28:19,781: Parsing materializations/bigquery.sql
2018-01-04 22:28:19,820: Parsing materializations/view.sql
2018-01-04 22:28:19,863: Parsing materializations/incremental.sql
2018-01-04 22:28:19,936: Parsing adapters/redshift.sql
2018-01-04 22:28:19,996: Parsing adapters/bigquery.sql
2018-01-04 22:28:20,010: Parsing adapters/postgres.sql
2018-01-04 22:28:20,020: Parsing adapters/common.sql
2018-01-04 22:28:20,063: Parsing model.parsely.parsely_audit
2018-01-04 22:28:20,065: Parsing model.parsely.parsely_video_content
2018-01-04 22:28:20,071: Parsing model.parsely.parsely_post_content
2018-01-04 22:28:20,077: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 22:28:20,083: Parsing model.parsely.parsely_rawdata
2018-01-04 22:28:20,088: Parsing model.parsely.calendar
2018-01-04 22:28:20,091: Parsing model.parsely.parsely_all_events
2018-01-04 22:28:20,107: Acquiring new redshift connection "parsely_all_events".
2018-01-04 22:28:20,107: Opening a new connection (0 currently allocated)
2018-01-04 22:28:20,125: Using redshift connection "parsely_all_events".
2018-01-04 22:28:20,125: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:20,151: SQL status: SELECT in 0.03 seconds
2018-01-04 22:28:20,164: Parsing model.parsely.parsely_event_ids
2018-01-04 22:28:20,173: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 22:28:20,177: Parsing model.parsely.parsely_base_events
2018-01-04 22:28:20,195: Acquiring new redshift connection "parsely_base_events".
2018-01-04 22:28:20,196: Re-using an available connection from the pool.
2018-01-04 22:28:20,196: Using redshift connection "parsely_base_events".
2018-01-04 22:28:20,196: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:20,216: SQL status: SELECT in 0.02 seconds
2018-01-04 22:28:20,218: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 22:28:20,232: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 22:28:20,245: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 22:28:20,257: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 22:28:20,269: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 22:28:20,279: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 22:28:20,295: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 22:28:20,310: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 22:28:20,321: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:28:20,321: Re-using an available connection from the pool.
2018-01-04 22:28:20,321: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:28:20,321: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:20,342: SQL status: SELECT in 0.02 seconds
2018-01-04 22:28:20,344: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 22:28:20,363: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 22:28:20,383: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:28:20,383: Re-using an available connection from the pool.
2018-01-04 22:28:20,383: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:28:20,383: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:20,402: SQL status: SELECT in 0.02 seconds
2018-01-04 22:28:20,403: Parsing model.parsely.parsely_incoming_users
2018-01-04 22:28:20,409: Parsing model.parsely.parsely_users
2018-01-04 22:28:20,424: Acquiring new redshift connection "parsely_users".
2018-01-04 22:28:20,425: Re-using an available connection from the pool.
2018-01-04 22:28:20,425: Using redshift connection "parsely_users".
2018-01-04 22:28:20,425: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:20,443: SQL status: SELECT in 0.02 seconds
2018-01-04 22:28:20,444: Parsing model.parsely.parsely_errors
2018-01-04 22:28:20,456: Parsing model.parsely.parsely_bot_traffic
2018-01-04 22:28:20,470: Parsing model.parsely.parsely_custom_events
2018-01-04 22:28:20,480: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 22:28:20,487: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 22:28:20,492: Parsing model.parsely.parsely_sessions
2018-01-04 22:28:20,503: Acquiring new redshift connection "parsely_sessions".
2018-01-04 22:28:20,503: Re-using an available connection from the pool.
2018-01-04 22:28:20,503: Using redshift connection "parsely_sessions".
2018-01-04 22:28:20,503: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:20,524: SQL status: SELECT in 0.02 seconds
2018-01-04 22:28:20,525: Parsing model.parsely.parsely_campaigns
2018-01-04 22:28:20,533: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 22:28:20,533: Re-using an available connection from the pool.
2018-01-04 22:28:20,533: Using redshift connection "parsely_campaigns".
2018-01-04 22:28:20,533: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:20,553: SQL status: SELECT in 0.02 seconds
2018-01-04 22:28:20,570: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 22:28:20,584: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 22:28:20,609: 
2018-01-04 22:28:20,614: Acquiring new redshift connection "master".
2018-01-04 22:28:20,614: Re-using an available connection from the pool.
2018-01-04 22:28:20,614: Using redshift connection "master".
2018-01-04 22:28:20,614: On master: select distinct nspname from pg_namespace
2018-01-04 22:28:20,617: SQL status: SELECT in 0.00 seconds
2018-01-04 22:28:20,622: Using redshift connection "master".
2018-01-04 22:28:20,622: On master: BEGIN
2018-01-04 22:28:20,627: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:28:20,627: On master: COMMIT
2018-01-04 22:28:20,627: Using redshift connection "master".
2018-01-04 22:28:20,627: On master: COMMIT
2018-01-04 22:28:20,629: SQL status: COMMIT in 0.00 seconds
2018-01-04 22:28:20,646: 22:28:20 | Concurrency: 1 threads (target='dev')
2018-01-04 22:28:20,646: 22:28:20 | 
2018-01-04 22:28:20,646: Using redshift connection "master".
2018-01-04 22:28:20,646: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:20,666: SQL status: SELECT in 0.02 seconds
2018-01-04 22:28:20,881: 22:28:20 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 22:28:20,882: Compiling model.parsely.calendar
2018-01-04 22:28:20,898: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 22:28:20,900: Acquiring new redshift connection "calendar".
2018-01-04 22:28:20,900: Opening a new connection (1 currently allocated)
2018-01-04 22:28:20,915: Using redshift connection "calendar".
2018-01-04 22:28:20,916: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:20,941: SQL status: SELECT in 0.03 seconds
2018-01-04 22:28:20,945: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 22:28:20,946: Using redshift connection "calendar".
2018-01-04 22:28:20,947: On calendar: BEGIN
2018-01-04 22:28:20,950: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:28:20,950: Using redshift connection "calendar".
2018-01-04 22:28:20,950: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 22:28:21,010: SQL status: CREATE VIEW in 0.06 seconds
2018-01-04 22:28:21,011: On calendar: COMMIT
2018-01-04 22:28:21,011: Using redshift connection "calendar".
2018-01-04 22:28:21,011: On calendar: COMMIT
2018-01-04 22:28:21,605: SQL status: COMMIT in 0.59 seconds
2018-01-04 22:28:21,605: Using redshift connection "calendar".
2018-01-04 22:28:21,605: On calendar: BEGIN
2018-01-04 22:28:21,607: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:28:21,608: Using redshift connection "calendar".
2018-01-04 22:28:21,608: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 22:28:21,814: SQL status: DROP VIEW in 0.21 seconds
2018-01-04 22:28:21,815: On calendar: COMMIT
2018-01-04 22:28:21,815: Using redshift connection "calendar".
2018-01-04 22:28:21,815: On calendar: COMMIT
2018-01-04 22:28:22,097: SQL status: COMMIT in 0.28 seconds
2018-01-04 22:28:22,097: Using redshift connection "calendar".
2018-01-04 22:28:22,097: On calendar: BEGIN
2018-01-04 22:28:22,099: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:28:22,099: Using redshift connection "calendar".
2018-01-04 22:28:22,100: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 22:28:22,105: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:28:22,105: On calendar: COMMIT
2018-01-04 22:28:22,105: Using redshift connection "calendar".
2018-01-04 22:28:22,105: On calendar: COMMIT
2018-01-04 22:28:22,570: SQL status: COMMIT in 0.46 seconds
2018-01-04 22:28:22,570: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574337bd0>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:28:22,631: 22:28:22 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.69s]
2018-01-04 22:28:22,631: 22:28:22 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 22:28:22,632: Compiling model.parsely.parsely_rawdata
2018-01-04 22:28:22,648: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 22:28:22,650: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 22:28:22,650: Re-using an available connection from the pool.
2018-01-04 22:28:22,651: Using redshift connection "parsely_rawdata".
2018-01-04 22:28:22,651: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:22,676: SQL status: SELECT in 0.02 seconds
2018-01-04 22:28:22,677: Using redshift connection "parsely_rawdata".
2018-01-04 22:28:22,677: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:28:22,698: SQL status: SELECT in 0.02 seconds
2018-01-04 22:28:22,700: Using redshift connection "parsely_rawdata".
2018-01-04 22:28:22,700: On parsely_rawdata: BEGIN
2018-01-04 22:28:22,702: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:28:22,702: Using redshift connection "parsely_rawdata".
2018-01-04 22:28:22,702: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:28:50,121: SQL status: SELECT in 27.42 seconds
2018-01-04 22:28:50,122: Using redshift connection "parsely_rawdata".
2018-01-04 22:28:50,122: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 22:28:50,318: SQL status: SELECT in 0.20 seconds
2018-01-04 22:28:50,319: Using redshift connection "parsely_rawdata".
2018-01-04 22:28:50,319: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:28:50,437: SQL status: SELECT in 0.12 seconds
2018-01-04 22:28:50,439: Using redshift connection "parsely_rawdata".
2018-01-04 22:28:50,439: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:28:50,558: SQL status: SELECT in 0.12 seconds
2018-01-04 22:28:50,566: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 22:28:50,571: Using redshift connection "parsely_rawdata".
2018-01-04 22:28:50,571: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 22:29:22,447: SQL status: INSERT 0 1033302 in 31.88 seconds
2018-01-04 22:29:22,448: On parsely_rawdata: COMMIT
2018-01-04 22:29:22,448: Using redshift connection "parsely_rawdata".
2018-01-04 22:29:22,448: On parsely_rawdata: COMMIT
2018-01-04 22:29:24,179: SQL status: COMMIT in 1.73 seconds
2018-01-04 22:29:24,180: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f85743a1b10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:29:24,247: 22:29:24 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1033302 in 61.55s]
2018-01-04 22:29:24,247: 22:29:24 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 22:29:24,247: Compiling model.parsely.parsely_all_events
2018-01-04 22:29:24,274: Acquiring new redshift connection "parsely_all_events".
2018-01-04 22:29:24,274: Re-using an available connection from the pool.
2018-01-04 22:29:24,275: Using redshift connection "parsely_all_events".
2018-01-04 22:29:24,275: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:29:24,296: SQL status: SELECT in 0.02 seconds
2018-01-04 22:29:24,312: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 22:29:24,315: Using redshift connection "parsely_all_events".
2018-01-04 22:29:24,315: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:29:24,337: SQL status: SELECT in 0.02 seconds
2018-01-04 22:29:24,337: Using redshift connection "parsely_all_events".
2018-01-04 22:29:24,337: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:29:24,358: SQL status: SELECT in 0.02 seconds
2018-01-04 22:29:24,361: Using redshift connection "parsely_all_events".
2018-01-04 22:29:24,362: On parsely_all_events: BEGIN
2018-01-04 22:29:24,371: SQL status: BEGIN in 0.01 seconds
2018-01-04 22:29:24,371: Using redshift connection "parsely_all_events".
2018-01-04 22:29:24,371: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:31:17,387: SQL status: SELECT in 113.02 seconds
2018-01-04 22:31:17,388: Using redshift connection "parsely_all_events".
2018-01-04 22:31:17,388: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 22:31:17,825: SQL status: SELECT in 0.44 seconds
2018-01-04 22:31:17,826: Using redshift connection "parsely_all_events".
2018-01-04 22:31:17,826: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:31:17,943: SQL status: SELECT in 0.12 seconds
2018-01-04 22:31:17,944: Using redshift connection "parsely_all_events".
2018-01-04 22:31:17,944: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:31:18,061: SQL status: SELECT in 0.12 seconds
2018-01-04 22:31:18,068: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 22:31:18,069: Using redshift connection "parsely_all_events".
2018-01-04 22:31:18,069: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 22:31:34,966: SQL status: INSERT 0 917810 in 16.90 seconds
2018-01-04 22:31:34,967: On parsely_all_events: COMMIT
2018-01-04 22:31:34,967: Using redshift connection "parsely_all_events".
2018-01-04 22:31:34,967: On parsely_all_events: COMMIT
2018-01-04 22:31:37,717: SQL status: COMMIT in 2.75 seconds
2018-01-04 22:31:37,718: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f85743f6810>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:31:37,791: 22:31:37 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 917810 in 133.47s]
2018-01-04 22:31:37,792: 22:31:37 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 22:31:37,792: Compiling model.parsely.parsely_bot_traffic
2018-01-04 22:31:37,801: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 22:31:37,803: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 22:31:37,803: Re-using an available connection from the pool.
2018-01-04 22:31:37,803: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:31:37,803: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:31:37,824: SQL status: SELECT in 0.02 seconds
2018-01-04 22:31:37,824: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:31:37,824: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:31:37,842: SQL status: SELECT in 0.02 seconds
2018-01-04 22:31:37,844: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:31:37,845: On parsely_bot_traffic: BEGIN
2018-01-04 22:31:37,846: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:31:37,847: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:31:37,847: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:32:22,262: SQL status: SELECT in 44.41 seconds
2018-01-04 22:32:22,262: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:32:22,262: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 22:32:22,494: SQL status: SELECT in 0.23 seconds
2018-01-04 22:32:22,495: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:32:22,495: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:32:22,612: SQL status: SELECT in 0.12 seconds
2018-01-04 22:32:22,613: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:32:22,614: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:32:22,732: SQL status: SELECT in 0.12 seconds
2018-01-04 22:32:22,738: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 22:32:22,747: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:32:22,747: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 22:32:23,886: SQL status: INSERT 0 4 in 1.14 seconds
2018-01-04 22:32:23,887: On parsely_bot_traffic: COMMIT
2018-01-04 22:32:23,887: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:32:23,887: On parsely_bot_traffic: COMMIT
2018-01-04 22:32:25,026: SQL status: COMMIT in 1.14 seconds
2018-01-04 22:32:25,026: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574337c90>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:32:25,067: 22:32:25 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 47.23s]
2018-01-04 22:32:25,067: 22:32:25 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 22:32:25,068: Compiling model.parsely.parsely_custom_events
2018-01-04 22:32:25,086: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 22:32:25,088: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 22:32:25,088: Re-using an available connection from the pool.
2018-01-04 22:32:25,088: Using redshift connection "parsely_custom_events".
2018-01-04 22:32:25,089: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:32:25,111: SQL status: SELECT in 0.02 seconds
2018-01-04 22:32:25,111: Using redshift connection "parsely_custom_events".
2018-01-04 22:32:25,112: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:32:25,131: SQL status: SELECT in 0.02 seconds
2018-01-04 22:32:25,134: Using redshift connection "parsely_custom_events".
2018-01-04 22:32:25,134: On parsely_custom_events: BEGIN
2018-01-04 22:32:25,139: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:32:25,139: Using redshift connection "parsely_custom_events".
2018-01-04 22:32:25,139: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:33:09,031: SQL status: SELECT in 43.89 seconds
2018-01-04 22:33:09,031: Using redshift connection "parsely_custom_events".
2018-01-04 22:33:09,031: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 22:33:09,186: SQL status: SELECT in 0.15 seconds
2018-01-04 22:33:09,187: Using redshift connection "parsely_custom_events".
2018-01-04 22:33:09,187: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:33:09,306: SQL status: SELECT in 0.12 seconds
2018-01-04 22:33:09,308: Using redshift connection "parsely_custom_events".
2018-01-04 22:33:09,308: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:33:09,426: SQL status: SELECT in 0.12 seconds
2018-01-04 22:33:09,432: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 22:33:09,434: Using redshift connection "parsely_custom_events".
2018-01-04 22:33:09,434: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 22:33:09,696: SQL status: INSERT 0 0 in 0.26 seconds
2018-01-04 22:33:09,697: On parsely_custom_events: COMMIT
2018-01-04 22:33:09,697: Using redshift connection "parsely_custom_events".
2018-01-04 22:33:09,697: On parsely_custom_events: COMMIT
2018-01-04 22:33:09,951: SQL status: COMMIT in 0.25 seconds
2018-01-04 22:33:09,951: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574337c90>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:33:09,998: 22:33:09 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 44.88s]
2018-01-04 22:33:09,999: 22:33:09 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 22:33:09,999: Compiling model.parsely.parsely_errors
2018-01-04 22:33:10,012: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 22:33:10,014: Acquiring new redshift connection "parsely_errors".
2018-01-04 22:33:10,014: Re-using an available connection from the pool.
2018-01-04 22:33:10,014: Using redshift connection "parsely_errors".
2018-01-04 22:33:10,014: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:33:10,035: SQL status: SELECT in 0.02 seconds
2018-01-04 22:33:10,036: Using redshift connection "parsely_errors".
2018-01-04 22:33:10,036: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:33:10,056: SQL status: SELECT in 0.02 seconds
2018-01-04 22:33:10,059: Using redshift connection "parsely_errors".
2018-01-04 22:33:10,059: On parsely_errors: BEGIN
2018-01-04 22:33:10,062: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:33:10,062: Using redshift connection "parsely_errors".
2018-01-04 22:33:10,062: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:33:54,912: SQL status: SELECT in 44.85 seconds
2018-01-04 22:33:54,913: Using redshift connection "parsely_errors".
2018-01-04 22:33:54,913: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 22:33:55,065: SQL status: SELECT in 0.15 seconds
2018-01-04 22:33:55,066: Using redshift connection "parsely_errors".
2018-01-04 22:33:55,066: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:33:55,185: SQL status: SELECT in 0.12 seconds
2018-01-04 22:33:55,186: Using redshift connection "parsely_errors".
2018-01-04 22:33:55,186: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:33:55,304: SQL status: SELECT in 0.12 seconds
2018-01-04 22:33:55,309: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 22:33:55,310: Using redshift connection "parsely_errors".
2018-01-04 22:33:55,310: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 22:33:56,002: SQL status: INSERT 0 2 in 0.69 seconds
2018-01-04 22:33:56,002: On parsely_errors: COMMIT
2018-01-04 22:33:56,002: Using redshift connection "parsely_errors".
2018-01-04 22:33:56,003: On parsely_errors: COMMIT
2018-01-04 22:33:57,090: SQL status: COMMIT in 1.09 seconds
2018-01-04 22:33:57,091: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f857432df10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:33:57,130: 22:33:57 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 47.09s]
2018-01-04 22:33:57,131: 22:33:57 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 22:33:57,131: Compiling model.parsely.parsely_base_events
2018-01-04 22:33:57,138: Acquiring new redshift connection "parsely_base_events".
2018-01-04 22:33:57,138: Re-using an available connection from the pool.
2018-01-04 22:33:57,138: Using redshift connection "parsely_base_events".
2018-01-04 22:33:57,139: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:33:57,160: SQL status: SELECT in 0.02 seconds
2018-01-04 22:33:57,165: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 22:33:57,166: Using redshift connection "parsely_base_events".
2018-01-04 22:33:57,166: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:33:57,188: SQL status: SELECT in 0.02 seconds
2018-01-04 22:33:57,190: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 22:33:57,191: Using redshift connection "parsely_base_events".
2018-01-04 22:33:57,191: On parsely_base_events: BEGIN
2018-01-04 22:33:57,193: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:33:57,194: Using redshift connection "parsely_base_events".
2018-01-04 22:33:57,194: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 22:33:57,397: SQL status: CREATE VIEW in 0.20 seconds
2018-01-04 22:33:57,398: On parsely_base_events: COMMIT
2018-01-04 22:33:57,398: Using redshift connection "parsely_base_events".
2018-01-04 22:33:57,398: On parsely_base_events: COMMIT
2018-01-04 22:33:57,641: SQL status: COMMIT in 0.24 seconds
2018-01-04 22:33:57,641: Using redshift connection "parsely_base_events".
2018-01-04 22:33:57,641: On parsely_base_events: BEGIN
2018-01-04 22:33:57,644: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:33:57,644: Using redshift connection "parsely_base_events".
2018-01-04 22:33:57,644: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 22:33:57,773: SQL status: DROP VIEW in 0.13 seconds
2018-01-04 22:33:57,774: On parsely_base_events: COMMIT
2018-01-04 22:33:57,774: Using redshift connection "parsely_base_events".
2018-01-04 22:33:57,774: On parsely_base_events: COMMIT
2018-01-04 22:33:58,000: SQL status: COMMIT in 0.23 seconds
2018-01-04 22:33:58,000: Using redshift connection "parsely_base_events".
2018-01-04 22:33:58,000: On parsely_base_events: BEGIN
2018-01-04 22:33:58,002: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:33:58,003: Using redshift connection "parsely_base_events".
2018-01-04 22:33:58,003: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 22:33:58,008: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 22:33:58,008: On parsely_base_events: COMMIT
2018-01-04 22:33:58,009: Using redshift connection "parsely_base_events".
2018-01-04 22:33:58,009: On parsely_base_events: COMMIT
2018-01-04 22:33:58,327: SQL status: COMMIT in 0.32 seconds
2018-01-04 22:33:58,327: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f85743a1950>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:33:58,357: 22:33:58 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 1.20s]
2018-01-04 22:33:58,357: 22:33:58 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 22:33:58,357: Compiling model.parsely.parsely_event_ids
2018-01-04 22:33:58,366: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 22:33:58,369: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 22:33:58,369: Re-using an available connection from the pool.
2018-01-04 22:33:58,369: Using redshift connection "parsely_event_ids".
2018-01-04 22:33:58,369: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:33:58,392: SQL status: SELECT in 0.02 seconds
2018-01-04 22:33:58,393: Using redshift connection "parsely_event_ids".
2018-01-04 22:33:58,393: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:33:58,414: SQL status: SELECT in 0.02 seconds
2018-01-04 22:33:58,415: Using redshift connection "parsely_event_ids".
2018-01-04 22:33:58,415: On parsely_event_ids: BEGIN
2018-01-04 22:33:58,417: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:33:58,417: Using redshift connection "parsely_event_ids".
2018-01-04 22:33:58,417: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:34:00,217: SQL status: SELECT in 1.80 seconds
2018-01-04 22:34:00,217: Using redshift connection "parsely_event_ids".
2018-01-04 22:34:00,217: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 22:34:00,450: SQL status: SELECT in 0.23 seconds
2018-01-04 22:34:00,450: Using redshift connection "parsely_event_ids".
2018-01-04 22:34:00,450: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:34:00,563: SQL status: SELECT in 0.11 seconds
2018-01-04 22:34:00,563: Using redshift connection "parsely_event_ids".
2018-01-04 22:34:00,563: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:34:00,677: SQL status: SELECT in 0.11 seconds
2018-01-04 22:34:00,679: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 22:34:00,680: Using redshift connection "parsely_event_ids".
2018-01-04 22:34:00,681: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 22:34:01,909: SQL status: INSERT 0 917806 in 1.23 seconds
2018-01-04 22:34:01,909: On parsely_event_ids: COMMIT
2018-01-04 22:34:01,910: Using redshift connection "parsely_event_ids".
2018-01-04 22:34:01,910: On parsely_event_ids: COMMIT
2018-01-04 22:34:02,509: SQL status: COMMIT in 0.60 seconds
2018-01-04 22:34:02,509: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f857434ef10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:34:02,541: 22:34:02 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 917806 in 4.15s]
2018-01-04 22:34:02,542: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 22:34:02,549: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 22:34:02,551: 22:34:02 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 22:34:02,551: Compiling model.parsely.parsely_post_content
2018-01-04 22:34:02,559: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 22:34:02,561: Acquiring new redshift connection "parsely_post_content".
2018-01-04 22:34:02,561: Re-using an available connection from the pool.
2018-01-04 22:34:02,561: Using redshift connection "parsely_post_content".
2018-01-04 22:34:02,561: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:34:02,583: SQL status: SELECT in 0.02 seconds
2018-01-04 22:34:02,584: Using redshift connection "parsely_post_content".
2018-01-04 22:34:02,584: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:34:02,604: SQL status: SELECT in 0.02 seconds
2018-01-04 22:34:02,606: Using redshift connection "parsely_post_content".
2018-01-04 22:34:02,606: On parsely_post_content: BEGIN
2018-01-04 22:34:02,608: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:34:02,608: Using redshift connection "parsely_post_content".
2018-01-04 22:34:02,609: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:34:11,545: SQL status: SELECT in 8.94 seconds
2018-01-04 22:34:11,545: Using redshift connection "parsely_post_content".
2018-01-04 22:34:11,545: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 22:34:11,748: SQL status: SELECT in 0.20 seconds
2018-01-04 22:34:11,748: Using redshift connection "parsely_post_content".
2018-01-04 22:34:11,748: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:34:11,866: SQL status: SELECT in 0.12 seconds
2018-01-04 22:34:11,867: Using redshift connection "parsely_post_content".
2018-01-04 22:34:11,867: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:34:11,985: SQL status: SELECT in 0.12 seconds
2018-01-04 22:34:11,987: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 22:34:11,989: Using redshift connection "parsely_post_content".
2018-01-04 22:34:11,989: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 22:34:12,392: SQL status: INSERT 0 887 in 0.40 seconds
2018-01-04 22:34:12,392: On parsely_post_content: COMMIT
2018-01-04 22:34:12,392: Using redshift connection "parsely_post_content".
2018-01-04 22:34:12,393: On parsely_post_content: COMMIT
2018-01-04 22:34:14,669: SQL status: COMMIT in 2.28 seconds
2018-01-04 22:34:14,669: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574398e10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:34:14,727: 22:34:14 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 887 in 12.12s]
2018-01-04 22:34:14,727: 22:34:14 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 22:34:14,728: Compiling model.parsely.parsely_video_content
2018-01-04 22:34:14,738: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 22:34:14,739: Acquiring new redshift connection "parsely_video_content".
2018-01-04 22:34:14,739: Re-using an available connection from the pool.
2018-01-04 22:34:14,739: Using redshift connection "parsely_video_content".
2018-01-04 22:34:14,740: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:34:14,761: SQL status: SELECT in 0.02 seconds
2018-01-04 22:34:14,762: Using redshift connection "parsely_video_content".
2018-01-04 22:34:14,762: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:34:14,782: SQL status: SELECT in 0.02 seconds
2018-01-04 22:34:14,783: Using redshift connection "parsely_video_content".
2018-01-04 22:34:14,783: On parsely_video_content: BEGIN
2018-01-04 22:34:14,785: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:34:14,785: Using redshift connection "parsely_video_content".
2018-01-04 22:34:14,785: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:34:23,319: SQL status: SELECT in 8.53 seconds
2018-01-04 22:34:23,320: Using redshift connection "parsely_video_content".
2018-01-04 22:34:23,320: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 22:34:23,510: SQL status: SELECT in 0.19 seconds
2018-01-04 22:34:23,510: Using redshift connection "parsely_video_content".
2018-01-04 22:34:23,510: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:34:23,625: SQL status: SELECT in 0.11 seconds
2018-01-04 22:34:23,626: Using redshift connection "parsely_video_content".
2018-01-04 22:34:23,626: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:34:23,740: SQL status: SELECT in 0.11 seconds
2018-01-04 22:34:23,742: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 22:34:23,743: Using redshift connection "parsely_video_content".
2018-01-04 22:34:23,743: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 22:34:24,113: SQL status: INSERT 0 469 in 0.37 seconds
2018-01-04 22:34:24,114: On parsely_video_content: COMMIT
2018-01-04 22:34:24,114: Using redshift connection "parsely_video_content".
2018-01-04 22:34:24,114: On parsely_video_content: COMMIT
2018-01-04 22:34:24,465: SQL status: COMMIT in 0.35 seconds
2018-01-04 22:34:24,466: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574398ed0>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:34:24,505: 22:34:24 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 469 in 9.74s]
2018-01-04 22:34:24,505: 22:34:24 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 22:34:24,506: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 22:34:24,516: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 22:34:24,518: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 22:34:24,518: Re-using an available connection from the pool.
2018-01-04 22:34:24,519: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:34:24,519: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:34:24,550: SQL status: SELECT in 0.03 seconds
2018-01-04 22:34:24,553: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 22:34:24,554: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:34:24,554: On parsely_entry_exit_urls: BEGIN
2018-01-04 22:34:24,557: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:34:24,557: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:34:24,557: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 22:34:25,120: SQL status: CREATE VIEW in 0.56 seconds
2018-01-04 22:34:25,121: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:34:25,121: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 22:34:25,331: SQL status: ALTER TABLE in 0.21 seconds
2018-01-04 22:34:25,332: On parsely_entry_exit_urls: COMMIT
2018-01-04 22:34:25,332: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:34:25,332: On parsely_entry_exit_urls: COMMIT
2018-01-04 22:34:25,740: SQL status: COMMIT in 0.41 seconds
2018-01-04 22:34:25,741: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574398ed0>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:34:25,780: 22:34:25 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 1.24s]
2018-01-04 22:34:25,781: 22:34:25 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 22:34:25,781: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 22:34:25,799: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 22:34:25,802: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 22:34:25,802: Re-using an available connection from the pool.
2018-01-04 22:34:25,803: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:34:25,803: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:34:25,823: SQL status: SELECT in 0.02 seconds
2018-01-04 22:34:25,827: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 22:34:25,829: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:34:25,829: On parsely_incoming_videoviews: BEGIN
2018-01-04 22:34:25,831: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:34:25,831: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:34:25,831: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 22:34:25,992: SQL status: CREATE VIEW in 0.16 seconds
2018-01-04 22:34:25,993: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:34:25,993: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 22:34:25,998: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 22:34:25,999: On parsely_incoming_videoviews: COMMIT
2018-01-04 22:34:25,999: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:34:25,999: On parsely_incoming_videoviews: COMMIT
2018-01-04 22:34:26,166: SQL status: COMMIT in 0.17 seconds
2018-01-04 22:34:26,167: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574398ed0>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:34:26,196: 22:34:26 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.39s]
2018-01-04 22:34:26,197: 22:34:26 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 22:34:26,197: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 22:34:26,203: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:34:26,203: Re-using an available connection from the pool.
2018-01-04 22:34:26,203: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:34:26,204: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:34:26,224: SQL status: SELECT in 0.02 seconds
2018-01-04 22:34:26,229: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 22:34:26,231: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:34:26,231: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:34:26,251: SQL status: SELECT in 0.02 seconds
2018-01-04 22:34:26,251: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:34:26,251: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:34:26,273: SQL status: SELECT in 0.02 seconds
2018-01-04 22:34:26,275: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:34:26,275: On parsely_videoviews_sessionized: BEGIN
2018-01-04 22:34:26,277: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:34:26,277: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:34:26,278: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:35:21,606: SQL status: SELECT in 55.33 seconds
2018-01-04 22:35:21,606: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:35:21,606: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 22:35:21,780: SQL status: SELECT in 0.17 seconds
2018-01-04 22:35:21,781: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:35:21,781: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:35:21,886: SQL status: SELECT in 0.10 seconds
2018-01-04 22:35:21,887: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:35:21,887: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:35:21,994: SQL status: SELECT in 0.11 seconds
2018-01-04 22:35:22,003: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 22:35:22,004: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:35:22,004: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 22:35:23,138: SQL status: INSERT 0 143 in 1.13 seconds
2018-01-04 22:35:23,138: On parsely_videoviews_sessionized: COMMIT
2018-01-04 22:35:23,139: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:35:23,139: On parsely_videoviews_sessionized: COMMIT
2018-01-04 22:35:24,086: SQL status: COMMIT in 0.95 seconds
2018-01-04 22:35:24,086: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f85743a1810>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:35:24,147: 22:35:24 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 143 in 57.89s]
2018-01-04 22:35:24,147: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 22:35:24,196: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 22:35:24,198: 22:35:24 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 22:35:24,198: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 22:35:24,227: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 22:35:24,228: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:35:24,229: Re-using an available connection from the pool.
2018-01-04 22:35:24,229: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:35:24,229: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:35:24,241: SQL status: SELECT in 0.01 seconds
2018-01-04 22:35:24,245: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 22:35:24,246: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:35:24,246: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 22:35:24,306: SQL status: BEGIN in 0.06 seconds
2018-01-04 22:35:24,306: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:35:24,306: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 22:35:25,337: SQL status: CREATE VIEW in 1.03 seconds
2018-01-04 22:35:25,337: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:35:25,337: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 22:35:25,342: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:35:25,342: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 22:35:25,342: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:35:25,342: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 22:35:25,761: SQL status: COMMIT in 0.42 seconds
2018-01-04 22:35:25,761: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574337f10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:35:25,795: 22:35:25 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.56s]
2018-01-04 22:35:25,795: 22:35:25 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 22:35:25,796: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 22:35:25,833: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 22:35:25,833: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:35:25,833: Re-using an available connection from the pool.
2018-01-04 22:35:25,834: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:35:25,834: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:35:25,848: SQL status: SELECT in 0.01 seconds
2018-01-04 22:35:25,852: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 22:35:25,852: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:35:25,853: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 22:35:25,854: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:35:25,855: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:35:25,855: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 22:35:25,934: SQL status: CREATE VIEW in 0.08 seconds
2018-01-04 22:35:25,934: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:35:25,934: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 22:35:25,938: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:35:25,938: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 22:35:25,938: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:35:25,938: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 22:35:26,169: SQL status: COMMIT in 0.23 seconds
2018-01-04 22:35:26,170: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574398e10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:35:26,210: 22:35:26 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.37s]
2018-01-04 22:35:26,211: 22:35:26 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 22:35:26,211: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 22:35:26,224: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 22:35:26,227: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 22:35:26,227: Re-using an available connection from the pool.
2018-01-04 22:35:26,227: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:35:26,227: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:35:26,242: SQL status: SELECT in 0.01 seconds
2018-01-04 22:35:26,246: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 22:35:26,248: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:35:26,248: On parsely_incoming_pageviews: BEGIN
2018-01-04 22:35:26,250: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:35:26,250: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:35:26,250: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 22:35:26,330: SQL status: CREATE VIEW in 0.08 seconds
2018-01-04 22:35:26,331: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:35:26,331: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 22:35:26,337: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 22:35:26,337: On parsely_incoming_pageviews: COMMIT
2018-01-04 22:35:26,338: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:35:26,338: On parsely_incoming_pageviews: COMMIT
2018-01-04 22:35:26,512: SQL status: COMMIT in 0.17 seconds
2018-01-04 22:35:26,512: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574398e10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:35:26,540: 22:35:26 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.30s]
2018-01-04 22:35:26,541: 22:35:26 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 22:35:26,541: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 22:35:26,547: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:35:26,548: Re-using an available connection from the pool.
2018-01-04 22:35:26,548: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:35:26,548: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:35:26,562: SQL status: SELECT in 0.01 seconds
2018-01-04 22:35:26,567: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 22:35:26,569: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:35:26,569: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:35:26,583: SQL status: SELECT in 0.01 seconds
2018-01-04 22:35:26,584: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:35:26,584: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:35:26,597: SQL status: SELECT in 0.01 seconds
2018-01-04 22:35:26,600: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:35:26,601: On parsely_pageviews_sessionized: BEGIN
2018-01-04 22:35:26,603: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:35:26,603: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:35:26,603: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:38:48,383: SQL status: SELECT in 201.78 seconds
2018-01-04 22:38:48,383: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:38:48,383: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 22:38:48,677: SQL status: SELECT in 0.29 seconds
2018-01-04 22:38:48,678: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:38:48,678: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:38:48,795: SQL status: SELECT in 0.12 seconds
2018-01-04 22:38:48,797: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:38:48,797: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:38:48,912: SQL status: SELECT in 0.11 seconds
2018-01-04 22:38:48,916: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 22:38:48,917: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:38:48,917: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 22:38:51,921: SQL status: INSERT 0 109589 in 3.00 seconds
2018-01-04 22:38:51,922: On parsely_pageviews_sessionized: COMMIT
2018-01-04 22:38:51,922: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:38:51,922: On parsely_pageviews_sessionized: COMMIT
2018-01-04 22:38:53,230: SQL status: COMMIT in 1.31 seconds
2018-01-04 22:38:53,231: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f85743fedd0>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:38:53,287: 22:38:53 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 109589 in 206.69s]
2018-01-04 22:38:53,287: 22:38:53 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 22:38:53,288: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 22:38:53,355: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 22:38:53,358: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:38:53,358: Re-using an available connection from the pool.
2018-01-04 22:38:53,358: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:38:53,358: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:38:53,382: SQL status: SELECT in 0.02 seconds
2018-01-04 22:38:53,386: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 22:38:53,388: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:38:53,388: On parsely_videoview_engagedtime: BEGIN
2018-01-04 22:38:53,390: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:38:53,390: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:38:53,390: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 22:38:53,625: SQL status: CREATE VIEW in 0.23 seconds
2018-01-04 22:38:53,626: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:38:53,626: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 22:38:53,630: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:38:53,630: On parsely_videoview_engagedtime: COMMIT
2018-01-04 22:38:53,630: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:38:53,630: On parsely_videoview_engagedtime: COMMIT
2018-01-04 22:38:53,981: SQL status: COMMIT in 0.35 seconds
2018-01-04 22:38:53,981: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574337150>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:38:54,015: 22:38:54 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.69s]
2018-01-04 22:38:54,015: 22:38:54 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 22:38:54,015: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 22:38:54,029: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 22:38:54,031: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:38:54,031: Re-using an available connection from the pool.
2018-01-04 22:38:54,032: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:38:54,032: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:38:54,054: SQL status: SELECT in 0.02 seconds
2018-01-04 22:38:54,055: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:38:54,055: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:38:54,074: SQL status: SELECT in 0.02 seconds
2018-01-04 22:38:54,077: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:38:54,077: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 22:38:54,079: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:38:54,079: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:38:54,079: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:41:17,616: SQL status: SELECT in 143.54 seconds
2018-01-04 22:41:17,616: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:41:17,617: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 22:41:17,788: SQL status: SELECT in 0.17 seconds
2018-01-04 22:41:17,789: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:41:17,789: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:41:17,908: SQL status: SELECT in 0.12 seconds
2018-01-04 22:41:17,909: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:41:17,909: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:41:18,026: SQL status: SELECT in 0.12 seconds
2018-01-04 22:41:18,033: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 22:41:18,035: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:41:18,035: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 22:41:19,137: SQL status: INSERT 0 142 in 1.10 seconds
2018-01-04 22:41:19,138: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 22:41:19,138: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:41:19,138: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 22:41:20,429: SQL status: COMMIT in 1.29 seconds
2018-01-04 22:41:20,429: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574398e10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:41:20,487: 22:41:20 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 142 in 146.41s]
2018-01-04 22:41:20,487: 22:41:20 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 22:41:20,488: Compiling model.parsely.parsely_campaigns
2018-01-04 22:41:20,496: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 22:41:20,496: Re-using an available connection from the pool.
2018-01-04 22:41:20,496: Using redshift connection "parsely_campaigns".
2018-01-04 22:41:20,496: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:41:20,519: SQL status: SELECT in 0.02 seconds
2018-01-04 22:41:20,525: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 22:41:20,526: Using redshift connection "parsely_campaigns".
2018-01-04 22:41:20,526: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:41:20,547: SQL status: SELECT in 0.02 seconds
2018-01-04 22:41:20,547: Using redshift connection "parsely_campaigns".
2018-01-04 22:41:20,547: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:41:20,568: SQL status: SELECT in 0.02 seconds
2018-01-04 22:41:20,569: Using redshift connection "parsely_campaigns".
2018-01-04 22:41:20,570: On parsely_campaigns: BEGIN
2018-01-04 22:41:20,574: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:41:20,574: Using redshift connection "parsely_campaigns".
2018-01-04 22:41:20,574: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:41:21,691: SQL status: SELECT in 1.12 seconds
2018-01-04 22:41:21,692: Using redshift connection "parsely_campaigns".
2018-01-04 22:41:21,692: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 22:41:21,886: SQL status: SELECT in 0.19 seconds
2018-01-04 22:41:21,886: Using redshift connection "parsely_campaigns".
2018-01-04 22:41:21,886: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:41:22,000: SQL status: SELECT in 0.11 seconds
2018-01-04 22:41:22,001: Using redshift connection "parsely_campaigns".
2018-01-04 22:41:22,001: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:41:22,116: SQL status: SELECT in 0.11 seconds
2018-01-04 22:41:22,118: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 22:41:22,119: Using redshift connection "parsely_campaigns".
2018-01-04 22:41:22,119: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 22:41:22,269: SQL status: INSERT 0 390 in 0.15 seconds
2018-01-04 22:41:22,270: On parsely_campaigns: COMMIT
2018-01-04 22:41:22,270: Using redshift connection "parsely_campaigns".
2018-01-04 22:41:22,270: On parsely_campaigns: COMMIT
2018-01-04 22:41:22,794: SQL status: COMMIT in 0.52 seconds
2018-01-04 22:41:22,795: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f85743fe950>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:41:22,823: 22:41:22 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 390 in 2.31s]
2018-01-04 22:41:22,824: Compiling model.parsely.parsely_incoming_users
2018-01-04 22:41:22,831: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 22:41:22,833: 22:41:22 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 22:41:22,833: Compiling model.parsely.parsely_users
2018-01-04 22:41:22,840: Acquiring new redshift connection "parsely_users".
2018-01-04 22:41:22,840: Re-using an available connection from the pool.
2018-01-04 22:41:22,840: Using redshift connection "parsely_users".
2018-01-04 22:41:22,841: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:41:22,863: SQL status: SELECT in 0.02 seconds
2018-01-04 22:41:22,947: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 22:41:22,949: Using redshift connection "parsely_users".
2018-01-04 22:41:22,949: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:41:22,972: SQL status: SELECT in 0.02 seconds
2018-01-04 22:41:22,972: Using redshift connection "parsely_users".
2018-01-04 22:41:22,973: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:41:22,994: SQL status: SELECT in 0.02 seconds
2018-01-04 22:41:22,998: Using redshift connection "parsely_users".
2018-01-04 22:41:22,998: On parsely_users: BEGIN
2018-01-04 22:41:23,000: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:41:23,000: Using redshift connection "parsely_users".
2018-01-04 22:41:23,000: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:41:25,152: SQL status: SELECT in 2.15 seconds
2018-01-04 22:41:25,152: Using redshift connection "parsely_users".
2018-01-04 22:41:25,152: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 22:41:25,357: SQL status: SELECT in 0.20 seconds
2018-01-04 22:41:25,357: Using redshift connection "parsely_users".
2018-01-04 22:41:25,357: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:41:25,472: SQL status: SELECT in 0.11 seconds
2018-01-04 22:41:25,472: Using redshift connection "parsely_users".
2018-01-04 22:41:25,473: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:41:25,586: SQL status: SELECT in 0.11 seconds
2018-01-04 22:41:25,587: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 22:41:25,588: Using redshift connection "parsely_users".
2018-01-04 22:41:25,589: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 22:41:25,872: SQL status: INSERT 0 53549 in 0.28 seconds
2018-01-04 22:41:25,872: On parsely_users: COMMIT
2018-01-04 22:41:25,873: Using redshift connection "parsely_users".
2018-01-04 22:41:25,873: On parsely_users: COMMIT
2018-01-04 22:41:26,435: SQL status: COMMIT in 0.56 seconds
2018-01-04 22:41:26,436: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f85743a1110>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:41:26,471: 22:41:26 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 53549 in 3.60s]
2018-01-04 22:41:26,471: 22:41:26 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 22:41:26,472: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 22:41:26,531: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 22:41:26,533: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:41:26,534: Re-using an available connection from the pool.
2018-01-04 22:41:26,534: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:41:26,534: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:41:26,556: SQL status: SELECT in 0.02 seconds
2018-01-04 22:41:26,560: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 22:41:26,561: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:41:26,561: On parsely_pageview_engagedtime: BEGIN
2018-01-04 22:41:26,564: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:41:26,564: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:41:26,564: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 22:41:26,738: SQL status: CREATE VIEW in 0.17 seconds
2018-01-04 22:41:26,739: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:41:26,739: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 22:41:26,818: SQL status: ALTER TABLE in 0.08 seconds
2018-01-04 22:41:26,818: On parsely_pageview_engagedtime: COMMIT
2018-01-04 22:41:26,818: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:41:26,818: On parsely_pageview_engagedtime: COMMIT
2018-01-04 22:41:27,339: SQL status: COMMIT in 0.52 seconds
2018-01-04 22:41:27,340: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574337810>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:41:27,369: 22:41:27 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.87s]
2018-01-04 22:41:27,370: 22:41:27 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 22:41:27,370: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 22:41:27,379: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 22:41:27,381: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 22:41:27,381: Re-using an available connection from the pool.
2018-01-04 22:41:27,381: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:41:27,381: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:41:27,403: SQL status: SELECT in 0.02 seconds
2018-01-04 22:41:27,407: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 22:41:27,409: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:41:27,409: On parsely_incoming_sessions: BEGIN
2018-01-04 22:41:27,411: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:41:27,411: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:41:27,411: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 22:41:27,561: SQL status: CREATE VIEW in 0.15 seconds
2018-01-04 22:41:27,561: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:41:27,562: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 22:41:27,566: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:41:27,566: On parsely_incoming_sessions: COMMIT
2018-01-04 22:41:27,567: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:41:27,567: On parsely_incoming_sessions: COMMIT
2018-01-04 22:41:27,786: SQL status: COMMIT in 0.22 seconds
2018-01-04 22:41:27,787: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f85743f6e10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:41:27,848: 22:41:27 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.42s]
2018-01-04 22:41:27,849: 22:41:27 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 22:41:27,849: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 22:41:27,866: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 22:41:27,868: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:41:27,868: Re-using an available connection from the pool.
2018-01-04 22:41:27,868: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:41:27,869: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:41:27,890: SQL status: SELECT in 0.02 seconds
2018-01-04 22:41:27,891: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:41:27,891: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:41:27,911: SQL status: SELECT in 0.02 seconds
2018-01-04 22:41:27,914: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:41:27,914: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 22:41:27,916: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:41:27,916: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:41:27,916: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:43:34,213: SQL status: SELECT in 126.30 seconds
2018-01-04 22:43:34,214: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:43:34,214: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 22:43:34,373: SQL status: SELECT in 0.16 seconds
2018-01-04 22:43:34,374: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:43:34,374: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:43:34,489: SQL status: SELECT in 0.11 seconds
2018-01-04 22:43:34,490: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:43:34,490: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:43:34,605: SQL status: SELECT in 0.12 seconds
2018-01-04 22:43:34,611: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 22:43:34,612: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:43:34,612: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 22:43:37,838: SQL status: INSERT 0 109583 in 3.23 seconds
2018-01-04 22:43:37,838: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 22:43:37,838: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:43:37,839: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 22:43:39,849: SQL status: COMMIT in 2.01 seconds
2018-01-04 22:43:39,849: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f85743f6e10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:43:39,910: 22:43:39 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 109583 in 132.00s]
2018-01-04 22:43:39,910: 22:43:39 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 22:43:39,911: Compiling model.parsely.parsely_sessions
2018-01-04 22:43:39,919: Acquiring new redshift connection "parsely_sessions".
2018-01-04 22:43:39,919: Re-using an available connection from the pool.
2018-01-04 22:43:39,919: Using redshift connection "parsely_sessions".
2018-01-04 22:43:39,920: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:43:39,942: SQL status: SELECT in 0.02 seconds
2018-01-04 22:43:39,946: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 22:43:39,948: Using redshift connection "parsely_sessions".
2018-01-04 22:43:39,948: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:43:39,966: SQL status: SELECT in 0.02 seconds
2018-01-04 22:43:39,967: Using redshift connection "parsely_sessions".
2018-01-04 22:43:39,967: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:43:39,986: SQL status: SELECT in 0.02 seconds
2018-01-04 22:43:39,989: Using redshift connection "parsely_sessions".
2018-01-04 22:43:39,989: On parsely_sessions: BEGIN
2018-01-04 22:43:39,991: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:43:39,992: Using redshift connection "parsely_sessions".
2018-01-04 22:43:39,992: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:44:04,107: SQL status: SELECT in 24.12 seconds
2018-01-04 22:44:04,108: Using redshift connection "parsely_sessions".
2018-01-04 22:44:04,108: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 22:44:04,246: SQL status: SELECT in 0.14 seconds
2018-01-04 22:44:04,246: Using redshift connection "parsely_sessions".
2018-01-04 22:44:04,246: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:44:04,361: SQL status: SELECT in 0.11 seconds
2018-01-04 22:44:04,363: Using redshift connection "parsely_sessions".
2018-01-04 22:44:04,363: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:44:04,478: SQL status: SELECT in 0.11 seconds
2018-01-04 22:44:04,482: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 22:44:04,483: Using redshift connection "parsely_sessions".
2018-01-04 22:44:04,483: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 22:44:06,195: SQL status: INSERT 0 89020 in 1.71 seconds
2018-01-04 22:44:06,195: On parsely_sessions: COMMIT
2018-01-04 22:44:06,196: Using redshift connection "parsely_sessions".
2018-01-04 22:44:06,196: On parsely_sessions: COMMIT
2018-01-04 22:44:07,173: SQL status: COMMIT in 0.98 seconds
2018-01-04 22:44:07,173: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f85743fed10>], 'label': '17029b3b-ae74-4973-966b-0aa64b587a0b'}
2018-01-04 22:44:07,220: 22:44:07 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 89020 in 27.26s]
2018-01-04 22:44:07,295: Using redshift connection "master".
2018-01-04 22:44:07,296: On master: BEGIN
2018-01-04 22:44:07,298: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:44:07,298: On master: COMMIT
2018-01-04 22:44:07,298: Using redshift connection "master".
2018-01-04 22:44:07,298: On master: COMMIT
2018-01-04 22:44:07,300: SQL status: COMMIT in 0.00 seconds
2018-01-04 22:44:07,300: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 22:44:07,308: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 22:44:07,309: Using redshift connection "master".
2018-01-04 22:44:07,309: On master:  select 1 
2018-01-04 22:44:07,311: SQL status: SELECT in 0.00 seconds
2018-01-04 22:44:07,312: 22:44:07 | 
2018-01-04 22:44:07,312: 22:44:07 | Finished running 10 view models, 15 incremental models in 946.66s.
2018-01-04 22:44:07,312: 
2018-01-04 22:44:07,312: Completed successfully
2018-01-04 22:44:07,313: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 22:44:07,313: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574449e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574449f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8574430950>], 'label': 'end'}
2018-01-04 22:44:07,353: Flushing usage events
2018-01-04 22:44:13,462: Tracking: tracking
2018-01-04 22:44:13,462: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9ebe10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9ebf90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9ebed0>], 'label': 'start'}
2018-01-04 22:44:13,504: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 22:44:13,527: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 22:44:13,529: Parsing core.sql
2018-01-04 22:44:13,553: Parsing etc/get_custom_schema.sql
2018-01-04 22:44:13,564: Parsing schema_tests/relationships.sql
2018-01-04 22:44:13,569: Parsing schema_tests/accepted_values.sql
2018-01-04 22:44:13,575: Parsing schema_tests/not_null.sql
2018-01-04 22:44:13,578: Parsing schema_tests/unique.sql
2018-01-04 22:44:13,582: Parsing materializations/wrapper.sql
2018-01-04 22:44:13,588: Parsing materializations/archive.sql
2018-01-04 22:44:13,650: Parsing materializations/table.sql
2018-01-04 22:44:13,689: Parsing materializations/helpers.sql
2018-01-04 22:44:13,723: Parsing materializations/bigquery.sql
2018-01-04 22:44:13,753: Parsing materializations/view.sql
2018-01-04 22:44:13,784: Parsing materializations/incremental.sql
2018-01-04 22:44:13,827: Parsing adapters/redshift.sql
2018-01-04 22:44:13,850: Parsing adapters/bigquery.sql
2018-01-04 22:44:13,856: Parsing adapters/postgres.sql
2018-01-04 22:44:13,859: Parsing adapters/common.sql
2018-01-04 22:44:13,884: Parsing model.parsely.parsely_audit
2018-01-04 22:44:13,885: Parsing model.parsely.parsely_video_content
2018-01-04 22:44:13,889: Parsing model.parsely.parsely_post_content
2018-01-04 22:44:13,893: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 22:44:13,896: Parsing model.parsely.parsely_rawdata
2018-01-04 22:44:13,900: Parsing model.parsely.calendar
2018-01-04 22:44:13,902: Parsing model.parsely.parsely_all_events
2018-01-04 22:44:13,915: Acquiring new redshift connection "parsely_all_events".
2018-01-04 22:44:13,915: Opening a new connection (0 currently allocated)
2018-01-04 22:44:13,931: Using redshift connection "parsely_all_events".
2018-01-04 22:44:13,931: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:13,960: SQL status: SELECT in 0.03 seconds
2018-01-04 22:44:13,968: Parsing model.parsely.parsely_event_ids
2018-01-04 22:44:13,971: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 22:44:13,975: Parsing model.parsely.parsely_base_events
2018-01-04 22:44:13,982: Acquiring new redshift connection "parsely_base_events".
2018-01-04 22:44:13,982: Re-using an available connection from the pool.
2018-01-04 22:44:13,982: Using redshift connection "parsely_base_events".
2018-01-04 22:44:13,982: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:14,001: SQL status: SELECT in 0.02 seconds
2018-01-04 22:44:14,002: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 22:44:14,010: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 22:44:14,015: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 22:44:14,018: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 22:44:14,021: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 22:44:14,024: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 22:44:14,032: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 22:44:14,041: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 22:44:14,048: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:44:14,048: Re-using an available connection from the pool.
2018-01-04 22:44:14,048: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:44:14,048: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:14,068: SQL status: SELECT in 0.02 seconds
2018-01-04 22:44:14,069: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 22:44:14,081: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 22:44:14,091: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:44:14,091: Re-using an available connection from the pool.
2018-01-04 22:44:14,091: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:44:14,092: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:14,109: SQL status: SELECT in 0.02 seconds
2018-01-04 22:44:14,111: Parsing model.parsely.parsely_incoming_users
2018-01-04 22:44:14,116: Parsing model.parsely.parsely_users
2018-01-04 22:44:14,126: Acquiring new redshift connection "parsely_users".
2018-01-04 22:44:14,127: Re-using an available connection from the pool.
2018-01-04 22:44:14,127: Using redshift connection "parsely_users".
2018-01-04 22:44:14,127: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:14,145: SQL status: SELECT in 0.02 seconds
2018-01-04 22:44:14,146: Parsing model.parsely.parsely_errors
2018-01-04 22:44:14,151: Parsing model.parsely.parsely_bot_traffic
2018-01-04 22:44:14,156: Parsing model.parsely.parsely_custom_events
2018-01-04 22:44:14,162: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 22:44:14,167: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 22:44:14,170: Parsing model.parsely.parsely_sessions
2018-01-04 22:44:14,177: Acquiring new redshift connection "parsely_sessions".
2018-01-04 22:44:14,177: Re-using an available connection from the pool.
2018-01-04 22:44:14,178: Using redshift connection "parsely_sessions".
2018-01-04 22:44:14,178: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:14,196: SQL status: SELECT in 0.02 seconds
2018-01-04 22:44:14,196: Parsing model.parsely.parsely_campaigns
2018-01-04 22:44:14,201: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 22:44:14,201: Re-using an available connection from the pool.
2018-01-04 22:44:14,202: Using redshift connection "parsely_campaigns".
2018-01-04 22:44:14,202: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:14,220: SQL status: SELECT in 0.02 seconds
2018-01-04 22:44:14,227: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 22:44:14,235: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 22:44:14,250: 
2018-01-04 22:44:14,255: Acquiring new redshift connection "master".
2018-01-04 22:44:14,255: Re-using an available connection from the pool.
2018-01-04 22:44:14,255: Using redshift connection "master".
2018-01-04 22:44:14,256: On master: select distinct nspname from pg_namespace
2018-01-04 22:44:14,258: SQL status: SELECT in 0.00 seconds
2018-01-04 22:44:14,263: Using redshift connection "master".
2018-01-04 22:44:14,263: On master: BEGIN
2018-01-04 22:44:14,265: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:44:14,265: On master: COMMIT
2018-01-04 22:44:14,265: Using redshift connection "master".
2018-01-04 22:44:14,265: On master: COMMIT
2018-01-04 22:44:14,267: SQL status: COMMIT in 0.00 seconds
2018-01-04 22:44:14,278: 22:44:14 | Concurrency: 1 threads (target='dev')
2018-01-04 22:44:14,278: 22:44:14 | 
2018-01-04 22:44:14,278: Using redshift connection "master".
2018-01-04 22:44:14,278: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:14,299: SQL status: SELECT in 0.02 seconds
2018-01-04 22:44:14,462: 22:44:14 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 22:44:14,462: Compiling model.parsely.calendar
2018-01-04 22:44:14,470: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 22:44:14,472: Acquiring new redshift connection "calendar".
2018-01-04 22:44:14,473: Opening a new connection (1 currently allocated)
2018-01-04 22:44:14,486: Using redshift connection "calendar".
2018-01-04 22:44:14,486: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:14,511: SQL status: SELECT in 0.02 seconds
2018-01-04 22:44:14,514: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 22:44:14,515: Using redshift connection "calendar".
2018-01-04 22:44:14,515: On calendar: BEGIN
2018-01-04 22:44:14,517: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:44:14,517: Using redshift connection "calendar".
2018-01-04 22:44:14,517: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 22:44:14,670: SQL status: CREATE VIEW in 0.15 seconds
2018-01-04 22:44:14,670: On calendar: COMMIT
2018-01-04 22:44:14,670: Using redshift connection "calendar".
2018-01-04 22:44:14,671: On calendar: COMMIT
2018-01-04 22:44:15,048: SQL status: COMMIT in 0.38 seconds
2018-01-04 22:44:15,049: Using redshift connection "calendar".
2018-01-04 22:44:15,049: On calendar: BEGIN
2018-01-04 22:44:15,051: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:44:15,051: Using redshift connection "calendar".
2018-01-04 22:44:15,051: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 22:44:15,101: SQL status: DROP VIEW in 0.05 seconds
2018-01-04 22:44:15,101: On calendar: COMMIT
2018-01-04 22:44:15,101: Using redshift connection "calendar".
2018-01-04 22:44:15,102: On calendar: COMMIT
2018-01-04 22:44:15,290: SQL status: COMMIT in 0.19 seconds
2018-01-04 22:44:15,290: Using redshift connection "calendar".
2018-01-04 22:44:15,290: On calendar: BEGIN
2018-01-04 22:44:15,293: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:44:15,293: Using redshift connection "calendar".
2018-01-04 22:44:15,293: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 22:44:15,298: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:44:15,298: On calendar: COMMIT
2018-01-04 22:44:15,298: Using redshift connection "calendar".
2018-01-04 22:44:15,298: On calendar: COMMIT
2018-01-04 22:44:15,756: SQL status: COMMIT in 0.46 seconds
2018-01-04 22:44:15,757: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e8d9bd0>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:44:15,789: 22:44:15 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.29s]
2018-01-04 22:44:15,790: 22:44:15 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 22:44:15,790: Compiling model.parsely.parsely_rawdata
2018-01-04 22:44:15,798: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 22:44:15,799: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 22:44:15,799: Re-using an available connection from the pool.
2018-01-04 22:44:15,799: Using redshift connection "parsely_rawdata".
2018-01-04 22:44:15,799: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:15,820: SQL status: SELECT in 0.02 seconds
2018-01-04 22:44:15,821: Using redshift connection "parsely_rawdata".
2018-01-04 22:44:15,821: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:44:15,831: SQL status: SELECT in 0.01 seconds
2018-01-04 22:44:15,833: Using redshift connection "parsely_rawdata".
2018-01-04 22:44:15,833: On parsely_rawdata: BEGIN
2018-01-04 22:44:15,835: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:44:15,835: Using redshift connection "parsely_rawdata".
2018-01-04 22:44:15,835: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:44:44,657: SQL status: SELECT in 28.82 seconds
2018-01-04 22:44:44,657: Using redshift connection "parsely_rawdata".
2018-01-04 22:44:44,657: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 22:44:44,909: SQL status: SELECT in 0.25 seconds
2018-01-04 22:44:44,911: Using redshift connection "parsely_rawdata".
2018-01-04 22:44:44,911: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:44:45,017: SQL status: SELECT in 0.11 seconds
2018-01-04 22:44:45,018: Using redshift connection "parsely_rawdata".
2018-01-04 22:44:45,018: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:44:45,123: SQL status: SELECT in 0.10 seconds
2018-01-04 22:44:45,131: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 22:44:45,133: Using redshift connection "parsely_rawdata".
2018-01-04 22:44:45,133: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 22:45:18,336: SQL status: INSERT 0 1034700 in 33.20 seconds
2018-01-04 22:45:18,336: On parsely_rawdata: COMMIT
2018-01-04 22:45:18,336: Using redshift connection "parsely_rawdata".
2018-01-04 22:45:18,336: On parsely_rawdata: COMMIT
2018-01-04 22:45:20,530: SQL status: COMMIT in 2.19 seconds
2018-01-04 22:45:20,530: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e943b10>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:45:20,614: 22:45:20 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1034700 in 64.74s]
2018-01-04 22:45:20,614: 22:45:20 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 22:45:20,614: Compiling model.parsely.parsely_all_events
2018-01-04 22:45:20,626: Acquiring new redshift connection "parsely_all_events".
2018-01-04 22:45:20,626: Re-using an available connection from the pool.
2018-01-04 22:45:20,626: Using redshift connection "parsely_all_events".
2018-01-04 22:45:20,626: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:45:20,641: SQL status: SELECT in 0.01 seconds
2018-01-04 22:45:20,656: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 22:45:20,659: Using redshift connection "parsely_all_events".
2018-01-04 22:45:20,659: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:45:20,672: SQL status: SELECT in 0.01 seconds
2018-01-04 22:45:20,673: Using redshift connection "parsely_all_events".
2018-01-04 22:45:20,673: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:45:20,686: SQL status: SELECT in 0.01 seconds
2018-01-04 22:45:20,688: Using redshift connection "parsely_all_events".
2018-01-04 22:45:20,689: On parsely_all_events: BEGIN
2018-01-04 22:45:20,690: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:45:20,691: Using redshift connection "parsely_all_events".
2018-01-04 22:45:20,691: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:47:22,751: SQL status: SELECT in 122.06 seconds
2018-01-04 22:47:22,751: Using redshift connection "parsely_all_events".
2018-01-04 22:47:22,751: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 22:47:22,889: SQL status: SELECT in 0.14 seconds
2018-01-04 22:47:22,889: Using redshift connection "parsely_all_events".
2018-01-04 22:47:22,889: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:47:22,996: SQL status: SELECT in 0.11 seconds
2018-01-04 22:47:22,997: Using redshift connection "parsely_all_events".
2018-01-04 22:47:22,998: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:47:23,103: SQL status: SELECT in 0.11 seconds
2018-01-04 22:47:23,108: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 22:47:23,109: Using redshift connection "parsely_all_events".
2018-01-04 22:47:23,109: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 22:47:40,327: SQL status: INSERT 0 919208 in 17.22 seconds
2018-01-04 22:47:40,327: On parsely_all_events: COMMIT
2018-01-04 22:47:40,327: Using redshift connection "parsely_all_events".
2018-01-04 22:47:40,327: On parsely_all_events: COMMIT
2018-01-04 22:47:43,311: SQL status: COMMIT in 2.98 seconds
2018-01-04 22:47:43,311: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e998810>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:47:43,439: 22:47:43 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 919208 in 142.70s]
2018-01-04 22:47:43,440: 22:47:43 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 22:47:43,440: Compiling model.parsely.parsely_bot_traffic
2018-01-04 22:47:43,449: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 22:47:43,451: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 22:47:43,451: Re-using an available connection from the pool.
2018-01-04 22:47:43,451: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:47:43,451: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:47:43,467: SQL status: SELECT in 0.02 seconds
2018-01-04 22:47:43,468: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:47:43,468: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:47:43,482: SQL status: SELECT in 0.01 seconds
2018-01-04 22:47:43,485: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:47:43,485: On parsely_bot_traffic: BEGIN
2018-01-04 22:47:43,487: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:47:43,487: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:47:43,487: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:48:47,652: SQL status: SELECT in 64.16 seconds
2018-01-04 22:48:47,652: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:48:47,653: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 22:48:48,070: SQL status: SELECT in 0.42 seconds
2018-01-04 22:48:48,071: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:48:48,071: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:48:48,660: SQL status: SELECT in 0.59 seconds
2018-01-04 22:48:48,662: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:48:48,662: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:48:49,121: SQL status: SELECT in 0.46 seconds
2018-01-04 22:48:49,126: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 22:48:49,127: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:48:49,127: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 22:48:51,210: SQL status: INSERT 0 4 in 2.08 seconds
2018-01-04 22:48:51,211: On parsely_bot_traffic: COMMIT
2018-01-04 22:48:51,211: Using redshift connection "parsely_bot_traffic".
2018-01-04 22:48:51,211: On parsely_bot_traffic: COMMIT
2018-01-04 22:48:53,147: SQL status: COMMIT in 1.94 seconds
2018-01-04 22:48:53,148: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e8d9f50>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:48:53,214: 22:48:53 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 69.71s]
2018-01-04 22:48:53,215: 22:48:53 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 22:48:53,215: Compiling model.parsely.parsely_custom_events
2018-01-04 22:48:53,235: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 22:48:53,239: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 22:48:53,239: Re-using an available connection from the pool.
2018-01-04 22:48:53,239: Using redshift connection "parsely_custom_events".
2018-01-04 22:48:53,240: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:48:53,288: SQL status: SELECT in 0.05 seconds
2018-01-04 22:48:53,289: Using redshift connection "parsely_custom_events".
2018-01-04 22:48:53,289: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:48:53,307: SQL status: SELECT in 0.02 seconds
2018-01-04 22:48:53,310: Using redshift connection "parsely_custom_events".
2018-01-04 22:48:53,311: On parsely_custom_events: BEGIN
2018-01-04 22:48:53,316: SQL status: BEGIN in 0.01 seconds
2018-01-04 22:48:53,316: Using redshift connection "parsely_custom_events".
2018-01-04 22:48:53,316: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:50:14,830: SQL status: SELECT in 81.51 seconds
2018-01-04 22:50:14,830: Using redshift connection "parsely_custom_events".
2018-01-04 22:50:14,830: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 22:50:14,975: SQL status: SELECT in 0.14 seconds
2018-01-04 22:50:14,976: Using redshift connection "parsely_custom_events".
2018-01-04 22:50:14,976: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:50:15,085: SQL status: SELECT in 0.11 seconds
2018-01-04 22:50:15,087: Using redshift connection "parsely_custom_events".
2018-01-04 22:50:15,087: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:50:15,193: SQL status: SELECT in 0.11 seconds
2018-01-04 22:50:15,197: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 22:50:15,199: Using redshift connection "parsely_custom_events".
2018-01-04 22:50:15,199: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 22:50:15,461: SQL status: INSERT 0 0 in 0.26 seconds
2018-01-04 22:50:15,462: On parsely_custom_events: COMMIT
2018-01-04 22:50:15,462: Using redshift connection "parsely_custom_events".
2018-01-04 22:50:15,462: On parsely_custom_events: COMMIT
2018-01-04 22:50:15,890: SQL status: COMMIT in 0.43 seconds
2018-01-04 22:50:15,891: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9e52d0>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:50:15,941: 22:50:15 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 82.68s]
2018-01-04 22:50:15,941: 22:50:15 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 22:50:15,942: Compiling model.parsely.parsely_errors
2018-01-04 22:50:15,955: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 22:50:15,957: Acquiring new redshift connection "parsely_errors".
2018-01-04 22:50:15,957: Re-using an available connection from the pool.
2018-01-04 22:50:15,957: Using redshift connection "parsely_errors".
2018-01-04 22:50:15,957: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:50:15,971: SQL status: SELECT in 0.01 seconds
2018-01-04 22:50:15,972: Using redshift connection "parsely_errors".
2018-01-04 22:50:15,972: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:50:15,985: SQL status: SELECT in 0.01 seconds
2018-01-04 22:50:15,988: Using redshift connection "parsely_errors".
2018-01-04 22:50:15,988: On parsely_errors: BEGIN
2018-01-04 22:50:15,990: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:50:15,990: Using redshift connection "parsely_errors".
2018-01-04 22:50:15,990: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:51:05,240: SQL status: SELECT in 49.25 seconds
2018-01-04 22:51:05,241: Using redshift connection "parsely_errors".
2018-01-04 22:51:05,241: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 22:51:05,404: SQL status: SELECT in 0.16 seconds
2018-01-04 22:51:05,405: Using redshift connection "parsely_errors".
2018-01-04 22:51:05,405: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:51:05,518: SQL status: SELECT in 0.11 seconds
2018-01-04 22:51:05,520: Using redshift connection "parsely_errors".
2018-01-04 22:51:05,520: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:51:05,631: SQL status: SELECT in 0.11 seconds
2018-01-04 22:51:05,636: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 22:51:05,637: Using redshift connection "parsely_errors".
2018-01-04 22:51:05,637: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 22:51:06,309: SQL status: INSERT 0 2 in 0.67 seconds
2018-01-04 22:51:06,310: On parsely_errors: COMMIT
2018-01-04 22:51:06,310: Using redshift connection "parsely_errors".
2018-01-04 22:51:06,310: On parsely_errors: COMMIT
2018-01-04 22:51:07,411: SQL status: COMMIT in 1.10 seconds
2018-01-04 22:51:07,413: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9e52d0>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:51:07,452: 22:51:07 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 51.47s]
2018-01-04 22:51:07,452: 22:51:07 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 22:51:07,453: Compiling model.parsely.parsely_base_events
2018-01-04 22:51:07,460: Acquiring new redshift connection "parsely_base_events".
2018-01-04 22:51:07,460: Re-using an available connection from the pool.
2018-01-04 22:51:07,460: Using redshift connection "parsely_base_events".
2018-01-04 22:51:07,460: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:07,475: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:07,482: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 22:51:07,484: Using redshift connection "parsely_base_events".
2018-01-04 22:51:07,484: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:07,498: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:07,501: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 22:51:07,502: Using redshift connection "parsely_base_events".
2018-01-04 22:51:07,502: On parsely_base_events: BEGIN
2018-01-04 22:51:07,504: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:51:07,505: Using redshift connection "parsely_base_events".
2018-01-04 22:51:07,505: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 22:51:07,636: SQL status: CREATE VIEW in 0.13 seconds
2018-01-04 22:51:07,637: On parsely_base_events: COMMIT
2018-01-04 22:51:07,637: Using redshift connection "parsely_base_events".
2018-01-04 22:51:07,637: On parsely_base_events: COMMIT
2018-01-04 22:51:07,845: SQL status: COMMIT in 0.21 seconds
2018-01-04 22:51:07,845: Using redshift connection "parsely_base_events".
2018-01-04 22:51:07,845: On parsely_base_events: BEGIN
2018-01-04 22:51:07,847: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:51:07,847: Using redshift connection "parsely_base_events".
2018-01-04 22:51:07,847: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 22:51:09,581: SQL status: DROP VIEW in 1.73 seconds
2018-01-04 22:51:09,582: On parsely_base_events: COMMIT
2018-01-04 22:51:09,582: Using redshift connection "parsely_base_events".
2018-01-04 22:51:09,582: On parsely_base_events: COMMIT
2018-01-04 22:51:09,952: SQL status: COMMIT in 0.37 seconds
2018-01-04 22:51:09,953: Using redshift connection "parsely_base_events".
2018-01-04 22:51:09,953: On parsely_base_events: BEGIN
2018-01-04 22:51:09,956: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:51:09,956: Using redshift connection "parsely_base_events".
2018-01-04 22:51:09,956: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 22:51:09,962: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 22:51:09,962: On parsely_base_events: COMMIT
2018-01-04 22:51:09,962: Using redshift connection "parsely_base_events".
2018-01-04 22:51:09,962: On parsely_base_events: COMMIT
2018-01-04 22:51:10,228: SQL status: COMMIT in 0.27 seconds
2018-01-04 22:51:10,228: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e998810>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:51:10,273: 22:51:10 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 2.78s]
2018-01-04 22:51:10,274: 22:51:10 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 22:51:10,274: Compiling model.parsely.parsely_event_ids
2018-01-04 22:51:10,284: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 22:51:10,287: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 22:51:10,288: Re-using an available connection from the pool.
2018-01-04 22:51:10,288: Using redshift connection "parsely_event_ids".
2018-01-04 22:51:10,288: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:10,303: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:10,303: Using redshift connection "parsely_event_ids".
2018-01-04 22:51:10,304: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:10,317: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:10,318: Using redshift connection "parsely_event_ids".
2018-01-04 22:51:10,318: On parsely_event_ids: BEGIN
2018-01-04 22:51:10,320: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:51:10,321: Using redshift connection "parsely_event_ids".
2018-01-04 22:51:10,321: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:51:11,710: SQL status: SELECT in 1.39 seconds
2018-01-04 22:51:11,711: Using redshift connection "parsely_event_ids".
2018-01-04 22:51:11,711: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 22:51:11,865: SQL status: SELECT in 0.15 seconds
2018-01-04 22:51:11,865: Using redshift connection "parsely_event_ids".
2018-01-04 22:51:11,865: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:51:11,973: SQL status: SELECT in 0.11 seconds
2018-01-04 22:51:11,973: Using redshift connection "parsely_event_ids".
2018-01-04 22:51:11,973: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:51:12,076: SQL status: SELECT in 0.10 seconds
2018-01-04 22:51:12,077: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 22:51:12,079: Using redshift connection "parsely_event_ids".
2018-01-04 22:51:12,079: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 22:51:13,562: SQL status: INSERT 0 919204 in 1.48 seconds
2018-01-04 22:51:13,563: On parsely_event_ids: COMMIT
2018-01-04 22:51:13,563: Using redshift connection "parsely_event_ids".
2018-01-04 22:51:13,563: On parsely_event_ids: COMMIT
2018-01-04 22:51:14,793: SQL status: COMMIT in 1.23 seconds
2018-01-04 22:51:14,793: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e8ebc10>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:51:14,826: 22:51:14 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 919204 in 4.52s]
2018-01-04 22:51:14,826: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 22:51:14,834: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 22:51:14,835: 22:51:14 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 22:51:14,835: Compiling model.parsely.parsely_post_content
2018-01-04 22:51:14,844: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 22:51:14,845: Acquiring new redshift connection "parsely_post_content".
2018-01-04 22:51:14,845: Re-using an available connection from the pool.
2018-01-04 22:51:14,845: Using redshift connection "parsely_post_content".
2018-01-04 22:51:14,846: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:14,860: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:14,861: Using redshift connection "parsely_post_content".
2018-01-04 22:51:14,861: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:14,879: SQL status: SELECT in 0.02 seconds
2018-01-04 22:51:14,881: Using redshift connection "parsely_post_content".
2018-01-04 22:51:14,881: On parsely_post_content: BEGIN
2018-01-04 22:51:14,884: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:51:14,885: Using redshift connection "parsely_post_content".
2018-01-04 22:51:14,885: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:51:25,234: SQL status: SELECT in 10.35 seconds
2018-01-04 22:51:25,234: Using redshift connection "parsely_post_content".
2018-01-04 22:51:25,234: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 22:51:25,437: SQL status: SELECT in 0.20 seconds
2018-01-04 22:51:25,437: Using redshift connection "parsely_post_content".
2018-01-04 22:51:25,437: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:51:25,544: SQL status: SELECT in 0.11 seconds
2018-01-04 22:51:25,545: Using redshift connection "parsely_post_content".
2018-01-04 22:51:25,545: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:51:25,649: SQL status: SELECT in 0.10 seconds
2018-01-04 22:51:25,652: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 22:51:25,653: Using redshift connection "parsely_post_content".
2018-01-04 22:51:25,653: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 22:51:26,011: SQL status: INSERT 0 887 in 0.36 seconds
2018-01-04 22:51:26,012: On parsely_post_content: COMMIT
2018-01-04 22:51:26,012: Using redshift connection "parsely_post_content".
2018-01-04 22:51:26,012: On parsely_post_content: COMMIT
2018-01-04 22:51:27,114: SQL status: COMMIT in 1.10 seconds
2018-01-04 22:51:27,114: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e8eba10>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:51:27,173: 22:51:27 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 887 in 12.28s]
2018-01-04 22:51:27,174: 22:51:27 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 22:51:27,174: Compiling model.parsely.parsely_video_content
2018-01-04 22:51:27,184: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 22:51:27,186: Acquiring new redshift connection "parsely_video_content".
2018-01-04 22:51:27,186: Re-using an available connection from the pool.
2018-01-04 22:51:27,186: Using redshift connection "parsely_video_content".
2018-01-04 22:51:27,187: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:27,202: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:27,203: Using redshift connection "parsely_video_content".
2018-01-04 22:51:27,203: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:27,217: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:27,219: Using redshift connection "parsely_video_content".
2018-01-04 22:51:27,219: On parsely_video_content: BEGIN
2018-01-04 22:51:27,221: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:51:27,221: Using redshift connection "parsely_video_content".
2018-01-04 22:51:27,221: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:51:36,594: SQL status: SELECT in 9.37 seconds
2018-01-04 22:51:36,594: Using redshift connection "parsely_video_content".
2018-01-04 22:51:36,594: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 22:51:36,822: SQL status: SELECT in 0.23 seconds
2018-01-04 22:51:36,823: Using redshift connection "parsely_video_content".
2018-01-04 22:51:36,823: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:51:36,931: SQL status: SELECT in 0.11 seconds
2018-01-04 22:51:36,932: Using redshift connection "parsely_video_content".
2018-01-04 22:51:36,932: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:51:37,037: SQL status: SELECT in 0.10 seconds
2018-01-04 22:51:37,040: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 22:51:37,041: Using redshift connection "parsely_video_content".
2018-01-04 22:51:37,041: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 22:51:37,423: SQL status: INSERT 0 469 in 0.38 seconds
2018-01-04 22:51:37,425: On parsely_video_content: COMMIT
2018-01-04 22:51:37,429: Using redshift connection "parsely_video_content".
2018-01-04 22:51:37,429: On parsely_video_content: COMMIT
2018-01-04 22:51:37,892: SQL status: COMMIT in 0.46 seconds
2018-01-04 22:51:37,892: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e943a50>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:51:37,933: 22:51:37 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 469 in 10.72s]
2018-01-04 22:51:37,933: 22:51:37 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 22:51:37,934: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 22:51:37,946: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 22:51:37,948: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 22:51:37,948: Re-using an available connection from the pool.
2018-01-04 22:51:37,948: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:51:37,948: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:37,963: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:37,966: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 22:51:37,968: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:51:37,968: On parsely_entry_exit_urls: BEGIN
2018-01-04 22:51:37,970: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:51:37,970: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:51:37,970: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 22:51:38,212: SQL status: CREATE VIEW in 0.24 seconds
2018-01-04 22:51:38,213: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:51:38,213: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 22:51:38,216: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:51:38,216: On parsely_entry_exit_urls: COMMIT
2018-01-04 22:51:38,216: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 22:51:38,216: On parsely_entry_exit_urls: COMMIT
2018-01-04 22:51:38,775: SQL status: COMMIT in 0.56 seconds
2018-01-04 22:51:38,776: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e943a50>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:51:38,812: 22:51:38 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.84s]
2018-01-04 22:51:38,813: 22:51:38 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 22:51:38,813: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 22:51:38,830: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 22:51:38,832: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 22:51:38,832: Re-using an available connection from the pool.
2018-01-04 22:51:38,832: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:51:38,833: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:38,848: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:38,854: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 22:51:38,857: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:51:38,857: On parsely_incoming_videoviews: BEGIN
2018-01-04 22:51:38,859: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:51:38,859: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:51:38,859: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 22:51:38,969: SQL status: CREATE VIEW in 0.11 seconds
2018-01-04 22:51:38,969: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:51:38,969: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 22:51:39,006: SQL status: ALTER TABLE in 0.04 seconds
2018-01-04 22:51:39,007: On parsely_incoming_videoviews: COMMIT
2018-01-04 22:51:39,007: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 22:51:39,007: On parsely_incoming_videoviews: COMMIT
2018-01-04 22:51:39,418: SQL status: COMMIT in 0.41 seconds
2018-01-04 22:51:39,418: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e943a50>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:51:39,456: 22:51:39 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.61s]
2018-01-04 22:51:39,457: 22:51:39 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 22:51:39,457: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 22:51:39,466: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:51:39,466: Re-using an available connection from the pool.
2018-01-04 22:51:39,466: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:51:39,466: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:39,481: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:39,487: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 22:51:39,489: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:51:39,489: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:39,503: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:39,504: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:51:39,504: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:51:39,518: SQL status: SELECT in 0.01 seconds
2018-01-04 22:51:39,521: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:51:39,521: On parsely_videoviews_sessionized: BEGIN
2018-01-04 22:51:39,523: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:51:39,523: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:51:39,523: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:52:40,779: SQL status: SELECT in 61.26 seconds
2018-01-04 22:52:40,779: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:52:40,779: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 22:52:40,944: SQL status: SELECT in 0.16 seconds
2018-01-04 22:52:40,945: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:52:40,945: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:52:41,058: SQL status: SELECT in 0.11 seconds
2018-01-04 22:52:41,058: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:52:41,059: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:52:41,173: SQL status: SELECT in 0.11 seconds
2018-01-04 22:52:41,178: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 22:52:41,179: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:52:41,179: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 22:52:42,325: SQL status: INSERT 0 143 in 1.15 seconds
2018-01-04 22:52:42,326: On parsely_videoviews_sessionized: COMMIT
2018-01-04 22:52:42,326: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 22:52:42,326: On parsely_videoviews_sessionized: COMMIT
2018-01-04 22:52:43,448: SQL status: COMMIT in 1.12 seconds
2018-01-04 22:52:43,449: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9a0dd0>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:52:43,498: 22:52:43 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 143 in 63.99s]
2018-01-04 22:52:43,499: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 22:52:43,548: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 22:52:43,549: 22:52:43 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 22:52:43,550: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 22:52:43,578: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 22:52:43,579: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:52:43,580: Re-using an available connection from the pool.
2018-01-04 22:52:43,580: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:52:43,580: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:52:43,594: SQL status: SELECT in 0.01 seconds
2018-01-04 22:52:43,597: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 22:52:43,598: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:52:43,599: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 22:52:43,601: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:52:43,601: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:52:43,601: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 22:52:43,685: SQL status: CREATE VIEW in 0.08 seconds
2018-01-04 22:52:43,686: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:52:43,686: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 22:52:43,689: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:52:43,689: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 22:52:43,689: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 22:52:43,690: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 22:52:43,901: SQL status: COMMIT in 0.21 seconds
2018-01-04 22:52:43,901: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e8ebad0>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:52:43,932: 22:52:43 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.35s]
2018-01-04 22:52:43,933: 22:52:43 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 22:52:43,933: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 22:52:43,971: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 22:52:43,973: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:52:43,973: Re-using an available connection from the pool.
2018-01-04 22:52:43,973: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:52:43,973: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:52:43,987: SQL status: SELECT in 0.01 seconds
2018-01-04 22:52:43,992: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 22:52:43,993: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:52:43,994: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 22:52:43,996: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:52:43,996: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:52:43,996: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 22:52:44,168: SQL status: CREATE VIEW in 0.17 seconds
2018-01-04 22:52:44,169: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:52:44,169: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 22:52:44,173: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:52:44,173: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 22:52:44,173: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 22:52:44,174: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 22:52:44,551: SQL status: COMMIT in 0.38 seconds
2018-01-04 22:52:44,551: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9d2990>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:52:44,605: 22:52:44 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.62s]
2018-01-04 22:52:44,605: 22:52:44 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 22:52:44,606: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 22:52:44,621: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 22:52:44,624: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 22:52:44,624: Re-using an available connection from the pool.
2018-01-04 22:52:44,624: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:52:44,624: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:52:44,638: SQL status: SELECT in 0.01 seconds
2018-01-04 22:52:44,643: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 22:52:44,644: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:52:44,644: On parsely_incoming_pageviews: BEGIN
2018-01-04 22:52:44,648: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:52:44,648: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:52:44,648: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 22:52:44,744: SQL status: CREATE VIEW in 0.10 seconds
2018-01-04 22:52:44,745: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:52:44,745: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 22:52:44,750: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:52:44,750: On parsely_incoming_pageviews: COMMIT
2018-01-04 22:52:44,750: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 22:52:44,750: On parsely_incoming_pageviews: COMMIT
2018-01-04 22:52:44,943: SQL status: COMMIT in 0.19 seconds
2018-01-04 22:52:44,944: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9d2990>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:52:44,974: 22:52:44 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.34s]
2018-01-04 22:52:44,974: 22:52:44 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 22:52:44,975: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 22:52:44,981: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:52:44,981: Re-using an available connection from the pool.
2018-01-04 22:52:44,981: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:52:44,981: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:52:44,995: SQL status: SELECT in 0.01 seconds
2018-01-04 22:52:45,003: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 22:52:45,006: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:52:45,006: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:52:45,020: SQL status: SELECT in 0.01 seconds
2018-01-04 22:52:45,021: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:52:45,021: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:52:45,035: SQL status: SELECT in 0.01 seconds
2018-01-04 22:52:45,039: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:52:45,039: On parsely_pageviews_sessionized: BEGIN
2018-01-04 22:52:45,041: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:52:45,041: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:52:45,042: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:56:20,070: SQL status: SELECT in 215.03 seconds
2018-01-04 22:56:20,070: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:56:20,070: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 22:56:20,323: SQL status: SELECT in 0.25 seconds
2018-01-04 22:56:20,323: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:56:20,323: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:56:20,439: SQL status: SELECT in 0.12 seconds
2018-01-04 22:56:20,441: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:56:20,441: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:56:20,556: SQL status: SELECT in 0.12 seconds
2018-01-04 22:56:20,559: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 22:56:20,561: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:56:20,561: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 22:56:23,783: SQL status: INSERT 0 109724 in 3.22 seconds
2018-01-04 22:56:23,783: On parsely_pageviews_sessionized: COMMIT
2018-01-04 22:56:23,783: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 22:56:23,784: On parsely_pageviews_sessionized: COMMIT
2018-01-04 22:56:25,078: SQL status: COMMIT in 1.29 seconds
2018-01-04 22:56:25,079: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9e5210>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:56:25,142: 22:56:25 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 109724 in 220.10s]
2018-01-04 22:56:25,142: 22:56:25 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 22:56:25,143: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 22:56:25,184: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 22:56:25,186: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:56:25,186: Re-using an available connection from the pool.
2018-01-04 22:56:25,186: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:56:25,186: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:56:25,210: SQL status: SELECT in 0.02 seconds
2018-01-04 22:56:25,212: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 22:56:25,214: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:56:25,214: On parsely_videoview_engagedtime: BEGIN
2018-01-04 22:56:25,216: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:56:25,216: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:56:25,216: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 22:56:25,309: SQL status: CREATE VIEW in 0.09 seconds
2018-01-04 22:56:25,309: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:56:25,309: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 22:56:25,313: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:56:25,314: On parsely_videoview_engagedtime: COMMIT
2018-01-04 22:56:25,314: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 22:56:25,314: On parsely_videoview_engagedtime: COMMIT
2018-01-04 22:56:25,537: SQL status: COMMIT in 0.22 seconds
2018-01-04 22:56:25,537: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9e5210>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:56:25,582: 22:56:25 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.39s]
2018-01-04 22:56:25,583: 22:56:25 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 22:56:25,583: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 22:56:25,592: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 22:56:25,593: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:56:25,593: Re-using an available connection from the pool.
2018-01-04 22:56:25,593: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:56:25,593: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:56:25,615: SQL status: SELECT in 0.02 seconds
2018-01-04 22:56:25,616: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:56:25,616: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:56:25,637: SQL status: SELECT in 0.02 seconds
2018-01-04 22:56:25,640: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:56:25,640: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 22:56:25,642: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:56:25,642: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:56:25,642: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:59:03,204: SQL status: SELECT in 157.56 seconds
2018-01-04 22:59:03,204: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:59:03,204: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 22:59:03,413: SQL status: SELECT in 0.21 seconds
2018-01-04 22:59:03,413: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:59:03,413: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:59:03,530: SQL status: SELECT in 0.12 seconds
2018-01-04 22:59:03,531: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:59:03,531: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:59:03,646: SQL status: SELECT in 0.11 seconds
2018-01-04 22:59:03,650: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 22:59:03,651: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:59:03,651: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 22:59:04,746: SQL status: INSERT 0 142 in 1.10 seconds
2018-01-04 22:59:04,746: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 22:59:04,747: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 22:59:04,747: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 22:59:06,018: SQL status: COMMIT in 1.27 seconds
2018-01-04 22:59:06,019: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e943ed0>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:59:06,090: 22:59:06 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 142 in 160.44s]
2018-01-04 22:59:06,090: 22:59:06 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 22:59:06,090: Compiling model.parsely.parsely_campaigns
2018-01-04 22:59:06,096: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 22:59:06,096: Re-using an available connection from the pool.
2018-01-04 22:59:06,096: Using redshift connection "parsely_campaigns".
2018-01-04 22:59:06,097: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:59:06,118: SQL status: SELECT in 0.02 seconds
2018-01-04 22:59:06,121: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 22:59:06,123: Using redshift connection "parsely_campaigns".
2018-01-04 22:59:06,123: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:59:06,141: SQL status: SELECT in 0.02 seconds
2018-01-04 22:59:06,142: Using redshift connection "parsely_campaigns".
2018-01-04 22:59:06,142: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:59:06,160: SQL status: SELECT in 0.02 seconds
2018-01-04 22:59:06,161: Using redshift connection "parsely_campaigns".
2018-01-04 22:59:06,161: On parsely_campaigns: BEGIN
2018-01-04 22:59:06,163: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:59:06,163: Using redshift connection "parsely_campaigns".
2018-01-04 22:59:06,163: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:59:07,155: SQL status: SELECT in 0.99 seconds
2018-01-04 22:59:07,155: Using redshift connection "parsely_campaigns".
2018-01-04 22:59:07,155: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 22:59:07,303: SQL status: SELECT in 0.15 seconds
2018-01-04 22:59:07,303: Using redshift connection "parsely_campaigns".
2018-01-04 22:59:07,303: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:59:07,414: SQL status: SELECT in 0.11 seconds
2018-01-04 22:59:07,415: Using redshift connection "parsely_campaigns".
2018-01-04 22:59:07,415: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:59:07,527: SQL status: SELECT in 0.11 seconds
2018-01-04 22:59:07,528: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 22:59:07,529: Using redshift connection "parsely_campaigns".
2018-01-04 22:59:07,529: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 22:59:07,674: SQL status: INSERT 0 390 in 0.14 seconds
2018-01-04 22:59:07,674: On parsely_campaigns: COMMIT
2018-01-04 22:59:07,674: Using redshift connection "parsely_campaigns".
2018-01-04 22:59:07,674: On parsely_campaigns: COMMIT
2018-01-04 22:59:08,352: SQL status: COMMIT in 0.68 seconds
2018-01-04 22:59:08,353: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e943ed0>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:59:08,386: 22:59:08 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 390 in 2.26s]
2018-01-04 22:59:08,386: Compiling model.parsely.parsely_incoming_users
2018-01-04 22:59:08,395: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 22:59:08,397: 22:59:08 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 22:59:08,397: Compiling model.parsely.parsely_users
2018-01-04 22:59:08,402: Acquiring new redshift connection "parsely_users".
2018-01-04 22:59:08,403: Re-using an available connection from the pool.
2018-01-04 22:59:08,403: Using redshift connection "parsely_users".
2018-01-04 22:59:08,403: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:59:08,424: SQL status: SELECT in 0.02 seconds
2018-01-04 22:59:08,464: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 22:59:08,466: Using redshift connection "parsely_users".
2018-01-04 22:59:08,466: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:59:08,485: SQL status: SELECT in 0.02 seconds
2018-01-04 22:59:08,485: Using redshift connection "parsely_users".
2018-01-04 22:59:08,486: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:59:08,504: SQL status: SELECT in 0.02 seconds
2018-01-04 22:59:08,506: Using redshift connection "parsely_users".
2018-01-04 22:59:08,506: On parsely_users: BEGIN
2018-01-04 22:59:08,508: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:59:08,508: Using redshift connection "parsely_users".
2018-01-04 22:59:08,508: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 22:59:10,701: SQL status: SELECT in 2.19 seconds
2018-01-04 22:59:10,701: Using redshift connection "parsely_users".
2018-01-04 22:59:10,702: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 22:59:10,895: SQL status: SELECT in 0.19 seconds
2018-01-04 22:59:10,895: Using redshift connection "parsely_users".
2018-01-04 22:59:10,895: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:59:11,007: SQL status: SELECT in 0.11 seconds
2018-01-04 22:59:11,007: Using redshift connection "parsely_users".
2018-01-04 22:59:11,007: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 22:59:11,119: SQL status: SELECT in 0.11 seconds
2018-01-04 22:59:11,120: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 22:59:11,122: Using redshift connection "parsely_users".
2018-01-04 22:59:11,122: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 22:59:11,422: SQL status: INSERT 0 53613 in 0.30 seconds
2018-01-04 22:59:11,423: On parsely_users: COMMIT
2018-01-04 22:59:11,423: Using redshift connection "parsely_users".
2018-01-04 22:59:11,423: On parsely_users: COMMIT
2018-01-04 22:59:11,900: SQL status: COMMIT in 0.48 seconds
2018-01-04 22:59:11,901: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e8cf650>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:59:11,932: 22:59:11 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 53613 in 3.50s]
2018-01-04 22:59:11,933: 22:59:11 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 22:59:11,933: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 22:59:11,964: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 22:59:11,966: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:59:11,966: Re-using an available connection from the pool.
2018-01-04 22:59:11,966: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:59:11,966: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:59:11,988: SQL status: SELECT in 0.02 seconds
2018-01-04 22:59:11,991: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 22:59:11,992: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:59:11,992: On parsely_pageview_engagedtime: BEGIN
2018-01-04 22:59:11,994: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:59:11,994: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:59:11,994: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 22:59:12,627: SQL status: CREATE VIEW in 0.63 seconds
2018-01-04 22:59:12,627: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:59:12,630: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 22:59:12,634: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:59:12,634: On parsely_pageview_engagedtime: COMMIT
2018-01-04 22:59:12,634: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 22:59:12,635: On parsely_pageview_engagedtime: COMMIT
2018-01-04 22:59:13,111: SQL status: COMMIT in 0.48 seconds
2018-01-04 22:59:13,112: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a693b0410>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:59:13,138: 22:59:13 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 1.18s]
2018-01-04 22:59:13,139: 22:59:13 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 22:59:13,139: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 22:59:13,146: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 22:59:13,147: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 22:59:13,147: Re-using an available connection from the pool.
2018-01-04 22:59:13,147: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:59:13,148: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:59:13,169: SQL status: SELECT in 0.02 seconds
2018-01-04 22:59:13,171: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 22:59:13,172: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:59:13,173: On parsely_incoming_sessions: BEGIN
2018-01-04 22:59:13,175: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:59:13,175: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:59:13,175: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 22:59:13,782: SQL status: CREATE VIEW in 0.61 seconds
2018-01-04 22:59:13,782: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:59:13,782: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 22:59:13,785: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 22:59:13,785: On parsely_incoming_sessions: COMMIT
2018-01-04 22:59:13,786: Using redshift connection "parsely_incoming_sessions".
2018-01-04 22:59:13,786: On parsely_incoming_sessions: COMMIT
2018-01-04 22:59:14,001: SQL status: COMMIT in 0.22 seconds
2018-01-04 22:59:14,002: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e8eb590>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 22:59:14,032: 22:59:14 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.86s]
2018-01-04 22:59:14,032: 22:59:14 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 22:59:14,032: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 22:59:14,041: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 22:59:14,042: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:59:14,043: Re-using an available connection from the pool.
2018-01-04 22:59:14,043: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:59:14,043: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:59:14,064: SQL status: SELECT in 0.02 seconds
2018-01-04 22:59:14,064: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:59:14,064: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 22:59:14,082: SQL status: SELECT in 0.02 seconds
2018-01-04 22:59:14,084: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:59:14,084: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 22:59:14,086: SQL status: BEGIN in 0.00 seconds
2018-01-04 22:59:14,086: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 22:59:14,086: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:01:13,707: SQL status: SELECT in 119.62 seconds
2018-01-04 23:01:13,707: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:01:13,707: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 23:01:13,855: SQL status: SELECT in 0.15 seconds
2018-01-04 23:01:13,856: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:01:13,856: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:01:13,993: SQL status: SELECT in 0.14 seconds
2018-01-04 23:01:13,994: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:01:13,994: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:01:14,114: SQL status: SELECT in 0.12 seconds
2018-01-04 23:01:14,118: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 23:01:14,119: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:01:14,119: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 23:01:17,764: SQL status: INSERT 0 109713 in 3.64 seconds
2018-01-04 23:01:17,764: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 23:01:17,764: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:01:17,764: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 23:01:19,620: SQL status: COMMIT in 1.86 seconds
2018-01-04 23:01:19,620: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9e5150>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 23:01:19,689: 23:01:19 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 109713 in 125.59s]
2018-01-04 23:01:19,690: 23:01:19 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 23:01:19,690: Compiling model.parsely.parsely_sessions
2018-01-04 23:01:19,696: Acquiring new redshift connection "parsely_sessions".
2018-01-04 23:01:19,696: Re-using an available connection from the pool.
2018-01-04 23:01:19,696: Using redshift connection "parsely_sessions".
2018-01-04 23:01:19,696: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:19,718: SQL status: SELECT in 0.02 seconds
2018-01-04 23:01:19,721: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 23:01:19,723: Using redshift connection "parsely_sessions".
2018-01-04 23:01:19,723: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:19,743: SQL status: SELECT in 0.02 seconds
2018-01-04 23:01:19,744: Using redshift connection "parsely_sessions".
2018-01-04 23:01:19,744: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:19,764: SQL status: SELECT in 0.02 seconds
2018-01-04 23:01:19,767: Using redshift connection "parsely_sessions".
2018-01-04 23:01:19,767: On parsely_sessions: BEGIN
2018-01-04 23:01:19,769: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:01:19,769: Using redshift connection "parsely_sessions".
2018-01-04 23:01:19,769: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:01:46,966: SQL status: SELECT in 27.20 seconds
2018-01-04 23:01:46,966: Using redshift connection "parsely_sessions".
2018-01-04 23:01:46,966: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 23:01:47,193: SQL status: SELECT in 0.23 seconds
2018-01-04 23:01:47,194: Using redshift connection "parsely_sessions".
2018-01-04 23:01:47,194: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:01:47,310: SQL status: SELECT in 0.12 seconds
2018-01-04 23:01:47,310: Using redshift connection "parsely_sessions".
2018-01-04 23:01:47,311: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:01:47,428: SQL status: SELECT in 0.12 seconds
2018-01-04 23:01:47,430: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 23:01:47,432: Using redshift connection "parsely_sessions".
2018-01-04 23:01:47,432: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 23:01:49,177: SQL status: INSERT 0 89137 in 1.74 seconds
2018-01-04 23:01:49,177: On parsely_sessions: COMMIT
2018-01-04 23:01:49,177: Using redshift connection "parsely_sessions".
2018-01-04 23:01:49,178: On parsely_sessions: COMMIT
2018-01-04 23:01:50,615: SQL status: COMMIT in 1.44 seconds
2018-01-04 23:01:50,615: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9e52d0>], 'label': '7265b0fa-aa2c-4d25-93ce-5985d1ea4927'}
2018-01-04 23:01:50,650: 23:01:50 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 89137 in 30.93s]
2018-01-04 23:01:50,724: Using redshift connection "master".
2018-01-04 23:01:50,724: On master: BEGIN
2018-01-04 23:01:50,727: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:01:50,727: On master: COMMIT
2018-01-04 23:01:50,727: Using redshift connection "master".
2018-01-04 23:01:50,727: On master: COMMIT
2018-01-04 23:01:50,729: SQL status: COMMIT in 0.00 seconds
2018-01-04 23:01:50,729: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 23:01:50,734: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 23:01:50,735: Using redshift connection "master".
2018-01-04 23:01:50,735: On master:  select 1 
2018-01-04 23:01:50,738: SQL status: SELECT in 0.00 seconds
2018-01-04 23:01:50,738: 23:01:50 | 
2018-01-04 23:01:50,738: 23:01:50 | Finished running 10 view models, 15 incremental models in 1056.45s.
2018-01-04 23:01:50,738: 
2018-01-04 23:01:50,739: Completed successfully
2018-01-04 23:01:50,739: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 23:01:50,739: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9ebe10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9ebf90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f1a5e9d2950>], 'label': 'end'}
2018-01-04 23:01:50,767: Flushing usage events
2018-01-04 23:01:56,813: Tracking: tracking
2018-01-04 23:01:56,813: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06b9e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06b9f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06b9ed0>], 'label': 'start'}
2018-01-04 23:01:56,857: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 23:01:56,873: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 23:01:56,874: Parsing core.sql
2018-01-04 23:01:56,886: Parsing etc/get_custom_schema.sql
2018-01-04 23:01:56,891: Parsing schema_tests/relationships.sql
2018-01-04 23:01:56,893: Parsing schema_tests/accepted_values.sql
2018-01-04 23:01:56,896: Parsing schema_tests/not_null.sql
2018-01-04 23:01:56,898: Parsing schema_tests/unique.sql
2018-01-04 23:01:56,900: Parsing materializations/wrapper.sql
2018-01-04 23:01:56,902: Parsing materializations/archive.sql
2018-01-04 23:01:56,931: Parsing materializations/table.sql
2018-01-04 23:01:56,948: Parsing materializations/helpers.sql
2018-01-04 23:01:56,963: Parsing materializations/bigquery.sql
2018-01-04 23:01:56,976: Parsing materializations/view.sql
2018-01-04 23:01:56,990: Parsing materializations/incremental.sql
2018-01-04 23:01:57,015: Parsing adapters/redshift.sql
2018-01-04 23:01:57,032: Parsing adapters/bigquery.sql
2018-01-04 23:01:57,036: Parsing adapters/postgres.sql
2018-01-04 23:01:57,039: Parsing adapters/common.sql
2018-01-04 23:01:57,058: Parsing model.parsely.parsely_audit
2018-01-04 23:01:57,059: Parsing model.parsely.parsely_video_content
2018-01-04 23:01:57,062: Parsing model.parsely.parsely_post_content
2018-01-04 23:01:57,065: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 23:01:57,068: Parsing model.parsely.parsely_rawdata
2018-01-04 23:01:57,070: Parsing model.parsely.calendar
2018-01-04 23:01:57,072: Parsing model.parsely.parsely_all_events
2018-01-04 23:01:57,080: Acquiring new redshift connection "parsely_all_events".
2018-01-04 23:01:57,080: Opening a new connection (0 currently allocated)
2018-01-04 23:01:57,093: Using redshift connection "parsely_all_events".
2018-01-04 23:01:57,093: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:57,119: SQL status: SELECT in 0.03 seconds
2018-01-04 23:01:57,124: Parsing model.parsely.parsely_event_ids
2018-01-04 23:01:57,127: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 23:01:57,129: Parsing model.parsely.parsely_base_events
2018-01-04 23:01:57,133: Acquiring new redshift connection "parsely_base_events".
2018-01-04 23:01:57,133: Re-using an available connection from the pool.
2018-01-04 23:01:57,133: Using redshift connection "parsely_base_events".
2018-01-04 23:01:57,133: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:57,153: SQL status: SELECT in 0.02 seconds
2018-01-04 23:01:57,154: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 23:01:57,160: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 23:01:57,164: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 23:01:57,166: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 23:01:57,168: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 23:01:57,171: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 23:01:57,177: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 23:01:57,184: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 23:01:57,189: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:01:57,189: Re-using an available connection from the pool.
2018-01-04 23:01:57,189: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:01:57,189: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:57,210: SQL status: SELECT in 0.02 seconds
2018-01-04 23:01:57,211: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 23:01:57,217: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 23:01:57,222: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:01:57,222: Re-using an available connection from the pool.
2018-01-04 23:01:57,222: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:01:57,223: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:57,243: SQL status: SELECT in 0.02 seconds
2018-01-04 23:01:57,243: Parsing model.parsely.parsely_incoming_users
2018-01-04 23:01:57,246: Parsing model.parsely.parsely_users
2018-01-04 23:01:57,251: Acquiring new redshift connection "parsely_users".
2018-01-04 23:01:57,251: Re-using an available connection from the pool.
2018-01-04 23:01:57,251: Using redshift connection "parsely_users".
2018-01-04 23:01:57,252: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:57,272: SQL status: SELECT in 0.02 seconds
2018-01-04 23:01:57,272: Parsing model.parsely.parsely_errors
2018-01-04 23:01:57,276: Parsing model.parsely.parsely_bot_traffic
2018-01-04 23:01:57,280: Parsing model.parsely.parsely_custom_events
2018-01-04 23:01:57,285: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 23:01:57,289: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 23:01:57,292: Parsing model.parsely.parsely_sessions
2018-01-04 23:01:57,297: Acquiring new redshift connection "parsely_sessions".
2018-01-04 23:01:57,297: Re-using an available connection from the pool.
2018-01-04 23:01:57,297: Using redshift connection "parsely_sessions".
2018-01-04 23:01:57,297: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:57,318: SQL status: SELECT in 0.02 seconds
2018-01-04 23:01:57,319: Parsing model.parsely.parsely_campaigns
2018-01-04 23:01:57,323: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 23:01:57,323: Re-using an available connection from the pool.
2018-01-04 23:01:57,323: Using redshift connection "parsely_campaigns".
2018-01-04 23:01:57,323: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:57,343: SQL status: SELECT in 0.02 seconds
2018-01-04 23:01:57,349: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 23:01:57,355: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 23:01:57,362: 
2018-01-04 23:01:57,365: Acquiring new redshift connection "master".
2018-01-04 23:01:57,365: Re-using an available connection from the pool.
2018-01-04 23:01:57,365: Using redshift connection "master".
2018-01-04 23:01:57,365: On master: select distinct nspname from pg_namespace
2018-01-04 23:01:57,367: SQL status: SELECT in 0.00 seconds
2018-01-04 23:01:57,370: Using redshift connection "master".
2018-01-04 23:01:57,370: On master: BEGIN
2018-01-04 23:01:57,372: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:01:57,372: On master: COMMIT
2018-01-04 23:01:57,372: Using redshift connection "master".
2018-01-04 23:01:57,372: On master: COMMIT
2018-01-04 23:01:57,373: SQL status: COMMIT in 0.00 seconds
2018-01-04 23:01:57,379: 23:01:57 | Concurrency: 1 threads (target='dev')
2018-01-04 23:01:57,379: 23:01:57 | 
2018-01-04 23:01:57,379: Using redshift connection "master".
2018-01-04 23:01:57,379: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:57,400: SQL status: SELECT in 0.02 seconds
2018-01-04 23:01:57,507: 23:01:57 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 23:01:57,507: Compiling model.parsely.calendar
2018-01-04 23:01:57,516: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 23:01:57,517: Acquiring new redshift connection "calendar".
2018-01-04 23:01:57,518: Opening a new connection (1 currently allocated)
2018-01-04 23:01:57,531: Using redshift connection "calendar".
2018-01-04 23:01:57,531: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:01:57,557: SQL status: SELECT in 0.03 seconds
2018-01-04 23:01:57,559: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 23:01:57,560: Using redshift connection "calendar".
2018-01-04 23:01:57,560: On calendar: BEGIN
2018-01-04 23:01:57,562: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:01:57,562: Using redshift connection "calendar".
2018-01-04 23:01:57,562: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 23:01:58,048: SQL status: CREATE VIEW in 0.49 seconds
2018-01-04 23:01:58,048: On calendar: COMMIT
2018-01-04 23:01:58,048: Using redshift connection "calendar".
2018-01-04 23:01:58,048: On calendar: COMMIT
2018-01-04 23:01:58,818: SQL status: COMMIT in 0.77 seconds
2018-01-04 23:01:58,818: Using redshift connection "calendar".
2018-01-04 23:01:58,818: On calendar: BEGIN
2018-01-04 23:01:58,821: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:01:58,821: Using redshift connection "calendar".
2018-01-04 23:01:58,821: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 23:01:59,322: SQL status: DROP VIEW in 0.50 seconds
2018-01-04 23:01:59,322: On calendar: COMMIT
2018-01-04 23:01:59,323: Using redshift connection "calendar".
2018-01-04 23:01:59,323: On calendar: COMMIT
2018-01-04 23:02:00,490: SQL status: COMMIT in 1.17 seconds
2018-01-04 23:02:00,490: Using redshift connection "calendar".
2018-01-04 23:02:00,490: On calendar: BEGIN
2018-01-04 23:02:00,492: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:02:00,492: Using redshift connection "calendar".
2018-01-04 23:02:00,493: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 23:02:00,497: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:02:00,497: On calendar: COMMIT
2018-01-04 23:02:00,497: Using redshift connection "calendar".
2018-01-04 23:02:00,497: On calendar: COMMIT
2018-01-04 23:02:01,028: SQL status: COMMIT in 0.53 seconds
2018-01-04 23:02:01,029: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b05a7bd0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:02:01,057: 23:02:01 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 3.52s]
2018-01-04 23:02:01,057: 23:02:01 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 23:02:01,058: Compiling model.parsely.parsely_rawdata
2018-01-04 23:02:01,063: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 23:02:01,065: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 23:02:01,065: Re-using an available connection from the pool.
2018-01-04 23:02:01,065: Using redshift connection "parsely_rawdata".
2018-01-04 23:02:01,065: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:02:01,085: SQL status: SELECT in 0.02 seconds
2018-01-04 23:02:01,085: Using redshift connection "parsely_rawdata".
2018-01-04 23:02:01,085: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:02:01,095: SQL status: SELECT in 0.01 seconds
2018-01-04 23:02:01,096: Using redshift connection "parsely_rawdata".
2018-01-04 23:02:01,096: On parsely_rawdata: BEGIN
2018-01-04 23:02:01,098: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:02:01,098: Using redshift connection "parsely_rawdata".
2018-01-04 23:02:01,098: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:02:30,501: SQL status: SELECT in 29.40 seconds
2018-01-04 23:02:30,501: Using redshift connection "parsely_rawdata".
2018-01-04 23:02:30,501: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 23:02:30,657: SQL status: SELECT in 0.15 seconds
2018-01-04 23:02:30,657: Using redshift connection "parsely_rawdata".
2018-01-04 23:02:30,657: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:02:30,764: SQL status: SELECT in 0.11 seconds
2018-01-04 23:02:30,764: Using redshift connection "parsely_rawdata".
2018-01-04 23:02:30,764: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:02:30,870: SQL status: SELECT in 0.11 seconds
2018-01-04 23:02:30,873: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 23:02:30,874: Using redshift connection "parsely_rawdata".
2018-01-04 23:02:30,874: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 23:03:03,939: SQL status: INSERT 0 1035448 in 33.06 seconds
2018-01-04 23:03:03,940: On parsely_rawdata: COMMIT
2018-01-04 23:03:03,940: Using redshift connection "parsely_rawdata".
2018-01-04 23:03:03,940: On parsely_rawdata: COMMIT
2018-01-04 23:03:05,960: SQL status: COMMIT in 2.02 seconds
2018-01-04 23:03:05,961: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0611b10>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:03:06,017: 23:03:06 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1035448 in 64.90s]
2018-01-04 23:03:06,018: 23:03:06 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 23:03:06,018: Compiling model.parsely.parsely_all_events
2018-01-04 23:03:06,026: Acquiring new redshift connection "parsely_all_events".
2018-01-04 23:03:06,027: Re-using an available connection from the pool.
2018-01-04 23:03:06,027: Using redshift connection "parsely_all_events".
2018-01-04 23:03:06,027: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:03:06,043: SQL status: SELECT in 0.02 seconds
2018-01-04 23:03:06,052: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 23:03:06,053: Using redshift connection "parsely_all_events".
2018-01-04 23:03:06,053: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:03:06,066: SQL status: SELECT in 0.01 seconds
2018-01-04 23:03:06,067: Using redshift connection "parsely_all_events".
2018-01-04 23:03:06,067: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:03:06,079: SQL status: SELECT in 0.01 seconds
2018-01-04 23:03:06,081: Using redshift connection "parsely_all_events".
2018-01-04 23:03:06,081: On parsely_all_events: BEGIN
2018-01-04 23:03:06,084: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:03:06,084: Using redshift connection "parsely_all_events".
2018-01-04 23:03:06,084: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:05:12,117: SQL status: SELECT in 126.03 seconds
2018-01-04 23:05:12,117: Using redshift connection "parsely_all_events".
2018-01-04 23:05:12,117: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 23:05:12,304: SQL status: SELECT in 0.19 seconds
2018-01-04 23:05:12,304: Using redshift connection "parsely_all_events".
2018-01-04 23:05:12,305: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:05:12,412: SQL status: SELECT in 0.11 seconds
2018-01-04 23:05:12,413: Using redshift connection "parsely_all_events".
2018-01-04 23:05:12,413: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:05:12,522: SQL status: SELECT in 0.11 seconds
2018-01-04 23:05:12,526: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 23:05:12,527: Using redshift connection "parsely_all_events".
2018-01-04 23:05:12,527: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 23:05:29,654: SQL status: INSERT 0 919956 in 17.13 seconds
2018-01-04 23:05:29,655: On parsely_all_events: COMMIT
2018-01-04 23:05:29,655: Using redshift connection "parsely_all_events".
2018-01-04 23:05:29,655: On parsely_all_events: COMMIT
2018-01-04 23:05:32,731: SQL status: COMMIT in 3.08 seconds
2018-01-04 23:05:32,732: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0666810>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:05:32,805: 23:05:32 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 919956 in 146.71s]
2018-01-04 23:05:32,806: 23:05:32 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 23:05:32,806: Compiling model.parsely.parsely_bot_traffic
2018-01-04 23:05:32,813: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 23:05:32,814: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 23:05:32,814: Re-using an available connection from the pool.
2018-01-04 23:05:32,814: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:05:32,814: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:05:32,829: SQL status: SELECT in 0.01 seconds
2018-01-04 23:05:32,830: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:05:32,830: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:05:32,844: SQL status: SELECT in 0.01 seconds
2018-01-04 23:05:32,845: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:05:32,846: On parsely_bot_traffic: BEGIN
2018-01-04 23:05:32,848: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:05:32,848: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:05:32,848: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:06:29,047: SQL status: SELECT in 56.20 seconds
2018-01-04 23:06:29,047: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:06:29,047: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 23:06:29,205: SQL status: SELECT in 0.16 seconds
2018-01-04 23:06:29,206: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:06:29,206: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:06:29,314: SQL status: SELECT in 0.11 seconds
2018-01-04 23:06:29,315: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:06:29,315: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:06:29,422: SQL status: SELECT in 0.11 seconds
2018-01-04 23:06:29,425: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 23:06:29,426: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:06:29,427: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 23:06:30,538: SQL status: INSERT 0 4 in 1.11 seconds
2018-01-04 23:06:30,538: On parsely_bot_traffic: COMMIT
2018-01-04 23:06:30,539: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:06:30,539: On parsely_bot_traffic: COMMIT
2018-01-04 23:06:31,597: SQL status: COMMIT in 1.06 seconds
2018-01-04 23:06:31,598: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b05a7c90>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:06:31,622: 23:06:31 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 58.79s]
2018-01-04 23:06:31,623: 23:06:31 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 23:06:31,623: Compiling model.parsely.parsely_custom_events
2018-01-04 23:06:31,631: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 23:06:31,633: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 23:06:31,633: Re-using an available connection from the pool.
2018-01-04 23:06:31,633: Using redshift connection "parsely_custom_events".
2018-01-04 23:06:31,633: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:06:31,648: SQL status: SELECT in 0.01 seconds
2018-01-04 23:06:31,648: Using redshift connection "parsely_custom_events".
2018-01-04 23:06:31,648: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:06:31,662: SQL status: SELECT in 0.01 seconds
2018-01-04 23:06:31,664: Using redshift connection "parsely_custom_events".
2018-01-04 23:06:31,664: On parsely_custom_events: BEGIN
2018-01-04 23:06:31,666: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:06:31,667: Using redshift connection "parsely_custom_events".
2018-01-04 23:06:31,667: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:07:27,281: SQL status: SELECT in 55.61 seconds
2018-01-04 23:07:27,281: Using redshift connection "parsely_custom_events".
2018-01-04 23:07:27,281: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 23:07:27,435: SQL status: SELECT in 0.15 seconds
2018-01-04 23:07:27,435: Using redshift connection "parsely_custom_events".
2018-01-04 23:07:27,436: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:07:27,544: SQL status: SELECT in 0.11 seconds
2018-01-04 23:07:27,545: Using redshift connection "parsely_custom_events".
2018-01-04 23:07:27,545: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:07:27,654: SQL status: SELECT in 0.11 seconds
2018-01-04 23:07:27,657: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 23:07:27,658: Using redshift connection "parsely_custom_events".
2018-01-04 23:07:27,658: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 23:07:27,922: SQL status: INSERT 0 0 in 0.26 seconds
2018-01-04 23:07:27,922: On parsely_custom_events: COMMIT
2018-01-04 23:07:27,923: Using redshift connection "parsely_custom_events".
2018-01-04 23:07:27,923: On parsely_custom_events: COMMIT
2018-01-04 23:07:28,688: SQL status: COMMIT in 0.76 seconds
2018-01-04 23:07:28,688: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b05a7c90>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:07:28,733: 23:07:28 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 57.06s]
2018-01-04 23:07:28,734: 23:07:28 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 23:07:28,734: Compiling model.parsely.parsely_errors
2018-01-04 23:07:28,744: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 23:07:28,745: Acquiring new redshift connection "parsely_errors".
2018-01-04 23:07:28,746: Re-using an available connection from the pool.
2018-01-04 23:07:28,746: Using redshift connection "parsely_errors".
2018-01-04 23:07:28,746: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:07:28,760: SQL status: SELECT in 0.01 seconds
2018-01-04 23:07:28,761: Using redshift connection "parsely_errors".
2018-01-04 23:07:28,761: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:07:28,775: SQL status: SELECT in 0.01 seconds
2018-01-04 23:07:28,776: Using redshift connection "parsely_errors".
2018-01-04 23:07:28,777: On parsely_errors: BEGIN
2018-01-04 23:07:28,779: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:07:28,779: Using redshift connection "parsely_errors".
2018-01-04 23:07:28,779: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:08:22,130: SQL status: SELECT in 53.35 seconds
2018-01-04 23:08:22,130: Using redshift connection "parsely_errors".
2018-01-04 23:08:22,130: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 23:08:22,396: SQL status: SELECT in 0.27 seconds
2018-01-04 23:08:22,396: Using redshift connection "parsely_errors".
2018-01-04 23:08:22,397: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:08:22,508: SQL status: SELECT in 0.11 seconds
2018-01-04 23:08:22,509: Using redshift connection "parsely_errors".
2018-01-04 23:08:22,509: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:08:22,618: SQL status: SELECT in 0.11 seconds
2018-01-04 23:08:22,621: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 23:08:22,622: Using redshift connection "parsely_errors".
2018-01-04 23:08:22,623: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 23:08:23,290: SQL status: INSERT 0 2 in 0.67 seconds
2018-01-04 23:08:23,291: On parsely_errors: COMMIT
2018-01-04 23:08:23,291: Using redshift connection "parsely_errors".
2018-01-04 23:08:23,291: On parsely_errors: COMMIT
2018-01-04 23:08:24,110: SQL status: COMMIT in 0.82 seconds
2018-01-04 23:08:24,110: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b059dbd0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:08:24,142: 23:08:24 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 55.38s]
2018-01-04 23:08:24,143: 23:08:24 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 23:08:24,143: Compiling model.parsely.parsely_base_events
2018-01-04 23:08:24,147: Acquiring new redshift connection "parsely_base_events".
2018-01-04 23:08:24,147: Re-using an available connection from the pool.
2018-01-04 23:08:24,147: Using redshift connection "parsely_base_events".
2018-01-04 23:08:24,147: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:24,162: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:24,165: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 23:08:24,167: Using redshift connection "parsely_base_events".
2018-01-04 23:08:24,167: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:24,181: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:24,183: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 23:08:24,183: Using redshift connection "parsely_base_events".
2018-01-04 23:08:24,184: On parsely_base_events: BEGIN
2018-01-04 23:08:24,186: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:08:24,186: Using redshift connection "parsely_base_events".
2018-01-04 23:08:24,186: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 23:08:24,543: SQL status: CREATE VIEW in 0.36 seconds
2018-01-04 23:08:24,544: On parsely_base_events: COMMIT
2018-01-04 23:08:24,544: Using redshift connection "parsely_base_events".
2018-01-04 23:08:24,544: On parsely_base_events: COMMIT
2018-01-04 23:08:24,910: SQL status: COMMIT in 0.37 seconds
2018-01-04 23:08:24,910: Using redshift connection "parsely_base_events".
2018-01-04 23:08:24,910: On parsely_base_events: BEGIN
2018-01-04 23:08:24,913: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:08:24,913: Using redshift connection "parsely_base_events".
2018-01-04 23:08:24,914: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 23:08:25,317: SQL status: DROP VIEW in 0.40 seconds
2018-01-04 23:08:25,318: On parsely_base_events: COMMIT
2018-01-04 23:08:25,318: Using redshift connection "parsely_base_events".
2018-01-04 23:08:25,318: On parsely_base_events: COMMIT
2018-01-04 23:08:25,703: SQL status: COMMIT in 0.39 seconds
2018-01-04 23:08:25,703: Using redshift connection "parsely_base_events".
2018-01-04 23:08:25,703: On parsely_base_events: BEGIN
2018-01-04 23:08:25,706: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:08:25,706: Using redshift connection "parsely_base_events".
2018-01-04 23:08:25,706: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 23:08:25,797: SQL status: ALTER TABLE in 0.09 seconds
2018-01-04 23:08:25,797: On parsely_base_events: COMMIT
2018-01-04 23:08:25,797: Using redshift connection "parsely_base_events".
2018-01-04 23:08:25,797: On parsely_base_events: COMMIT
2018-01-04 23:08:26,808: SQL status: COMMIT in 1.01 seconds
2018-01-04 23:08:26,809: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06119d0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:08:26,838: 23:08:26 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 2.67s]
2018-01-04 23:08:26,838: 23:08:26 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 23:08:26,839: Compiling model.parsely.parsely_event_ids
2018-01-04 23:08:26,844: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 23:08:26,846: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 23:08:26,846: Re-using an available connection from the pool.
2018-01-04 23:08:26,846: Using redshift connection "parsely_event_ids".
2018-01-04 23:08:26,846: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:26,862: SQL status: SELECT in 0.02 seconds
2018-01-04 23:08:26,862: Using redshift connection "parsely_event_ids".
2018-01-04 23:08:26,862: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:26,876: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:26,877: Using redshift connection "parsely_event_ids".
2018-01-04 23:08:26,877: On parsely_event_ids: BEGIN
2018-01-04 23:08:26,879: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:08:26,879: Using redshift connection "parsely_event_ids".
2018-01-04 23:08:26,879: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:08:28,269: SQL status: SELECT in 1.39 seconds
2018-01-04 23:08:28,269: Using redshift connection "parsely_event_ids".
2018-01-04 23:08:28,270: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 23:08:28,419: SQL status: SELECT in 0.15 seconds
2018-01-04 23:08:28,419: Using redshift connection "parsely_event_ids".
2018-01-04 23:08:28,419: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:08:28,527: SQL status: SELECT in 0.11 seconds
2018-01-04 23:08:28,527: Using redshift connection "parsely_event_ids".
2018-01-04 23:08:28,527: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:08:28,632: SQL status: SELECT in 0.10 seconds
2018-01-04 23:08:28,633: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 23:08:28,634: Using redshift connection "parsely_event_ids".
2018-01-04 23:08:28,634: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 23:08:30,036: SQL status: INSERT 0 919952 in 1.40 seconds
2018-01-04 23:08:30,036: On parsely_event_ids: COMMIT
2018-01-04 23:08:30,036: Using redshift connection "parsely_event_ids".
2018-01-04 23:08:30,036: On parsely_event_ids: COMMIT
2018-01-04 23:08:30,359: SQL status: COMMIT in 0.32 seconds
2018-01-04 23:08:30,359: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b05b9dd0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:08:30,397: 23:08:30 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 919952 in 3.52s]
2018-01-04 23:08:30,398: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 23:08:30,403: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 23:08:30,404: 23:08:30 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 23:08:30,405: Compiling model.parsely.parsely_post_content
2018-01-04 23:08:30,411: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 23:08:30,412: Acquiring new redshift connection "parsely_post_content".
2018-01-04 23:08:30,412: Re-using an available connection from the pool.
2018-01-04 23:08:30,412: Using redshift connection "parsely_post_content".
2018-01-04 23:08:30,412: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:30,427: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:30,427: Using redshift connection "parsely_post_content".
2018-01-04 23:08:30,427: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:30,441: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:30,442: Using redshift connection "parsely_post_content".
2018-01-04 23:08:30,443: On parsely_post_content: BEGIN
2018-01-04 23:08:30,444: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:08:30,445: Using redshift connection "parsely_post_content".
2018-01-04 23:08:30,445: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:08:41,903: SQL status: SELECT in 11.46 seconds
2018-01-04 23:08:41,903: Using redshift connection "parsely_post_content".
2018-01-04 23:08:41,904: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 23:08:42,133: SQL status: SELECT in 0.23 seconds
2018-01-04 23:08:42,133: Using redshift connection "parsely_post_content".
2018-01-04 23:08:42,133: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:08:42,242: SQL status: SELECT in 0.11 seconds
2018-01-04 23:08:42,242: Using redshift connection "parsely_post_content".
2018-01-04 23:08:42,242: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:08:42,346: SQL status: SELECT in 0.10 seconds
2018-01-04 23:08:42,347: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 23:08:42,348: Using redshift connection "parsely_post_content".
2018-01-04 23:08:42,348: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 23:08:42,708: SQL status: INSERT 0 887 in 0.36 seconds
2018-01-04 23:08:42,709: On parsely_post_content: COMMIT
2018-01-04 23:08:42,709: Using redshift connection "parsely_post_content".
2018-01-04 23:08:42,709: On parsely_post_content: COMMIT
2018-01-04 23:08:43,603: SQL status: COMMIT in 0.89 seconds
2018-01-04 23:08:43,603: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0608ed0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:08:43,632: 23:08:43 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 887 in 13.20s]
2018-01-04 23:08:43,632: 23:08:43 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 23:08:43,633: Compiling model.parsely.parsely_video_content
2018-01-04 23:08:43,639: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 23:08:43,640: Acquiring new redshift connection "parsely_video_content".
2018-01-04 23:08:43,640: Re-using an available connection from the pool.
2018-01-04 23:08:43,640: Using redshift connection "parsely_video_content".
2018-01-04 23:08:43,641: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:43,655: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:43,656: Using redshift connection "parsely_video_content".
2018-01-04 23:08:43,656: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:43,671: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:43,672: Using redshift connection "parsely_video_content".
2018-01-04 23:08:43,672: On parsely_video_content: BEGIN
2018-01-04 23:08:43,674: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:08:43,674: Using redshift connection "parsely_video_content".
2018-01-04 23:08:43,674: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:08:53,866: SQL status: SELECT in 10.19 seconds
2018-01-04 23:08:53,866: Using redshift connection "parsely_video_content".
2018-01-04 23:08:53,866: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 23:08:54,014: SQL status: SELECT in 0.15 seconds
2018-01-04 23:08:54,014: Using redshift connection "parsely_video_content".
2018-01-04 23:08:54,014: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:08:54,122: SQL status: SELECT in 0.11 seconds
2018-01-04 23:08:54,122: Using redshift connection "parsely_video_content".
2018-01-04 23:08:54,122: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:08:54,226: SQL status: SELECT in 0.10 seconds
2018-01-04 23:08:54,228: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 23:08:54,229: Using redshift connection "parsely_video_content".
2018-01-04 23:08:54,229: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 23:08:54,571: SQL status: INSERT 0 469 in 0.34 seconds
2018-01-04 23:08:54,571: On parsely_video_content: COMMIT
2018-01-04 23:08:54,571: Using redshift connection "parsely_video_content".
2018-01-04 23:08:54,571: On parsely_video_content: COMMIT
2018-01-04 23:08:55,407: SQL status: COMMIT in 0.84 seconds
2018-01-04 23:08:55,408: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0608ed0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:08:55,438: 23:08:55 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 469 in 11.77s]
2018-01-04 23:08:55,438: 23:08:55 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 23:08:55,438: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 23:08:55,444: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 23:08:55,445: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 23:08:55,445: Re-using an available connection from the pool.
2018-01-04 23:08:55,445: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:08:55,446: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:55,460: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:55,462: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 23:08:55,463: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:08:55,463: On parsely_entry_exit_urls: BEGIN
2018-01-04 23:08:55,465: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:08:55,465: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:08:55,465: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 23:08:56,865: SQL status: CREATE VIEW in 1.40 seconds
2018-01-04 23:08:56,866: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:08:56,870: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 23:08:56,874: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:08:56,874: On parsely_entry_exit_urls: COMMIT
2018-01-04 23:08:56,874: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:08:56,874: On parsely_entry_exit_urls: COMMIT
2018-01-04 23:08:57,115: SQL status: COMMIT in 0.24 seconds
2018-01-04 23:08:57,116: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0608ed0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:08:57,149: 23:08:57 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 1.68s]
2018-01-04 23:08:57,149: 23:08:57 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 23:08:57,150: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 23:08:57,160: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 23:08:57,162: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 23:08:57,162: Re-using an available connection from the pool.
2018-01-04 23:08:57,162: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:08:57,162: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:57,177: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:57,180: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 23:08:57,181: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:08:57,182: On parsely_incoming_videoviews: BEGIN
2018-01-04 23:08:57,184: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:08:57,184: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:08:57,184: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 23:08:57,594: SQL status: CREATE VIEW in 0.41 seconds
2018-01-04 23:08:57,595: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:08:57,595: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 23:08:57,599: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:08:57,599: On parsely_incoming_videoviews: COMMIT
2018-01-04 23:08:57,600: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:08:57,600: On parsely_incoming_videoviews: COMMIT
2018-01-04 23:08:57,857: SQL status: COMMIT in 0.26 seconds
2018-01-04 23:08:57,858: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0608ed0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:08:57,898: 23:08:57 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.71s]
2018-01-04 23:08:57,898: 23:08:57 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 23:08:57,898: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 23:08:57,903: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:08:57,904: Re-using an available connection from the pool.
2018-01-04 23:08:57,904: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:08:57,904: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:57,918: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:57,922: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 23:08:57,924: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:08:57,924: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:57,938: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:57,938: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:08:57,938: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:08:57,951: SQL status: SELECT in 0.01 seconds
2018-01-04 23:08:57,953: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:08:57,954: On parsely_videoviews_sessionized: BEGIN
2018-01-04 23:08:57,956: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:08:57,956: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:08:57,956: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:10:05,427: SQL status: SELECT in 67.47 seconds
2018-01-04 23:10:05,427: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:10:05,427: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 23:10:05,592: SQL status: SELECT in 0.16 seconds
2018-01-04 23:10:05,593: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:10:05,593: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:10:05,705: SQL status: SELECT in 0.11 seconds
2018-01-04 23:10:05,706: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:10:05,706: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:10:05,817: SQL status: SELECT in 0.11 seconds
2018-01-04 23:10:05,820: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 23:10:05,821: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:10:05,821: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 23:10:06,970: SQL status: INSERT 0 143 in 1.15 seconds
2018-01-04 23:10:06,971: On parsely_videoviews_sessionized: COMMIT
2018-01-04 23:10:06,971: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:10:06,971: On parsely_videoviews_sessionized: COMMIT
2018-01-04 23:10:08,809: SQL status: COMMIT in 1.84 seconds
2018-01-04 23:10:08,809: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0608ed0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:10:08,880: 23:10:08 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 143 in 70.91s]
2018-01-04 23:10:08,880: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 23:10:08,903: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 23:10:08,904: 23:10:08 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 23:10:08,905: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 23:10:08,918: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 23:10:08,919: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:10:08,919: Re-using an available connection from the pool.
2018-01-04 23:10:08,919: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:10:08,919: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:10:08,936: SQL status: SELECT in 0.02 seconds
2018-01-04 23:10:08,938: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 23:10:08,939: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:10:08,939: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 23:10:08,941: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:10:08,941: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:10:08,941: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 23:10:10,291: SQL status: CREATE VIEW in 1.35 seconds
2018-01-04 23:10:10,291: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:10:10,291: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 23:10:10,295: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:10:10,295: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 23:10:10,295: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:10:10,295: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 23:10:10,767: SQL status: COMMIT in 0.47 seconds
2018-01-04 23:10:10,768: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b05a7890>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:10:10,798: 23:10:10 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.86s]
2018-01-04 23:10:10,798: 23:10:10 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 23:10:10,799: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 23:10:10,827: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 23:10:10,828: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:10:10,828: Re-using an available connection from the pool.
2018-01-04 23:10:10,828: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:10:10,828: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:10:10,846: SQL status: SELECT in 0.02 seconds
2018-01-04 23:10:10,849: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 23:10:10,850: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:10:10,850: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 23:10:10,852: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:10:10,852: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:10:10,853: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 23:10:11,146: SQL status: CREATE VIEW in 0.29 seconds
2018-01-04 23:10:11,147: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:10:11,147: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 23:10:11,151: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:10:11,151: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 23:10:11,151: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:10:11,151: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 23:10:11,864: SQL status: COMMIT in 0.71 seconds
2018-01-04 23:10:11,864: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b059d1d0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:10:11,893: 23:10:11 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 1.07s]
2018-01-04 23:10:11,894: 23:10:11 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 23:10:11,894: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 23:10:11,904: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 23:10:11,906: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 23:10:11,906: Re-using an available connection from the pool.
2018-01-04 23:10:11,907: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:10:11,907: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:10:11,924: SQL status: SELECT in 0.02 seconds
2018-01-04 23:10:11,928: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 23:10:11,929: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:10:11,929: On parsely_incoming_pageviews: BEGIN
2018-01-04 23:10:11,931: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:10:11,931: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:10:11,931: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 23:10:12,588: SQL status: CREATE VIEW in 0.66 seconds
2018-01-04 23:10:12,589: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:10:12,589: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 23:10:12,594: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:10:12,594: On parsely_incoming_pageviews: COMMIT
2018-01-04 23:10:12,594: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:10:12,594: On parsely_incoming_pageviews: COMMIT
2018-01-04 23:10:13,124: SQL status: COMMIT in 0.53 seconds
2018-01-04 23:10:13,124: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06a0990>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:10:13,154: 23:10:13 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.23s]
2018-01-04 23:10:13,155: 23:10:13 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 23:10:13,155: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 23:10:13,160: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:10:13,160: Re-using an available connection from the pool.
2018-01-04 23:10:13,160: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:10:13,160: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:10:13,179: SQL status: SELECT in 0.02 seconds
2018-01-04 23:10:13,185: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 23:10:13,187: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:10:13,187: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:10:13,204: SQL status: SELECT in 0.02 seconds
2018-01-04 23:10:13,205: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:10:13,205: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:10:13,224: SQL status: SELECT in 0.02 seconds
2018-01-04 23:10:13,226: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:10:13,226: On parsely_pageviews_sessionized: BEGIN
2018-01-04 23:10:13,228: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:10:13,228: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:10:13,228: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:14:06,021: SQL status: SELECT in 232.79 seconds
2018-01-04 23:14:06,021: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:14:06,021: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 23:14:06,183: SQL status: SELECT in 0.16 seconds
2018-01-04 23:14:06,184: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:14:06,184: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:14:06,303: SQL status: SELECT in 0.12 seconds
2018-01-04 23:14:06,304: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:14:06,304: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:14:06,421: SQL status: SELECT in 0.12 seconds
2018-01-04 23:14:06,425: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 23:14:06,426: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:14:06,426: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 23:14:09,594: SQL status: INSERT 0 109829 in 3.17 seconds
2018-01-04 23:14:09,594: On parsely_pageviews_sessionized: COMMIT
2018-01-04 23:14:09,594: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:14:09,594: On parsely_pageviews_sessionized: COMMIT
2018-01-04 23:14:11,153: SQL status: COMMIT in 1.56 seconds
2018-01-04 23:14:11,153: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0608ed0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:14:11,201: 23:14:11 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 109829 in 238.00s]
2018-01-04 23:14:11,202: 23:14:11 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 23:14:11,202: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 23:14:11,244: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 23:14:11,246: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:14:11,246: Re-using an available connection from the pool.
2018-01-04 23:14:11,246: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:14:11,246: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:14:11,269: SQL status: SELECT in 0.02 seconds
2018-01-04 23:14:11,271: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 23:14:11,272: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:14:11,273: On parsely_videoview_engagedtime: BEGIN
2018-01-04 23:14:11,275: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:14:11,275: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:14:11,275: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 23:14:11,495: SQL status: CREATE VIEW in 0.22 seconds
2018-01-04 23:14:11,495: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:14:11,495: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 23:14:11,792: SQL status: ALTER TABLE in 0.30 seconds
2018-01-04 23:14:11,792: On parsely_videoview_engagedtime: COMMIT
2018-01-04 23:14:11,792: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:14:11,792: On parsely_videoview_engagedtime: COMMIT
2018-01-04 23:14:13,119: SQL status: COMMIT in 1.33 seconds
2018-01-04 23:14:13,119: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0608ed0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:14:13,308: 23:14:13 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.92s]
2018-01-04 23:14:13,309: 23:14:13 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 23:14:13,309: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 23:14:13,318: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 23:14:13,320: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:14:13,320: Re-using an available connection from the pool.
2018-01-04 23:14:13,320: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:14:13,320: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:14:13,345: SQL status: SELECT in 0.02 seconds
2018-01-04 23:14:13,345: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:14:13,345: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:14:13,366: SQL status: SELECT in 0.02 seconds
2018-01-04 23:14:13,368: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:14:13,368: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 23:14:13,370: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:14:13,370: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:14:13,371: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:17:07,530: SQL status: SELECT in 174.16 seconds
2018-01-04 23:17:07,530: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:17:07,530: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 23:17:08,087: SQL status: SELECT in 0.56 seconds
2018-01-04 23:17:08,087: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:17:08,088: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:17:08,206: SQL status: SELECT in 0.12 seconds
2018-01-04 23:17:08,207: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:17:08,207: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:17:08,326: SQL status: SELECT in 0.12 seconds
2018-01-04 23:17:08,329: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 23:17:08,330: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:17:08,331: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 23:17:09,402: SQL status: INSERT 0 142 in 1.07 seconds
2018-01-04 23:17:09,402: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 23:17:09,402: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:17:09,402: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 23:17:10,522: SQL status: COMMIT in 1.12 seconds
2018-01-04 23:17:10,523: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06a0990>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:17:10,567: 23:17:10 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 142 in 177.21s]
2018-01-04 23:17:10,568: 23:17:10 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 23:17:10,568: Compiling model.parsely.parsely_campaigns
2018-01-04 23:17:10,572: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 23:17:10,572: Re-using an available connection from the pool.
2018-01-04 23:17:10,572: Using redshift connection "parsely_campaigns".
2018-01-04 23:17:10,572: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:17:10,595: SQL status: SELECT in 0.02 seconds
2018-01-04 23:17:10,598: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 23:17:10,600: Using redshift connection "parsely_campaigns".
2018-01-04 23:17:10,600: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:17:10,621: SQL status: SELECT in 0.02 seconds
2018-01-04 23:17:10,622: Using redshift connection "parsely_campaigns".
2018-01-04 23:17:10,622: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:17:10,644: SQL status: SELECT in 0.02 seconds
2018-01-04 23:17:10,645: Using redshift connection "parsely_campaigns".
2018-01-04 23:17:10,645: On parsely_campaigns: BEGIN
2018-01-04 23:17:10,647: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:17:10,647: Using redshift connection "parsely_campaigns".
2018-01-04 23:17:10,647: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:17:11,707: SQL status: SELECT in 1.06 seconds
2018-01-04 23:17:11,707: Using redshift connection "parsely_campaigns".
2018-01-04 23:17:11,707: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 23:17:12,004: SQL status: SELECT in 0.30 seconds
2018-01-04 23:17:12,004: Using redshift connection "parsely_campaigns".
2018-01-04 23:17:12,004: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:17:12,116: SQL status: SELECT in 0.11 seconds
2018-01-04 23:17:12,116: Using redshift connection "parsely_campaigns".
2018-01-04 23:17:12,117: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:17:12,229: SQL status: SELECT in 0.11 seconds
2018-01-04 23:17:12,230: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 23:17:12,232: Using redshift connection "parsely_campaigns".
2018-01-04 23:17:12,232: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 23:17:12,376: SQL status: INSERT 0 390 in 0.14 seconds
2018-01-04 23:17:12,376: On parsely_campaigns: COMMIT
2018-01-04 23:17:12,376: Using redshift connection "parsely_campaigns".
2018-01-04 23:17:12,376: On parsely_campaigns: COMMIT
2018-01-04 23:17:13,116: SQL status: COMMIT in 0.74 seconds
2018-01-04 23:17:13,116: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06a0990>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:17:13,146: 23:17:13 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 390 in 2.55s]
2018-01-04 23:17:13,147: Compiling model.parsely.parsely_incoming_users
2018-01-04 23:17:13,153: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 23:17:13,154: 23:17:13 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 23:17:13,154: Compiling model.parsely.parsely_users
2018-01-04 23:17:13,161: Acquiring new redshift connection "parsely_users".
2018-01-04 23:17:13,161: Re-using an available connection from the pool.
2018-01-04 23:17:13,161: Using redshift connection "parsely_users".
2018-01-04 23:17:13,161: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:17:13,183: SQL status: SELECT in 0.02 seconds
2018-01-04 23:17:13,224: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 23:17:13,226: Using redshift connection "parsely_users".
2018-01-04 23:17:13,226: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:17:13,248: SQL status: SELECT in 0.02 seconds
2018-01-04 23:17:13,248: Using redshift connection "parsely_users".
2018-01-04 23:17:13,248: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:17:13,270: SQL status: SELECT in 0.02 seconds
2018-01-04 23:17:13,272: Using redshift connection "parsely_users".
2018-01-04 23:17:13,272: On parsely_users: BEGIN
2018-01-04 23:17:13,274: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:17:13,274: Using redshift connection "parsely_users".
2018-01-04 23:17:13,274: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:17:15,468: SQL status: SELECT in 2.19 seconds
2018-01-04 23:17:15,468: Using redshift connection "parsely_users".
2018-01-04 23:17:15,468: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 23:17:15,654: SQL status: SELECT in 0.19 seconds
2018-01-04 23:17:15,654: Using redshift connection "parsely_users".
2018-01-04 23:17:15,654: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:17:15,769: SQL status: SELECT in 0.11 seconds
2018-01-04 23:17:15,769: Using redshift connection "parsely_users".
2018-01-04 23:17:15,769: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:17:15,884: SQL status: SELECT in 0.11 seconds
2018-01-04 23:17:15,885: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 23:17:15,886: Using redshift connection "parsely_users".
2018-01-04 23:17:15,886: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 23:17:16,179: SQL status: INSERT 0 53666 in 0.29 seconds
2018-01-04 23:17:16,179: On parsely_users: COMMIT
2018-01-04 23:17:16,180: Using redshift connection "parsely_users".
2018-01-04 23:17:16,180: On parsely_users: COMMIT
2018-01-04 23:17:16,656: SQL status: COMMIT in 0.48 seconds
2018-01-04 23:17:16,656: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06119d0>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:17:16,684: 23:17:16 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 53666 in 3.50s]
2018-01-04 23:17:16,685: 23:17:16 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 23:17:16,685: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 23:17:16,717: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 23:17:16,718: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:17:16,719: Re-using an available connection from the pool.
2018-01-04 23:17:16,719: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:17:16,719: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:17:16,741: SQL status: SELECT in 0.02 seconds
2018-01-04 23:17:16,743: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 23:17:16,744: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:17:16,744: On parsely_pageview_engagedtime: BEGIN
2018-01-04 23:17:16,746: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:17:16,746: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:17:16,747: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 23:17:19,134: SQL status: CREATE VIEW in 2.39 seconds
2018-01-04 23:17:19,134: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:17:19,135: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 23:17:19,481: SQL status: ALTER TABLE in 0.35 seconds
2018-01-04 23:17:19,482: On parsely_pageview_engagedtime: COMMIT
2018-01-04 23:17:19,482: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:17:19,482: On parsely_pageview_engagedtime: COMMIT
2018-01-04 23:17:19,830: SQL status: COMMIT in 0.35 seconds
2018-01-04 23:17:19,830: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0666d50>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:17:19,864: 23:17:19 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 3.15s]
2018-01-04 23:17:19,865: 23:17:19 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 23:17:19,865: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 23:17:19,874: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 23:17:19,875: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 23:17:19,875: Re-using an available connection from the pool.
2018-01-04 23:17:19,876: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:17:19,876: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:17:19,898: SQL status: SELECT in 0.02 seconds
2018-01-04 23:17:19,900: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 23:17:19,901: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:17:19,901: On parsely_incoming_sessions: BEGIN
2018-01-04 23:17:19,903: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:17:19,903: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:17:19,904: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 23:17:20,256: SQL status: CREATE VIEW in 0.35 seconds
2018-01-04 23:17:20,256: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:17:20,256: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 23:17:20,259: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:17:20,260: On parsely_incoming_sessions: COMMIT
2018-01-04 23:17:20,260: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:17:20,260: On parsely_incoming_sessions: COMMIT
2018-01-04 23:17:20,439: SQL status: COMMIT in 0.18 seconds
2018-01-04 23:17:20,439: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06a0990>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:17:20,470: 23:17:20 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.57s]
2018-01-04 23:17:20,470: 23:17:20 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 23:17:20,471: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 23:17:20,480: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 23:17:20,482: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:17:20,482: Re-using an available connection from the pool.
2018-01-04 23:17:20,482: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:17:20,482: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:17:20,504: SQL status: SELECT in 0.02 seconds
2018-01-04 23:17:20,504: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:17:20,504: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:17:20,525: SQL status: SELECT in 0.02 seconds
2018-01-04 23:17:20,527: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:17:20,527: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 23:17:20,529: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:17:20,529: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:17:20,529: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:19:31,829: SQL status: SELECT in 131.30 seconds
2018-01-04 23:19:31,830: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:19:31,830: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 23:19:32,084: SQL status: SELECT in 0.25 seconds
2018-01-04 23:19:32,085: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:19:32,085: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:19:32,203: SQL status: SELECT in 0.12 seconds
2018-01-04 23:19:32,204: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:19:32,204: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:19:32,323: SQL status: SELECT in 0.12 seconds
2018-01-04 23:19:32,327: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 23:19:32,328: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:19:32,328: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 23:19:35,589: SQL status: INSERT 0 109807 in 3.26 seconds
2018-01-04 23:19:35,589: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 23:19:35,589: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:19:35,590: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 23:19:36,875: SQL status: COMMIT in 1.28 seconds
2018-01-04 23:19:36,875: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06a0990>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:19:36,955: 23:19:36 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 109807 in 136.40s]
2018-01-04 23:19:36,956: 23:19:36 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 23:19:36,956: Compiling model.parsely.parsely_sessions
2018-01-04 23:19:36,962: Acquiring new redshift connection "parsely_sessions".
2018-01-04 23:19:36,963: Re-using an available connection from the pool.
2018-01-04 23:19:36,963: Using redshift connection "parsely_sessions".
2018-01-04 23:19:36,963: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:19:36,985: SQL status: SELECT in 0.02 seconds
2018-01-04 23:19:36,988: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 23:19:36,990: Using redshift connection "parsely_sessions".
2018-01-04 23:19:36,990: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:19:37,010: SQL status: SELECT in 0.02 seconds
2018-01-04 23:19:37,011: Using redshift connection "parsely_sessions".
2018-01-04 23:19:37,011: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:19:37,031: SQL status: SELECT in 0.02 seconds
2018-01-04 23:19:37,035: Using redshift connection "parsely_sessions".
2018-01-04 23:19:37,035: On parsely_sessions: BEGIN
2018-01-04 23:19:37,037: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:19:37,037: Using redshift connection "parsely_sessions".
2018-01-04 23:19:37,037: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:20:06,156: SQL status: SELECT in 29.12 seconds
2018-01-04 23:20:06,157: Using redshift connection "parsely_sessions".
2018-01-04 23:20:06,157: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 23:20:06,347: SQL status: SELECT in 0.19 seconds
2018-01-04 23:20:06,348: Using redshift connection "parsely_sessions".
2018-01-04 23:20:06,348: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:20:06,469: SQL status: SELECT in 0.12 seconds
2018-01-04 23:20:06,471: Using redshift connection "parsely_sessions".
2018-01-04 23:20:06,471: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:20:06,590: SQL status: SELECT in 0.12 seconds
2018-01-04 23:20:06,593: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 23:20:06,594: Using redshift connection "parsely_sessions".
2018-01-04 23:20:06,594: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 23:20:08,436: SQL status: INSERT 0 89232 in 1.84 seconds
2018-01-04 23:20:08,437: On parsely_sessions: COMMIT
2018-01-04 23:20:08,437: Using redshift connection "parsely_sessions".
2018-01-04 23:20:08,437: On parsely_sessions: COMMIT
2018-01-04 23:20:10,951: SQL status: COMMIT in 2.51 seconds
2018-01-04 23:20:10,951: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b0611110>], 'label': '84371fae-261a-4490-8c30-af90740ace4a'}
2018-01-04 23:20:10,986: 23:20:10 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 89232 in 34.00s]
2018-01-04 23:20:11,040: Using redshift connection "master".
2018-01-04 23:20:11,040: On master: BEGIN
2018-01-04 23:20:11,043: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:20:11,043: On master: COMMIT
2018-01-04 23:20:11,043: Using redshift connection "master".
2018-01-04 23:20:11,043: On master: COMMIT
2018-01-04 23:20:11,045: SQL status: COMMIT in 0.00 seconds
2018-01-04 23:20:11,045: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 23:20:11,053: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 23:20:11,054: Using redshift connection "master".
2018-01-04 23:20:11,054: On master:  select 1 
2018-01-04 23:20:11,057: SQL status: SELECT in 0.00 seconds
2018-01-04 23:20:11,057: 23:20:11 | 
2018-01-04 23:20:11,057: 23:20:11 | Finished running 10 view models, 15 incremental models in 1093.66s.
2018-01-04 23:20:11,058: 
2018-01-04 23:20:11,058: Completed successfully
2018-01-04 23:20:11,058: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 23:20:11,059: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06b9e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06b9f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc7b06a0950>], 'label': 'end'}
2018-01-04 23:20:11,096: Flushing usage events
2018-01-04 23:20:18,922: Tracking: tracking
2018-01-04 23:20:18,923: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b98e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b98f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b98ed0>], 'label': 'start'}
2018-01-04 23:20:18,970: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 23:20:19,001: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 23:20:19,003: Parsing core.sql
2018-01-04 23:20:19,018: Parsing etc/get_custom_schema.sql
2018-01-04 23:20:19,023: Parsing schema_tests/relationships.sql
2018-01-04 23:20:19,026: Parsing schema_tests/accepted_values.sql
2018-01-04 23:20:19,029: Parsing schema_tests/not_null.sql
2018-01-04 23:20:19,030: Parsing schema_tests/unique.sql
2018-01-04 23:20:19,033: Parsing materializations/wrapper.sql
2018-01-04 23:20:19,038: Parsing materializations/archive.sql
2018-01-04 23:20:19,090: Parsing materializations/table.sql
2018-01-04 23:20:19,123: Parsing materializations/helpers.sql
2018-01-04 23:20:19,142: Parsing materializations/bigquery.sql
2018-01-04 23:20:19,157: Parsing materializations/view.sql
2018-01-04 23:20:19,182: Parsing materializations/incremental.sql
2018-01-04 23:20:19,229: Parsing adapters/redshift.sql
2018-01-04 23:20:19,260: Parsing adapters/bigquery.sql
2018-01-04 23:20:19,268: Parsing adapters/postgres.sql
2018-01-04 23:20:19,270: Parsing adapters/common.sql
2018-01-04 23:20:19,300: Parsing model.parsely.parsely_audit
2018-01-04 23:20:19,302: Parsing model.parsely.parsely_video_content
2018-01-04 23:20:19,307: Parsing model.parsely.parsely_post_content
2018-01-04 23:20:19,313: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 23:20:19,318: Parsing model.parsely.parsely_rawdata
2018-01-04 23:20:19,322: Parsing model.parsely.calendar
2018-01-04 23:20:19,325: Parsing model.parsely.parsely_all_events
2018-01-04 23:20:19,340: Acquiring new redshift connection "parsely_all_events".
2018-01-04 23:20:19,340: Opening a new connection (0 currently allocated)
2018-01-04 23:20:19,354: Using redshift connection "parsely_all_events".
2018-01-04 23:20:19,354: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:19,380: SQL status: SELECT in 0.03 seconds
2018-01-04 23:20:19,390: Parsing model.parsely.parsely_event_ids
2018-01-04 23:20:19,394: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 23:20:19,398: Parsing model.parsely.parsely_base_events
2018-01-04 23:20:19,405: Acquiring new redshift connection "parsely_base_events".
2018-01-04 23:20:19,405: Re-using an available connection from the pool.
2018-01-04 23:20:19,405: Using redshift connection "parsely_base_events".
2018-01-04 23:20:19,405: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:19,425: SQL status: SELECT in 0.02 seconds
2018-01-04 23:20:19,427: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 23:20:19,437: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 23:20:19,442: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 23:20:19,444: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 23:20:19,446: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 23:20:19,449: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 23:20:19,455: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 23:20:19,464: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 23:20:19,474: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:20:19,474: Re-using an available connection from the pool.
2018-01-04 23:20:19,474: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:20:19,474: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:19,494: SQL status: SELECT in 0.02 seconds
2018-01-04 23:20:19,495: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 23:20:19,507: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 23:20:19,516: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:20:19,516: Re-using an available connection from the pool.
2018-01-04 23:20:19,516: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:20:19,517: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:19,538: SQL status: SELECT in 0.02 seconds
2018-01-04 23:20:19,540: Parsing model.parsely.parsely_incoming_users
2018-01-04 23:20:19,545: Parsing model.parsely.parsely_users
2018-01-04 23:20:19,554: Acquiring new redshift connection "parsely_users".
2018-01-04 23:20:19,554: Re-using an available connection from the pool.
2018-01-04 23:20:19,554: Using redshift connection "parsely_users".
2018-01-04 23:20:19,554: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:19,575: SQL status: SELECT in 0.02 seconds
2018-01-04 23:20:19,576: Parsing model.parsely.parsely_errors
2018-01-04 23:20:19,583: Parsing model.parsely.parsely_bot_traffic
2018-01-04 23:20:19,591: Parsing model.parsely.parsely_custom_events
2018-01-04 23:20:19,599: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 23:20:19,605: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 23:20:19,610: Parsing model.parsely.parsely_sessions
2018-01-04 23:20:19,617: Acquiring new redshift connection "parsely_sessions".
2018-01-04 23:20:19,617: Re-using an available connection from the pool.
2018-01-04 23:20:19,617: Using redshift connection "parsely_sessions".
2018-01-04 23:20:19,617: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:19,638: SQL status: SELECT in 0.02 seconds
2018-01-04 23:20:19,639: Parsing model.parsely.parsely_campaigns
2018-01-04 23:20:19,646: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 23:20:19,646: Re-using an available connection from the pool.
2018-01-04 23:20:19,646: Using redshift connection "parsely_campaigns".
2018-01-04 23:20:19,646: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:19,668: SQL status: SELECT in 0.02 seconds
2018-01-04 23:20:19,673: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 23:20:19,688: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 23:20:19,702: 
2018-01-04 23:20:19,706: Acquiring new redshift connection "master".
2018-01-04 23:20:19,706: Re-using an available connection from the pool.
2018-01-04 23:20:19,707: Using redshift connection "master".
2018-01-04 23:20:19,707: On master: select distinct nspname from pg_namespace
2018-01-04 23:20:19,709: SQL status: SELECT in 0.00 seconds
2018-01-04 23:20:19,714: Using redshift connection "master".
2018-01-04 23:20:19,714: On master: BEGIN
2018-01-04 23:20:19,716: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:20:19,716: On master: COMMIT
2018-01-04 23:20:19,716: Using redshift connection "master".
2018-01-04 23:20:19,716: On master: COMMIT
2018-01-04 23:20:19,717: SQL status: COMMIT in 0.00 seconds
2018-01-04 23:20:19,723: 23:20:19 | Concurrency: 1 threads (target='dev')
2018-01-04 23:20:19,723: 23:20:19 | 
2018-01-04 23:20:19,723: Using redshift connection "master".
2018-01-04 23:20:19,723: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:19,746: SQL status: SELECT in 0.02 seconds
2018-01-04 23:20:19,843: 23:20:19 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 23:20:19,843: Compiling model.parsely.calendar
2018-01-04 23:20:19,851: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 23:20:19,853: Acquiring new redshift connection "calendar".
2018-01-04 23:20:19,853: Opening a new connection (1 currently allocated)
2018-01-04 23:20:19,866: Using redshift connection "calendar".
2018-01-04 23:20:19,866: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:19,893: SQL status: SELECT in 0.03 seconds
2018-01-04 23:20:19,896: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 23:20:19,897: Using redshift connection "calendar".
2018-01-04 23:20:19,897: On calendar: BEGIN
2018-01-04 23:20:19,899: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:20:19,899: Using redshift connection "calendar".
2018-01-04 23:20:19,900: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 23:20:19,952: SQL status: CREATE VIEW in 0.05 seconds
2018-01-04 23:20:19,953: On calendar: COMMIT
2018-01-04 23:20:19,953: Using redshift connection "calendar".
2018-01-04 23:20:19,953: On calendar: COMMIT
2018-01-04 23:20:20,181: SQL status: COMMIT in 0.23 seconds
2018-01-04 23:20:20,181: Using redshift connection "calendar".
2018-01-04 23:20:20,181: On calendar: BEGIN
2018-01-04 23:20:20,183: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:20:20,183: Using redshift connection "calendar".
2018-01-04 23:20:20,183: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 23:20:20,191: SQL status: DROP VIEW in 0.01 seconds
2018-01-04 23:20:20,191: On calendar: COMMIT
2018-01-04 23:20:20,191: Using redshift connection "calendar".
2018-01-04 23:20:20,191: On calendar: COMMIT
2018-01-04 23:20:20,540: SQL status: COMMIT in 0.35 seconds
2018-01-04 23:20:20,541: Using redshift connection "calendar".
2018-01-04 23:20:20,541: On calendar: BEGIN
2018-01-04 23:20:20,543: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:20:20,543: Using redshift connection "calendar".
2018-01-04 23:20:20,543: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 23:20:20,630: SQL status: ALTER TABLE in 0.09 seconds
2018-01-04 23:20:20,630: On calendar: COMMIT
2018-01-04 23:20:20,631: Using redshift connection "calendar".
2018-01-04 23:20:20,631: On calendar: COMMIT
2018-01-04 23:20:21,334: SQL status: COMMIT in 0.70 seconds
2018-01-04 23:20:21,335: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2a86bd0>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:20:21,378: 23:20:21 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.49s]
2018-01-04 23:20:21,378: 23:20:21 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 23:20:21,378: Compiling model.parsely.parsely_rawdata
2018-01-04 23:20:21,388: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 23:20:21,390: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 23:20:21,390: Re-using an available connection from the pool.
2018-01-04 23:20:21,390: Using redshift connection "parsely_rawdata".
2018-01-04 23:20:21,391: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:21,410: SQL status: SELECT in 0.02 seconds
2018-01-04 23:20:21,411: Using redshift connection "parsely_rawdata".
2018-01-04 23:20:21,411: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:20:21,421: SQL status: SELECT in 0.01 seconds
2018-01-04 23:20:21,422: Using redshift connection "parsely_rawdata".
2018-01-04 23:20:21,422: On parsely_rawdata: BEGIN
2018-01-04 23:20:21,424: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:20:21,424: Using redshift connection "parsely_rawdata".
2018-01-04 23:20:21,425: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:20:51,720: SQL status: SELECT in 30.30 seconds
2018-01-04 23:20:51,721: Using redshift connection "parsely_rawdata".
2018-01-04 23:20:51,725: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 23:20:51,964: SQL status: SELECT in 0.24 seconds
2018-01-04 23:20:51,964: Using redshift connection "parsely_rawdata".
2018-01-04 23:20:51,965: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:20:52,070: SQL status: SELECT in 0.11 seconds
2018-01-04 23:20:52,071: Using redshift connection "parsely_rawdata".
2018-01-04 23:20:52,071: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:20:52,175: SQL status: SELECT in 0.10 seconds
2018-01-04 23:20:52,178: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 23:20:52,180: Using redshift connection "parsely_rawdata".
2018-01-04 23:20:52,180: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 23:21:24,754: SQL status: INSERT 0 1037001 in 32.57 seconds
2018-01-04 23:21:24,754: On parsely_rawdata: COMMIT
2018-01-04 23:21:24,754: Using redshift connection "parsely_rawdata".
2018-01-04 23:21:24,755: On parsely_rawdata: COMMIT
2018-01-04 23:21:26,996: SQL status: COMMIT in 2.24 seconds
2018-01-04 23:21:26,997: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2af0b10>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:21:27,095: 23:21:27 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1037001 in 65.62s]
2018-01-04 23:21:27,096: 23:21:27 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 23:21:27,096: Compiling model.parsely.parsely_all_events
2018-01-04 23:21:27,105: Acquiring new redshift connection "parsely_all_events".
2018-01-04 23:21:27,105: Re-using an available connection from the pool.
2018-01-04 23:21:27,105: Using redshift connection "parsely_all_events".
2018-01-04 23:21:27,105: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:21:27,121: SQL status: SELECT in 0.02 seconds
2018-01-04 23:21:27,129: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 23:21:27,130: Using redshift connection "parsely_all_events".
2018-01-04 23:21:27,131: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:21:27,145: SQL status: SELECT in 0.01 seconds
2018-01-04 23:21:27,145: Using redshift connection "parsely_all_events".
2018-01-04 23:21:27,145: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:21:27,159: SQL status: SELECT in 0.01 seconds
2018-01-04 23:21:27,161: Using redshift connection "parsely_all_events".
2018-01-04 23:21:27,161: On parsely_all_events: BEGIN
2018-01-04 23:21:27,163: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:21:27,163: Using redshift connection "parsely_all_events".
2018-01-04 23:21:27,163: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:23:37,689: SQL status: SELECT in 130.53 seconds
2018-01-04 23:23:37,689: Using redshift connection "parsely_all_events".
2018-01-04 23:23:37,689: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 23:23:37,837: SQL status: SELECT in 0.15 seconds
2018-01-04 23:23:37,837: Using redshift connection "parsely_all_events".
2018-01-04 23:23:37,837: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:23:37,946: SQL status: SELECT in 0.11 seconds
2018-01-04 23:23:37,946: Using redshift connection "parsely_all_events".
2018-01-04 23:23:37,947: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:23:38,055: SQL status: SELECT in 0.11 seconds
2018-01-04 23:23:38,059: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 23:23:38,060: Using redshift connection "parsely_all_events".
2018-01-04 23:23:38,060: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 23:23:55,155: SQL status: INSERT 0 921509 in 17.10 seconds
2018-01-04 23:23:55,156: On parsely_all_events: COMMIT
2018-01-04 23:23:55,156: Using redshift connection "parsely_all_events".
2018-01-04 23:23:55,156: On parsely_all_events: COMMIT
2018-01-04 23:23:57,307: SQL status: COMMIT in 2.15 seconds
2018-01-04 23:23:57,308: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b45810>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:23:57,348: 23:23:57 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 921509 in 150.21s]
2018-01-04 23:23:57,349: 23:23:57 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 23:23:57,349: Compiling model.parsely.parsely_bot_traffic
2018-01-04 23:23:57,356: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 23:23:57,358: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 23:23:57,358: Re-using an available connection from the pool.
2018-01-04 23:23:57,358: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:23:57,358: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:23:57,374: SQL status: SELECT in 0.02 seconds
2018-01-04 23:23:57,375: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:23:57,375: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:23:57,389: SQL status: SELECT in 0.01 seconds
2018-01-04 23:23:57,390: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:23:57,390: On parsely_bot_traffic: BEGIN
2018-01-04 23:23:57,392: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:23:57,392: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:23:57,392: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:24:55,424: SQL status: SELECT in 58.03 seconds
2018-01-04 23:24:55,425: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:24:55,425: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 23:24:55,563: SQL status: SELECT in 0.14 seconds
2018-01-04 23:24:55,563: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:24:55,563: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:24:55,674: SQL status: SELECT in 0.11 seconds
2018-01-04 23:24:55,675: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:24:55,675: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:24:55,782: SQL status: SELECT in 0.11 seconds
2018-01-04 23:24:55,785: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 23:24:55,787: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:24:55,787: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 23:24:56,854: SQL status: INSERT 0 4 in 1.07 seconds
2018-01-04 23:24:56,855: On parsely_bot_traffic: COMMIT
2018-01-04 23:24:56,855: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:24:56,855: On parsely_bot_traffic: COMMIT
2018-01-04 23:24:57,997: SQL status: COMMIT in 1.14 seconds
2018-01-04 23:24:57,998: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2a86c90>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:24:58,072: 23:24:58 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 60.65s]
2018-01-04 23:24:58,073: 23:24:58 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 23:24:58,073: Compiling model.parsely.parsely_custom_events
2018-01-04 23:24:58,081: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 23:24:58,083: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 23:24:58,083: Re-using an available connection from the pool.
2018-01-04 23:24:58,083: Using redshift connection "parsely_custom_events".
2018-01-04 23:24:58,083: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:24:58,097: SQL status: SELECT in 0.01 seconds
2018-01-04 23:24:58,098: Using redshift connection "parsely_custom_events".
2018-01-04 23:24:58,098: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:24:58,110: SQL status: SELECT in 0.01 seconds
2018-01-04 23:24:58,112: Using redshift connection "parsely_custom_events".
2018-01-04 23:24:58,112: On parsely_custom_events: BEGIN
2018-01-04 23:24:58,114: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:24:58,114: Using redshift connection "parsely_custom_events".
2018-01-04 23:24:58,114: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:25:58,827: SQL status: SELECT in 60.71 seconds
2018-01-04 23:25:58,827: Using redshift connection "parsely_custom_events".
2018-01-04 23:25:58,827: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 23:25:58,968: SQL status: SELECT in 0.14 seconds
2018-01-04 23:25:58,969: Using redshift connection "parsely_custom_events".
2018-01-04 23:25:58,969: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:25:59,088: SQL status: SELECT in 0.12 seconds
2018-01-04 23:25:59,089: Using redshift connection "parsely_custom_events".
2018-01-04 23:25:59,089: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:25:59,200: SQL status: SELECT in 0.11 seconds
2018-01-04 23:25:59,204: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 23:25:59,205: Using redshift connection "parsely_custom_events".
2018-01-04 23:25:59,205: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 23:25:59,465: SQL status: INSERT 0 0 in 0.26 seconds
2018-01-04 23:25:59,465: On parsely_custom_events: COMMIT
2018-01-04 23:25:59,465: Using redshift connection "parsely_custom_events".
2018-01-04 23:25:59,465: On parsely_custom_events: COMMIT
2018-01-04 23:26:00,161: SQL status: COMMIT in 0.70 seconds
2018-01-04 23:26:00,161: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2a86c90>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:26:00,201: 23:26:00 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 62.09s]
2018-01-04 23:26:00,202: 23:26:00 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 23:26:00,202: Compiling model.parsely.parsely_errors
2018-01-04 23:26:00,209: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 23:26:00,211: Acquiring new redshift connection "parsely_errors".
2018-01-04 23:26:00,211: Re-using an available connection from the pool.
2018-01-04 23:26:00,211: Using redshift connection "parsely_errors".
2018-01-04 23:26:00,211: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:26:00,226: SQL status: SELECT in 0.01 seconds
2018-01-04 23:26:00,226: Using redshift connection "parsely_errors".
2018-01-04 23:26:00,226: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:26:00,240: SQL status: SELECT in 0.01 seconds
2018-01-04 23:26:00,242: Using redshift connection "parsely_errors".
2018-01-04 23:26:00,242: On parsely_errors: BEGIN
2018-01-04 23:26:00,244: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:26:00,244: Using redshift connection "parsely_errors".
2018-01-04 23:26:00,244: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:27:00,350: SQL status: SELECT in 60.11 seconds
2018-01-04 23:27:00,350: Using redshift connection "parsely_errors".
2018-01-04 23:27:00,350: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 23:27:00,569: SQL status: SELECT in 0.22 seconds
2018-01-04 23:27:00,569: Using redshift connection "parsely_errors".
2018-01-04 23:27:00,570: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:27:00,685: SQL status: SELECT in 0.12 seconds
2018-01-04 23:27:00,686: Using redshift connection "parsely_errors".
2018-01-04 23:27:00,686: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:27:00,798: SQL status: SELECT in 0.11 seconds
2018-01-04 23:27:00,805: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 23:27:00,807: Using redshift connection "parsely_errors".
2018-01-04 23:27:00,807: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 23:27:01,486: SQL status: INSERT 0 2 in 0.68 seconds
2018-01-04 23:27:01,487: On parsely_errors: COMMIT
2018-01-04 23:27:01,487: Using redshift connection "parsely_errors".
2018-01-04 23:27:01,487: On parsely_errors: COMMIT
2018-01-04 23:27:02,400: SQL status: COMMIT in 0.91 seconds
2018-01-04 23:27:02,401: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2a7cf10>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:27:02,447: 23:27:02 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 62.20s]
2018-01-04 23:27:02,448: 23:27:02 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 23:27:02,448: Compiling model.parsely.parsely_base_events
2018-01-04 23:27:02,452: Acquiring new redshift connection "parsely_base_events".
2018-01-04 23:27:02,452: Re-using an available connection from the pool.
2018-01-04 23:27:02,452: Using redshift connection "parsely_base_events".
2018-01-04 23:27:02,452: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:02,467: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:02,470: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 23:27:02,472: Using redshift connection "parsely_base_events".
2018-01-04 23:27:02,472: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:02,486: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:02,487: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 23:27:02,488: Using redshift connection "parsely_base_events".
2018-01-04 23:27:02,489: On parsely_base_events: BEGIN
2018-01-04 23:27:02,491: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:27:02,491: Using redshift connection "parsely_base_events".
2018-01-04 23:27:02,491: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 23:27:03,258: SQL status: CREATE VIEW in 0.77 seconds
2018-01-04 23:27:03,259: On parsely_base_events: COMMIT
2018-01-04 23:27:03,259: Using redshift connection "parsely_base_events".
2018-01-04 23:27:03,259: On parsely_base_events: COMMIT
2018-01-04 23:27:03,732: SQL status: COMMIT in 0.47 seconds
2018-01-04 23:27:03,733: Using redshift connection "parsely_base_events".
2018-01-04 23:27:03,733: On parsely_base_events: BEGIN
2018-01-04 23:27:03,735: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:27:03,735: Using redshift connection "parsely_base_events".
2018-01-04 23:27:03,735: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 23:27:03,909: SQL status: DROP VIEW in 0.17 seconds
2018-01-04 23:27:03,909: On parsely_base_events: COMMIT
2018-01-04 23:27:03,910: Using redshift connection "parsely_base_events".
2018-01-04 23:27:03,910: On parsely_base_events: COMMIT
2018-01-04 23:27:04,077: SQL status: COMMIT in 0.17 seconds
2018-01-04 23:27:04,077: Using redshift connection "parsely_base_events".
2018-01-04 23:27:04,077: On parsely_base_events: BEGIN
2018-01-04 23:27:04,080: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:27:04,080: Using redshift connection "parsely_base_events".
2018-01-04 23:27:04,080: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 23:27:04,086: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 23:27:04,086: On parsely_base_events: COMMIT
2018-01-04 23:27:04,086: Using redshift connection "parsely_base_events".
2018-01-04 23:27:04,086: On parsely_base_events: COMMIT
2018-01-04 23:27:04,260: SQL status: COMMIT in 0.17 seconds
2018-01-04 23:27:04,261: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2af09d0>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:27:04,290: 23:27:04 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 1.81s]
2018-01-04 23:27:04,291: 23:27:04 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 23:27:04,291: Compiling model.parsely.parsely_event_ids
2018-01-04 23:27:04,296: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 23:27:04,299: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 23:27:04,299: Re-using an available connection from the pool.
2018-01-04 23:27:04,299: Using redshift connection "parsely_event_ids".
2018-01-04 23:27:04,299: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:04,315: SQL status: SELECT in 0.02 seconds
2018-01-04 23:27:04,315: Using redshift connection "parsely_event_ids".
2018-01-04 23:27:04,315: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:04,330: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:04,330: Using redshift connection "parsely_event_ids".
2018-01-04 23:27:04,331: On parsely_event_ids: BEGIN
2018-01-04 23:27:04,333: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:27:04,333: Using redshift connection "parsely_event_ids".
2018-01-04 23:27:04,333: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:27:05,761: SQL status: SELECT in 1.43 seconds
2018-01-04 23:27:05,761: Using redshift connection "parsely_event_ids".
2018-01-04 23:27:05,761: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 23:27:05,923: SQL status: SELECT in 0.16 seconds
2018-01-04 23:27:05,923: Using redshift connection "parsely_event_ids".
2018-01-04 23:27:05,923: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:27:06,032: SQL status: SELECT in 0.11 seconds
2018-01-04 23:27:06,032: Using redshift connection "parsely_event_ids".
2018-01-04 23:27:06,032: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:27:06,138: SQL status: SELECT in 0.11 seconds
2018-01-04 23:27:06,139: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 23:27:06,140: Using redshift connection "parsely_event_ids".
2018-01-04 23:27:06,140: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 23:27:07,685: SQL status: INSERT 0 921505 in 1.54 seconds
2018-01-04 23:27:07,686: On parsely_event_ids: COMMIT
2018-01-04 23:27:07,686: Using redshift connection "parsely_event_ids".
2018-01-04 23:27:07,686: On parsely_event_ids: COMMIT
2018-01-04 23:27:08,209: SQL status: COMMIT in 0.52 seconds
2018-01-04 23:27:08,210: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2a9df10>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:27:08,239: 23:27:08 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 921505 in 3.92s]
2018-01-04 23:27:08,240: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 23:27:08,247: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 23:27:08,249: 23:27:08 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 23:27:08,249: Compiling model.parsely.parsely_post_content
2018-01-04 23:27:08,255: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 23:27:08,257: Acquiring new redshift connection "parsely_post_content".
2018-01-04 23:27:08,257: Re-using an available connection from the pool.
2018-01-04 23:27:08,257: Using redshift connection "parsely_post_content".
2018-01-04 23:27:08,257: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:08,271: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:08,272: Using redshift connection "parsely_post_content".
2018-01-04 23:27:08,272: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:08,285: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:08,287: Using redshift connection "parsely_post_content".
2018-01-04 23:27:08,287: On parsely_post_content: BEGIN
2018-01-04 23:27:08,289: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:27:08,289: Using redshift connection "parsely_post_content".
2018-01-04 23:27:08,289: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:27:20,335: SQL status: SELECT in 12.05 seconds
2018-01-04 23:27:20,335: Using redshift connection "parsely_post_content".
2018-01-04 23:27:20,336: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 23:27:20,538: SQL status: SELECT in 0.20 seconds
2018-01-04 23:27:20,538: Using redshift connection "parsely_post_content".
2018-01-04 23:27:20,538: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:27:20,647: SQL status: SELECT in 0.11 seconds
2018-01-04 23:27:20,648: Using redshift connection "parsely_post_content".
2018-01-04 23:27:20,648: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:27:20,753: SQL status: SELECT in 0.11 seconds
2018-01-04 23:27:20,754: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 23:27:20,755: Using redshift connection "parsely_post_content".
2018-01-04 23:27:20,756: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 23:27:21,111: SQL status: INSERT 0 887 in 0.36 seconds
2018-01-04 23:27:21,112: On parsely_post_content: COMMIT
2018-01-04 23:27:21,112: Using redshift connection "parsely_post_content".
2018-01-04 23:27:21,112: On parsely_post_content: COMMIT
2018-01-04 23:27:21,536: SQL status: COMMIT in 0.42 seconds
2018-01-04 23:27:21,536: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2ae7e10>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:27:21,657: 23:27:21 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 887 in 13.29s]
2018-01-04 23:27:21,657: 23:27:21 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 23:27:21,657: Compiling model.parsely.parsely_video_content
2018-01-04 23:27:21,663: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 23:27:21,665: Acquiring new redshift connection "parsely_video_content".
2018-01-04 23:27:21,665: Re-using an available connection from the pool.
2018-01-04 23:27:21,665: Using redshift connection "parsely_video_content".
2018-01-04 23:27:21,665: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:21,680: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:21,680: Using redshift connection "parsely_video_content".
2018-01-04 23:27:21,680: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:21,694: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:21,695: Using redshift connection "parsely_video_content".
2018-01-04 23:27:21,695: On parsely_video_content: BEGIN
2018-01-04 23:27:21,697: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:27:21,698: Using redshift connection "parsely_video_content".
2018-01-04 23:27:21,698: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:27:33,423: SQL status: SELECT in 11.73 seconds
2018-01-04 23:27:33,423: Using redshift connection "parsely_video_content".
2018-01-04 23:27:33,423: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 23:27:33,705: SQL status: SELECT in 0.28 seconds
2018-01-04 23:27:33,705: Using redshift connection "parsely_video_content".
2018-01-04 23:27:33,705: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:27:33,812: SQL status: SELECT in 0.11 seconds
2018-01-04 23:27:33,812: Using redshift connection "parsely_video_content".
2018-01-04 23:27:33,812: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:27:33,915: SQL status: SELECT in 0.10 seconds
2018-01-04 23:27:33,917: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 23:27:33,918: Using redshift connection "parsely_video_content".
2018-01-04 23:27:33,918: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 23:27:34,261: SQL status: INSERT 0 469 in 0.34 seconds
2018-01-04 23:27:34,261: On parsely_video_content: COMMIT
2018-01-04 23:27:34,261: Using redshift connection "parsely_video_content".
2018-01-04 23:27:34,261: On parsely_video_content: COMMIT
2018-01-04 23:27:34,646: SQL status: COMMIT in 0.38 seconds
2018-01-04 23:27:34,646: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2ae7e10>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:27:34,680: 23:27:34 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 469 in 12.99s]
2018-01-04 23:27:34,680: 23:27:34 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 23:27:34,681: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 23:27:34,687: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 23:27:34,688: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 23:27:34,688: Re-using an available connection from the pool.
2018-01-04 23:27:34,688: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:27:34,688: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:34,703: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:34,705: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 23:27:34,706: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:27:34,706: On parsely_entry_exit_urls: BEGIN
2018-01-04 23:27:34,708: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:27:34,708: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:27:34,708: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 23:27:34,763: SQL status: CREATE VIEW in 0.06 seconds
2018-01-04 23:27:34,764: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:27:34,764: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 23:27:34,767: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:27:34,767: On parsely_entry_exit_urls: COMMIT
2018-01-04 23:27:34,767: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:27:34,767: On parsely_entry_exit_urls: COMMIT
2018-01-04 23:27:34,971: SQL status: COMMIT in 0.20 seconds
2018-01-04 23:27:34,972: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b92210>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:27:35,003: 23:27:34 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.29s]
2018-01-04 23:27:35,003: 23:27:35 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 23:27:35,004: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 23:27:35,014: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 23:27:35,016: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 23:27:35,016: Re-using an available connection from the pool.
2018-01-04 23:27:35,016: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:27:35,016: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:35,031: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:35,034: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 23:27:35,035: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:27:35,036: On parsely_incoming_videoviews: BEGIN
2018-01-04 23:27:35,037: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:27:35,038: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:27:35,038: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 23:27:35,512: SQL status: CREATE VIEW in 0.47 seconds
2018-01-04 23:27:35,513: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:27:35,513: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 23:27:35,660: SQL status: ALTER TABLE in 0.15 seconds
2018-01-04 23:27:35,661: On parsely_incoming_videoviews: COMMIT
2018-01-04 23:27:35,661: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:27:35,661: On parsely_incoming_videoviews: COMMIT
2018-01-04 23:27:36,413: SQL status: COMMIT in 0.75 seconds
2018-01-04 23:27:36,413: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b92210>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:27:36,444: 23:27:36 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.41s]
2018-01-04 23:27:36,444: 23:27:36 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 23:27:36,445: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 23:27:36,450: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:27:36,450: Re-using an available connection from the pool.
2018-01-04 23:27:36,450: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:27:36,450: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:36,464: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:36,468: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 23:27:36,469: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:27:36,470: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:36,483: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:36,483: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:27:36,484: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:27:36,497: SQL status: SELECT in 0.01 seconds
2018-01-04 23:27:36,499: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:27:36,499: On parsely_videoviews_sessionized: BEGIN
2018-01-04 23:27:36,501: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:27:36,501: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:27:36,501: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:29:40,309: SQL status: SELECT in 123.81 seconds
2018-01-04 23:29:40,309: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:29:40,310: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 23:29:41,176: SQL status: SELECT in 0.87 seconds
2018-01-04 23:29:41,177: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:29:41,177: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:29:41,494: SQL status: SELECT in 0.32 seconds
2018-01-04 23:29:41,495: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:29:41,495: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:29:41,923: SQL status: SELECT in 0.43 seconds
2018-01-04 23:29:41,926: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 23:29:41,928: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:29:41,928: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 23:29:43,991: SQL status: INSERT 0 145 in 2.06 seconds
2018-01-04 23:29:43,992: On parsely_videoviews_sessionized: COMMIT
2018-01-04 23:29:43,992: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:29:43,992: On parsely_videoviews_sessionized: COMMIT
2018-01-04 23:29:45,552: SQL status: COMMIT in 1.56 seconds
2018-01-04 23:29:45,553: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2af0ed0>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:29:45,613: 23:29:45 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 145 in 129.11s]
2018-01-04 23:29:45,613: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 23:29:45,636: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 23:29:45,637: 23:29:45 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 23:29:45,638: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 23:29:45,651: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 23:29:45,652: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:29:45,652: Re-using an available connection from the pool.
2018-01-04 23:29:45,652: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:29:45,652: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:29:45,722: SQL status: SELECT in 0.07 seconds
2018-01-04 23:29:45,723: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 23:29:45,725: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:29:45,725: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 23:29:45,740: SQL status: BEGIN in 0.02 seconds
2018-01-04 23:29:45,741: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:29:45,741: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 23:29:46,671: SQL status: CREATE VIEW in 0.93 seconds
2018-01-04 23:29:46,672: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:29:46,672: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 23:29:46,693: SQL status: ALTER TABLE in 0.02 seconds
2018-01-04 23:29:46,693: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 23:29:46,693: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:29:46,693: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 23:29:47,506: SQL status: COMMIT in 0.81 seconds
2018-01-04 23:29:47,507: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2a862d0>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:29:47,535: 23:29:47 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.87s]
2018-01-04 23:29:47,536: 23:29:47 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 23:29:47,536: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 23:29:47,565: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 23:29:47,567: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:29:47,567: Re-using an available connection from the pool.
2018-01-04 23:29:47,567: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:29:47,567: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:29:47,582: SQL status: SELECT in 0.01 seconds
2018-01-04 23:29:47,585: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 23:29:47,586: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:29:47,586: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 23:29:47,588: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:29:47,588: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:29:47,588: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 23:29:47,684: SQL status: CREATE VIEW in 0.10 seconds
2018-01-04 23:29:47,684: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:29:47,685: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 23:29:47,690: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 23:29:47,690: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 23:29:47,690: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:29:47,690: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 23:29:47,915: SQL status: COMMIT in 0.22 seconds
2018-01-04 23:29:47,915: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2a7ca50>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:29:47,946: 23:29:47 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.38s]
2018-01-04 23:29:47,947: 23:29:47 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 23:29:47,947: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 23:29:47,958: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 23:29:47,960: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 23:29:47,960: Re-using an available connection from the pool.
2018-01-04 23:29:47,960: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:29:47,960: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:29:47,975: SQL status: SELECT in 0.01 seconds
2018-01-04 23:29:47,978: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 23:29:47,980: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:29:47,980: On parsely_incoming_pageviews: BEGIN
2018-01-04 23:29:47,982: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:29:47,982: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:29:47,982: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 23:29:48,600: SQL status: CREATE VIEW in 0.62 seconds
2018-01-04 23:29:48,600: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:29:48,600: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 23:29:48,605: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:29:48,606: On parsely_incoming_pageviews: COMMIT
2018-01-04 23:29:48,606: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:29:48,606: On parsely_incoming_pageviews: COMMIT
2018-01-04 23:29:49,203: SQL status: COMMIT in 0.60 seconds
2018-01-04 23:29:49,203: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b7f990>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:29:49,235: 23:29:49 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.26s]
2018-01-04 23:29:49,235: 23:29:49 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 23:29:49,235: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 23:29:49,240: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:29:49,241: Re-using an available connection from the pool.
2018-01-04 23:29:49,241: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:29:49,241: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:29:49,255: SQL status: SELECT in 0.01 seconds
2018-01-04 23:29:49,261: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 23:29:49,263: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:29:49,263: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:29:49,277: SQL status: SELECT in 0.01 seconds
2018-01-04 23:29:49,277: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:29:49,277: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:29:49,291: SQL status: SELECT in 0.01 seconds
2018-01-04 23:29:49,293: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:29:49,293: On parsely_pageviews_sessionized: BEGIN
2018-01-04 23:29:49,295: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:29:49,295: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:29:49,295: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:33:59,730: SQL status: SELECT in 250.43 seconds
2018-01-04 23:33:59,730: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:33:59,730: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 23:33:59,875: SQL status: SELECT in 0.14 seconds
2018-01-04 23:33:59,875: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:33:59,875: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:33:59,995: SQL status: SELECT in 0.12 seconds
2018-01-04 23:33:59,996: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:33:59,996: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:34:00,112: SQL status: SELECT in 0.12 seconds
2018-01-04 23:34:00,115: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 23:34:00,116: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:34:00,117: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 23:34:03,239: SQL status: INSERT 0 109979 in 3.12 seconds
2018-01-04 23:34:03,240: On parsely_pageviews_sessionized: COMMIT
2018-01-04 23:34:03,240: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:34:03,240: On parsely_pageviews_sessionized: COMMIT
2018-01-04 23:34:04,656: SQL status: COMMIT in 1.42 seconds
2018-01-04 23:34:04,656: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b45b90>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:34:04,753: 23:34:04 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 109979 in 255.42s]
2018-01-04 23:34:04,754: 23:34:04 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 23:34:04,754: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 23:34:04,796: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 23:34:04,798: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:34:04,798: Re-using an available connection from the pool.
2018-01-04 23:34:04,798: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:34:04,798: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:34:04,820: SQL status: SELECT in 0.02 seconds
2018-01-04 23:34:04,823: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 23:34:04,824: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:34:04,824: On parsely_videoview_engagedtime: BEGIN
2018-01-04 23:34:04,826: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:34:04,826: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:34:04,826: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 23:34:06,013: SQL status: CREATE VIEW in 1.19 seconds
2018-01-04 23:34:06,013: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:34:06,013: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 23:34:06,018: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:34:06,018: On parsely_videoview_engagedtime: COMMIT
2018-01-04 23:34:06,018: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:34:06,018: On parsely_videoview_engagedtime: COMMIT
2018-01-04 23:34:06,297: SQL status: COMMIT in 0.28 seconds
2018-01-04 23:34:06,297: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b45b90>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:34:06,327: 23:34:06 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.54s]
2018-01-04 23:34:06,327: 23:34:06 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 23:34:06,328: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 23:34:06,336: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 23:34:06,338: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:34:06,338: Re-using an available connection from the pool.
2018-01-04 23:34:06,338: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:34:06,338: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:34:06,360: SQL status: SELECT in 0.02 seconds
2018-01-04 23:34:06,360: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:34:06,360: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:34:06,379: SQL status: SELECT in 0.02 seconds
2018-01-04 23:34:06,381: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:34:06,381: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 23:34:06,383: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:34:06,383: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:34:06,384: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:37:16,173: SQL status: SELECT in 189.79 seconds
2018-01-04 23:37:16,174: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:37:16,174: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 23:37:16,400: SQL status: SELECT in 0.23 seconds
2018-01-04 23:37:16,400: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:37:16,400: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:37:16,516: SQL status: SELECT in 0.12 seconds
2018-01-04 23:37:16,517: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:37:16,517: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:37:16,633: SQL status: SELECT in 0.12 seconds
2018-01-04 23:37:16,637: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 23:37:16,638: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:37:16,638: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 23:37:17,707: SQL status: INSERT 0 144 in 1.07 seconds
2018-01-04 23:37:17,708: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 23:37:17,708: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:37:17,708: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 23:37:18,865: SQL status: COMMIT in 1.16 seconds
2018-01-04 23:37:18,866: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b7f990>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:37:18,928: 23:37:18 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 144 in 192.54s]
2018-01-04 23:37:18,928: 23:37:18 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 23:37:18,929: Compiling model.parsely.parsely_campaigns
2018-01-04 23:37:18,933: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 23:37:18,933: Re-using an available connection from the pool.
2018-01-04 23:37:18,933: Using redshift connection "parsely_campaigns".
2018-01-04 23:37:18,933: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:37:18,958: SQL status: SELECT in 0.02 seconds
2018-01-04 23:37:18,961: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 23:37:18,963: Using redshift connection "parsely_campaigns".
2018-01-04 23:37:18,963: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:37:18,982: SQL status: SELECT in 0.02 seconds
2018-01-04 23:37:18,983: Using redshift connection "parsely_campaigns".
2018-01-04 23:37:18,983: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:37:19,003: SQL status: SELECT in 0.02 seconds
2018-01-04 23:37:19,005: Using redshift connection "parsely_campaigns".
2018-01-04 23:37:19,005: On parsely_campaigns: BEGIN
2018-01-04 23:37:19,007: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:37:19,007: Using redshift connection "parsely_campaigns".
2018-01-04 23:37:19,007: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:37:20,225: SQL status: SELECT in 1.22 seconds
2018-01-04 23:37:20,225: Using redshift connection "parsely_campaigns".
2018-01-04 23:37:20,225: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 23:37:20,391: SQL status: SELECT in 0.17 seconds
2018-01-04 23:37:20,391: Using redshift connection "parsely_campaigns".
2018-01-04 23:37:20,391: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:37:20,505: SQL status: SELECT in 0.11 seconds
2018-01-04 23:37:20,505: Using redshift connection "parsely_campaigns".
2018-01-04 23:37:20,505: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:37:20,618: SQL status: SELECT in 0.11 seconds
2018-01-04 23:37:20,619: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 23:37:20,620: Using redshift connection "parsely_campaigns".
2018-01-04 23:37:20,620: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 23:37:20,763: SQL status: INSERT 0 390 in 0.14 seconds
2018-01-04 23:37:20,764: On parsely_campaigns: COMMIT
2018-01-04 23:37:20,764: Using redshift connection "parsely_campaigns".
2018-01-04 23:37:20,764: On parsely_campaigns: COMMIT
2018-01-04 23:37:21,656: SQL status: COMMIT in 0.89 seconds
2018-01-04 23:37:21,657: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b7f990>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:37:21,684: 23:37:21 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 390 in 2.73s]
2018-01-04 23:37:21,684: Compiling model.parsely.parsely_incoming_users
2018-01-04 23:37:21,690: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 23:37:21,692: 23:37:21 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 23:37:21,692: Compiling model.parsely.parsely_users
2018-01-04 23:37:21,697: Acquiring new redshift connection "parsely_users".
2018-01-04 23:37:21,697: Re-using an available connection from the pool.
2018-01-04 23:37:21,698: Using redshift connection "parsely_users".
2018-01-04 23:37:21,698: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:37:21,719: SQL status: SELECT in 0.02 seconds
2018-01-04 23:37:21,761: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 23:37:21,763: Using redshift connection "parsely_users".
2018-01-04 23:37:21,763: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:37:21,784: SQL status: SELECT in 0.02 seconds
2018-01-04 23:37:21,784: Using redshift connection "parsely_users".
2018-01-04 23:37:21,784: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:37:21,802: SQL status: SELECT in 0.02 seconds
2018-01-04 23:37:21,805: Using redshift connection "parsely_users".
2018-01-04 23:37:21,805: On parsely_users: BEGIN
2018-01-04 23:37:21,807: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:37:21,807: Using redshift connection "parsely_users".
2018-01-04 23:37:21,810: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:37:24,385: SQL status: SELECT in 2.57 seconds
2018-01-04 23:37:24,386: Using redshift connection "parsely_users".
2018-01-04 23:37:24,386: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 23:37:24,836: SQL status: SELECT in 0.45 seconds
2018-01-04 23:37:24,836: Using redshift connection "parsely_users".
2018-01-04 23:37:24,837: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:37:24,954: SQL status: SELECT in 0.12 seconds
2018-01-04 23:37:24,954: Using redshift connection "parsely_users".
2018-01-04 23:37:24,954: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:37:25,068: SQL status: SELECT in 0.11 seconds
2018-01-04 23:37:25,070: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 23:37:25,071: Using redshift connection "parsely_users".
2018-01-04 23:37:25,071: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 23:37:25,378: SQL status: INSERT 0 53735 in 0.31 seconds
2018-01-04 23:37:25,378: On parsely_users: COMMIT
2018-01-04 23:37:25,378: Using redshift connection "parsely_users".
2018-01-04 23:37:25,378: On parsely_users: COMMIT
2018-01-04 23:37:25,830: SQL status: COMMIT in 0.45 seconds
2018-01-04 23:37:25,830: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2af0950>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:37:25,859: 23:37:25 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 53735 in 4.14s]
2018-01-04 23:37:25,859: 23:37:25 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 23:37:25,860: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 23:37:25,891: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 23:37:25,893: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:37:25,893: Re-using an available connection from the pool.
2018-01-04 23:37:25,893: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:37:25,893: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:37:25,916: SQL status: SELECT in 0.02 seconds
2018-01-04 23:37:25,918: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 23:37:25,919: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:37:25,919: On parsely_pageview_engagedtime: BEGIN
2018-01-04 23:37:25,921: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:37:25,921: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:37:25,921: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 23:37:26,426: SQL status: CREATE VIEW in 0.50 seconds
2018-01-04 23:37:26,427: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:37:26,427: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 23:37:26,431: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:37:26,431: On parsely_pageview_engagedtime: COMMIT
2018-01-04 23:37:26,431: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:37:26,431: On parsely_pageview_engagedtime: COMMIT
2018-01-04 23:37:27,088: SQL status: COMMIT in 0.66 seconds
2018-01-04 23:37:27,089: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b45710>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:37:27,114: 23:37:27 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 1.23s]
2018-01-04 23:37:27,114: 23:37:27 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 23:37:27,115: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 23:37:27,123: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 23:37:27,124: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 23:37:27,124: Re-using an available connection from the pool.
2018-01-04 23:37:27,124: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:37:27,124: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:37:27,146: SQL status: SELECT in 0.02 seconds
2018-01-04 23:37:27,148: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 23:37:27,149: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:37:27,149: On parsely_incoming_sessions: BEGIN
2018-01-04 23:37:27,151: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:37:27,151: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:37:27,151: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 23:37:27,563: SQL status: CREATE VIEW in 0.41 seconds
2018-01-04 23:37:27,563: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:37:27,563: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 23:37:27,566: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:37:27,567: On parsely_incoming_sessions: COMMIT
2018-01-04 23:37:27,567: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:37:27,567: On parsely_incoming_sessions: COMMIT
2018-01-04 23:37:27,782: SQL status: COMMIT in 0.22 seconds
2018-01-04 23:37:27,783: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b7f990>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:37:27,815: 23:37:27 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.67s]
2018-01-04 23:37:27,815: 23:37:27 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 23:37:27,815: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 23:37:27,825: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 23:37:27,827: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:37:27,827: Re-using an available connection from the pool.
2018-01-04 23:37:27,827: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:37:27,827: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:37:27,848: SQL status: SELECT in 0.02 seconds
2018-01-04 23:37:27,848: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:37:27,849: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:37:27,866: SQL status: SELECT in 0.02 seconds
2018-01-04 23:37:27,868: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:37:27,868: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 23:37:27,870: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:37:27,870: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:37:27,871: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:39:45,795: SQL status: SELECT in 137.92 seconds
2018-01-04 23:39:45,795: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:39:45,795: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 23:39:46,161: SQL status: SELECT in 0.37 seconds
2018-01-04 23:39:46,162: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:39:46,162: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:39:46,280: SQL status: SELECT in 0.12 seconds
2018-01-04 23:39:46,280: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:39:46,281: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:39:46,398: SQL status: SELECT in 0.12 seconds
2018-01-04 23:39:46,402: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 23:39:46,403: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:39:46,403: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 23:39:49,730: SQL status: INSERT 0 109944 in 3.33 seconds
2018-01-04 23:39:49,731: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 23:39:49,731: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:39:49,731: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 23:39:51,048: SQL status: COMMIT in 1.32 seconds
2018-01-04 23:39:51,048: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b7f990>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:39:51,172: 23:39:51 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 109944 in 143.23s]
2018-01-04 23:39:51,173: 23:39:51 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 23:39:51,173: Compiling model.parsely.parsely_sessions
2018-01-04 23:39:51,184: Acquiring new redshift connection "parsely_sessions".
2018-01-04 23:39:51,185: Re-using an available connection from the pool.
2018-01-04 23:39:51,185: Using redshift connection "parsely_sessions".
2018-01-04 23:39:51,185: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:39:51,207: SQL status: SELECT in 0.02 seconds
2018-01-04 23:39:51,213: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 23:39:51,215: Using redshift connection "parsely_sessions".
2018-01-04 23:39:51,215: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:39:51,235: SQL status: SELECT in 0.02 seconds
2018-01-04 23:39:51,236: Using redshift connection "parsely_sessions".
2018-01-04 23:39:51,236: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:39:51,255: SQL status: SELECT in 0.02 seconds
2018-01-04 23:39:51,260: Using redshift connection "parsely_sessions".
2018-01-04 23:39:51,260: On parsely_sessions: BEGIN
2018-01-04 23:39:51,263: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:39:51,264: Using redshift connection "parsely_sessions".
2018-01-04 23:39:51,264: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:40:22,133: SQL status: SELECT in 30.87 seconds
2018-01-04 23:40:22,134: Using redshift connection "parsely_sessions".
2018-01-04 23:40:22,134: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-04 23:40:22,321: SQL status: SELECT in 0.19 seconds
2018-01-04 23:40:22,322: Using redshift connection "parsely_sessions".
2018-01-04 23:40:22,322: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:40:22,440: SQL status: SELECT in 0.12 seconds
2018-01-04 23:40:22,440: Using redshift connection "parsely_sessions".
2018-01-04 23:40:22,440: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:40:22,557: SQL status: SELECT in 0.12 seconds
2018-01-04 23:40:22,560: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-04 23:40:22,561: Using redshift connection "parsely_sessions".
2018-01-04 23:40:22,561: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-04 23:40:24,153: SQL status: INSERT 0 89353 in 1.59 seconds
2018-01-04 23:40:24,154: On parsely_sessions: COMMIT
2018-01-04 23:40:24,154: Using redshift connection "parsely_sessions".
2018-01-04 23:40:24,154: On parsely_sessions: COMMIT
2018-01-04 23:40:25,480: SQL status: COMMIT in 1.33 seconds
2018-01-04 23:40:25,480: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b45710>], 'label': 'e8bbb47b-e253-4d10-9c72-cde70165b779'}
2018-01-04 23:40:25,507: 23:40:25 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 89353 in 34.31s]
2018-01-04 23:40:25,593: Using redshift connection "master".
2018-01-04 23:40:25,593: On master: BEGIN
2018-01-04 23:40:25,595: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:40:25,595: On master: COMMIT
2018-01-04 23:40:25,596: Using redshift connection "master".
2018-01-04 23:40:25,596: On master: COMMIT
2018-01-04 23:40:25,597: SQL status: COMMIT in 0.00 seconds
2018-01-04 23:40:25,598: Compiling operation.parsely.parsely-on-run-end-0
2018-01-04 23:40:25,603: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-04 23:40:25,604: Using redshift connection "master".
2018-01-04 23:40:25,604: On master:  select 1 
2018-01-04 23:40:25,606: SQL status: SELECT in 0.00 seconds
2018-01-04 23:40:25,606: 23:40:25 | 
2018-01-04 23:40:25,606: 23:40:25 | Finished running 10 view models, 15 incremental models in 1205.87s.
2018-01-04 23:40:25,607: 
2018-01-04 23:40:25,607: Completed successfully
2018-01-04 23:40:25,607: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-04 23:40:25,608: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b98e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b98f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f71c2b7f950>], 'label': 'end'}
2018-01-04 23:40:25,635: Flushing usage events
2018-01-04 23:40:33,946: Tracking: tracking
2018-01-04 23:40:33,947: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d8691e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d8691f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d8691ed0>], 'label': 'start'}
2018-01-04 23:40:33,984: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-04 23:40:34,000: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-04 23:40:34,002: Parsing core.sql
2018-01-04 23:40:34,013: Parsing etc/get_custom_schema.sql
2018-01-04 23:40:34,018: Parsing schema_tests/relationships.sql
2018-01-04 23:40:34,020: Parsing schema_tests/accepted_values.sql
2018-01-04 23:40:34,023: Parsing schema_tests/not_null.sql
2018-01-04 23:40:34,025: Parsing schema_tests/unique.sql
2018-01-04 23:40:34,027: Parsing materializations/wrapper.sql
2018-01-04 23:40:34,030: Parsing materializations/archive.sql
2018-01-04 23:40:34,058: Parsing materializations/table.sql
2018-01-04 23:40:34,075: Parsing materializations/helpers.sql
2018-01-04 23:40:34,090: Parsing materializations/bigquery.sql
2018-01-04 23:40:34,103: Parsing materializations/view.sql
2018-01-04 23:40:34,117: Parsing materializations/incremental.sql
2018-01-04 23:40:34,141: Parsing adapters/redshift.sql
2018-01-04 23:40:34,158: Parsing adapters/bigquery.sql
2018-01-04 23:40:34,162: Parsing adapters/postgres.sql
2018-01-04 23:40:34,165: Parsing adapters/common.sql
2018-01-04 23:40:34,184: Parsing model.parsely.parsely_audit
2018-01-04 23:40:34,185: Parsing model.parsely.parsely_video_content
2018-01-04 23:40:34,188: Parsing model.parsely.parsely_post_content
2018-01-04 23:40:34,191: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-04 23:40:34,193: Parsing model.parsely.parsely_rawdata
2018-01-04 23:40:34,196: Parsing model.parsely.calendar
2018-01-04 23:40:34,198: Parsing model.parsely.parsely_all_events
2018-01-04 23:40:34,206: Acquiring new redshift connection "parsely_all_events".
2018-01-04 23:40:34,206: Opening a new connection (0 currently allocated)
2018-01-04 23:40:34,218: Using redshift connection "parsely_all_events".
2018-01-04 23:40:34,219: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:34,245: SQL status: SELECT in 0.03 seconds
2018-01-04 23:40:34,250: Parsing model.parsely.parsely_event_ids
2018-01-04 23:40:34,252: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-04 23:40:34,255: Parsing model.parsely.parsely_base_events
2018-01-04 23:40:34,258: Acquiring new redshift connection "parsely_base_events".
2018-01-04 23:40:34,258: Re-using an available connection from the pool.
2018-01-04 23:40:34,258: Using redshift connection "parsely_base_events".
2018-01-04 23:40:34,258: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:34,277: SQL status: SELECT in 0.02 seconds
2018-01-04 23:40:34,278: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-04 23:40:34,284: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-04 23:40:34,288: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 23:40:34,290: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 23:40:34,292: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-04 23:40:34,295: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-04 23:40:34,301: Parsing model.parsely.parsely_incoming_pageviews
2018-01-04 23:40:34,308: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-04 23:40:34,313: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:40:34,313: Re-using an available connection from the pool.
2018-01-04 23:40:34,313: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:40:34,313: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:34,333: SQL status: SELECT in 0.02 seconds
2018-01-04 23:40:34,334: Parsing model.parsely.parsely_incoming_videoviews
2018-01-04 23:40:34,340: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-04 23:40:34,345: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:40:34,345: Re-using an available connection from the pool.
2018-01-04 23:40:34,345: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:40:34,346: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:34,365: SQL status: SELECT in 0.02 seconds
2018-01-04 23:40:34,366: Parsing model.parsely.parsely_incoming_users
2018-01-04 23:40:34,368: Parsing model.parsely.parsely_users
2018-01-04 23:40:34,373: Acquiring new redshift connection "parsely_users".
2018-01-04 23:40:34,374: Re-using an available connection from the pool.
2018-01-04 23:40:34,374: Using redshift connection "parsely_users".
2018-01-04 23:40:34,374: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:34,393: SQL status: SELECT in 0.02 seconds
2018-01-04 23:40:34,393: Parsing model.parsely.parsely_errors
2018-01-04 23:40:34,397: Parsing model.parsely.parsely_bot_traffic
2018-01-04 23:40:34,401: Parsing model.parsely.parsely_custom_events
2018-01-04 23:40:34,406: Parsing model.parsely.parsely_incoming_sessions
2018-01-04 23:40:34,410: Parsing model.parsely.parsely_entry_exit_urls
2018-01-04 23:40:34,412: Parsing model.parsely.parsely_sessions
2018-01-04 23:40:34,418: Acquiring new redshift connection "parsely_sessions".
2018-01-04 23:40:34,418: Re-using an available connection from the pool.
2018-01-04 23:40:34,418: Using redshift connection "parsely_sessions".
2018-01-04 23:40:34,418: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:34,438: SQL status: SELECT in 0.02 seconds
2018-01-04 23:40:34,438: Parsing model.parsely.parsely_campaigns
2018-01-04 23:40:34,442: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 23:40:34,442: Re-using an available connection from the pool.
2018-01-04 23:40:34,442: Using redshift connection "parsely_campaigns".
2018-01-04 23:40:34,442: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:34,461: SQL status: SELECT in 0.02 seconds
2018-01-04 23:40:34,467: Parsing operation.parsely.parsely-on-run-end-0
2018-01-04 23:40:34,472: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-04 23:40:34,480: 
2018-01-04 23:40:34,482: Acquiring new redshift connection "master".
2018-01-04 23:40:34,482: Re-using an available connection from the pool.
2018-01-04 23:40:34,483: Using redshift connection "master".
2018-01-04 23:40:34,483: On master: select distinct nspname from pg_namespace
2018-01-04 23:40:34,485: SQL status: SELECT in 0.00 seconds
2018-01-04 23:40:34,487: Using redshift connection "master".
2018-01-04 23:40:34,488: On master: BEGIN
2018-01-04 23:40:34,489: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:40:34,489: On master: COMMIT
2018-01-04 23:40:34,489: Using redshift connection "master".
2018-01-04 23:40:34,489: On master: COMMIT
2018-01-04 23:40:34,491: SQL status: COMMIT in 0.00 seconds
2018-01-04 23:40:34,496: 23:40:34 | Concurrency: 1 threads (target='dev')
2018-01-04 23:40:34,496: 23:40:34 | 
2018-01-04 23:40:34,497: Using redshift connection "master".
2018-01-04 23:40:34,497: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:34,517: SQL status: SELECT in 0.02 seconds
2018-01-04 23:40:34,591: 23:40:34 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-04 23:40:34,592: Compiling model.parsely.calendar
2018-01-04 23:40:34,596: Writing injected SQL for node "model.parsely.calendar"
2018-01-04 23:40:34,597: Acquiring new redshift connection "calendar".
2018-01-04 23:40:34,598: Opening a new connection (1 currently allocated)
2018-01-04 23:40:34,610: Using redshift connection "calendar".
2018-01-04 23:40:34,610: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:34,635: SQL status: SELECT in 0.03 seconds
2018-01-04 23:40:34,637: Writing runtime SQL for node "model.parsely.calendar"
2018-01-04 23:40:34,638: Using redshift connection "calendar".
2018-01-04 23:40:34,638: On calendar: BEGIN
2018-01-04 23:40:34,640: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:40:34,640: Using redshift connection "calendar".
2018-01-04 23:40:34,640: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-04 23:40:34,657: SQL status: CREATE VIEW in 0.02 seconds
2018-01-04 23:40:34,658: On calendar: COMMIT
2018-01-04 23:40:34,658: Using redshift connection "calendar".
2018-01-04 23:40:34,658: On calendar: COMMIT
2018-01-04 23:40:35,029: SQL status: COMMIT in 0.37 seconds
2018-01-04 23:40:35,029: Using redshift connection "calendar".
2018-01-04 23:40:35,029: On calendar: BEGIN
2018-01-04 23:40:35,031: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:40:35,031: Using redshift connection "calendar".
2018-01-04 23:40:35,031: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-04 23:40:35,079: SQL status: DROP VIEW in 0.05 seconds
2018-01-04 23:40:35,079: On calendar: COMMIT
2018-01-04 23:40:35,079: Using redshift connection "calendar".
2018-01-04 23:40:35,079: On calendar: COMMIT
2018-01-04 23:40:35,238: SQL status: COMMIT in 0.16 seconds
2018-01-04 23:40:35,238: Using redshift connection "calendar".
2018-01-04 23:40:35,238: On calendar: BEGIN
2018-01-04 23:40:35,240: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:40:35,240: Using redshift connection "calendar".
2018-01-04 23:40:35,240: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-04 23:40:35,245: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:40:35,245: On calendar: COMMIT
2018-01-04 23:40:35,245: Using redshift connection "calendar".
2018-01-04 23:40:35,245: On calendar: COMMIT
2018-01-04 23:40:35,530: SQL status: COMMIT in 0.28 seconds
2018-01-04 23:40:35,530: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d857fbd0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:40:35,560: 23:40:35 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 0.94s]
2018-01-04 23:40:35,561: 23:40:35 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-04 23:40:35,561: Compiling model.parsely.parsely_rawdata
2018-01-04 23:40:35,567: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-04 23:40:35,568: Acquiring new redshift connection "parsely_rawdata".
2018-01-04 23:40:35,568: Re-using an available connection from the pool.
2018-01-04 23:40:35,568: Using redshift connection "parsely_rawdata".
2018-01-04 23:40:35,568: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:35,590: SQL status: SELECT in 0.02 seconds
2018-01-04 23:40:35,590: Using redshift connection "parsely_rawdata".
2018-01-04 23:40:35,590: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:40:35,609: SQL status: SELECT in 0.02 seconds
2018-01-04 23:40:35,610: Using redshift connection "parsely_rawdata".
2018-01-04 23:40:35,610: On parsely_rawdata: BEGIN
2018-01-04 23:40:35,612: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:40:35,612: Using redshift connection "parsely_rawdata".
2018-01-04 23:40:35,613: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:41:07,716: SQL status: SELECT in 32.10 seconds
2018-01-04 23:41:07,716: Using redshift connection "parsely_rawdata".
2018-01-04 23:41:07,716: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-04 23:41:08,087: SQL status: SELECT in 0.37 seconds
2018-01-04 23:41:08,088: Using redshift connection "parsely_rawdata".
2018-01-04 23:41:08,088: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:41:08,213: SQL status: SELECT in 0.12 seconds
2018-01-04 23:41:08,214: Using redshift connection "parsely_rawdata".
2018-01-04 23:41:08,214: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:41:08,336: SQL status: SELECT in 0.12 seconds
2018-01-04 23:41:08,339: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-04 23:41:08,340: Using redshift connection "parsely_rawdata".
2018-01-04 23:41:08,340: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-04 23:41:42,818: SQL status: INSERT 0 1041298 in 34.48 seconds
2018-01-04 23:41:42,819: On parsely_rawdata: COMMIT
2018-01-04 23:41:42,819: Using redshift connection "parsely_rawdata".
2018-01-04 23:41:42,819: On parsely_rawdata: COMMIT
2018-01-04 23:41:44,849: SQL status: COMMIT in 2.03 seconds
2018-01-04 23:41:44,849: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85e9b10>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:41:44,892: 23:41:44 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1041298 in 69.29s]
2018-01-04 23:41:44,893: 23:41:44 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-04 23:41:44,893: Compiling model.parsely.parsely_all_events
2018-01-04 23:41:44,901: Acquiring new redshift connection "parsely_all_events".
2018-01-04 23:41:44,901: Re-using an available connection from the pool.
2018-01-04 23:41:44,902: Using redshift connection "parsely_all_events".
2018-01-04 23:41:44,902: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:41:44,923: SQL status: SELECT in 0.02 seconds
2018-01-04 23:41:44,931: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-04 23:41:44,933: Using redshift connection "parsely_all_events".
2018-01-04 23:41:44,933: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:41:44,952: SQL status: SELECT in 0.02 seconds
2018-01-04 23:41:44,952: Using redshift connection "parsely_all_events".
2018-01-04 23:41:44,953: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:41:44,971: SQL status: SELECT in 0.02 seconds
2018-01-04 23:41:44,973: Using redshift connection "parsely_all_events".
2018-01-04 23:41:44,973: On parsely_all_events: BEGIN
2018-01-04 23:41:44,975: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:41:44,975: Using redshift connection "parsely_all_events".
2018-01-04 23:41:44,975: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:43:02,942: SQL status: SELECT in 77.97 seconds
2018-01-04 23:43:02,942: Using redshift connection "parsely_all_events".
2018-01-04 23:43:02,942: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-04 23:43:03,108: SQL status: SELECT in 0.17 seconds
2018-01-04 23:43:03,108: Using redshift connection "parsely_all_events".
2018-01-04 23:43:03,108: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:43:03,230: SQL status: SELECT in 0.12 seconds
2018-01-04 23:43:03,230: Using redshift connection "parsely_all_events".
2018-01-04 23:43:03,231: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:43:03,352: SQL status: SELECT in 0.12 seconds
2018-01-04 23:43:03,356: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-04 23:43:03,357: Using redshift connection "parsely_all_events".
2018-01-04 23:43:03,357: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-04 23:43:21,350: SQL status: INSERT 0 925806 in 17.99 seconds
2018-01-04 23:43:21,351: On parsely_all_events: COMMIT
2018-01-04 23:43:21,351: Using redshift connection "parsely_all_events".
2018-01-04 23:43:21,351: On parsely_all_events: COMMIT
2018-01-04 23:43:23,735: SQL status: COMMIT in 2.38 seconds
2018-01-04 23:43:23,735: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d863e810>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:43:23,790: 23:43:23 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 925806 in 98.84s]
2018-01-04 23:43:23,791: 23:43:23 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-04 23:43:23,791: Compiling model.parsely.parsely_bot_traffic
2018-01-04 23:43:23,798: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 23:43:23,800: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-04 23:43:23,800: Re-using an available connection from the pool.
2018-01-04 23:43:23,800: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:43:23,800: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:43:23,823: SQL status: SELECT in 0.02 seconds
2018-01-04 23:43:23,823: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:43:23,824: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:43:23,841: SQL status: SELECT in 0.02 seconds
2018-01-04 23:43:23,843: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:43:23,843: On parsely_bot_traffic: BEGIN
2018-01-04 23:43:23,845: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:43:23,845: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:43:23,846: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:44:27,649: SQL status: SELECT in 63.80 seconds
2018-01-04 23:44:27,650: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:44:27,650: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-04 23:44:28,038: SQL status: SELECT in 0.39 seconds
2018-01-04 23:44:28,038: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:44:28,038: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:44:28,157: SQL status: SELECT in 0.12 seconds
2018-01-04 23:44:28,158: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:44:28,158: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:44:28,277: SQL status: SELECT in 0.12 seconds
2018-01-04 23:44:28,280: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-04 23:44:28,281: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:44:28,282: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-04 23:44:29,351: SQL status: INSERT 0 4 in 1.07 seconds
2018-01-04 23:44:29,351: On parsely_bot_traffic: COMMIT
2018-01-04 23:44:29,351: Using redshift connection "parsely_bot_traffic".
2018-01-04 23:44:29,352: On parsely_bot_traffic: COMMIT
2018-01-04 23:44:30,313: SQL status: COMMIT in 0.96 seconds
2018-01-04 23:44:30,313: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d857fc90>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:44:30,358: 23:44:30 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 66.52s]
2018-01-04 23:44:30,358: 23:44:30 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-04 23:44:30,359: Compiling model.parsely.parsely_custom_events
2018-01-04 23:44:30,368: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-04 23:44:30,370: Acquiring new redshift connection "parsely_custom_events".
2018-01-04 23:44:30,370: Re-using an available connection from the pool.
2018-01-04 23:44:30,370: Using redshift connection "parsely_custom_events".
2018-01-04 23:44:30,371: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:44:30,392: SQL status: SELECT in 0.02 seconds
2018-01-04 23:44:30,392: Using redshift connection "parsely_custom_events".
2018-01-04 23:44:30,392: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:44:30,413: SQL status: SELECT in 0.02 seconds
2018-01-04 23:44:30,415: Using redshift connection "parsely_custom_events".
2018-01-04 23:44:30,415: On parsely_custom_events: BEGIN
2018-01-04 23:44:30,417: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:44:30,417: Using redshift connection "parsely_custom_events".
2018-01-04 23:44:30,417: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:45:35,124: SQL status: SELECT in 64.71 seconds
2018-01-04 23:45:35,124: Using redshift connection "parsely_custom_events".
2018-01-04 23:45:35,124: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-04 23:45:35,311: SQL status: SELECT in 0.19 seconds
2018-01-04 23:45:35,311: Using redshift connection "parsely_custom_events".
2018-01-04 23:45:35,311: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:45:35,429: SQL status: SELECT in 0.12 seconds
2018-01-04 23:45:35,430: Using redshift connection "parsely_custom_events".
2018-01-04 23:45:35,430: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:45:35,549: SQL status: SELECT in 0.12 seconds
2018-01-04 23:45:35,553: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-04 23:45:35,554: Using redshift connection "parsely_custom_events".
2018-01-04 23:45:35,554: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-04 23:45:35,827: SQL status: INSERT 0 0 in 0.27 seconds
2018-01-04 23:45:35,827: On parsely_custom_events: COMMIT
2018-01-04 23:45:35,828: Using redshift connection "parsely_custom_events".
2018-01-04 23:45:35,828: On parsely_custom_events: COMMIT
2018-01-04 23:45:36,168: SQL status: COMMIT in 0.34 seconds
2018-01-04 23:45:36,168: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d857fc90>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:45:36,205: 23:45:36 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 65.81s]
2018-01-04 23:45:36,205: 23:45:36 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-04 23:45:36,206: Compiling model.parsely.parsely_errors
2018-01-04 23:45:36,215: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-04 23:45:36,216: Acquiring new redshift connection "parsely_errors".
2018-01-04 23:45:36,216: Re-using an available connection from the pool.
2018-01-04 23:45:36,216: Using redshift connection "parsely_errors".
2018-01-04 23:45:36,216: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:45:36,237: SQL status: SELECT in 0.02 seconds
2018-01-04 23:45:36,238: Using redshift connection "parsely_errors".
2018-01-04 23:45:36,238: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:45:36,256: SQL status: SELECT in 0.02 seconds
2018-01-04 23:45:36,258: Using redshift connection "parsely_errors".
2018-01-04 23:45:36,258: On parsely_errors: BEGIN
2018-01-04 23:45:36,260: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:45:36,260: Using redshift connection "parsely_errors".
2018-01-04 23:45:36,260: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:46:39,847: SQL status: SELECT in 63.59 seconds
2018-01-04 23:46:39,847: Using redshift connection "parsely_errors".
2018-01-04 23:46:39,847: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-04 23:46:40,044: SQL status: SELECT in 0.20 seconds
2018-01-04 23:46:40,045: Using redshift connection "parsely_errors".
2018-01-04 23:46:40,045: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:46:40,167: SQL status: SELECT in 0.12 seconds
2018-01-04 23:46:40,168: Using redshift connection "parsely_errors".
2018-01-04 23:46:40,168: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:46:40,289: SQL status: SELECT in 0.12 seconds
2018-01-04 23:46:40,293: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-04 23:46:40,294: Using redshift connection "parsely_errors".
2018-01-04 23:46:40,294: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-04 23:46:41,285: SQL status: INSERT 0 2 in 0.99 seconds
2018-01-04 23:46:41,286: On parsely_errors: COMMIT
2018-01-04 23:46:41,286: Using redshift connection "parsely_errors".
2018-01-04 23:46:41,286: On parsely_errors: COMMIT
2018-01-04 23:46:41,952: SQL status: COMMIT in 0.67 seconds
2018-01-04 23:46:41,953: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d8575a90>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:46:41,990: 23:46:41 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 65.75s]
2018-01-04 23:46:41,991: 23:46:41 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-04 23:46:41,991: Compiling model.parsely.parsely_base_events
2018-01-04 23:46:41,995: Acquiring new redshift connection "parsely_base_events".
2018-01-04 23:46:41,995: Re-using an available connection from the pool.
2018-01-04 23:46:41,995: Using redshift connection "parsely_base_events".
2018-01-04 23:46:41,995: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:46:42,017: SQL status: SELECT in 0.02 seconds
2018-01-04 23:46:42,021: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-04 23:46:42,022: Using redshift connection "parsely_base_events".
2018-01-04 23:46:42,023: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:46:42,043: SQL status: SELECT in 0.02 seconds
2018-01-04 23:46:42,045: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-04 23:46:42,046: Using redshift connection "parsely_base_events".
2018-01-04 23:46:42,046: On parsely_base_events: BEGIN
2018-01-04 23:46:42,048: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:46:42,048: Using redshift connection "parsely_base_events".
2018-01-04 23:46:42,048: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-04 23:46:43,143: SQL status: CREATE VIEW in 1.09 seconds
2018-01-04 23:46:43,143: On parsely_base_events: COMMIT
2018-01-04 23:46:43,143: Using redshift connection "parsely_base_events".
2018-01-04 23:46:43,143: On parsely_base_events: COMMIT
2018-01-04 23:46:43,561: SQL status: COMMIT in 0.42 seconds
2018-01-04 23:46:43,561: Using redshift connection "parsely_base_events".
2018-01-04 23:46:43,561: On parsely_base_events: BEGIN
2018-01-04 23:46:43,563: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:46:43,563: Using redshift connection "parsely_base_events".
2018-01-04 23:46:43,563: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-04 23:46:43,949: SQL status: DROP VIEW in 0.39 seconds
2018-01-04 23:46:43,949: On parsely_base_events: COMMIT
2018-01-04 23:46:43,949: Using redshift connection "parsely_base_events".
2018-01-04 23:46:43,949: On parsely_base_events: COMMIT
2018-01-04 23:46:44,161: SQL status: COMMIT in 0.21 seconds
2018-01-04 23:46:44,161: Using redshift connection "parsely_base_events".
2018-01-04 23:46:44,161: On parsely_base_events: BEGIN
2018-01-04 23:46:44,164: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:46:44,164: Using redshift connection "parsely_base_events".
2018-01-04 23:46:44,164: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-04 23:46:44,170: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 23:46:44,170: On parsely_base_events: COMMIT
2018-01-04 23:46:44,170: Using redshift connection "parsely_base_events".
2018-01-04 23:46:44,170: On parsely_base_events: COMMIT
2018-01-04 23:46:44,553: SQL status: COMMIT in 0.38 seconds
2018-01-04 23:46:44,553: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85e99d0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:46:44,580: 23:46:44 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 2.56s]
2018-01-04 23:46:44,580: 23:46:44 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-04 23:46:44,580: Compiling model.parsely.parsely_event_ids
2018-01-04 23:46:44,585: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-04 23:46:44,588: Acquiring new redshift connection "parsely_event_ids".
2018-01-04 23:46:44,588: Re-using an available connection from the pool.
2018-01-04 23:46:44,588: Using redshift connection "parsely_event_ids".
2018-01-04 23:46:44,588: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:46:44,610: SQL status: SELECT in 0.02 seconds
2018-01-04 23:46:44,611: Using redshift connection "parsely_event_ids".
2018-01-04 23:46:44,611: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:46:44,628: SQL status: SELECT in 0.02 seconds
2018-01-04 23:46:44,629: Using redshift connection "parsely_event_ids".
2018-01-04 23:46:44,629: On parsely_event_ids: BEGIN
2018-01-04 23:46:44,631: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:46:44,631: Using redshift connection "parsely_event_ids".
2018-01-04 23:46:44,631: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:46:46,994: SQL status: SELECT in 2.36 seconds
2018-01-04 23:46:46,994: Using redshift connection "parsely_event_ids".
2018-01-04 23:46:46,997: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-04 23:46:47,237: SQL status: SELECT in 0.24 seconds
2018-01-04 23:46:47,237: Using redshift connection "parsely_event_ids".
2018-01-04 23:46:47,237: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:46:47,351: SQL status: SELECT in 0.11 seconds
2018-01-04 23:46:47,351: Using redshift connection "parsely_event_ids".
2018-01-04 23:46:47,352: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:46:47,466: SQL status: SELECT in 0.11 seconds
2018-01-04 23:46:47,468: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-04 23:46:47,469: Using redshift connection "parsely_event_ids".
2018-01-04 23:46:47,469: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-04 23:46:49,001: SQL status: INSERT 0 925802 in 1.53 seconds
2018-01-04 23:46:49,001: On parsely_event_ids: COMMIT
2018-01-04 23:46:49,001: Using redshift connection "parsely_event_ids".
2018-01-04 23:46:49,002: On parsely_event_ids: COMMIT
2018-01-04 23:46:49,369: SQL status: COMMIT in 0.37 seconds
2018-01-04 23:46:49,370: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d8591dd0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:46:49,398: 23:46:49 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 925802 in 4.79s]
2018-01-04 23:46:49,399: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-04 23:46:49,404: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-04 23:46:49,405: 23:46:49 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-04 23:46:49,406: Compiling model.parsely.parsely_post_content
2018-01-04 23:46:49,412: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-04 23:46:49,413: Acquiring new redshift connection "parsely_post_content".
2018-01-04 23:46:49,413: Re-using an available connection from the pool.
2018-01-04 23:46:49,413: Using redshift connection "parsely_post_content".
2018-01-04 23:46:49,413: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:46:49,436: SQL status: SELECT in 0.02 seconds
2018-01-04 23:46:49,436: Using redshift connection "parsely_post_content".
2018-01-04 23:46:49,436: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:46:49,457: SQL status: SELECT in 0.02 seconds
2018-01-04 23:46:49,458: Using redshift connection "parsely_post_content".
2018-01-04 23:46:49,458: On parsely_post_content: BEGIN
2018-01-04 23:46:49,460: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:46:49,460: Using redshift connection "parsely_post_content".
2018-01-04 23:46:49,460: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:47:02,425: SQL status: SELECT in 12.96 seconds
2018-01-04 23:47:02,426: Using redshift connection "parsely_post_content".
2018-01-04 23:47:02,426: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-04 23:47:02,572: SQL status: SELECT in 0.15 seconds
2018-01-04 23:47:02,572: Using redshift connection "parsely_post_content".
2018-01-04 23:47:02,572: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:47:02,688: SQL status: SELECT in 0.12 seconds
2018-01-04 23:47:02,689: Using redshift connection "parsely_post_content".
2018-01-04 23:47:02,689: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:47:02,806: SQL status: SELECT in 0.12 seconds
2018-01-04 23:47:02,808: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-04 23:47:02,809: Using redshift connection "parsely_post_content".
2018-01-04 23:47:02,809: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-04 23:47:03,224: SQL status: INSERT 0 887 in 0.41 seconds
2018-01-04 23:47:03,224: On parsely_post_content: COMMIT
2018-01-04 23:47:03,224: Using redshift connection "parsely_post_content".
2018-01-04 23:47:03,224: On parsely_post_content: COMMIT
2018-01-04 23:47:04,254: SQL status: COMMIT in 1.03 seconds
2018-01-04 23:47:04,254: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85e0ed0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:47:04,283: 23:47:04 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 887 in 14.85s]
2018-01-04 23:47:04,283: 23:47:04 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-04 23:47:04,284: Compiling model.parsely.parsely_video_content
2018-01-04 23:47:04,289: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-04 23:47:04,291: Acquiring new redshift connection "parsely_video_content".
2018-01-04 23:47:04,291: Re-using an available connection from the pool.
2018-01-04 23:47:04,291: Using redshift connection "parsely_video_content".
2018-01-04 23:47:04,291: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:47:04,313: SQL status: SELECT in 0.02 seconds
2018-01-04 23:47:04,313: Using redshift connection "parsely_video_content".
2018-01-04 23:47:04,313: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:47:04,334: SQL status: SELECT in 0.02 seconds
2018-01-04 23:47:04,336: Using redshift connection "parsely_video_content".
2018-01-04 23:47:04,336: On parsely_video_content: BEGIN
2018-01-04 23:47:04,338: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:47:04,338: Using redshift connection "parsely_video_content".
2018-01-04 23:47:04,338: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:47:16,265: SQL status: SELECT in 11.93 seconds
2018-01-04 23:47:16,265: Using redshift connection "parsely_video_content".
2018-01-04 23:47:16,266: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-04 23:47:16,505: SQL status: SELECT in 0.24 seconds
2018-01-04 23:47:16,506: Using redshift connection "parsely_video_content".
2018-01-04 23:47:16,506: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:47:16,620: SQL status: SELECT in 0.11 seconds
2018-01-04 23:47:16,621: Using redshift connection "parsely_video_content".
2018-01-04 23:47:16,621: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:47:16,737: SQL status: SELECT in 0.12 seconds
2018-01-04 23:47:16,738: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-04 23:47:16,739: Using redshift connection "parsely_video_content".
2018-01-04 23:47:16,739: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-04 23:47:17,083: SQL status: INSERT 0 469 in 0.34 seconds
2018-01-04 23:47:17,083: On parsely_video_content: COMMIT
2018-01-04 23:47:17,083: Using redshift connection "parsely_video_content".
2018-01-04 23:47:17,083: On parsely_video_content: COMMIT
2018-01-04 23:47:17,581: SQL status: COMMIT in 0.50 seconds
2018-01-04 23:47:17,581: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85e0ed0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:47:17,611: 23:47:17 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 469 in 13.30s]
2018-01-04 23:47:17,611: 23:47:17 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-04 23:47:17,611: Compiling model.parsely.parsely_entry_exit_urls
2018-01-04 23:47:17,617: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 23:47:17,618: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-04 23:47:17,618: Re-using an available connection from the pool.
2018-01-04 23:47:17,618: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:47:17,618: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:47:17,640: SQL status: SELECT in 0.02 seconds
2018-01-04 23:47:17,643: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-04 23:47:17,644: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:47:17,644: On parsely_entry_exit_urls: BEGIN
2018-01-04 23:47:17,646: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:47:17,646: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:47:17,646: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-04 23:47:17,702: SQL status: CREATE VIEW in 0.06 seconds
2018-01-04 23:47:17,702: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:47:17,702: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-04 23:47:17,708: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 23:47:17,708: On parsely_entry_exit_urls: COMMIT
2018-01-04 23:47:17,708: Using redshift connection "parsely_entry_exit_urls".
2018-01-04 23:47:17,708: On parsely_entry_exit_urls: COMMIT
2018-01-04 23:47:17,973: SQL status: COMMIT in 0.26 seconds
2018-01-04 23:47:17,973: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85e0ed0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:47:18,001: 23:47:17 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.36s]
2018-01-04 23:47:18,002: 23:47:17 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-04 23:47:18,002: Compiling model.parsely.parsely_incoming_videoviews
2018-01-04 23:47:18,012: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 23:47:18,014: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-04 23:47:18,014: Re-using an available connection from the pool.
2018-01-04 23:47:18,014: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:47:18,014: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:47:18,036: SQL status: SELECT in 0.02 seconds
2018-01-04 23:47:18,039: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-04 23:47:18,041: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:47:18,041: On parsely_incoming_videoviews: BEGIN
2018-01-04 23:47:18,043: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:47:18,043: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:47:18,043: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-04 23:47:19,323: SQL status: CREATE VIEW in 1.28 seconds
2018-01-04 23:47:19,324: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:47:19,324: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-04 23:47:19,328: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:47:19,329: On parsely_incoming_videoviews: COMMIT
2018-01-04 23:47:19,329: Using redshift connection "parsely_incoming_videoviews".
2018-01-04 23:47:19,329: On parsely_incoming_videoviews: COMMIT
2018-01-04 23:47:19,564: SQL status: COMMIT in 0.24 seconds
2018-01-04 23:47:19,565: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85e0ed0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:47:19,596: 23:47:19 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.56s]
2018-01-04 23:47:19,596: 23:47:19 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-04 23:47:19,597: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-04 23:47:19,602: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:47:19,602: Re-using an available connection from the pool.
2018-01-04 23:47:19,602: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:47:19,602: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:47:19,624: SQL status: SELECT in 0.02 seconds
2018-01-04 23:47:19,628: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 23:47:19,629: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:47:19,629: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:47:19,650: SQL status: SELECT in 0.02 seconds
2018-01-04 23:47:19,650: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:47:19,651: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:47:19,669: SQL status: SELECT in 0.02 seconds
2018-01-04 23:47:19,671: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:47:19,671: On parsely_videoviews_sessionized: BEGIN
2018-01-04 23:47:19,673: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:47:19,673: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:47:19,674: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:48:37,283: SQL status: SELECT in 77.61 seconds
2018-01-04 23:48:37,283: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:48:37,284: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-04 23:48:37,444: SQL status: SELECT in 0.16 seconds
2018-01-04 23:48:37,445: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:48:37,445: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:48:37,557: SQL status: SELECT in 0.11 seconds
2018-01-04 23:48:37,557: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:48:37,558: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:48:37,669: SQL status: SELECT in 0.11 seconds
2018-01-04 23:48:37,672: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-04 23:48:37,673: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:48:37,673: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 23:48:38,820: SQL status: INSERT 0 145 in 1.15 seconds
2018-01-04 23:48:38,820: On parsely_videoviews_sessionized: COMMIT
2018-01-04 23:48:38,820: Using redshift connection "parsely_videoviews_sessionized".
2018-01-04 23:48:38,821: On parsely_videoviews_sessionized: COMMIT
2018-01-04 23:48:42,052: SQL status: COMMIT in 3.23 seconds
2018-01-04 23:48:42,053: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85e0ed0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:48:42,088: 23:48:42 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 145 in 82.46s]
2018-01-04 23:48:42,089: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-04 23:48:42,118: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-04 23:48:42,119: 23:48:42 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-04 23:48:42,119: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-04 23:48:42,133: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 23:48:42,134: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:48:42,134: Re-using an available connection from the pool.
2018-01-04 23:48:42,134: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:48:42,134: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:48:42,149: SQL status: SELECT in 0.01 seconds
2018-01-04 23:48:42,151: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-04 23:48:42,152: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:48:42,152: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-04 23:48:42,154: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:48:42,155: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:48:42,155: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-04 23:48:43,057: SQL status: CREATE VIEW in 0.90 seconds
2018-01-04 23:48:43,058: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:48:43,058: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-04 23:48:43,061: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:48:43,061: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 23:48:43,061: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-04 23:48:43,061: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-04 23:48:44,343: SQL status: COMMIT in 1.28 seconds
2018-01-04 23:48:44,344: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d857fed0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:48:44,368: 23:48:44 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 2.22s]
2018-01-04 23:48:44,369: 23:48:44 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-04 23:48:44,369: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-04 23:48:44,397: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 23:48:44,399: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:48:44,399: Re-using an available connection from the pool.
2018-01-04 23:48:44,399: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:48:44,399: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:48:44,413: SQL status: SELECT in 0.01 seconds
2018-01-04 23:48:44,416: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-04 23:48:44,417: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:48:44,417: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-04 23:48:44,419: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:48:44,419: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:48:44,419: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-04 23:48:45,067: SQL status: CREATE VIEW in 0.65 seconds
2018-01-04 23:48:45,068: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:48:45,068: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-04 23:48:45,072: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:48:45,072: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 23:48:45,072: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-04 23:48:45,072: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-04 23:48:45,344: SQL status: COMMIT in 0.27 seconds
2018-01-04 23:48:45,344: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85751d0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:48:45,374: 23:48:45 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.97s]
2018-01-04 23:48:45,375: 23:48:45 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-04 23:48:45,375: Compiling model.parsely.parsely_incoming_pageviews
2018-01-04 23:48:45,386: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 23:48:45,388: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-04 23:48:45,388: Re-using an available connection from the pool.
2018-01-04 23:48:45,388: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:48:45,388: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:48:45,402: SQL status: SELECT in 0.01 seconds
2018-01-04 23:48:45,405: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-04 23:48:45,407: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:48:45,407: On parsely_incoming_pageviews: BEGIN
2018-01-04 23:48:45,409: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:48:45,409: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:48:45,409: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-04 23:48:45,489: SQL status: CREATE VIEW in 0.08 seconds
2018-01-04 23:48:45,489: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:48:45,489: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-04 23:48:45,494: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:48:45,494: On parsely_incoming_pageviews: COMMIT
2018-01-04 23:48:45,494: Using redshift connection "parsely_incoming_pageviews".
2018-01-04 23:48:45,494: On parsely_incoming_pageviews: COMMIT
2018-01-04 23:48:45,703: SQL status: COMMIT in 0.21 seconds
2018-01-04 23:48:45,703: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d8678990>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:48:45,729: 23:48:45 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.33s]
2018-01-04 23:48:45,729: 23:48:45 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-04 23:48:45,730: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-04 23:48:45,734: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:48:45,735: Re-using an available connection from the pool.
2018-01-04 23:48:45,735: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:48:45,735: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:48:45,749: SQL status: SELECT in 0.01 seconds
2018-01-04 23:48:45,753: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 23:48:45,754: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:48:45,754: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:48:45,767: SQL status: SELECT in 0.01 seconds
2018-01-04 23:48:45,768: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:48:45,768: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:48:45,781: SQL status: SELECT in 0.01 seconds
2018-01-04 23:48:45,783: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:48:45,783: On parsely_pageviews_sessionized: BEGIN
2018-01-04 23:48:45,785: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:48:45,785: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:48:45,785: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:53:16,244: SQL status: SELECT in 270.46 seconds
2018-01-04 23:53:16,244: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:53:16,244: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-04 23:53:16,741: SQL status: SELECT in 0.50 seconds
2018-01-04 23:53:16,741: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:53:16,741: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:53:16,858: SQL status: SELECT in 0.12 seconds
2018-01-04 23:53:16,859: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:53:16,859: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:53:16,976: SQL status: SELECT in 0.12 seconds
2018-01-04 23:53:16,979: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-04 23:53:16,980: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:53:16,981: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-04 23:53:19,984: SQL status: INSERT 0 110483 in 3.00 seconds
2018-01-04 23:53:19,985: On parsely_pageviews_sessionized: COMMIT
2018-01-04 23:53:19,985: Using redshift connection "parsely_pageviews_sessionized".
2018-01-04 23:53:19,985: On parsely_pageviews_sessionized: COMMIT
2018-01-04 23:53:21,396: SQL status: COMMIT in 1.41 seconds
2018-01-04 23:53:21,396: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85e0ed0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:53:21,450: 23:53:21 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 110483 in 275.67s]
2018-01-04 23:53:21,450: 23:53:21 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-04 23:53:21,450: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-04 23:53:21,493: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 23:53:21,494: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:53:21,494: Re-using an available connection from the pool.
2018-01-04 23:53:21,494: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:53:21,494: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:53:21,516: SQL status: SELECT in 0.02 seconds
2018-01-04 23:53:21,518: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-04 23:53:21,520: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:53:21,520: On parsely_videoview_engagedtime: BEGIN
2018-01-04 23:53:21,522: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:53:21,522: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:53:21,522: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-04 23:53:22,324: SQL status: CREATE VIEW in 0.80 seconds
2018-01-04 23:53:22,324: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:53:22,324: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-04 23:53:22,328: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:53:22,328: On parsely_videoview_engagedtime: COMMIT
2018-01-04 23:53:22,329: Using redshift connection "parsely_videoview_engagedtime".
2018-01-04 23:53:22,329: On parsely_videoview_engagedtime: COMMIT
2018-01-04 23:53:22,662: SQL status: COMMIT in 0.33 seconds
2018-01-04 23:53:22,663: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85e0ed0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:53:22,693: 23:53:22 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.21s]
2018-01-04 23:53:22,694: 23:53:22 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-04 23:53:22,694: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-04 23:53:22,703: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 23:53:22,704: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:53:22,704: Re-using an available connection from the pool.
2018-01-04 23:53:22,704: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:53:22,704: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:53:22,726: SQL status: SELECT in 0.02 seconds
2018-01-04 23:53:22,726: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:53:22,726: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:53:22,745: SQL status: SELECT in 0.02 seconds
2018-01-04 23:53:22,747: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:53:22,747: On parsely_videoview_behavior_workflow: BEGIN
2018-01-04 23:53:22,749: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:53:22,749: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:53:22,749: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:56:55,330: SQL status: SELECT in 212.58 seconds
2018-01-04 23:56:55,330: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:56:55,330: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 23:56:55,473: SQL status: SELECT in 0.14 seconds
2018-01-04 23:56:55,474: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:56:55,474: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:56:55,591: SQL status: SELECT in 0.12 seconds
2018-01-04 23:56:55,592: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:56:55,592: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:56:55,709: SQL status: SELECT in 0.12 seconds
2018-01-04 23:56:55,712: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-04 23:56:55,714: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:56:55,714: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 23:56:56,821: SQL status: INSERT 0 144 in 1.11 seconds
2018-01-04 23:56:56,821: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 23:56:56,821: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-04 23:56:56,821: On parsely_videoview_behavior_workflow: COMMIT
2018-01-04 23:56:58,877: SQL status: COMMIT in 2.06 seconds
2018-01-04 23:56:58,878: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d8678990>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:56:58,932: 23:56:58 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 144 in 216.18s]
2018-01-04 23:56:58,932: 23:56:58 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-04 23:56:58,933: Compiling model.parsely.parsely_campaigns
2018-01-04 23:56:58,937: Acquiring new redshift connection "parsely_campaigns".
2018-01-04 23:56:58,937: Re-using an available connection from the pool.
2018-01-04 23:56:58,937: Using redshift connection "parsely_campaigns".
2018-01-04 23:56:58,937: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:56:58,963: SQL status: SELECT in 0.03 seconds
2018-01-04 23:56:58,966: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-04 23:56:58,967: Using redshift connection "parsely_campaigns".
2018-01-04 23:56:58,967: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:56:58,989: SQL status: SELECT in 0.02 seconds
2018-01-04 23:56:58,990: Using redshift connection "parsely_campaigns".
2018-01-04 23:56:58,990: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:56:59,010: SQL status: SELECT in 0.02 seconds
2018-01-04 23:56:59,011: Using redshift connection "parsely_campaigns".
2018-01-04 23:56:59,011: On parsely_campaigns: BEGIN
2018-01-04 23:56:59,013: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:56:59,013: Using redshift connection "parsely_campaigns".
2018-01-04 23:56:59,013: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:57:00,242: SQL status: SELECT in 1.23 seconds
2018-01-04 23:57:00,243: Using redshift connection "parsely_campaigns".
2018-01-04 23:57:00,243: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-04 23:57:00,468: SQL status: SELECT in 0.22 seconds
2018-01-04 23:57:00,468: Using redshift connection "parsely_campaigns".
2018-01-04 23:57:00,468: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:57:00,585: SQL status: SELECT in 0.12 seconds
2018-01-04 23:57:00,586: Using redshift connection "parsely_campaigns".
2018-01-04 23:57:00,586: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:57:00,702: SQL status: SELECT in 0.12 seconds
2018-01-04 23:57:00,703: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-04 23:57:00,705: Using redshift connection "parsely_campaigns".
2018-01-04 23:57:00,705: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-04 23:57:00,851: SQL status: INSERT 0 391 in 0.15 seconds
2018-01-04 23:57:00,852: On parsely_campaigns: COMMIT
2018-01-04 23:57:00,852: Using redshift connection "parsely_campaigns".
2018-01-04 23:57:00,852: On parsely_campaigns: COMMIT
2018-01-04 23:57:01,194: SQL status: COMMIT in 0.34 seconds
2018-01-04 23:57:01,194: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85f90d0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:57:01,222: 23:57:01 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 391 in 2.26s]
2018-01-04 23:57:01,222: Compiling model.parsely.parsely_incoming_users
2018-01-04 23:57:01,228: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-04 23:57:01,230: 23:57:01 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-04 23:57:01,230: Compiling model.parsely.parsely_users
2018-01-04 23:57:01,236: Acquiring new redshift connection "parsely_users".
2018-01-04 23:57:01,237: Re-using an available connection from the pool.
2018-01-04 23:57:01,237: Using redshift connection "parsely_users".
2018-01-04 23:57:01,237: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:57:01,259: SQL status: SELECT in 0.02 seconds
2018-01-04 23:57:01,300: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-04 23:57:01,301: Using redshift connection "parsely_users".
2018-01-04 23:57:01,301: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:57:01,325: SQL status: SELECT in 0.02 seconds
2018-01-04 23:57:01,325: Using redshift connection "parsely_users".
2018-01-04 23:57:01,325: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:57:01,347: SQL status: SELECT in 0.02 seconds
2018-01-04 23:57:01,349: Using redshift connection "parsely_users".
2018-01-04 23:57:01,350: On parsely_users: BEGIN
2018-01-04 23:57:01,352: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:57:01,352: Using redshift connection "parsely_users".
2018-01-04 23:57:01,352: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:57:03,890: SQL status: SELECT in 2.54 seconds
2018-01-04 23:57:03,890: Using redshift connection "parsely_users".
2018-01-04 23:57:03,890: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-04 23:57:04,062: SQL status: SELECT in 0.17 seconds
2018-01-04 23:57:04,063: Using redshift connection "parsely_users".
2018-01-04 23:57:04,063: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:57:04,179: SQL status: SELECT in 0.12 seconds
2018-01-04 23:57:04,179: Using redshift connection "parsely_users".
2018-01-04 23:57:04,179: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:57:04,294: SQL status: SELECT in 0.12 seconds
2018-01-04 23:57:04,296: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-04 23:57:04,297: Using redshift connection "parsely_users".
2018-01-04 23:57:04,297: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-04 23:57:04,601: SQL status: INSERT 0 53992 in 0.30 seconds
2018-01-04 23:57:04,601: On parsely_users: COMMIT
2018-01-04 23:57:04,601: Using redshift connection "parsely_users".
2018-01-04 23:57:04,601: On parsely_users: COMMIT
2018-01-04 23:57:05,076: SQL status: COMMIT in 0.47 seconds
2018-01-04 23:57:05,076: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85e0ed0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:57:05,105: 23:57:05 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 53992 in 3.85s]
2018-01-04 23:57:05,105: 23:57:05 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-04 23:57:05,105: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-04 23:57:05,137: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 23:57:05,139: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:57:05,139: Re-using an available connection from the pool.
2018-01-04 23:57:05,139: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:57:05,140: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:57:05,162: SQL status: SELECT in 0.02 seconds
2018-01-04 23:57:05,165: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-04 23:57:05,166: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:57:05,166: On parsely_pageview_engagedtime: BEGIN
2018-01-04 23:57:05,168: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:57:05,168: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:57:05,168: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-04 23:57:05,536: SQL status: CREATE VIEW in 0.37 seconds
2018-01-04 23:57:05,537: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:57:05,539: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-04 23:57:05,544: SQL status: ALTER TABLE in 0.00 seconds
2018-01-04 23:57:05,544: On parsely_pageview_engagedtime: COMMIT
2018-01-04 23:57:05,544: Using redshift connection "parsely_pageview_engagedtime".
2018-01-04 23:57:05,544: On parsely_pageview_engagedtime: COMMIT
2018-01-04 23:57:05,793: SQL status: COMMIT in 0.25 seconds
2018-01-04 23:57:05,793: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d863e710>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:57:05,822: 23:57:05 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.69s]
2018-01-04 23:57:05,823: 23:57:05 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-04 23:57:05,823: Compiling model.parsely.parsely_incoming_sessions
2018-01-04 23:57:05,830: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 23:57:05,832: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-04 23:57:05,832: Re-using an available connection from the pool.
2018-01-04 23:57:05,832: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:57:05,832: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:57:05,854: SQL status: SELECT in 0.02 seconds
2018-01-04 23:57:05,858: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-04 23:57:05,859: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:57:05,860: On parsely_incoming_sessions: BEGIN
2018-01-04 23:57:05,862: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:57:05,862: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:57:05,862: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-04 23:57:06,312: SQL status: CREATE VIEW in 0.45 seconds
2018-01-04 23:57:06,312: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:57:06,312: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-04 23:57:06,317: SQL status: ALTER TABLE in 0.01 seconds
2018-01-04 23:57:06,318: On parsely_incoming_sessions: COMMIT
2018-01-04 23:57:06,318: Using redshift connection "parsely_incoming_sessions".
2018-01-04 23:57:06,318: On parsely_incoming_sessions: COMMIT
2018-01-04 23:57:07,106: SQL status: COMMIT in 0.79 seconds
2018-01-04 23:57:07,107: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d86466d0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:57:07,133: 23:57:07 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 1.28s]
2018-01-04 23:57:07,134: 23:57:07 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-04 23:57:07,134: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-04 23:57:07,143: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 23:57:07,144: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:57:07,144: Re-using an available connection from the pool.
2018-01-04 23:57:07,145: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:57:07,145: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:57:07,167: SQL status: SELECT in 0.02 seconds
2018-01-04 23:57:07,167: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:57:07,167: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:57:07,187: SQL status: SELECT in 0.02 seconds
2018-01-04 23:57:07,189: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:57:07,189: On parsely_pageview_behavior_workflow: BEGIN
2018-01-04 23:57:07,191: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:57:07,191: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:57:07,191: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-04 23:59:39,742: SQL status: SELECT in 152.55 seconds
2018-01-04 23:59:39,743: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:59:39,743: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-04 23:59:39,950: SQL status: SELECT in 0.21 seconds
2018-01-04 23:59:39,951: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:59:39,951: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:59:40,074: SQL status: SELECT in 0.12 seconds
2018-01-04 23:59:40,075: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:59:40,075: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-04 23:59:40,198: SQL status: SELECT in 0.12 seconds
2018-01-04 23:59:40,201: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-04 23:59:40,202: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:59:40,202: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-04 23:59:43,633: SQL status: INSERT 0 110435 in 3.43 seconds
2018-01-04 23:59:43,634: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 23:59:43,634: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-04 23:59:43,634: On parsely_pageview_behavior_workflow: COMMIT
2018-01-04 23:59:45,226: SQL status: COMMIT in 1.59 seconds
2018-01-04 23:59:45,227: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d857f7d0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-04 23:59:45,275: 23:59:45 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 110435 in 158.09s]
2018-01-04 23:59:45,276: 23:59:45 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-04 23:59:45,276: Compiling model.parsely.parsely_sessions
2018-01-04 23:59:45,282: Acquiring new redshift connection "parsely_sessions".
2018-01-04 23:59:45,282: Re-using an available connection from the pool.
2018-01-04 23:59:45,282: Using redshift connection "parsely_sessions".
2018-01-04 23:59:45,282: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:59:45,304: SQL status: SELECT in 0.02 seconds
2018-01-04 23:59:45,307: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-04 23:59:45,309: Using redshift connection "parsely_sessions".
2018-01-04 23:59:45,309: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:59:45,329: SQL status: SELECT in 0.02 seconds
2018-01-04 23:59:45,330: Using redshift connection "parsely_sessions".
2018-01-04 23:59:45,330: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-04 23:59:45,351: SQL status: SELECT in 0.02 seconds
2018-01-04 23:59:45,354: Using redshift connection "parsely_sessions".
2018-01-04 23:59:45,354: On parsely_sessions: BEGIN
2018-01-04 23:59:45,356: SQL status: BEGIN in 0.00 seconds
2018-01-04 23:59:45,356: Using redshift connection "parsely_sessions".
2018-01-04 23:59:45,356: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:00:19,621: SQL status: SELECT in 34.26 seconds
2018-01-05 00:00:19,621: Using redshift connection "parsely_sessions".
2018-01-05 00:00:19,621: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-05 00:00:19,811: SQL status: SELECT in 0.19 seconds
2018-01-05 00:00:19,812: Using redshift connection "parsely_sessions".
2018-01-05 00:00:19,812: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:00:19,932: SQL status: SELECT in 0.12 seconds
2018-01-05 00:00:19,933: Using redshift connection "parsely_sessions".
2018-01-05 00:00:19,933: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:00:20,058: SQL status: SELECT in 0.12 seconds
2018-01-05 00:00:20,061: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-05 00:00:20,062: Using redshift connection "parsely_sessions".
2018-01-05 00:00:20,062: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-05 00:00:22,083: SQL status: INSERT 0 89801 in 2.02 seconds
2018-01-05 00:00:22,084: On parsely_sessions: COMMIT
2018-01-05 00:00:22,084: Using redshift connection "parsely_sessions".
2018-01-05 00:00:22,084: On parsely_sessions: COMMIT
2018-01-05 00:00:23,398: SQL status: COMMIT in 1.31 seconds
2018-01-05 00:00:23,398: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d85f9ad0>], 'label': '8699bc47-8239-4d49-84d1-a23baec26cea'}
2018-01-05 00:00:23,425: 00:00:23 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 89801 in 38.12s]
2018-01-05 00:00:23,473: Using redshift connection "master".
2018-01-05 00:00:23,473: On master: BEGIN
2018-01-05 00:00:23,475: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:00:23,475: On master: COMMIT
2018-01-05 00:00:23,475: Using redshift connection "master".
2018-01-05 00:00:23,475: On master: COMMIT
2018-01-05 00:00:23,477: SQL status: COMMIT in 0.00 seconds
2018-01-05 00:00:23,477: Compiling operation.parsely.parsely-on-run-end-0
2018-01-05 00:00:23,482: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-05 00:00:23,483: Using redshift connection "master".
2018-01-05 00:00:23,484: On master:  select 1 
2018-01-05 00:00:23,486: SQL status: SELECT in 0.00 seconds
2018-01-05 00:00:23,486: 00:00:23 | 
2018-01-05 00:00:23,486: 00:00:23 | Finished running 10 view models, 15 incremental models in 1188.98s.
2018-01-05 00:00:23,487: 
2018-01-05 00:00:23,487: Completed successfully
2018-01-05 00:00:23,487: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-05 00:00:23,487: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d8691e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d8691f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb9d8678950>], 'label': 'end'}
2018-01-05 00:00:23,520: Flushing usage events
2018-01-05 00:00:32,677: Tracking: tracking
2018-01-05 00:00:32,677: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b587e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b587f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b587ed0>], 'label': 'start'}
2018-01-05 00:00:32,715: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-05 00:00:32,731: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-05 00:00:32,732: Parsing core.sql
2018-01-05 00:00:32,744: Parsing etc/get_custom_schema.sql
2018-01-05 00:00:32,750: Parsing schema_tests/relationships.sql
2018-01-05 00:00:32,752: Parsing schema_tests/accepted_values.sql
2018-01-05 00:00:32,755: Parsing schema_tests/not_null.sql
2018-01-05 00:00:32,757: Parsing schema_tests/unique.sql
2018-01-05 00:00:32,758: Parsing materializations/wrapper.sql
2018-01-05 00:00:32,761: Parsing materializations/archive.sql
2018-01-05 00:00:32,789: Parsing materializations/table.sql
2018-01-05 00:00:32,807: Parsing materializations/helpers.sql
2018-01-05 00:00:32,822: Parsing materializations/bigquery.sql
2018-01-05 00:00:32,835: Parsing materializations/view.sql
2018-01-05 00:00:32,848: Parsing materializations/incremental.sql
2018-01-05 00:00:32,873: Parsing adapters/redshift.sql
2018-01-05 00:00:32,890: Parsing adapters/bigquery.sql
2018-01-05 00:00:32,894: Parsing adapters/postgres.sql
2018-01-05 00:00:32,897: Parsing adapters/common.sql
2018-01-05 00:00:32,915: Parsing model.parsely.parsely_audit
2018-01-05 00:00:32,916: Parsing model.parsely.parsely_video_content
2018-01-05 00:00:32,919: Parsing model.parsely.parsely_post_content
2018-01-05 00:00:32,922: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-05 00:00:32,925: Parsing model.parsely.parsely_rawdata
2018-01-05 00:00:32,928: Parsing model.parsely.calendar
2018-01-05 00:00:32,929: Parsing model.parsely.parsely_all_events
2018-01-05 00:00:32,937: Acquiring new redshift connection "parsely_all_events".
2018-01-05 00:00:32,937: Opening a new connection (0 currently allocated)
2018-01-05 00:00:32,950: Using redshift connection "parsely_all_events".
2018-01-05 00:00:32,950: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:32,977: SQL status: SELECT in 0.03 seconds
2018-01-05 00:00:32,982: Parsing model.parsely.parsely_event_ids
2018-01-05 00:00:32,984: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-05 00:00:32,987: Parsing model.parsely.parsely_base_events
2018-01-05 00:00:32,990: Acquiring new redshift connection "parsely_base_events".
2018-01-05 00:00:32,990: Re-using an available connection from the pool.
2018-01-05 00:00:32,990: Using redshift connection "parsely_base_events".
2018-01-05 00:00:32,991: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:33,012: SQL status: SELECT in 0.02 seconds
2018-01-05 00:00:33,013: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-05 00:00:33,018: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-05 00:00:33,022: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-05 00:00:33,024: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-05 00:00:33,026: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-05 00:00:33,029: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-05 00:00:33,035: Parsing model.parsely.parsely_incoming_pageviews
2018-01-05 00:00:33,042: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-05 00:00:33,047: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:00:33,047: Re-using an available connection from the pool.
2018-01-05 00:00:33,047: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:00:33,047: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:33,069: SQL status: SELECT in 0.02 seconds
2018-01-05 00:00:33,069: Parsing model.parsely.parsely_incoming_videoviews
2018-01-05 00:00:33,076: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-05 00:00:33,081: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:00:33,081: Re-using an available connection from the pool.
2018-01-05 00:00:33,081: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:00:33,081: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:33,103: SQL status: SELECT in 0.02 seconds
2018-01-05 00:00:33,104: Parsing model.parsely.parsely_incoming_users
2018-01-05 00:00:33,106: Parsing model.parsely.parsely_users
2018-01-05 00:00:33,111: Acquiring new redshift connection "parsely_users".
2018-01-05 00:00:33,111: Re-using an available connection from the pool.
2018-01-05 00:00:33,111: Using redshift connection "parsely_users".
2018-01-05 00:00:33,112: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:33,133: SQL status: SELECT in 0.02 seconds
2018-01-05 00:00:33,134: Parsing model.parsely.parsely_errors
2018-01-05 00:00:33,138: Parsing model.parsely.parsely_bot_traffic
2018-01-05 00:00:33,142: Parsing model.parsely.parsely_custom_events
2018-01-05 00:00:33,146: Parsing model.parsely.parsely_incoming_sessions
2018-01-05 00:00:33,150: Parsing model.parsely.parsely_entry_exit_urls
2018-01-05 00:00:33,153: Parsing model.parsely.parsely_sessions
2018-01-05 00:00:33,158: Acquiring new redshift connection "parsely_sessions".
2018-01-05 00:00:33,158: Re-using an available connection from the pool.
2018-01-05 00:00:33,158: Using redshift connection "parsely_sessions".
2018-01-05 00:00:33,158: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:33,180: SQL status: SELECT in 0.02 seconds
2018-01-05 00:00:33,181: Parsing model.parsely.parsely_campaigns
2018-01-05 00:00:33,187: Acquiring new redshift connection "parsely_campaigns".
2018-01-05 00:00:33,188: Re-using an available connection from the pool.
2018-01-05 00:00:33,188: Using redshift connection "parsely_campaigns".
2018-01-05 00:00:33,188: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:33,210: SQL status: SELECT in 0.02 seconds
2018-01-05 00:00:33,219: Parsing operation.parsely.parsely-on-run-end-0
2018-01-05 00:00:33,226: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-05 00:00:33,236: 
2018-01-05 00:00:33,239: Acquiring new redshift connection "master".
2018-01-05 00:00:33,239: Re-using an available connection from the pool.
2018-01-05 00:00:33,239: Using redshift connection "master".
2018-01-05 00:00:33,239: On master: select distinct nspname from pg_namespace
2018-01-05 00:00:33,241: SQL status: SELECT in 0.00 seconds
2018-01-05 00:00:33,246: Using redshift connection "master".
2018-01-05 00:00:33,246: On master: BEGIN
2018-01-05 00:00:33,248: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:00:33,248: On master: COMMIT
2018-01-05 00:00:33,248: Using redshift connection "master".
2018-01-05 00:00:33,248: On master: COMMIT
2018-01-05 00:00:33,250: SQL status: COMMIT in 0.00 seconds
2018-01-05 00:00:33,264: 00:00:33 | Concurrency: 1 threads (target='dev')
2018-01-05 00:00:33,265: 00:00:33 | 
2018-01-05 00:00:33,265: Using redshift connection "master".
2018-01-05 00:00:33,265: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:33,287: SQL status: SELECT in 0.02 seconds
2018-01-05 00:00:33,360: 00:00:33 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-05 00:00:33,360: Compiling model.parsely.calendar
2018-01-05 00:00:33,365: Writing injected SQL for node "model.parsely.calendar"
2018-01-05 00:00:33,366: Acquiring new redshift connection "calendar".
2018-01-05 00:00:33,366: Opening a new connection (1 currently allocated)
2018-01-05 00:00:33,383: Using redshift connection "calendar".
2018-01-05 00:00:33,383: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:33,410: SQL status: SELECT in 0.03 seconds
2018-01-05 00:00:33,412: Writing runtime SQL for node "model.parsely.calendar"
2018-01-05 00:00:33,413: Using redshift connection "calendar".
2018-01-05 00:00:33,413: On calendar: BEGIN
2018-01-05 00:00:33,415: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:00:33,415: Using redshift connection "calendar".
2018-01-05 00:00:33,415: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-05 00:00:33,837: SQL status: CREATE VIEW in 0.42 seconds
2018-01-05 00:00:33,837: On calendar: COMMIT
2018-01-05 00:00:33,838: Using redshift connection "calendar".
2018-01-05 00:00:33,838: On calendar: COMMIT
2018-01-05 00:00:34,186: SQL status: COMMIT in 0.35 seconds
2018-01-05 00:00:34,186: Using redshift connection "calendar".
2018-01-05 00:00:34,186: On calendar: BEGIN
2018-01-05 00:00:34,188: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:00:34,189: Using redshift connection "calendar".
2018-01-05 00:00:34,189: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-05 00:00:34,303: SQL status: DROP VIEW in 0.11 seconds
2018-01-05 00:00:34,303: On calendar: COMMIT
2018-01-05 00:00:34,303: Using redshift connection "calendar".
2018-01-05 00:00:34,303: On calendar: COMMIT
2018-01-05 00:00:34,813: SQL status: COMMIT in 0.51 seconds
2018-01-05 00:00:34,813: Using redshift connection "calendar".
2018-01-05 00:00:34,813: On calendar: BEGIN
2018-01-05 00:00:34,816: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:00:34,816: Using redshift connection "calendar".
2018-01-05 00:00:34,816: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-05 00:00:34,821: SQL status: ALTER TABLE in 0.01 seconds
2018-01-05 00:00:34,821: On calendar: COMMIT
2018-01-05 00:00:34,821: Using redshift connection "calendar".
2018-01-05 00:00:34,821: On calendar: COMMIT
2018-01-05 00:00:35,039: SQL status: COMMIT in 0.22 seconds
2018-01-05 00:00:35,039: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b475bd0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:00:35,069: 00:00:35 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.68s]
2018-01-05 00:00:35,070: 00:00:35 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-05 00:00:35,070: Compiling model.parsely.parsely_rawdata
2018-01-05 00:00:35,076: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-05 00:00:35,077: Acquiring new redshift connection "parsely_rawdata".
2018-01-05 00:00:35,077: Re-using an available connection from the pool.
2018-01-05 00:00:35,077: Using redshift connection "parsely_rawdata".
2018-01-05 00:00:35,077: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:35,099: SQL status: SELECT in 0.02 seconds
2018-01-05 00:00:35,099: Using redshift connection "parsely_rawdata".
2018-01-05 00:00:35,100: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:00:35,120: SQL status: SELECT in 0.02 seconds
2018-01-05 00:00:35,121: Using redshift connection "parsely_rawdata".
2018-01-05 00:00:35,121: On parsely_rawdata: BEGIN
2018-01-05 00:00:35,123: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:00:35,123: Using redshift connection "parsely_rawdata".
2018-01-05 00:00:35,124: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:01:08,710: SQL status: SELECT in 33.59 seconds
2018-01-05 00:01:08,710: Using redshift connection "parsely_rawdata".
2018-01-05 00:01:08,711: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-05 00:01:08,901: SQL status: SELECT in 0.19 seconds
2018-01-05 00:01:08,902: Using redshift connection "parsely_rawdata".
2018-01-05 00:01:08,902: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:01:09,022: SQL status: SELECT in 0.12 seconds
2018-01-05 00:01:09,023: Using redshift connection "parsely_rawdata".
2018-01-05 00:01:09,023: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:01:09,147: SQL status: SELECT in 0.12 seconds
2018-01-05 00:01:09,150: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-05 00:01:09,152: Using redshift connection "parsely_rawdata".
2018-01-05 00:01:09,152: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-05 00:01:49,766: SQL status: INSERT 0 1047403 in 40.61 seconds
2018-01-05 00:01:49,767: On parsely_rawdata: COMMIT
2018-01-05 00:01:49,767: Using redshift connection "parsely_rawdata".
2018-01-05 00:01:49,767: On parsely_rawdata: COMMIT
2018-01-05 00:01:52,624: SQL status: COMMIT in 2.86 seconds
2018-01-05 00:01:52,625: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4dfb10>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:01:52,676: 00:01:52 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1047403 in 77.55s]
2018-01-05 00:01:52,676: 00:01:52 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-05 00:01:52,676: Compiling model.parsely.parsely_all_events
2018-01-05 00:01:52,685: Acquiring new redshift connection "parsely_all_events".
2018-01-05 00:01:52,685: Re-using an available connection from the pool.
2018-01-05 00:01:52,685: Using redshift connection "parsely_all_events".
2018-01-05 00:01:52,685: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:01:52,711: SQL status: SELECT in 0.03 seconds
2018-01-05 00:01:52,719: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-05 00:01:52,721: Using redshift connection "parsely_all_events".
2018-01-05 00:01:52,721: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:01:52,743: SQL status: SELECT in 0.02 seconds
2018-01-05 00:01:52,743: Using redshift connection "parsely_all_events".
2018-01-05 00:01:52,743: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:01:52,769: SQL status: SELECT in 0.03 seconds
2018-01-05 00:01:52,771: Using redshift connection "parsely_all_events".
2018-01-05 00:01:52,771: On parsely_all_events: BEGIN
2018-01-05 00:01:52,773: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:01:52,773: Using redshift connection "parsely_all_events".
2018-01-05 00:01:52,773: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:03:32,334: SQL status: SELECT in 99.56 seconds
2018-01-05 00:03:32,334: Using redshift connection "parsely_all_events".
2018-01-05 00:03:32,335: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-05 00:03:32,499: SQL status: SELECT in 0.16 seconds
2018-01-05 00:03:32,499: Using redshift connection "parsely_all_events".
2018-01-05 00:03:32,499: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:03:32,622: SQL status: SELECT in 0.12 seconds
2018-01-05 00:03:32,623: Using redshift connection "parsely_all_events".
2018-01-05 00:03:32,623: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:03:32,745: SQL status: SELECT in 0.12 seconds
2018-01-05 00:03:32,748: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-05 00:03:32,750: Using redshift connection "parsely_all_events".
2018-01-05 00:03:32,750: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-05 00:03:51,726: SQL status: INSERT 0 931911 in 18.98 seconds
2018-01-05 00:03:51,727: On parsely_all_events: COMMIT
2018-01-05 00:03:51,727: Using redshift connection "parsely_all_events".
2018-01-05 00:03:51,727: On parsely_all_events: COMMIT
2018-01-05 00:03:54,448: SQL status: COMMIT in 2.72 seconds
2018-01-05 00:03:54,449: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b534810>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:03:54,493: 00:03:54 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 931911 in 121.77s]
2018-01-05 00:03:54,494: 00:03:54 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-05 00:03:54,494: Compiling model.parsely.parsely_bot_traffic
2018-01-05 00:03:54,501: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-05 00:03:54,503: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-05 00:03:54,503: Re-using an available connection from the pool.
2018-01-05 00:03:54,503: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:03:54,503: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:03:54,527: SQL status: SELECT in 0.02 seconds
2018-01-05 00:03:54,527: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:03:54,527: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:03:54,548: SQL status: SELECT in 0.02 seconds
2018-01-05 00:03:54,549: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:03:54,550: On parsely_bot_traffic: BEGIN
2018-01-05 00:03:54,552: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:03:54,552: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:03:54,552: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:05:06,750: SQL status: SELECT in 72.20 seconds
2018-01-05 00:05:06,750: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:05:06,750: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-05 00:05:06,927: SQL status: SELECT in 0.18 seconds
2018-01-05 00:05:06,928: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:05:06,928: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:05:07,051: SQL status: SELECT in 0.12 seconds
2018-01-05 00:05:07,052: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:05:07,052: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:05:07,175: SQL status: SELECT in 0.12 seconds
2018-01-05 00:05:07,179: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-05 00:05:07,180: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:05:07,180: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-05 00:05:08,760: SQL status: INSERT 0 4 in 1.58 seconds
2018-01-05 00:05:08,761: On parsely_bot_traffic: COMMIT
2018-01-05 00:05:08,761: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:05:08,761: On parsely_bot_traffic: COMMIT
2018-01-05 00:05:10,323: SQL status: COMMIT in 1.56 seconds
2018-01-05 00:05:10,323: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b475c90>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:05:10,366: 00:05:10 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 75.83s]
2018-01-05 00:05:10,366: 00:05:10 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-05 00:05:10,366: Compiling model.parsely.parsely_custom_events
2018-01-05 00:05:10,374: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-05 00:05:10,376: Acquiring new redshift connection "parsely_custom_events".
2018-01-05 00:05:10,376: Re-using an available connection from the pool.
2018-01-05 00:05:10,376: Using redshift connection "parsely_custom_events".
2018-01-05 00:05:10,377: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:05:10,398: SQL status: SELECT in 0.02 seconds
2018-01-05 00:05:10,399: Using redshift connection "parsely_custom_events".
2018-01-05 00:05:10,399: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:05:10,420: SQL status: SELECT in 0.02 seconds
2018-01-05 00:05:10,422: Using redshift connection "parsely_custom_events".
2018-01-05 00:05:10,422: On parsely_custom_events: BEGIN
2018-01-05 00:05:10,424: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:05:10,424: Using redshift connection "parsely_custom_events".
2018-01-05 00:05:10,424: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:06:24,764: SQL status: SELECT in 74.34 seconds
2018-01-05 00:06:24,764: Using redshift connection "parsely_custom_events".
2018-01-05 00:06:24,764: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-05 00:06:24,981: SQL status: SELECT in 0.22 seconds
2018-01-05 00:06:24,981: Using redshift connection "parsely_custom_events".
2018-01-05 00:06:24,981: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:06:25,107: SQL status: SELECT in 0.13 seconds
2018-01-05 00:06:25,108: Using redshift connection "parsely_custom_events".
2018-01-05 00:06:25,108: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:06:25,233: SQL status: SELECT in 0.12 seconds
2018-01-05 00:06:25,236: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-05 00:06:25,237: Using redshift connection "parsely_custom_events".
2018-01-05 00:06:25,237: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-05 00:06:25,513: SQL status: INSERT 0 0 in 0.28 seconds
2018-01-05 00:06:25,513: On parsely_custom_events: COMMIT
2018-01-05 00:06:25,513: Using redshift connection "parsely_custom_events".
2018-01-05 00:06:25,514: On parsely_custom_events: COMMIT
2018-01-05 00:06:26,153: SQL status: COMMIT in 0.64 seconds
2018-01-05 00:06:26,153: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b475c90>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:06:26,269: 00:06:26 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 75.79s]
2018-01-05 00:06:26,270: 00:06:26 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-05 00:06:26,270: Compiling model.parsely.parsely_errors
2018-01-05 00:06:26,278: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-05 00:06:26,279: Acquiring new redshift connection "parsely_errors".
2018-01-05 00:06:26,279: Re-using an available connection from the pool.
2018-01-05 00:06:26,279: Using redshift connection "parsely_errors".
2018-01-05 00:06:26,279: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:06:26,301: SQL status: SELECT in 0.02 seconds
2018-01-05 00:06:26,301: Using redshift connection "parsely_errors".
2018-01-05 00:06:26,301: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:06:26,324: SQL status: SELECT in 0.02 seconds
2018-01-05 00:06:26,325: Using redshift connection "parsely_errors".
2018-01-05 00:06:26,325: On parsely_errors: BEGIN
2018-01-05 00:06:26,327: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:06:26,327: Using redshift connection "parsely_errors".
2018-01-05 00:06:26,327: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:07:40,492: SQL status: SELECT in 74.16 seconds
2018-01-05 00:07:40,492: Using redshift connection "parsely_errors".
2018-01-05 00:07:40,492: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-05 00:07:40,691: SQL status: SELECT in 0.20 seconds
2018-01-05 00:07:40,692: Using redshift connection "parsely_errors".
2018-01-05 00:07:40,692: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:07:40,813: SQL status: SELECT in 0.12 seconds
2018-01-05 00:07:40,814: Using redshift connection "parsely_errors".
2018-01-05 00:07:40,814: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:07:40,935: SQL status: SELECT in 0.12 seconds
2018-01-05 00:07:40,938: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-05 00:07:40,939: Using redshift connection "parsely_errors".
2018-01-05 00:07:40,940: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-05 00:07:42,010: SQL status: INSERT 0 2 in 1.07 seconds
2018-01-05 00:07:42,010: On parsely_errors: COMMIT
2018-01-05 00:07:42,010: Using redshift connection "parsely_errors".
2018-01-05 00:07:42,011: On parsely_errors: COMMIT
2018-01-05 00:07:42,675: SQL status: COMMIT in 0.66 seconds
2018-01-05 00:07:42,676: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b46ba90>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:07:42,722: 00:07:42 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 76.41s]
2018-01-05 00:07:42,723: 00:07:42 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-05 00:07:42,723: Compiling model.parsely.parsely_base_events
2018-01-05 00:07:42,727: Acquiring new redshift connection "parsely_base_events".
2018-01-05 00:07:42,727: Re-using an available connection from the pool.
2018-01-05 00:07:42,727: Using redshift connection "parsely_base_events".
2018-01-05 00:07:42,727: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:07:42,749: SQL status: SELECT in 0.02 seconds
2018-01-05 00:07:42,753: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-05 00:07:42,754: Using redshift connection "parsely_base_events".
2018-01-05 00:07:42,754: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:07:42,776: SQL status: SELECT in 0.02 seconds
2018-01-05 00:07:42,778: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-05 00:07:42,779: Using redshift connection "parsely_base_events".
2018-01-05 00:07:42,779: On parsely_base_events: BEGIN
2018-01-05 00:07:42,781: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:07:42,781: Using redshift connection "parsely_base_events".
2018-01-05 00:07:42,781: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-05 00:07:43,403: SQL status: CREATE VIEW in 0.62 seconds
2018-01-05 00:07:43,403: On parsely_base_events: COMMIT
2018-01-05 00:07:43,403: Using redshift connection "parsely_base_events".
2018-01-05 00:07:43,403: On parsely_base_events: COMMIT
2018-01-05 00:07:44,033: SQL status: COMMIT in 0.63 seconds
2018-01-05 00:07:44,034: Using redshift connection "parsely_base_events".
2018-01-05 00:07:44,034: On parsely_base_events: BEGIN
2018-01-05 00:07:44,036: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:07:44,036: Using redshift connection "parsely_base_events".
2018-01-05 00:07:44,036: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-05 00:07:45,193: SQL status: DROP VIEW in 1.16 seconds
2018-01-05 00:07:45,193: On parsely_base_events: COMMIT
2018-01-05 00:07:45,193: Using redshift connection "parsely_base_events".
2018-01-05 00:07:45,194: On parsely_base_events: COMMIT
2018-01-05 00:07:45,842: SQL status: COMMIT in 0.65 seconds
2018-01-05 00:07:45,842: Using redshift connection "parsely_base_events".
2018-01-05 00:07:45,842: On parsely_base_events: BEGIN
2018-01-05 00:07:45,845: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:07:45,845: Using redshift connection "parsely_base_events".
2018-01-05 00:07:45,846: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-05 00:07:46,017: SQL status: ALTER TABLE in 0.17 seconds
2018-01-05 00:07:46,018: On parsely_base_events: COMMIT
2018-01-05 00:07:46,018: Using redshift connection "parsely_base_events".
2018-01-05 00:07:46,018: On parsely_base_events: COMMIT
2018-01-05 00:07:46,525: SQL status: COMMIT in 0.51 seconds
2018-01-05 00:07:46,525: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4df9d0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:07:46,584: 00:07:46 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 3.80s]
2018-01-05 00:07:46,584: 00:07:46 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-05 00:07:46,585: Compiling model.parsely.parsely_event_ids
2018-01-05 00:07:46,590: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-05 00:07:46,592: Acquiring new redshift connection "parsely_event_ids".
2018-01-05 00:07:46,592: Re-using an available connection from the pool.
2018-01-05 00:07:46,592: Using redshift connection "parsely_event_ids".
2018-01-05 00:07:46,592: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:07:46,616: SQL status: SELECT in 0.02 seconds
2018-01-05 00:07:46,616: Using redshift connection "parsely_event_ids".
2018-01-05 00:07:46,616: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:07:46,637: SQL status: SELECT in 0.02 seconds
2018-01-05 00:07:46,638: Using redshift connection "parsely_event_ids".
2018-01-05 00:07:46,638: On parsely_event_ids: BEGIN
2018-01-05 00:07:46,640: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:07:46,640: Using redshift connection "parsely_event_ids".
2018-01-05 00:07:46,640: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:07:48,944: SQL status: SELECT in 2.30 seconds
2018-01-05 00:07:48,944: Using redshift connection "parsely_event_ids".
2018-01-05 00:07:48,944: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-05 00:07:49,203: SQL status: SELECT in 0.26 seconds
2018-01-05 00:07:49,203: Using redshift connection "parsely_event_ids".
2018-01-05 00:07:49,203: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:07:49,321: SQL status: SELECT in 0.12 seconds
2018-01-05 00:07:49,321: Using redshift connection "parsely_event_ids".
2018-01-05 00:07:49,321: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:07:49,436: SQL status: SELECT in 0.12 seconds
2018-01-05 00:07:49,437: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-05 00:07:49,438: Using redshift connection "parsely_event_ids".
2018-01-05 00:07:49,439: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-05 00:07:51,329: SQL status: INSERT 0 931907 in 1.89 seconds
2018-01-05 00:07:51,330: On parsely_event_ids: COMMIT
2018-01-05 00:07:51,330: Using redshift connection "parsely_event_ids".
2018-01-05 00:07:51,330: On parsely_event_ids: COMMIT
2018-01-05 00:07:51,998: SQL status: COMMIT in 0.67 seconds
2018-01-05 00:07:51,998: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b497dd0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:07:52,030: 00:07:52 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 931907 in 5.41s]
2018-01-05 00:07:52,031: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-05 00:07:52,036: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-05 00:07:52,037: 00:07:52 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-05 00:07:52,037: Compiling model.parsely.parsely_post_content
2018-01-05 00:07:52,043: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-05 00:07:52,045: Acquiring new redshift connection "parsely_post_content".
2018-01-05 00:07:52,045: Re-using an available connection from the pool.
2018-01-05 00:07:52,045: Using redshift connection "parsely_post_content".
2018-01-05 00:07:52,045: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:07:52,067: SQL status: SELECT in 0.02 seconds
2018-01-05 00:07:52,067: Using redshift connection "parsely_post_content".
2018-01-05 00:07:52,067: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:07:52,088: SQL status: SELECT in 0.02 seconds
2018-01-05 00:07:52,089: Using redshift connection "parsely_post_content".
2018-01-05 00:07:52,089: On parsely_post_content: BEGIN
2018-01-05 00:07:52,091: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:07:52,091: Using redshift connection "parsely_post_content".
2018-01-05 00:07:52,091: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:08:07,803: SQL status: SELECT in 15.71 seconds
2018-01-05 00:08:07,804: Using redshift connection "parsely_post_content".
2018-01-05 00:08:07,804: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-05 00:08:08,012: SQL status: SELECT in 0.21 seconds
2018-01-05 00:08:08,013: Using redshift connection "parsely_post_content".
2018-01-05 00:08:08,013: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:08:08,131: SQL status: SELECT in 0.12 seconds
2018-01-05 00:08:08,131: Using redshift connection "parsely_post_content".
2018-01-05 00:08:08,132: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:08:08,250: SQL status: SELECT in 0.12 seconds
2018-01-05 00:08:08,251: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-05 00:08:08,252: Using redshift connection "parsely_post_content".
2018-01-05 00:08:08,252: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-05 00:08:08,676: SQL status: INSERT 0 894 in 0.42 seconds
2018-01-05 00:08:08,676: On parsely_post_content: COMMIT
2018-01-05 00:08:08,676: Using redshift connection "parsely_post_content".
2018-01-05 00:08:08,676: On parsely_post_content: COMMIT
2018-01-05 00:08:09,407: SQL status: COMMIT in 0.73 seconds
2018-01-05 00:08:09,407: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4d6ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:08:09,436: 00:08:09 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 894 in 17.37s]
2018-01-05 00:08:09,437: 00:08:09 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-05 00:08:09,437: Compiling model.parsely.parsely_video_content
2018-01-05 00:08:09,443: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-05 00:08:09,444: Acquiring new redshift connection "parsely_video_content".
2018-01-05 00:08:09,444: Re-using an available connection from the pool.
2018-01-05 00:08:09,444: Using redshift connection "parsely_video_content".
2018-01-05 00:08:09,444: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:08:09,466: SQL status: SELECT in 0.02 seconds
2018-01-05 00:08:09,467: Using redshift connection "parsely_video_content".
2018-01-05 00:08:09,467: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:08:09,486: SQL status: SELECT in 0.02 seconds
2018-01-05 00:08:09,488: Using redshift connection "parsely_video_content".
2018-01-05 00:08:09,488: On parsely_video_content: BEGIN
2018-01-05 00:08:09,490: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:08:09,490: Using redshift connection "parsely_video_content".
2018-01-05 00:08:09,490: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:08:23,204: SQL status: SELECT in 13.71 seconds
2018-01-05 00:08:23,204: Using redshift connection "parsely_video_content".
2018-01-05 00:08:23,204: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-05 00:08:23,377: SQL status: SELECT in 0.17 seconds
2018-01-05 00:08:23,378: Using redshift connection "parsely_video_content".
2018-01-05 00:08:23,378: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:08:23,495: SQL status: SELECT in 0.12 seconds
2018-01-05 00:08:23,496: Using redshift connection "parsely_video_content".
2018-01-05 00:08:23,496: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:08:23,613: SQL status: SELECT in 0.12 seconds
2018-01-05 00:08:23,614: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-05 00:08:23,615: Using redshift connection "parsely_video_content".
2018-01-05 00:08:23,616: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-05 00:08:24,008: SQL status: INSERT 0 470 in 0.39 seconds
2018-01-05 00:08:24,009: On parsely_video_content: COMMIT
2018-01-05 00:08:24,009: Using redshift connection "parsely_video_content".
2018-01-05 00:08:24,009: On parsely_video_content: COMMIT
2018-01-05 00:08:24,532: SQL status: COMMIT in 0.52 seconds
2018-01-05 00:08:24,533: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4d6ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:08:24,558: 00:08:24 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 470 in 15.10s]
2018-01-05 00:08:24,558: 00:08:24 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-05 00:08:24,559: Compiling model.parsely.parsely_entry_exit_urls
2018-01-05 00:08:24,564: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-05 00:08:24,565: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-05 00:08:24,565: Re-using an available connection from the pool.
2018-01-05 00:08:24,566: Using redshift connection "parsely_entry_exit_urls".
2018-01-05 00:08:24,566: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:08:24,587: SQL status: SELECT in 0.02 seconds
2018-01-05 00:08:24,589: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-05 00:08:24,590: Using redshift connection "parsely_entry_exit_urls".
2018-01-05 00:08:24,591: On parsely_entry_exit_urls: BEGIN
2018-01-05 00:08:24,592: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:08:24,593: Using redshift connection "parsely_entry_exit_urls".
2018-01-05 00:08:24,593: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-05 00:08:25,658: SQL status: CREATE VIEW in 1.06 seconds
2018-01-05 00:08:25,658: Using redshift connection "parsely_entry_exit_urls".
2018-01-05 00:08:25,658: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-05 00:08:25,661: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:08:25,661: On parsely_entry_exit_urls: COMMIT
2018-01-05 00:08:25,661: Using redshift connection "parsely_entry_exit_urls".
2018-01-05 00:08:25,662: On parsely_entry_exit_urls: COMMIT
2018-01-05 00:08:26,266: SQL status: COMMIT in 0.60 seconds
2018-01-05 00:08:26,267: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4d6ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:08:26,298: 00:08:26 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 1.71s]
2018-01-05 00:08:26,299: 00:08:26 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-05 00:08:26,299: Compiling model.parsely.parsely_incoming_videoviews
2018-01-05 00:08:26,309: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-05 00:08:26,311: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-05 00:08:26,311: Re-using an available connection from the pool.
2018-01-05 00:08:26,311: Using redshift connection "parsely_incoming_videoviews".
2018-01-05 00:08:26,311: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:08:26,333: SQL status: SELECT in 0.02 seconds
2018-01-05 00:08:26,336: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-05 00:08:26,338: Using redshift connection "parsely_incoming_videoviews".
2018-01-05 00:08:26,338: On parsely_incoming_videoviews: BEGIN
2018-01-05 00:08:26,340: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:08:26,340: Using redshift connection "parsely_incoming_videoviews".
2018-01-05 00:08:26,340: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-05 00:08:27,464: SQL status: CREATE VIEW in 1.12 seconds
2018-01-05 00:08:27,464: Using redshift connection "parsely_incoming_videoviews".
2018-01-05 00:08:27,464: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-05 00:08:27,688: SQL status: ALTER TABLE in 0.22 seconds
2018-01-05 00:08:27,688: On parsely_incoming_videoviews: COMMIT
2018-01-05 00:08:27,688: Using redshift connection "parsely_incoming_videoviews".
2018-01-05 00:08:27,688: On parsely_incoming_videoviews: COMMIT
2018-01-05 00:08:28,799: SQL status: COMMIT in 1.11 seconds
2018-01-05 00:08:28,799: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4d6ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:08:28,827: 00:08:28 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 2.50s]
2018-01-05 00:08:28,827: 00:08:28 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-05 00:08:28,827: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-05 00:08:28,832: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:08:28,832: Re-using an available connection from the pool.
2018-01-05 00:08:28,833: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:08:28,833: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:08:28,861: SQL status: SELECT in 0.03 seconds
2018-01-05 00:08:28,864: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-05 00:08:28,866: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:08:28,866: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:08:28,893: SQL status: SELECT in 0.03 seconds
2018-01-05 00:08:28,893: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:08:28,893: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:08:28,921: SQL status: SELECT in 0.03 seconds
2018-01-05 00:08:28,923: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:08:28,923: On parsely_videoviews_sessionized: BEGIN
2018-01-05 00:08:28,925: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:08:28,926: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:08:28,926: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:10:50,734: SQL status: SELECT in 141.81 seconds
2018-01-05 00:10:50,734: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:10:50,734: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-05 00:10:51,003: SQL status: SELECT in 0.27 seconds
2018-01-05 00:10:51,004: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:10:51,004: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:10:51,114: SQL status: SELECT in 0.11 seconds
2018-01-05 00:10:51,114: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:10:51,114: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:10:51,223: SQL status: SELECT in 0.11 seconds
2018-01-05 00:10:51,227: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-05 00:10:51,228: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:10:51,228: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-05 00:10:52,914: SQL status: INSERT 0 145 in 1.69 seconds
2018-01-05 00:10:52,914: On parsely_videoviews_sessionized: COMMIT
2018-01-05 00:10:52,914: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:10:52,914: On parsely_videoviews_sessionized: COMMIT
2018-01-05 00:10:56,314: SQL status: COMMIT in 3.40 seconds
2018-01-05 00:10:56,315: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4d6ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:10:56,372: 00:10:56 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 145 in 147.49s]
2018-01-05 00:10:56,373: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-05 00:10:56,397: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-05 00:10:56,398: 00:10:56 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-05 00:10:56,398: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-05 00:10:56,412: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-05 00:10:56,414: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:10:56,414: Re-using an available connection from the pool.
2018-01-05 00:10:56,414: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:10:56,414: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:10:56,426: SQL status: SELECT in 0.01 seconds
2018-01-05 00:10:56,428: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-05 00:10:56,429: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:10:56,429: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-05 00:10:56,431: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:10:56,431: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:10:56,431: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-05 00:10:57,448: SQL status: CREATE VIEW in 1.02 seconds
2018-01-05 00:10:57,448: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:10:57,448: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-05 00:10:57,452: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:10:57,452: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-05 00:10:57,452: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:10:57,452: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-05 00:10:58,364: SQL status: COMMIT in 0.91 seconds
2018-01-05 00:10:58,365: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b475ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:10:58,397: 00:10:58 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.97s]
2018-01-05 00:10:58,398: 00:10:58 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-05 00:10:58,398: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-05 00:10:58,426: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-05 00:10:58,427: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:10:58,427: Re-using an available connection from the pool.
2018-01-05 00:10:58,427: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:10:58,427: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:10:58,442: SQL status: SELECT in 0.01 seconds
2018-01-05 00:10:58,445: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-05 00:10:58,446: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:10:58,446: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-05 00:10:58,448: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:10:58,448: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:10:58,448: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-05 00:10:58,808: SQL status: CREATE VIEW in 0.36 seconds
2018-01-05 00:10:58,808: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:10:58,809: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-05 00:10:58,812: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:10:58,813: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-05 00:10:58,813: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:10:58,813: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-05 00:10:59,064: SQL status: COMMIT in 0.25 seconds
2018-01-05 00:10:59,064: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b46b1d0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:10:59,092: 00:10:59 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.67s]
2018-01-05 00:10:59,093: 00:10:59 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-05 00:10:59,093: Compiling model.parsely.parsely_incoming_pageviews
2018-01-05 00:10:59,103: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-05 00:10:59,105: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-05 00:10:59,105: Re-using an available connection from the pool.
2018-01-05 00:10:59,105: Using redshift connection "parsely_incoming_pageviews".
2018-01-05 00:10:59,106: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:10:59,116: SQL status: SELECT in 0.01 seconds
2018-01-05 00:10:59,120: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-05 00:10:59,121: Using redshift connection "parsely_incoming_pageviews".
2018-01-05 00:10:59,121: On parsely_incoming_pageviews: BEGIN
2018-01-05 00:10:59,123: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:10:59,123: Using redshift connection "parsely_incoming_pageviews".
2018-01-05 00:10:59,124: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-05 00:10:59,247: SQL status: CREATE VIEW in 0.12 seconds
2018-01-05 00:10:59,247: Using redshift connection "parsely_incoming_pageviews".
2018-01-05 00:10:59,247: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-05 00:10:59,252: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:10:59,252: On parsely_incoming_pageviews: COMMIT
2018-01-05 00:10:59,252: Using redshift connection "parsely_incoming_pageviews".
2018-01-05 00:10:59,253: On parsely_incoming_pageviews: COMMIT
2018-01-05 00:10:59,748: SQL status: COMMIT in 0.50 seconds
2018-01-05 00:10:59,748: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b56e990>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:10:59,773: 00:10:59 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.66s]
2018-01-05 00:10:59,774: 00:10:59 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-05 00:10:59,774: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-05 00:10:59,779: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:10:59,779: Re-using an available connection from the pool.
2018-01-05 00:10:59,779: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:10:59,779: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:10:59,790: SQL status: SELECT in 0.01 seconds
2018-01-05 00:10:59,794: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-05 00:10:59,796: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:10:59,796: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:10:59,806: SQL status: SELECT in 0.01 seconds
2018-01-05 00:10:59,806: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:10:59,806: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:10:59,817: SQL status: SELECT in 0.01 seconds
2018-01-05 00:10:59,819: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:10:59,819: On parsely_pageviews_sessionized: BEGIN
2018-01-05 00:10:59,821: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:10:59,821: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:10:59,821: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:16:08,662: SQL status: SELECT in 308.84 seconds
2018-01-05 00:16:08,662: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:16:08,662: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-05 00:16:08,937: SQL status: SELECT in 0.27 seconds
2018-01-05 00:16:08,937: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:16:08,937: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:16:09,058: SQL status: SELECT in 0.12 seconds
2018-01-05 00:16:09,059: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:16:09,059: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:16:09,182: SQL status: SELECT in 0.12 seconds
2018-01-05 00:16:09,185: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-05 00:16:09,186: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:16:09,186: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-05 00:16:12,527: SQL status: INSERT 0 111151 in 3.34 seconds
2018-01-05 00:16:12,527: On parsely_pageviews_sessionized: COMMIT
2018-01-05 00:16:12,527: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:16:12,527: On parsely_pageviews_sessionized: COMMIT
2018-01-05 00:16:14,009: SQL status: COMMIT in 1.48 seconds
2018-01-05 00:16:14,009: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4d6ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:16:14,065: 00:16:14 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 111151 in 314.23s]
2018-01-05 00:16:14,066: 00:16:14 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-05 00:16:14,066: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-05 00:16:14,107: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-05 00:16:14,109: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:16:14,109: Re-using an available connection from the pool.
2018-01-05 00:16:14,109: Using redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:16:14,109: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:16:14,135: SQL status: SELECT in 0.03 seconds
2018-01-05 00:16:14,137: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-05 00:16:14,139: Using redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:16:14,139: On parsely_videoview_engagedtime: BEGIN
2018-01-05 00:16:14,141: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:16:14,141: Using redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:16:14,141: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-05 00:16:14,289: SQL status: CREATE VIEW in 0.15 seconds
2018-01-05 00:16:14,290: Using redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:16:14,290: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-05 00:16:14,296: SQL status: ALTER TABLE in 0.01 seconds
2018-01-05 00:16:14,296: On parsely_videoview_engagedtime: COMMIT
2018-01-05 00:16:14,296: Using redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:16:14,296: On parsely_videoview_engagedtime: COMMIT
2018-01-05 00:16:14,484: SQL status: COMMIT in 0.19 seconds
2018-01-05 00:16:14,484: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4d6ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:16:14,514: 00:16:14 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.42s]
2018-01-05 00:16:14,515: 00:16:14 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-05 00:16:14,515: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-05 00:16:14,523: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-05 00:16:14,525: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:16:14,525: Re-using an available connection from the pool.
2018-01-05 00:16:14,525: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:16:14,525: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:16:14,548: SQL status: SELECT in 0.02 seconds
2018-01-05 00:16:14,549: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:16:14,549: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:16:14,571: SQL status: SELECT in 0.02 seconds
2018-01-05 00:16:14,573: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:16:14,573: On parsely_videoview_behavior_workflow: BEGIN
2018-01-05 00:16:14,575: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:16:14,575: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:16:14,575: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:20:25,157: SQL status: SELECT in 250.58 seconds
2018-01-05 00:20:25,157: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:20:25,157: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-05 00:20:25,403: SQL status: SELECT in 0.25 seconds
2018-01-05 00:20:25,404: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:20:25,404: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:20:25,524: SQL status: SELECT in 0.12 seconds
2018-01-05 00:20:25,525: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:20:25,525: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:20:25,647: SQL status: SELECT in 0.12 seconds
2018-01-05 00:20:25,651: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-05 00:20:25,652: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:20:25,652: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-05 00:20:27,345: SQL status: INSERT 0 144 in 1.69 seconds
2018-01-05 00:20:27,346: On parsely_videoview_behavior_workflow: COMMIT
2018-01-05 00:20:27,346: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:20:27,346: On parsely_videoview_behavior_workflow: COMMIT
2018-01-05 00:20:28,909: SQL status: COMMIT in 1.56 seconds
2018-01-05 00:20:28,909: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b56e990>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:20:28,968: 00:20:28 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 144 in 254.39s]
2018-01-05 00:20:28,968: 00:20:28 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-05 00:20:28,969: Compiling model.parsely.parsely_campaigns
2018-01-05 00:20:28,973: Acquiring new redshift connection "parsely_campaigns".
2018-01-05 00:20:28,973: Re-using an available connection from the pool.
2018-01-05 00:20:28,973: Using redshift connection "parsely_campaigns".
2018-01-05 00:20:28,973: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:20:28,996: SQL status: SELECT in 0.02 seconds
2018-01-05 00:20:28,999: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-05 00:20:29,000: Using redshift connection "parsely_campaigns".
2018-01-05 00:20:29,000: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:20:29,022: SQL status: SELECT in 0.02 seconds
2018-01-05 00:20:29,023: Using redshift connection "parsely_campaigns".
2018-01-05 00:20:29,023: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:20:29,045: SQL status: SELECT in 0.02 seconds
2018-01-05 00:20:29,046: Using redshift connection "parsely_campaigns".
2018-01-05 00:20:29,046: On parsely_campaigns: BEGIN
2018-01-05 00:20:29,048: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:20:29,048: Using redshift connection "parsely_campaigns".
2018-01-05 00:20:29,048: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:20:30,368: SQL status: SELECT in 1.32 seconds
2018-01-05 00:20:30,368: Using redshift connection "parsely_campaigns".
2018-01-05 00:20:30,368: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-05 00:20:30,589: SQL status: SELECT in 0.22 seconds
2018-01-05 00:20:30,590: Using redshift connection "parsely_campaigns".
2018-01-05 00:20:30,590: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:20:30,707: SQL status: SELECT in 0.12 seconds
2018-01-05 00:20:30,708: Using redshift connection "parsely_campaigns".
2018-01-05 00:20:30,708: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:20:30,824: SQL status: SELECT in 0.12 seconds
2018-01-05 00:20:30,825: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-05 00:20:30,826: Using redshift connection "parsely_campaigns".
2018-01-05 00:20:30,827: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-05 00:20:30,977: SQL status: INSERT 0 392 in 0.15 seconds
2018-01-05 00:20:30,977: On parsely_campaigns: COMMIT
2018-01-05 00:20:30,977: Using redshift connection "parsely_campaigns".
2018-01-05 00:20:30,977: On parsely_campaigns: COMMIT
2018-01-05 00:20:31,308: SQL status: COMMIT in 0.33 seconds
2018-01-05 00:20:31,309: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4effd0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:20:31,336: 00:20:31 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 392 in 2.34s]
2018-01-05 00:20:31,337: Compiling model.parsely.parsely_incoming_users
2018-01-05 00:20:31,342: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-05 00:20:31,344: 00:20:31 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-05 00:20:31,344: Compiling model.parsely.parsely_users
2018-01-05 00:20:31,350: Acquiring new redshift connection "parsely_users".
2018-01-05 00:20:31,350: Re-using an available connection from the pool.
2018-01-05 00:20:31,350: Using redshift connection "parsely_users".
2018-01-05 00:20:31,350: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:20:31,372: SQL status: SELECT in 0.02 seconds
2018-01-05 00:20:31,412: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-05 00:20:31,413: Using redshift connection "parsely_users".
2018-01-05 00:20:31,413: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:20:31,435: SQL status: SELECT in 0.02 seconds
2018-01-05 00:20:31,436: Using redshift connection "parsely_users".
2018-01-05 00:20:31,436: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:20:31,456: SQL status: SELECT in 0.02 seconds
2018-01-05 00:20:31,458: Using redshift connection "parsely_users".
2018-01-05 00:20:31,459: On parsely_users: BEGIN
2018-01-05 00:20:31,461: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:20:31,461: Using redshift connection "parsely_users".
2018-01-05 00:20:31,461: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:20:33,935: SQL status: SELECT in 2.47 seconds
2018-01-05 00:20:33,935: Using redshift connection "parsely_users".
2018-01-05 00:20:33,935: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-05 00:20:34,367: SQL status: SELECT in 0.43 seconds
2018-01-05 00:20:34,367: Using redshift connection "parsely_users".
2018-01-05 00:20:34,367: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:20:34,483: SQL status: SELECT in 0.12 seconds
2018-01-05 00:20:34,483: Using redshift connection "parsely_users".
2018-01-05 00:20:34,483: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:20:34,599: SQL status: SELECT in 0.12 seconds
2018-01-05 00:20:34,600: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-05 00:20:34,601: Using redshift connection "parsely_users".
2018-01-05 00:20:34,601: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-05 00:20:34,915: SQL status: INSERT 0 54273 in 0.31 seconds
2018-01-05 00:20:34,916: On parsely_users: COMMIT
2018-01-05 00:20:34,916: Using redshift connection "parsely_users".
2018-01-05 00:20:34,916: On parsely_users: COMMIT
2018-01-05 00:20:35,270: SQL status: COMMIT in 0.35 seconds
2018-01-05 00:20:35,271: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4d6ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:20:35,300: 00:20:35 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 54273 in 3.93s]
2018-01-05 00:20:35,301: 00:20:35 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-05 00:20:35,301: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-05 00:20:35,332: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-05 00:20:35,334: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:20:35,334: Re-using an available connection from the pool.
2018-01-05 00:20:35,334: Using redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:20:35,334: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:20:35,360: SQL status: SELECT in 0.03 seconds
2018-01-05 00:20:35,362: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-05 00:20:35,363: Using redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:20:35,363: On parsely_pageview_engagedtime: BEGIN
2018-01-05 00:20:35,365: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:20:35,365: Using redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:20:35,365: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-05 00:20:35,591: SQL status: CREATE VIEW in 0.23 seconds
2018-01-05 00:20:35,591: Using redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:20:35,592: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-05 00:20:35,596: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:20:35,596: On parsely_pageview_engagedtime: COMMIT
2018-01-05 00:20:35,596: Using redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:20:35,596: On parsely_pageview_engagedtime: COMMIT
2018-01-05 00:20:35,791: SQL status: COMMIT in 0.19 seconds
2018-01-05 00:20:35,791: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b534690>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:20:35,822: 00:20:35 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.49s]
2018-01-05 00:20:35,823: 00:20:35 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-05 00:20:35,823: Compiling model.parsely.parsely_incoming_sessions
2018-01-05 00:20:35,830: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-05 00:20:35,831: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-05 00:20:35,832: Re-using an available connection from the pool.
2018-01-05 00:20:35,832: Using redshift connection "parsely_incoming_sessions".
2018-01-05 00:20:35,832: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:20:35,853: SQL status: SELECT in 0.02 seconds
2018-01-05 00:20:35,856: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-05 00:20:35,857: Using redshift connection "parsely_incoming_sessions".
2018-01-05 00:20:35,857: On parsely_incoming_sessions: BEGIN
2018-01-05 00:20:35,859: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:20:35,859: Using redshift connection "parsely_incoming_sessions".
2018-01-05 00:20:35,859: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-05 00:20:36,696: SQL status: CREATE VIEW in 0.84 seconds
2018-01-05 00:20:36,697: Using redshift connection "parsely_incoming_sessions".
2018-01-05 00:20:36,697: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-05 00:20:37,041: SQL status: ALTER TABLE in 0.34 seconds
2018-01-05 00:20:37,041: On parsely_incoming_sessions: COMMIT
2018-01-05 00:20:37,041: Using redshift connection "parsely_incoming_sessions".
2018-01-05 00:20:37,041: On parsely_incoming_sessions: COMMIT
2018-01-05 00:20:37,707: SQL status: COMMIT in 0.67 seconds
2018-01-05 00:20:37,708: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4d6ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:20:37,743: 00:20:37 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 1.88s]
2018-01-05 00:20:37,744: 00:20:37 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-05 00:20:37,744: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-05 00:20:37,753: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-05 00:20:37,754: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:20:37,754: Re-using an available connection from the pool.
2018-01-05 00:20:37,754: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:20:37,754: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:20:37,777: SQL status: SELECT in 0.02 seconds
2018-01-05 00:20:37,778: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:20:37,778: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:20:37,800: SQL status: SELECT in 0.02 seconds
2018-01-05 00:20:37,802: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:20:37,802: On parsely_pageview_behavior_workflow: BEGIN
2018-01-05 00:20:37,804: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:20:37,804: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:20:37,804: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:23:30,661: SQL status: SELECT in 172.86 seconds
2018-01-05 00:23:30,662: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:23:30,662: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-05 00:23:30,822: SQL status: SELECT in 0.16 seconds
2018-01-05 00:23:30,822: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:23:30,822: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:23:30,948: SQL status: SELECT in 0.13 seconds
2018-01-05 00:23:30,949: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:23:30,949: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:23:31,071: SQL status: SELECT in 0.12 seconds
2018-01-05 00:23:31,074: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-05 00:23:31,075: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:23:31,075: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-05 00:23:34,864: SQL status: INSERT 0 111113 in 3.79 seconds
2018-01-05 00:23:34,864: On parsely_pageview_behavior_workflow: COMMIT
2018-01-05 00:23:34,865: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:23:34,865: On parsely_pageview_behavior_workflow: COMMIT
2018-01-05 00:23:36,292: SQL status: COMMIT in 1.43 seconds
2018-01-05 00:23:36,293: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b4d6ed0>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:23:36,394: 00:23:36 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 111113 in 178.55s]
2018-01-05 00:23:36,395: 00:23:36 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-05 00:23:36,395: Compiling model.parsely.parsely_sessions
2018-01-05 00:23:36,401: Acquiring new redshift connection "parsely_sessions".
2018-01-05 00:23:36,401: Re-using an available connection from the pool.
2018-01-05 00:23:36,401: Using redshift connection "parsely_sessions".
2018-01-05 00:23:36,401: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:23:36,423: SQL status: SELECT in 0.02 seconds
2018-01-05 00:23:36,426: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-05 00:23:36,428: Using redshift connection "parsely_sessions".
2018-01-05 00:23:36,428: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:23:36,449: SQL status: SELECT in 0.02 seconds
2018-01-05 00:23:36,450: Using redshift connection "parsely_sessions".
2018-01-05 00:23:36,450: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:23:36,470: SQL status: SELECT in 0.02 seconds
2018-01-05 00:23:36,473: Using redshift connection "parsely_sessions".
2018-01-05 00:23:36,473: On parsely_sessions: BEGIN
2018-01-05 00:23:36,475: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:23:36,475: Using redshift connection "parsely_sessions".
2018-01-05 00:23:36,475: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:24:11,821: SQL status: SELECT in 35.35 seconds
2018-01-05 00:24:11,822: Using redshift connection "parsely_sessions".
2018-01-05 00:24:11,826: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-05 00:24:11,991: SQL status: SELECT in 0.16 seconds
2018-01-05 00:24:11,992: Using redshift connection "parsely_sessions".
2018-01-05 00:24:11,992: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:24:12,111: SQL status: SELECT in 0.12 seconds
2018-01-05 00:24:12,112: Using redshift connection "parsely_sessions".
2018-01-05 00:24:12,112: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:24:12,230: SQL status: SELECT in 0.12 seconds
2018-01-05 00:24:12,233: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-05 00:24:12,234: Using redshift connection "parsely_sessions".
2018-01-05 00:24:12,234: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-05 00:24:14,100: SQL status: INSERT 0 90323 in 1.87 seconds
2018-01-05 00:24:14,100: On parsely_sessions: COMMIT
2018-01-05 00:24:14,100: Using redshift connection "parsely_sessions".
2018-01-05 00:24:14,101: On parsely_sessions: COMMIT
2018-01-05 00:24:15,550: SQL status: COMMIT in 1.45 seconds
2018-01-05 00:24:15,550: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b475490>], 'label': 'b19ab9bd-21c6-4bb8-8142-04defa59669d'}
2018-01-05 00:24:15,587: 00:24:15 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 90323 in 39.16s]
2018-01-05 00:24:15,633: Using redshift connection "master".
2018-01-05 00:24:15,633: On master: BEGIN
2018-01-05 00:24:15,636: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:24:15,636: On master: COMMIT
2018-01-05 00:24:15,636: Using redshift connection "master".
2018-01-05 00:24:15,636: On master: COMMIT
2018-01-05 00:24:15,638: SQL status: COMMIT in 0.00 seconds
2018-01-05 00:24:15,638: Compiling operation.parsely.parsely-on-run-end-0
2018-01-05 00:24:15,643: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-05 00:24:15,644: Using redshift connection "master".
2018-01-05 00:24:15,644: On master:  select 1 
2018-01-05 00:24:15,646: SQL status: SELECT in 0.00 seconds
2018-01-05 00:24:15,647: 00:24:15 | 
2018-01-05 00:24:15,647: 00:24:15 | Finished running 10 view models, 15 incremental models in 1422.38s.
2018-01-05 00:24:15,647: 
2018-01-05 00:24:15,647: Completed successfully
2018-01-05 00:24:15,648: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-05 00:24:15,648: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b587e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b587f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f000b56e950>], 'label': 'end'}
2018-01-05 00:24:15,676: Flushing usage events
2018-01-05 00:24:24,478: Tracking: tracking
2018-01-05 00:24:24,478: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba91e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba91f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba91ed0>], 'label': 'start'}
2018-01-05 00:24:24,521: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-05 00:24:24,537: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-05 00:24:24,538: Parsing core.sql
2018-01-05 00:24:24,549: Parsing etc/get_custom_schema.sql
2018-01-05 00:24:24,554: Parsing schema_tests/relationships.sql
2018-01-05 00:24:24,556: Parsing schema_tests/accepted_values.sql
2018-01-05 00:24:24,559: Parsing schema_tests/not_null.sql
2018-01-05 00:24:24,561: Parsing schema_tests/unique.sql
2018-01-05 00:24:24,563: Parsing materializations/wrapper.sql
2018-01-05 00:24:24,566: Parsing materializations/archive.sql
2018-01-05 00:24:24,593: Parsing materializations/table.sql
2018-01-05 00:24:24,610: Parsing materializations/helpers.sql
2018-01-05 00:24:24,625: Parsing materializations/bigquery.sql
2018-01-05 00:24:24,638: Parsing materializations/view.sql
2018-01-05 00:24:24,652: Parsing materializations/incremental.sql
2018-01-05 00:24:24,676: Parsing adapters/redshift.sql
2018-01-05 00:24:24,693: Parsing adapters/bigquery.sql
2018-01-05 00:24:24,697: Parsing adapters/postgres.sql
2018-01-05 00:24:24,700: Parsing adapters/common.sql
2018-01-05 00:24:24,718: Parsing model.parsely.parsely_audit
2018-01-05 00:24:24,720: Parsing model.parsely.parsely_video_content
2018-01-05 00:24:24,722: Parsing model.parsely.parsely_post_content
2018-01-05 00:24:24,725: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-05 00:24:24,728: Parsing model.parsely.parsely_rawdata
2018-01-05 00:24:24,731: Parsing model.parsely.calendar
2018-01-05 00:24:24,732: Parsing model.parsely.parsely_all_events
2018-01-05 00:24:24,740: Acquiring new redshift connection "parsely_all_events".
2018-01-05 00:24:24,741: Opening a new connection (0 currently allocated)
2018-01-05 00:24:24,753: Using redshift connection "parsely_all_events".
2018-01-05 00:24:24,753: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:24,780: SQL status: SELECT in 0.03 seconds
2018-01-05 00:24:24,786: Parsing model.parsely.parsely_event_ids
2018-01-05 00:24:24,788: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-05 00:24:24,790: Parsing model.parsely.parsely_base_events
2018-01-05 00:24:24,794: Acquiring new redshift connection "parsely_base_events".
2018-01-05 00:24:24,794: Re-using an available connection from the pool.
2018-01-05 00:24:24,794: Using redshift connection "parsely_base_events".
2018-01-05 00:24:24,794: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:24,815: SQL status: SELECT in 0.02 seconds
2018-01-05 00:24:24,816: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-05 00:24:24,822: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-05 00:24:24,826: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-05 00:24:24,828: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-05 00:24:24,830: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-05 00:24:24,833: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-05 00:24:24,838: Parsing model.parsely.parsely_incoming_pageviews
2018-01-05 00:24:24,845: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-05 00:24:24,850: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:24:24,850: Re-using an available connection from the pool.
2018-01-05 00:24:24,851: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:24:24,851: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:24,872: SQL status: SELECT in 0.02 seconds
2018-01-05 00:24:24,873: Parsing model.parsely.parsely_incoming_videoviews
2018-01-05 00:24:24,880: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-05 00:24:24,884: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:24:24,885: Re-using an available connection from the pool.
2018-01-05 00:24:24,885: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:24:24,885: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:24,906: SQL status: SELECT in 0.02 seconds
2018-01-05 00:24:24,906: Parsing model.parsely.parsely_incoming_users
2018-01-05 00:24:24,909: Parsing model.parsely.parsely_users
2018-01-05 00:24:24,914: Acquiring new redshift connection "parsely_users".
2018-01-05 00:24:24,914: Re-using an available connection from the pool.
2018-01-05 00:24:24,914: Using redshift connection "parsely_users".
2018-01-05 00:24:24,914: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:24,934: SQL status: SELECT in 0.02 seconds
2018-01-05 00:24:24,935: Parsing model.parsely.parsely_errors
2018-01-05 00:24:24,938: Parsing model.parsely.parsely_bot_traffic
2018-01-05 00:24:24,942: Parsing model.parsely.parsely_custom_events
2018-01-05 00:24:24,947: Parsing model.parsely.parsely_incoming_sessions
2018-01-05 00:24:24,951: Parsing model.parsely.parsely_entry_exit_urls
2018-01-05 00:24:24,954: Parsing model.parsely.parsely_sessions
2018-01-05 00:24:24,959: Acquiring new redshift connection "parsely_sessions".
2018-01-05 00:24:24,959: Re-using an available connection from the pool.
2018-01-05 00:24:24,959: Using redshift connection "parsely_sessions".
2018-01-05 00:24:24,960: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:24,981: SQL status: SELECT in 0.02 seconds
2018-01-05 00:24:24,981: Parsing model.parsely.parsely_campaigns
2018-01-05 00:24:24,985: Acquiring new redshift connection "parsely_campaigns".
2018-01-05 00:24:24,985: Re-using an available connection from the pool.
2018-01-05 00:24:24,985: Using redshift connection "parsely_campaigns".
2018-01-05 00:24:24,985: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:25,005: SQL status: SELECT in 0.02 seconds
2018-01-05 00:24:25,011: Parsing operation.parsely.parsely-on-run-end-0
2018-01-05 00:24:25,017: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-05 00:24:25,025: 
2018-01-05 00:24:25,028: Acquiring new redshift connection "master".
2018-01-05 00:24:25,028: Re-using an available connection from the pool.
2018-01-05 00:24:25,028: Using redshift connection "master".
2018-01-05 00:24:25,028: On master: select distinct nspname from pg_namespace
2018-01-05 00:24:25,031: SQL status: SELECT in 0.00 seconds
2018-01-05 00:24:25,033: Using redshift connection "master".
2018-01-05 00:24:25,033: On master: BEGIN
2018-01-05 00:24:25,051: SQL status: BEGIN in 0.02 seconds
2018-01-05 00:24:25,052: On master: COMMIT
2018-01-05 00:24:25,052: Using redshift connection "master".
2018-01-05 00:24:25,052: On master: COMMIT
2018-01-05 00:24:25,053: SQL status: COMMIT in 0.00 seconds
2018-01-05 00:24:25,059: 00:24:25 | Concurrency: 1 threads (target='dev')
2018-01-05 00:24:25,059: 00:24:25 | 
2018-01-05 00:24:25,059: Using redshift connection "master".
2018-01-05 00:24:25,059: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:25,080: SQL status: SELECT in 0.02 seconds
2018-01-05 00:24:25,153: 00:24:25 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-05 00:24:25,153: Compiling model.parsely.calendar
2018-01-05 00:24:25,161: Writing injected SQL for node "model.parsely.calendar"
2018-01-05 00:24:25,162: Acquiring new redshift connection "calendar".
2018-01-05 00:24:25,162: Opening a new connection (1 currently allocated)
2018-01-05 00:24:25,174: Using redshift connection "calendar".
2018-01-05 00:24:25,175: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:25,201: SQL status: SELECT in 0.03 seconds
2018-01-05 00:24:25,203: Writing runtime SQL for node "model.parsely.calendar"
2018-01-05 00:24:25,204: Using redshift connection "calendar".
2018-01-05 00:24:25,204: On calendar: BEGIN
2018-01-05 00:24:25,206: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:24:25,206: Using redshift connection "calendar".
2018-01-05 00:24:25,206: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-05 00:24:25,332: SQL status: CREATE VIEW in 0.13 seconds
2018-01-05 00:24:25,332: On calendar: COMMIT
2018-01-05 00:24:25,332: Using redshift connection "calendar".
2018-01-05 00:24:25,332: On calendar: COMMIT
2018-01-05 00:24:25,906: SQL status: COMMIT in 0.57 seconds
2018-01-05 00:24:25,906: Using redshift connection "calendar".
2018-01-05 00:24:25,907: On calendar: BEGIN
2018-01-05 00:24:25,909: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:24:25,909: Using redshift connection "calendar".
2018-01-05 00:24:25,909: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-05 00:24:25,954: SQL status: DROP VIEW in 0.04 seconds
2018-01-05 00:24:25,954: On calendar: COMMIT
2018-01-05 00:24:25,954: Using redshift connection "calendar".
2018-01-05 00:24:25,954: On calendar: COMMIT
2018-01-05 00:24:26,796: SQL status: COMMIT in 0.84 seconds
2018-01-05 00:24:26,796: Using redshift connection "calendar".
2018-01-05 00:24:26,797: On calendar: BEGIN
2018-01-05 00:24:26,799: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:24:26,799: Using redshift connection "calendar".
2018-01-05 00:24:26,799: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-05 00:24:26,870: SQL status: ALTER TABLE in 0.07 seconds
2018-01-05 00:24:26,871: On calendar: COMMIT
2018-01-05 00:24:26,871: Using redshift connection "calendar".
2018-01-05 00:24:26,871: On calendar: COMMIT
2018-01-05 00:24:27,466: SQL status: COMMIT in 0.60 seconds
2018-01-05 00:24:27,467: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab97fbd0>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:24:27,496: 00:24:27 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 2.31s]
2018-01-05 00:24:27,496: 00:24:27 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-05 00:24:27,496: Compiling model.parsely.parsely_rawdata
2018-01-05 00:24:27,502: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-05 00:24:27,503: Acquiring new redshift connection "parsely_rawdata".
2018-01-05 00:24:27,503: Re-using an available connection from the pool.
2018-01-05 00:24:27,503: Using redshift connection "parsely_rawdata".
2018-01-05 00:24:27,504: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:27,526: SQL status: SELECT in 0.02 seconds
2018-01-05 00:24:27,526: Using redshift connection "parsely_rawdata".
2018-01-05 00:24:27,526: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:24:27,547: SQL status: SELECT in 0.02 seconds
2018-01-05 00:24:27,548: Using redshift connection "parsely_rawdata".
2018-01-05 00:24:27,548: On parsely_rawdata: BEGIN
2018-01-05 00:24:27,550: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:24:27,550: Using redshift connection "parsely_rawdata".
2018-01-05 00:24:27,550: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:24:59,502: SQL status: SELECT in 31.95 seconds
2018-01-05 00:24:59,502: Using redshift connection "parsely_rawdata".
2018-01-05 00:24:59,502: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-05 00:24:59,694: SQL status: SELECT in 0.19 seconds
2018-01-05 00:24:59,694: Using redshift connection "parsely_rawdata".
2018-01-05 00:24:59,694: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:24:59,816: SQL status: SELECT in 0.12 seconds
2018-01-05 00:24:59,817: Using redshift connection "parsely_rawdata".
2018-01-05 00:24:59,817: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:24:59,939: SQL status: SELECT in 0.12 seconds
2018-01-05 00:24:59,942: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-05 00:24:59,943: Using redshift connection "parsely_rawdata".
2018-01-05 00:24:59,943: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-05 00:25:38,155: SQL status: INSERT 0 1052079 in 38.21 seconds
2018-01-05 00:25:38,155: On parsely_rawdata: COMMIT
2018-01-05 00:25:38,155: Using redshift connection "parsely_rawdata".
2018-01-05 00:25:38,156: On parsely_rawdata: COMMIT
2018-01-05 00:25:40,427: SQL status: COMMIT in 2.27 seconds
2018-01-05 00:25:40,427: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9e9b10>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:25:40,504: 00:25:40 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1052079 in 72.93s]
2018-01-05 00:25:40,505: 00:25:40 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-05 00:25:40,505: Compiling model.parsely.parsely_all_events
2018-01-05 00:25:40,519: Acquiring new redshift connection "parsely_all_events".
2018-01-05 00:25:40,519: Re-using an available connection from the pool.
2018-01-05 00:25:40,519: Using redshift connection "parsely_all_events".
2018-01-05 00:25:40,519: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:25:40,540: SQL status: SELECT in 0.02 seconds
2018-01-05 00:25:40,548: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-05 00:25:40,550: Using redshift connection "parsely_all_events".
2018-01-05 00:25:40,550: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:25:40,571: SQL status: SELECT in 0.02 seconds
2018-01-05 00:25:40,571: Using redshift connection "parsely_all_events".
2018-01-05 00:25:40,571: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:25:40,592: SQL status: SELECT in 0.02 seconds
2018-01-05 00:25:40,594: Using redshift connection "parsely_all_events".
2018-01-05 00:25:40,594: On parsely_all_events: BEGIN
2018-01-05 00:25:40,596: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:25:40,596: Using redshift connection "parsely_all_events".
2018-01-05 00:25:40,596: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:27:15,988: SQL status: SELECT in 95.39 seconds
2018-01-05 00:27:15,988: Using redshift connection "parsely_all_events".
2018-01-05 00:27:15,988: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-05 00:27:16,303: SQL status: SELECT in 0.31 seconds
2018-01-05 00:27:16,304: Using redshift connection "parsely_all_events".
2018-01-05 00:27:16,304: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:27:16,429: SQL status: SELECT in 0.13 seconds
2018-01-05 00:27:16,430: Using redshift connection "parsely_all_events".
2018-01-05 00:27:16,430: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:27:16,554: SQL status: SELECT in 0.12 seconds
2018-01-05 00:27:16,557: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-05 00:27:16,559: Using redshift connection "parsely_all_events".
2018-01-05 00:27:16,559: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-05 00:27:35,220: SQL status: INSERT 0 936586 in 18.66 seconds
2018-01-05 00:27:35,221: On parsely_all_events: COMMIT
2018-01-05 00:27:35,221: Using redshift connection "parsely_all_events".
2018-01-05 00:27:35,221: On parsely_all_events: COMMIT
2018-01-05 00:27:37,963: SQL status: COMMIT in 2.74 seconds
2018-01-05 00:27:37,963: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba3e810>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:27:38,070: 00:27:38 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 936586 in 117.46s]
2018-01-05 00:27:38,071: 00:27:38 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-05 00:27:38,071: Compiling model.parsely.parsely_bot_traffic
2018-01-05 00:27:38,078: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-05 00:27:38,080: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-05 00:27:38,080: Re-using an available connection from the pool.
2018-01-05 00:27:38,080: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:27:38,080: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:27:38,102: SQL status: SELECT in 0.02 seconds
2018-01-05 00:27:38,103: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:27:38,103: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:27:38,125: SQL status: SELECT in 0.02 seconds
2018-01-05 00:27:38,126: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:27:38,126: On parsely_bot_traffic: BEGIN
2018-01-05 00:27:38,128: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:27:38,128: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:27:38,128: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:28:53,878: SQL status: SELECT in 75.75 seconds
2018-01-05 00:28:53,878: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:28:53,878: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-05 00:28:54,054: SQL status: SELECT in 0.18 seconds
2018-01-05 00:28:54,055: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:28:54,055: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:28:54,181: SQL status: SELECT in 0.13 seconds
2018-01-05 00:28:54,182: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:28:54,182: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:28:54,305: SQL status: SELECT in 0.12 seconds
2018-01-05 00:28:54,308: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-05 00:28:54,309: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:28:54,309: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-05 00:28:55,668: SQL status: INSERT 0 4 in 1.36 seconds
2018-01-05 00:28:55,668: On parsely_bot_traffic: COMMIT
2018-01-05 00:28:55,668: Using redshift connection "parsely_bot_traffic".
2018-01-05 00:28:55,668: On parsely_bot_traffic: COMMIT
2018-01-05 00:28:56,835: SQL status: COMMIT in 1.17 seconds
2018-01-05 00:28:56,836: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab97fc90>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:28:56,885: 00:28:56 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 78.76s]
2018-01-05 00:28:56,885: 00:28:56 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-05 00:28:56,886: Compiling model.parsely.parsely_custom_events
2018-01-05 00:28:56,895: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-05 00:28:56,897: Acquiring new redshift connection "parsely_custom_events".
2018-01-05 00:28:56,897: Re-using an available connection from the pool.
2018-01-05 00:28:56,898: Using redshift connection "parsely_custom_events".
2018-01-05 00:28:56,898: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:28:56,923: SQL status: SELECT in 0.03 seconds
2018-01-05 00:28:56,923: Using redshift connection "parsely_custom_events".
2018-01-05 00:28:56,923: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:28:56,944: SQL status: SELECT in 0.02 seconds
2018-01-05 00:28:56,946: Using redshift connection "parsely_custom_events".
2018-01-05 00:28:56,946: On parsely_custom_events: BEGIN
2018-01-05 00:28:56,948: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:28:56,949: Using redshift connection "parsely_custom_events".
2018-01-05 00:28:56,949: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:30:15,030: SQL status: SELECT in 78.08 seconds
2018-01-05 00:30:15,031: Using redshift connection "parsely_custom_events".
2018-01-05 00:30:15,031: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-05 00:30:15,221: SQL status: SELECT in 0.19 seconds
2018-01-05 00:30:15,222: Using redshift connection "parsely_custom_events".
2018-01-05 00:30:15,222: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:30:15,345: SQL status: SELECT in 0.12 seconds
2018-01-05 00:30:15,346: Using redshift connection "parsely_custom_events".
2018-01-05 00:30:15,346: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:30:15,469: SQL status: SELECT in 0.12 seconds
2018-01-05 00:30:15,472: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-05 00:30:15,473: Using redshift connection "parsely_custom_events".
2018-01-05 00:30:15,473: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-05 00:30:15,744: SQL status: INSERT 0 0 in 0.27 seconds
2018-01-05 00:30:15,744: On parsely_custom_events: COMMIT
2018-01-05 00:30:15,744: Using redshift connection "parsely_custom_events".
2018-01-05 00:30:15,745: On parsely_custom_events: COMMIT
2018-01-05 00:30:16,155: SQL status: COMMIT in 0.41 seconds
2018-01-05 00:30:16,156: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab97fc90>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:30:16,250: 00:30:16 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 79.27s]
2018-01-05 00:30:16,250: 00:30:16 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-05 00:30:16,250: Compiling model.parsely.parsely_errors
2018-01-05 00:30:16,262: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-05 00:30:16,264: Acquiring new redshift connection "parsely_errors".
2018-01-05 00:30:16,264: Re-using an available connection from the pool.
2018-01-05 00:30:16,265: Using redshift connection "parsely_errors".
2018-01-05 00:30:16,265: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:30:16,287: SQL status: SELECT in 0.02 seconds
2018-01-05 00:30:16,288: Using redshift connection "parsely_errors".
2018-01-05 00:30:16,288: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:30:16,308: SQL status: SELECT in 0.02 seconds
2018-01-05 00:30:16,311: Using redshift connection "parsely_errors".
2018-01-05 00:30:16,311: On parsely_errors: BEGIN
2018-01-05 00:30:16,313: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:30:16,313: Using redshift connection "parsely_errors".
2018-01-05 00:30:16,313: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:31:34,108: SQL status: SELECT in 77.79 seconds
2018-01-05 00:31:34,109: Using redshift connection "parsely_errors".
2018-01-05 00:31:34,109: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-05 00:31:34,309: SQL status: SELECT in 0.20 seconds
2018-01-05 00:31:34,310: Using redshift connection "parsely_errors".
2018-01-05 00:31:34,310: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:31:34,435: SQL status: SELECT in 0.12 seconds
2018-01-05 00:31:34,436: Using redshift connection "parsely_errors".
2018-01-05 00:31:34,437: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:31:34,569: SQL status: SELECT in 0.13 seconds
2018-01-05 00:31:34,575: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-05 00:31:34,576: Using redshift connection "parsely_errors".
2018-01-05 00:31:34,576: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-05 00:31:35,250: SQL status: INSERT 0 2 in 0.67 seconds
2018-01-05 00:31:35,251: On parsely_errors: COMMIT
2018-01-05 00:31:35,251: Using redshift connection "parsely_errors".
2018-01-05 00:31:35,251: On parsely_errors: COMMIT
2018-01-05 00:31:36,135: SQL status: COMMIT in 0.88 seconds
2018-01-05 00:31:36,136: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab975bd0>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:31:36,187: 00:31:36 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 79.89s]
2018-01-05 00:31:36,188: 00:31:36 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-05 00:31:36,188: Compiling model.parsely.parsely_base_events
2018-01-05 00:31:36,192: Acquiring new redshift connection "parsely_base_events".
2018-01-05 00:31:36,192: Re-using an available connection from the pool.
2018-01-05 00:31:36,192: Using redshift connection "parsely_base_events".
2018-01-05 00:31:36,192: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:31:36,215: SQL status: SELECT in 0.02 seconds
2018-01-05 00:31:36,219: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-05 00:31:36,220: Using redshift connection "parsely_base_events".
2018-01-05 00:31:36,220: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:31:36,242: SQL status: SELECT in 0.02 seconds
2018-01-05 00:31:36,244: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-05 00:31:36,245: Using redshift connection "parsely_base_events".
2018-01-05 00:31:36,245: On parsely_base_events: BEGIN
2018-01-05 00:31:36,247: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:31:36,247: Using redshift connection "parsely_base_events".
2018-01-05 00:31:36,247: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-05 00:31:37,270: SQL status: CREATE VIEW in 1.02 seconds
2018-01-05 00:31:37,270: On parsely_base_events: COMMIT
2018-01-05 00:31:37,271: Using redshift connection "parsely_base_events".
2018-01-05 00:31:37,271: On parsely_base_events: COMMIT
2018-01-05 00:31:37,491: SQL status: COMMIT in 0.22 seconds
2018-01-05 00:31:37,491: Using redshift connection "parsely_base_events".
2018-01-05 00:31:37,491: On parsely_base_events: BEGIN
2018-01-05 00:31:37,493: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:31:37,493: Using redshift connection "parsely_base_events".
2018-01-05 00:31:37,493: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-05 00:31:37,601: SQL status: DROP VIEW in 0.11 seconds
2018-01-05 00:31:37,601: On parsely_base_events: COMMIT
2018-01-05 00:31:37,601: Using redshift connection "parsely_base_events".
2018-01-05 00:31:37,601: On parsely_base_events: COMMIT
2018-01-05 00:31:37,775: SQL status: COMMIT in 0.17 seconds
2018-01-05 00:31:37,775: Using redshift connection "parsely_base_events".
2018-01-05 00:31:37,775: On parsely_base_events: BEGIN
2018-01-05 00:31:37,777: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:31:37,778: Using redshift connection "parsely_base_events".
2018-01-05 00:31:37,778: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-05 00:31:37,783: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:31:37,783: On parsely_base_events: COMMIT
2018-01-05 00:31:37,783: Using redshift connection "parsely_base_events".
2018-01-05 00:31:37,783: On parsely_base_events: COMMIT
2018-01-05 00:31:38,159: SQL status: COMMIT in 0.38 seconds
2018-01-05 00:31:38,159: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9e9810>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:31:38,195: 00:31:38 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 1.97s]
2018-01-05 00:31:38,195: 00:31:38 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-05 00:31:38,196: Compiling model.parsely.parsely_event_ids
2018-01-05 00:31:38,201: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-05 00:31:38,203: Acquiring new redshift connection "parsely_event_ids".
2018-01-05 00:31:38,203: Re-using an available connection from the pool.
2018-01-05 00:31:38,203: Using redshift connection "parsely_event_ids".
2018-01-05 00:31:38,203: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:31:38,226: SQL status: SELECT in 0.02 seconds
2018-01-05 00:31:38,226: Using redshift connection "parsely_event_ids".
2018-01-05 00:31:38,226: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:31:38,248: SQL status: SELECT in 0.02 seconds
2018-01-05 00:31:38,249: Using redshift connection "parsely_event_ids".
2018-01-05 00:31:38,249: On parsely_event_ids: BEGIN
2018-01-05 00:31:38,251: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:31:38,251: Using redshift connection "parsely_event_ids".
2018-01-05 00:31:38,251: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:31:40,474: SQL status: SELECT in 2.22 seconds
2018-01-05 00:31:40,474: Using redshift connection "parsely_event_ids".
2018-01-05 00:31:40,474: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-05 00:31:40,619: SQL status: SELECT in 0.15 seconds
2018-01-05 00:31:40,620: Using redshift connection "parsely_event_ids".
2018-01-05 00:31:40,620: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:31:40,737: SQL status: SELECT in 0.12 seconds
2018-01-05 00:31:40,737: Using redshift connection "parsely_event_ids".
2018-01-05 00:31:40,737: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:31:40,865: SQL status: SELECT in 0.13 seconds
2018-01-05 00:31:40,866: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-05 00:31:40,867: Using redshift connection "parsely_event_ids".
2018-01-05 00:31:40,867: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-05 00:31:43,081: SQL status: INSERT 0 936582 in 2.21 seconds
2018-01-05 00:31:43,081: On parsely_event_ids: COMMIT
2018-01-05 00:31:43,081: Using redshift connection "parsely_event_ids".
2018-01-05 00:31:43,082: On parsely_event_ids: COMMIT
2018-01-05 00:31:43,433: SQL status: COMMIT in 0.35 seconds
2018-01-05 00:31:43,434: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9a3dd0>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:31:43,463: 00:31:43 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 936582 in 5.24s]
2018-01-05 00:31:43,463: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-05 00:31:43,469: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-05 00:31:43,470: 00:31:43 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-05 00:31:43,470: Compiling model.parsely.parsely_post_content
2018-01-05 00:31:43,477: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-05 00:31:43,478: Acquiring new redshift connection "parsely_post_content".
2018-01-05 00:31:43,478: Re-using an available connection from the pool.
2018-01-05 00:31:43,478: Using redshift connection "parsely_post_content".
2018-01-05 00:31:43,478: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:31:43,501: SQL status: SELECT in 0.02 seconds
2018-01-05 00:31:43,501: Using redshift connection "parsely_post_content".
2018-01-05 00:31:43,501: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:31:43,523: SQL status: SELECT in 0.02 seconds
2018-01-05 00:31:43,525: Using redshift connection "parsely_post_content".
2018-01-05 00:31:43,525: On parsely_post_content: BEGIN
2018-01-05 00:31:43,527: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:31:43,527: Using redshift connection "parsely_post_content".
2018-01-05 00:31:43,527: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:32:00,070: SQL status: SELECT in 16.54 seconds
2018-01-05 00:32:00,070: Using redshift connection "parsely_post_content".
2018-01-05 00:32:00,070: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-05 00:32:00,369: SQL status: SELECT in 0.30 seconds
2018-01-05 00:32:00,369: Using redshift connection "parsely_post_content".
2018-01-05 00:32:00,370: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:32:00,488: SQL status: SELECT in 0.12 seconds
2018-01-05 00:32:00,489: Using redshift connection "parsely_post_content".
2018-01-05 00:32:00,489: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:32:00,608: SQL status: SELECT in 0.12 seconds
2018-01-05 00:32:00,611: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-05 00:32:00,612: Using redshift connection "parsely_post_content".
2018-01-05 00:32:00,612: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-05 00:32:01,049: SQL status: INSERT 0 894 in 0.44 seconds
2018-01-05 00:32:01,049: On parsely_post_content: COMMIT
2018-01-05 00:32:01,049: Using redshift connection "parsely_post_content".
2018-01-05 00:32:01,049: On parsely_post_content: COMMIT
2018-01-05 00:32:01,766: SQL status: COMMIT in 0.72 seconds
2018-01-05 00:32:01,766: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9e0ed0>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:32:01,809: 00:32:01 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 894 in 18.30s]
2018-01-05 00:32:01,809: 00:32:01 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-05 00:32:01,810: Compiling model.parsely.parsely_video_content
2018-01-05 00:32:01,819: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-05 00:32:01,825: Acquiring new redshift connection "parsely_video_content".
2018-01-05 00:32:01,825: Re-using an available connection from the pool.
2018-01-05 00:32:01,826: Using redshift connection "parsely_video_content".
2018-01-05 00:32:01,826: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:32:01,850: SQL status: SELECT in 0.02 seconds
2018-01-05 00:32:01,851: Using redshift connection "parsely_video_content".
2018-01-05 00:32:01,852: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:32:01,873: SQL status: SELECT in 0.02 seconds
2018-01-05 00:32:01,875: Using redshift connection "parsely_video_content".
2018-01-05 00:32:01,875: On parsely_video_content: BEGIN
2018-01-05 00:32:01,877: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:32:01,877: Using redshift connection "parsely_video_content".
2018-01-05 00:32:01,878: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:32:15,878: SQL status: SELECT in 14.00 seconds
2018-01-05 00:32:15,879: Using redshift connection "parsely_video_content".
2018-01-05 00:32:15,879: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-05 00:32:16,151: SQL status: SELECT in 0.27 seconds
2018-01-05 00:32:16,151: Using redshift connection "parsely_video_content".
2018-01-05 00:32:16,151: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:32:16,271: SQL status: SELECT in 0.12 seconds
2018-01-05 00:32:16,272: Using redshift connection "parsely_video_content".
2018-01-05 00:32:16,272: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:32:16,390: SQL status: SELECT in 0.12 seconds
2018-01-05 00:32:16,393: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-05 00:32:16,394: Using redshift connection "parsely_video_content".
2018-01-05 00:32:16,394: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-05 00:32:16,815: SQL status: INSERT 0 470 in 0.42 seconds
2018-01-05 00:32:16,815: On parsely_video_content: COMMIT
2018-01-05 00:32:16,815: Using redshift connection "parsely_video_content".
2018-01-05 00:32:16,815: On parsely_video_content: COMMIT
2018-01-05 00:32:17,266: SQL status: COMMIT in 0.45 seconds
2018-01-05 00:32:17,267: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba8b150>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:32:17,306: 00:32:17 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 470 in 15.46s]
2018-01-05 00:32:17,306: 00:32:17 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-05 00:32:17,306: Compiling model.parsely.parsely_entry_exit_urls
2018-01-05 00:32:17,316: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-05 00:32:17,318: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-05 00:32:17,318: Re-using an available connection from the pool.
2018-01-05 00:32:17,318: Using redshift connection "parsely_entry_exit_urls".
2018-01-05 00:32:17,319: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:32:17,341: SQL status: SELECT in 0.02 seconds
2018-01-05 00:32:17,344: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-05 00:32:17,346: Using redshift connection "parsely_entry_exit_urls".
2018-01-05 00:32:17,346: On parsely_entry_exit_urls: BEGIN
2018-01-05 00:32:17,348: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:32:17,348: Using redshift connection "parsely_entry_exit_urls".
2018-01-05 00:32:17,348: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-05 00:32:17,671: SQL status: CREATE VIEW in 0.32 seconds
2018-01-05 00:32:17,671: Using redshift connection "parsely_entry_exit_urls".
2018-01-05 00:32:17,671: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-05 00:32:17,674: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:32:17,675: On parsely_entry_exit_urls: COMMIT
2018-01-05 00:32:17,675: Using redshift connection "parsely_entry_exit_urls".
2018-01-05 00:32:17,675: On parsely_entry_exit_urls: COMMIT
2018-01-05 00:32:18,025: SQL status: COMMIT in 0.35 seconds
2018-01-05 00:32:18,026: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba8b150>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:32:18,061: 00:32:18 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.72s]
2018-01-05 00:32:18,062: 00:32:18 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-05 00:32:18,062: Compiling model.parsely.parsely_incoming_videoviews
2018-01-05 00:32:18,079: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-05 00:32:18,082: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-05 00:32:18,082: Re-using an available connection from the pool.
2018-01-05 00:32:18,082: Using redshift connection "parsely_incoming_videoviews".
2018-01-05 00:32:18,082: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:32:18,111: SQL status: SELECT in 0.03 seconds
2018-01-05 00:32:18,115: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-05 00:32:18,117: Using redshift connection "parsely_incoming_videoviews".
2018-01-05 00:32:18,117: On parsely_incoming_videoviews: BEGIN
2018-01-05 00:32:18,119: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:32:18,119: Using redshift connection "parsely_incoming_videoviews".
2018-01-05 00:32:18,119: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-05 00:32:18,209: SQL status: CREATE VIEW in 0.09 seconds
2018-01-05 00:32:18,210: Using redshift connection "parsely_incoming_videoviews".
2018-01-05 00:32:18,210: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-05 00:32:18,214: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:32:18,215: On parsely_incoming_videoviews: COMMIT
2018-01-05 00:32:18,215: Using redshift connection "parsely_incoming_videoviews".
2018-01-05 00:32:18,215: On parsely_incoming_videoviews: COMMIT
2018-01-05 00:32:18,571: SQL status: COMMIT in 0.36 seconds
2018-01-05 00:32:18,572: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba8b150>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:32:18,607: 00:32:18 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.51s]
2018-01-05 00:32:18,608: 00:32:18 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-05 00:32:18,608: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-05 00:32:18,615: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:32:18,615: Re-using an available connection from the pool.
2018-01-05 00:32:18,615: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:32:18,615: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:32:18,637: SQL status: SELECT in 0.02 seconds
2018-01-05 00:32:18,641: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-05 00:32:18,642: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:32:18,643: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:32:18,664: SQL status: SELECT in 0.02 seconds
2018-01-05 00:32:18,665: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:32:18,665: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:32:18,686: SQL status: SELECT in 0.02 seconds
2018-01-05 00:32:18,689: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:32:18,689: On parsely_videoviews_sessionized: BEGIN
2018-01-05 00:32:18,691: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:32:18,691: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:32:18,691: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:33:57,635: SQL status: SELECT in 98.94 seconds
2018-01-05 00:33:57,635: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:33:57,635: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-05 00:33:57,786: SQL status: SELECT in 0.15 seconds
2018-01-05 00:33:57,787: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:33:57,787: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:33:57,897: SQL status: SELECT in 0.11 seconds
2018-01-05 00:33:57,898: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:33:57,898: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:33:58,009: SQL status: SELECT in 0.11 seconds
2018-01-05 00:33:58,015: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-05 00:33:58,016: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:33:58,016: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-05 00:33:59,730: SQL status: INSERT 0 145 in 1.71 seconds
2018-01-05 00:33:59,731: On parsely_videoviews_sessionized: COMMIT
2018-01-05 00:33:59,731: Using redshift connection "parsely_videoviews_sessionized".
2018-01-05 00:33:59,731: On parsely_videoviews_sessionized: COMMIT
2018-01-05 00:34:01,186: SQL status: COMMIT in 1.46 seconds
2018-01-05 00:34:01,187: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9e0e10>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:34:01,256: 00:34:01 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 145 in 102.58s]
2018-01-05 00:34:01,256: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-05 00:34:01,301: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-05 00:34:01,304: 00:34:01 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-05 00:34:01,304: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-05 00:34:01,327: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-05 00:34:01,330: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:34:01,330: Re-using an available connection from the pool.
2018-01-05 00:34:01,330: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:34:01,330: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:34:01,346: SQL status: SELECT in 0.02 seconds
2018-01-05 00:34:01,349: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-05 00:34:01,352: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:34:01,352: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-05 00:34:01,354: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:34:01,354: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:34:01,354: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-05 00:34:01,489: SQL status: CREATE VIEW in 0.13 seconds
2018-01-05 00:34:01,490: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:34:01,490: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-05 00:34:01,495: SQL status: ALTER TABLE in 0.01 seconds
2018-01-05 00:34:01,495: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-05 00:34:01,495: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-05 00:34:01,495: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-05 00:34:02,085: SQL status: COMMIT in 0.59 seconds
2018-01-05 00:34:02,086: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba46dd0>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:34:02,120: 00:34:02 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.78s]
2018-01-05 00:34:02,121: 00:34:02 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-05 00:34:02,121: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-05 00:34:02,165: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-05 00:34:02,168: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:34:02,168: Re-using an available connection from the pool.
2018-01-05 00:34:02,168: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:34:02,168: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:34:02,183: SQL status: SELECT in 0.01 seconds
2018-01-05 00:34:02,188: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-05 00:34:02,189: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:34:02,190: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-05 00:34:02,193: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:34:02,193: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:34:02,193: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-05 00:34:02,566: SQL status: CREATE VIEW in 0.37 seconds
2018-01-05 00:34:02,567: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:34:02,567: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-05 00:34:02,572: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:34:02,572: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-05 00:34:02,572: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-05 00:34:02,572: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-05 00:34:02,760: SQL status: COMMIT in 0.19 seconds
2018-01-05 00:34:02,761: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab97ff50>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:34:02,795: 00:34:02 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.64s]
2018-01-05 00:34:02,796: 00:34:02 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-05 00:34:02,796: Compiling model.parsely.parsely_incoming_pageviews
2018-01-05 00:34:02,814: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-05 00:34:02,817: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-05 00:34:02,817: Re-using an available connection from the pool.
2018-01-05 00:34:02,817: Using redshift connection "parsely_incoming_pageviews".
2018-01-05 00:34:02,817: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:34:02,832: SQL status: SELECT in 0.01 seconds
2018-01-05 00:34:02,837: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-05 00:34:02,839: Using redshift connection "parsely_incoming_pageviews".
2018-01-05 00:34:02,839: On parsely_incoming_pageviews: BEGIN
2018-01-05 00:34:02,841: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:34:02,841: Using redshift connection "parsely_incoming_pageviews".
2018-01-05 00:34:02,842: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-05 00:34:02,923: SQL status: CREATE VIEW in 0.08 seconds
2018-01-05 00:34:02,924: Using redshift connection "parsely_incoming_pageviews".
2018-01-05 00:34:02,924: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-05 00:34:02,929: SQL status: ALTER TABLE in 0.01 seconds
2018-01-05 00:34:02,930: On parsely_incoming_pageviews: COMMIT
2018-01-05 00:34:02,930: Using redshift connection "parsely_incoming_pageviews".
2018-01-05 00:34:02,930: On parsely_incoming_pageviews: COMMIT
2018-01-05 00:34:03,111: SQL status: COMMIT in 0.18 seconds
2018-01-05 00:34:03,111: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab97ff50>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:34:03,145: 00:34:03 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.32s]
2018-01-05 00:34:03,146: 00:34:03 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-05 00:34:03,146: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-05 00:34:03,151: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:34:03,151: Re-using an available connection from the pool.
2018-01-05 00:34:03,151: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:34:03,151: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:34:03,166: SQL status: SELECT in 0.01 seconds
2018-01-05 00:34:03,170: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-05 00:34:03,172: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:34:03,172: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:34:03,186: SQL status: SELECT in 0.01 seconds
2018-01-05 00:34:03,187: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:34:03,187: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:34:03,201: SQL status: SELECT in 0.01 seconds
2018-01-05 00:34:03,203: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:34:03,204: On parsely_pageviews_sessionized: BEGIN
2018-01-05 00:34:03,205: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:34:03,206: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:34:03,206: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:39:28,067: SQL status: SELECT in 324.86 seconds
2018-01-05 00:39:28,067: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:39:28,067: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-05 00:39:28,253: SQL status: SELECT in 0.19 seconds
2018-01-05 00:39:28,254: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:39:28,254: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:39:28,373: SQL status: SELECT in 0.12 seconds
2018-01-05 00:39:28,374: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:39:28,374: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:39:28,493: SQL status: SELECT in 0.12 seconds
2018-01-05 00:39:28,496: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-05 00:39:28,498: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:39:28,498: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-05 00:39:31,945: SQL status: INSERT 0 111740 in 3.45 seconds
2018-01-05 00:39:31,946: On parsely_pageviews_sessionized: COMMIT
2018-01-05 00:39:31,946: Using redshift connection "parsely_pageviews_sessionized".
2018-01-05 00:39:31,946: On parsely_pageviews_sessionized: COMMIT
2018-01-05 00:39:33,345: SQL status: COMMIT in 1.40 seconds
2018-01-05 00:39:33,346: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9e9ed0>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:39:33,383: 00:39:33 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 111740 in 330.20s]
2018-01-05 00:39:33,383: 00:39:33 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-05 00:39:33,384: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-05 00:39:33,426: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-05 00:39:33,427: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:39:33,427: Re-using an available connection from the pool.
2018-01-05 00:39:33,427: Using redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:39:33,427: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:39:33,450: SQL status: SELECT in 0.02 seconds
2018-01-05 00:39:33,452: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-05 00:39:33,453: Using redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:39:33,453: On parsely_videoview_engagedtime: BEGIN
2018-01-05 00:39:33,455: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:39:33,455: Using redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:39:33,455: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-05 00:39:33,615: SQL status: CREATE VIEW in 0.16 seconds
2018-01-05 00:39:33,615: Using redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:39:33,615: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-05 00:39:33,619: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:39:33,619: On parsely_videoview_engagedtime: COMMIT
2018-01-05 00:39:33,619: Using redshift connection "parsely_videoview_engagedtime".
2018-01-05 00:39:33,619: On parsely_videoview_engagedtime: COMMIT
2018-01-05 00:39:33,920: SQL status: COMMIT in 0.30 seconds
2018-01-05 00:39:33,921: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9e9ed0>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:39:33,970: 00:39:33 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.54s]
2018-01-05 00:39:33,971: 00:39:33 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-05 00:39:33,971: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-05 00:39:33,979: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-05 00:39:33,981: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:39:33,981: Re-using an available connection from the pool.
2018-01-05 00:39:33,981: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:39:33,981: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:39:34,003: SQL status: SELECT in 0.02 seconds
2018-01-05 00:39:34,003: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:39:34,003: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:39:34,024: SQL status: SELECT in 0.02 seconds
2018-01-05 00:39:34,026: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:39:34,026: On parsely_videoview_behavior_workflow: BEGIN
2018-01-05 00:39:34,028: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:39:34,028: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:39:34,028: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:44:18,283: SQL status: SELECT in 284.25 seconds
2018-01-05 00:44:18,283: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:44:18,283: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-05 00:44:18,460: SQL status: SELECT in 0.18 seconds
2018-01-05 00:44:18,460: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:44:18,460: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:44:18,581: SQL status: SELECT in 0.12 seconds
2018-01-05 00:44:18,582: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:44:18,582: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:44:18,702: SQL status: SELECT in 0.12 seconds
2018-01-05 00:44:18,705: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-05 00:44:18,707: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:44:18,707: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-05 00:44:19,977: SQL status: INSERT 0 144 in 1.27 seconds
2018-01-05 00:44:19,977: On parsely_videoview_behavior_workflow: COMMIT
2018-01-05 00:44:19,977: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-05 00:44:19,978: On parsely_videoview_behavior_workflow: COMMIT
2018-01-05 00:44:21,500: SQL status: COMMIT in 1.52 seconds
2018-01-05 00:44:21,500: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9e9950>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:44:21,575: 00:44:21 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 144 in 287.53s]
2018-01-05 00:44:21,575: 00:44:21 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-05 00:44:21,576: Compiling model.parsely.parsely_campaigns
2018-01-05 00:44:21,581: Acquiring new redshift connection "parsely_campaigns".
2018-01-05 00:44:21,581: Re-using an available connection from the pool.
2018-01-05 00:44:21,581: Using redshift connection "parsely_campaigns".
2018-01-05 00:44:21,582: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:44:21,604: SQL status: SELECT in 0.02 seconds
2018-01-05 00:44:21,607: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-05 00:44:21,609: Using redshift connection "parsely_campaigns".
2018-01-05 00:44:21,609: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:44:21,631: SQL status: SELECT in 0.02 seconds
2018-01-05 00:44:21,631: Using redshift connection "parsely_campaigns".
2018-01-05 00:44:21,632: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:44:21,652: SQL status: SELECT in 0.02 seconds
2018-01-05 00:44:21,654: Using redshift connection "parsely_campaigns".
2018-01-05 00:44:21,654: On parsely_campaigns: BEGIN
2018-01-05 00:44:21,656: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:44:21,656: Using redshift connection "parsely_campaigns".
2018-01-05 00:44:21,656: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:44:22,983: SQL status: SELECT in 1.33 seconds
2018-01-05 00:44:22,983: Using redshift connection "parsely_campaigns".
2018-01-05 00:44:22,983: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-05 00:44:23,158: SQL status: SELECT in 0.18 seconds
2018-01-05 00:44:23,158: Using redshift connection "parsely_campaigns".
2018-01-05 00:44:23,159: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:44:23,274: SQL status: SELECT in 0.11 seconds
2018-01-05 00:44:23,274: Using redshift connection "parsely_campaigns".
2018-01-05 00:44:23,274: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:44:23,388: SQL status: SELECT in 0.11 seconds
2018-01-05 00:44:23,389: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-05 00:44:23,393: Using redshift connection "parsely_campaigns".
2018-01-05 00:44:23,393: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-05 00:44:23,536: SQL status: INSERT 0 392 in 0.14 seconds
2018-01-05 00:44:23,537: On parsely_campaigns: COMMIT
2018-01-05 00:44:23,537: Using redshift connection "parsely_campaigns".
2018-01-05 00:44:23,537: On parsely_campaigns: COMMIT
2018-01-05 00:44:23,874: SQL status: COMMIT in 0.34 seconds
2018-01-05 00:44:23,875: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9e9950>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:44:23,931: 00:44:23 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 392 in 2.30s]
2018-01-05 00:44:23,932: Compiling model.parsely.parsely_incoming_users
2018-01-05 00:44:23,938: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-05 00:44:23,939: 00:44:23 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-05 00:44:23,940: Compiling model.parsely.parsely_users
2018-01-05 00:44:23,945: Acquiring new redshift connection "parsely_users".
2018-01-05 00:44:23,945: Re-using an available connection from the pool.
2018-01-05 00:44:23,945: Using redshift connection "parsely_users".
2018-01-05 00:44:23,945: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:44:23,967: SQL status: SELECT in 0.02 seconds
2018-01-05 00:44:24,007: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-05 00:44:24,009: Using redshift connection "parsely_users".
2018-01-05 00:44:24,009: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:44:24,027: SQL status: SELECT in 0.02 seconds
2018-01-05 00:44:24,028: Using redshift connection "parsely_users".
2018-01-05 00:44:24,028: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:44:24,047: SQL status: SELECT in 0.02 seconds
2018-01-05 00:44:24,049: Using redshift connection "parsely_users".
2018-01-05 00:44:24,049: On parsely_users: BEGIN
2018-01-05 00:44:24,051: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:44:24,051: Using redshift connection "parsely_users".
2018-01-05 00:44:24,051: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:44:26,936: SQL status: SELECT in 2.88 seconds
2018-01-05 00:44:26,936: Using redshift connection "parsely_users".
2018-01-05 00:44:26,936: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-05 00:44:27,091: SQL status: SELECT in 0.15 seconds
2018-01-05 00:44:27,091: Using redshift connection "parsely_users".
2018-01-05 00:44:27,091: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:44:27,206: SQL status: SELECT in 0.11 seconds
2018-01-05 00:44:27,206: Using redshift connection "parsely_users".
2018-01-05 00:44:27,206: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:44:27,320: SQL status: SELECT in 0.11 seconds
2018-01-05 00:44:27,321: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-05 00:44:27,322: Using redshift connection "parsely_users".
2018-01-05 00:44:27,323: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-05 00:44:27,636: SQL status: INSERT 0 54477 in 0.31 seconds
2018-01-05 00:44:27,637: On parsely_users: COMMIT
2018-01-05 00:44:27,637: Using redshift connection "parsely_users".
2018-01-05 00:44:27,637: On parsely_users: COMMIT
2018-01-05 00:44:27,973: SQL status: COMMIT in 0.34 seconds
2018-01-05 00:44:27,973: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9e9ed0>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:44:28,004: 00:44:28 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 54477 in 4.03s]
2018-01-05 00:44:28,005: 00:44:28 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-05 00:44:28,005: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-05 00:44:28,037: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-05 00:44:28,039: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:44:28,039: Re-using an available connection from the pool.
2018-01-05 00:44:28,039: Using redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:44:28,039: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:44:28,061: SQL status: SELECT in 0.02 seconds
2018-01-05 00:44:28,063: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-05 00:44:28,064: Using redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:44:28,065: On parsely_pageview_engagedtime: BEGIN
2018-01-05 00:44:28,067: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:44:28,067: Using redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:44:28,067: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-05 00:44:28,421: SQL status: CREATE VIEW in 0.35 seconds
2018-01-05 00:44:28,421: Using redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:44:28,424: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-05 00:44:28,428: SQL status: ALTER TABLE in 0.00 seconds
2018-01-05 00:44:28,428: On parsely_pageview_engagedtime: COMMIT
2018-01-05 00:44:28,428: Using redshift connection "parsely_pageview_engagedtime".
2018-01-05 00:44:28,428: On parsely_pageview_engagedtime: COMMIT
2018-01-05 00:44:28,809: SQL status: COMMIT in 0.38 seconds
2018-01-05 00:44:28,809: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba462d0>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:44:28,839: 00:44:28 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.80s]
2018-01-05 00:44:28,840: 00:44:28 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-05 00:44:28,840: Compiling model.parsely.parsely_incoming_sessions
2018-01-05 00:44:28,847: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-05 00:44:28,849: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-05 00:44:28,849: Re-using an available connection from the pool.
2018-01-05 00:44:28,849: Using redshift connection "parsely_incoming_sessions".
2018-01-05 00:44:28,849: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:44:28,874: SQL status: SELECT in 0.02 seconds
2018-01-05 00:44:28,876: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-05 00:44:28,877: Using redshift connection "parsely_incoming_sessions".
2018-01-05 00:44:28,877: On parsely_incoming_sessions: BEGIN
2018-01-05 00:44:28,879: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:44:28,880: Using redshift connection "parsely_incoming_sessions".
2018-01-05 00:44:28,880: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-05 00:44:29,448: SQL status: CREATE VIEW in 0.57 seconds
2018-01-05 00:44:29,449: Using redshift connection "parsely_incoming_sessions".
2018-01-05 00:44:29,449: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-05 00:44:29,454: SQL status: ALTER TABLE in 0.01 seconds
2018-01-05 00:44:29,454: On parsely_incoming_sessions: COMMIT
2018-01-05 00:44:29,454: Using redshift connection "parsely_incoming_sessions".
2018-01-05 00:44:29,455: On parsely_incoming_sessions: COMMIT
2018-01-05 00:44:29,965: SQL status: COMMIT in 0.51 seconds
2018-01-05 00:44:29,966: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9f9e10>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:44:29,996: 00:44:29 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 1.13s]
2018-01-05 00:44:29,997: 00:44:29 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-05 00:44:29,997: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-05 00:44:30,006: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-05 00:44:30,010: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:44:30,010: Re-using an available connection from the pool.
2018-01-05 00:44:30,010: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:44:30,011: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:44:30,033: SQL status: SELECT in 0.02 seconds
2018-01-05 00:44:30,033: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:44:30,033: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:44:30,053: SQL status: SELECT in 0.02 seconds
2018-01-05 00:44:30,055: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:44:30,055: On parsely_pageview_behavior_workflow: BEGIN
2018-01-05 00:44:30,057: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:44:30,057: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:44:30,058: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:47:34,511: SQL status: SELECT in 184.45 seconds
2018-01-05 00:47:34,511: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:47:34,511: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-05 00:47:34,779: SQL status: SELECT in 0.27 seconds
2018-01-05 00:47:34,780: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:47:34,780: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:47:34,914: SQL status: SELECT in 0.13 seconds
2018-01-05 00:47:34,914: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:47:34,914: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:47:35,049: SQL status: SELECT in 0.13 seconds
2018-01-05 00:47:35,052: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-05 00:47:35,053: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:47:35,053: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-05 00:47:38,895: SQL status: INSERT 0 111708 in 3.84 seconds
2018-01-05 00:47:38,895: On parsely_pageview_behavior_workflow: COMMIT
2018-01-05 00:47:38,895: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-05 00:47:38,895: On parsely_pageview_behavior_workflow: COMMIT
2018-01-05 00:47:40,521: SQL status: COMMIT in 1.63 seconds
2018-01-05 00:47:40,522: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba78990>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:47:40,610: 00:47:40 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 111708 in 190.52s]
2018-01-05 00:47:40,610: 00:47:40 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-05 00:47:40,611: Compiling model.parsely.parsely_sessions
2018-01-05 00:47:40,616: Acquiring new redshift connection "parsely_sessions".
2018-01-05 00:47:40,616: Re-using an available connection from the pool.
2018-01-05 00:47:40,616: Using redshift connection "parsely_sessions".
2018-01-05 00:47:40,617: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:47:40,639: SQL status: SELECT in 0.02 seconds
2018-01-05 00:47:40,642: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-05 00:47:40,643: Using redshift connection "parsely_sessions".
2018-01-05 00:47:40,644: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:47:40,664: SQL status: SELECT in 0.02 seconds
2018-01-05 00:47:40,665: Using redshift connection "parsely_sessions".
2018-01-05 00:47:40,665: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-05 00:47:40,685: SQL status: SELECT in 0.02 seconds
2018-01-05 00:47:40,688: Using redshift connection "parsely_sessions".
2018-01-05 00:47:40,688: On parsely_sessions: BEGIN
2018-01-05 00:47:40,690: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:47:40,690: Using redshift connection "parsely_sessions".
2018-01-05 00:47:40,690: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-05 00:48:19,169: SQL status: SELECT in 38.48 seconds
2018-01-05 00:48:19,169: Using redshift connection "parsely_sessions".
2018-01-05 00:48:19,169: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-05 00:48:19,419: SQL status: SELECT in 0.25 seconds
2018-01-05 00:48:19,419: Using redshift connection "parsely_sessions".
2018-01-05 00:48:19,419: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:48:19,537: SQL status: SELECT in 0.12 seconds
2018-01-05 00:48:19,538: Using redshift connection "parsely_sessions".
2018-01-05 00:48:19,538: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-05 00:48:19,657: SQL status: SELECT in 0.12 seconds
2018-01-05 00:48:19,660: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-05 00:48:19,661: Using redshift connection "parsely_sessions".
2018-01-05 00:48:19,661: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-05 00:48:21,567: SQL status: INSERT 0 90755 in 1.91 seconds
2018-01-05 00:48:21,567: On parsely_sessions: COMMIT
2018-01-05 00:48:21,567: Using redshift connection "parsely_sessions".
2018-01-05 00:48:21,567: On parsely_sessions: COMMIT
2018-01-05 00:48:22,983: SQL status: COMMIT in 1.42 seconds
2018-01-05 00:48:22,983: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aab9e9950>], 'label': '8a7cc785-f7df-4af2-9692-0ffb53f78a16'}
2018-01-05 00:48:23,014: 00:48:23 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 90755 in 42.37s]
2018-01-05 00:48:23,071: Using redshift connection "master".
2018-01-05 00:48:23,071: On master: BEGIN
2018-01-05 00:48:23,073: SQL status: BEGIN in 0.00 seconds
2018-01-05 00:48:23,073: On master: COMMIT
2018-01-05 00:48:23,073: Using redshift connection "master".
2018-01-05 00:48:23,074: On master: COMMIT
2018-01-05 00:48:23,075: SQL status: COMMIT in 0.00 seconds
2018-01-05 00:48:23,076: Compiling operation.parsely.parsely-on-run-end-0
2018-01-05 00:48:23,080: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-05 00:48:23,082: Using redshift connection "master".
2018-01-05 00:48:23,082: On master:  select 1 
2018-01-05 00:48:23,084: SQL status: SELECT in 0.00 seconds
2018-01-05 00:48:23,084: 00:48:23 | 
2018-01-05 00:48:23,084: 00:48:23 | Finished running 10 view models, 15 incremental models in 1438.01s.
2018-01-05 00:48:23,085: 
2018-01-05 00:48:23,085: Completed successfully
2018-01-05 00:48:23,085: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-05 00:48:23,086: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba91e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba91f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7aaba78950>], 'label': 'end'}
2018-01-05 00:48:23,115: Flushing usage events
