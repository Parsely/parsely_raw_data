2017-12-20 21:43:51,578: Tracking: tracking
2017-12-20 21:43:51,578: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f12b5477250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f12b54774d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f12b5477310>], 'label': 'start'}
2017-12-20 21:43:51,666: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-20 21:43:51,688: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-20 21:43:51,689: Parsing core.sql
2017-12-20 21:43:51,700: Parsing etc/get_custom_schema.sql
2017-12-20 21:43:51,706: Parsing schema_tests/relationships.sql
2017-12-20 21:43:51,708: Parsing schema_tests/accepted_values.sql
2017-12-20 21:43:51,711: Parsing schema_tests/not_null.sql
2017-12-20 21:43:51,712: Parsing schema_tests/unique.sql
2017-12-20 21:43:51,717: Parsing materializations/wrapper.sql
2017-12-20 21:43:51,721: Parsing materializations/archive.sql
2017-12-20 21:43:51,774: Parsing materializations/table.sql
2017-12-20 21:43:51,808: Parsing materializations/helpers.sql
2017-12-20 21:43:51,839: Parsing materializations/bigquery.sql
2017-12-20 21:43:51,866: Parsing materializations/view.sql
2017-12-20 21:43:51,895: Parsing materializations/incremental.sql
2017-12-20 21:43:51,945: Parsing adapters/redshift.sql
2017-12-20 21:43:51,981: Parsing adapters/bigquery.sql
2017-12-20 21:43:51,990: Parsing adapters/postgres.sql
2017-12-20 21:43:51,995: Parsing adapters/common.sql
2017-12-20 21:43:52,033: Parsing model.parsely.parsely_audit
2017-12-20 21:43:52,036: Parsing model.parsely.parsely_video_content
2017-12-20 21:43:52,041: Parsing model.parsely.parsely_post_content
2017-12-20 21:43:52,047: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-20 21:43:52,052: Parsing model.parsely.parsely_rawdata
2017-12-20 21:43:52,057: Parsing model.parsely.calendar
2017-12-20 21:43:52,059: Parsing model.parsely.parsely_all_events
2017-12-20 21:43:52,075: Acquiring new redshift connection "parsely_all_events".
2017-12-20 21:43:52,076: Opening a new connection (0 currently allocated)
2017-12-20 21:43:52,104: Using redshift connection "parsely_all_events".
2017-12-20 21:43:52,104: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:52,131: SQL status: SELECT in 0.03 seconds
2017-12-20 21:43:52,140: Parsing model.parsely.parsely_event_ids
2017-12-20 21:43:52,145: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-20 21:43:52,149: Parsing model.parsely.parsely_base_events
2017-12-20 21:43:52,156: Acquiring new redshift connection "parsely_base_events".
2017-12-20 21:43:52,156: Re-using an available connection from the pool.
2017-12-20 21:43:52,156: Using redshift connection "parsely_base_events".
2017-12-20 21:43:52,157: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:52,177: SQL status: SELECT in 0.02 seconds
2017-12-20 21:43:52,179: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-20 21:43:52,189: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-20 21:43:52,197: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-20 21:43:52,201: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-20 21:43:52,204: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-20 21:43:52,210: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-20 21:43:52,220: Parsing model.parsely.parsely_incoming_pageviews
2017-12-20 21:43:52,233: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-20 21:43:52,242: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-20 21:43:52,243: Re-using an available connection from the pool.
2017-12-20 21:43:52,243: Using redshift connection "parsely_pageviews_sessionized".
2017-12-20 21:43:52,243: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:52,263: SQL status: SELECT in 0.02 seconds
2017-12-20 21:43:52,264: Parsing model.parsely.parsely_incoming_videoviews
2017-12-20 21:43:52,270: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-20 21:43:52,275: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-20 21:43:52,275: Re-using an available connection from the pool.
2017-12-20 21:43:52,275: Using redshift connection "parsely_videoviews_sessionized".
2017-12-20 21:43:52,275: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:52,295: SQL status: SELECT in 0.02 seconds
2017-12-20 21:43:52,295: Parsing model.parsely.parsely_incoming_users
2017-12-20 21:43:52,298: Parsing model.parsely.parsely_users
2017-12-20 21:43:52,303: Acquiring new redshift connection "parsely_users".
2017-12-20 21:43:52,303: Re-using an available connection from the pool.
2017-12-20 21:43:52,303: Using redshift connection "parsely_users".
2017-12-20 21:43:52,303: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:52,325: SQL status: SELECT in 0.02 seconds
2017-12-20 21:43:52,326: Parsing model.parsely.parsely_errors
2017-12-20 21:43:52,333: Parsing model.parsely.parsely_bot_traffic
2017-12-20 21:43:52,340: Parsing model.parsely.parsely_custom_events
2017-12-20 21:43:52,348: Parsing model.parsely.parsely_incoming_sessions
2017-12-20 21:43:52,354: Parsing model.parsely.parsely_entry_exit_urls
2017-12-20 21:43:52,359: Parsing model.parsely.parsely_sessions
2017-12-20 21:43:52,367: Acquiring new redshift connection "parsely_sessions".
2017-12-20 21:43:52,367: Re-using an available connection from the pool.
2017-12-20 21:43:52,367: Using redshift connection "parsely_sessions".
2017-12-20 21:43:52,367: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:52,391: SQL status: SELECT in 0.02 seconds
2017-12-20 21:43:52,392: Parsing model.parsely.parsely_campaigns
2017-12-20 21:43:52,400: Acquiring new redshift connection "parsely_campaigns".
2017-12-20 21:43:52,400: Re-using an available connection from the pool.
2017-12-20 21:43:52,400: Using redshift connection "parsely_campaigns".
2017-12-20 21:43:52,400: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:52,420: SQL status: SELECT in 0.02 seconds
2017-12-20 21:43:52,432: Parsing operation.parsely.parsely-on-run-end-0
2017-12-20 21:43:52,442: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-20 21:43:52,456: 
2017-12-20 21:43:52,460: Acquiring new redshift connection "master".
2017-12-20 21:43:52,461: Re-using an available connection from the pool.
2017-12-20 21:43:52,461: Using redshift connection "master".
2017-12-20 21:43:52,461: On master: select distinct nspname from pg_namespace
2017-12-20 21:43:52,463: SQL status: SELECT in 0.00 seconds
2017-12-20 21:43:52,468: Using redshift connection "master".
2017-12-20 21:43:52,468: On master: BEGIN
2017-12-20 21:43:52,470: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:43:52,470: On master: COMMIT
2017-12-20 21:43:52,470: Using redshift connection "master".
2017-12-20 21:43:52,470: On master: COMMIT
2017-12-20 21:43:52,472: SQL status: COMMIT in 0.00 seconds
2017-12-20 21:43:52,482: 21:43:52 | Concurrency: 1 threads (target='dev')
2017-12-20 21:43:52,482: 21:43:52 | 
2017-12-20 21:43:52,482: Using redshift connection "master".
2017-12-20 21:43:52,482: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:52,503: SQL status: SELECT in 0.02 seconds
2017-12-20 21:43:52,634: 21:43:52 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-20 21:43:52,635: Compiling model.parsely.calendar
2017-12-20 21:43:52,643: Writing injected SQL for node "model.parsely.calendar"
2017-12-20 21:43:52,644: Acquiring new redshift connection "calendar".
2017-12-20 21:43:52,644: Opening a new connection (1 currently allocated)
2017-12-20 21:43:52,657: Using redshift connection "calendar".
2017-12-20 21:43:52,657: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:52,681: SQL status: SELECT in 0.02 seconds
2017-12-20 21:43:52,685: Writing runtime SQL for node "model.parsely.calendar"
2017-12-20 21:43:52,686: Using redshift connection "calendar".
2017-12-20 21:43:52,686: On calendar: BEGIN
2017-12-20 21:43:52,688: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:43:52,688: Using redshift connection "calendar".
2017-12-20 21:43:52,688: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-20 21:43:53,354: SQL status: CREATE VIEW in 0.67 seconds
2017-12-20 21:43:53,355: Using redshift connection "calendar".
2017-12-20 21:43:53,355: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-20 21:43:53,357: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 21:43:53,358: On calendar: COMMIT
2017-12-20 21:43:53,358: Using redshift connection "calendar".
2017-12-20 21:43:53,358: On calendar: COMMIT
2017-12-20 21:43:53,856: SQL status: COMMIT in 0.50 seconds
2017-12-20 21:43:53,857: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f12b536a690>], 'label': '8f0e45e6-ffb6-4a97-8ceb-0c05635ab6fd'}
2017-12-20 21:43:53,898: 21:43:53 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.22s]
2017-12-20 21:43:53,898: 21:43:53 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-20 21:43:53,898: Compiling model.parsely.parsely_rawdata
2017-12-20 21:43:53,904: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-20 21:43:53,905: Acquiring new redshift connection "parsely_rawdata".
2017-12-20 21:43:53,905: Re-using an available connection from the pool.
2017-12-20 21:43:53,905: Using redshift connection "parsely_rawdata".
2017-12-20 21:43:53,905: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:53,926: SQL status: SELECT in 0.02 seconds
2017-12-20 21:43:53,926: Using redshift connection "parsely_rawdata".
2017-12-20 21:43:53,926: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:43:53,946: SQL status: SELECT in 0.02 seconds
2017-12-20 21:43:53,947: Using redshift connection "parsely_rawdata".
2017-12-20 21:43:53,947: On parsely_rawdata: BEGIN
2017-12-20 21:43:53,949: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:43:53,949: Using redshift connection "parsely_rawdata".
2017-12-20 21:43:53,949: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-20 21:44:19,920: SQL status: SELECT in 25.97 seconds
2017-12-20 21:44:19,921: Using redshift connection "parsely_rawdata".
2017-12-20 21:44:19,921: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-20 21:44:20,085: SQL status: SELECT in 0.16 seconds
2017-12-20 21:44:20,086: Using redshift connection "parsely_rawdata".
2017-12-20 21:44:20,086: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-20 21:44:20,198: SQL status: SELECT in 0.11 seconds
2017-12-20 21:44:20,199: Using redshift connection "parsely_rawdata".
2017-12-20 21:44:20,199: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-20 21:44:20,308: SQL status: SELECT in 0.11 seconds
2017-12-20 21:44:20,311: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-20 21:44:20,312: Using redshift connection "parsely_rawdata".
2017-12-20 21:44:20,312: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-20 21:44:51,984: SQL status: INSERT 0 996095 in 31.67 seconds
2017-12-20 21:44:51,984: On parsely_rawdata: COMMIT
2017-12-20 21:44:51,985: Using redshift connection "parsely_rawdata".
2017-12-20 21:44:51,985: On parsely_rawdata: COMMIT
2017-12-20 21:44:53,937: SQL status: COMMIT in 1.95 seconds
2017-12-20 21:44:53,938: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f12b542cbd0>], 'label': '8f0e45e6-ffb6-4a97-8ceb-0c05635ab6fd'}
2017-12-20 21:44:54,023: 21:44:54 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 996095 in 60.04s]
2017-12-20 21:44:54,024: 21:44:54 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-20 21:44:54,024: Compiling model.parsely.parsely_all_events
2017-12-20 21:44:54,040: Acquiring new redshift connection "parsely_all_events".
2017-12-20 21:44:54,040: Re-using an available connection from the pool.
2017-12-20 21:44:54,040: Using redshift connection "parsely_all_events".
2017-12-20 21:44:54,040: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:44:54,060: SQL status: SELECT in 0.02 seconds
2017-12-20 21:44:54,075: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-20 21:44:54,077: Using redshift connection "parsely_all_events".
2017-12-20 21:44:54,077: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:44:54,096: SQL status: SELECT in 0.02 seconds
2017-12-20 21:44:54,096: Using redshift connection "parsely_all_events".
2017-12-20 21:44:54,096: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:44:54,114: SQL status: SELECT in 0.02 seconds
2017-12-20 21:44:54,117: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-20 21:44:54,118: Using redshift connection "parsely_all_events".
2017-12-20 21:44:54,118: On parsely_all_events: BEGIN
2017-12-20 21:44:54,120: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:44:54,120: Using redshift connection "parsely_all_events".
2017-12-20 21:44:54,120: On parsely_all_events: 
    
  

  create  table "blog_dbt_dev"."parsely_all_events"
  
  
  as (
    

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    

),

with timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone(America/New_York, ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone(America/New_York, ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone(America/New_York, ts_session_last) as ts_session_last_tz,
--      meatadata_pub_date_tmsp
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(meatadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as meatadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
)


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
  );
2017-12-20 21:44:54,128: Postgres error: syntax error at or near "with"
LINE 20: with timezone_convert as (
         ^

2017-12-20 21:44:54,128: On parsely_all_events: ROLLBACK
2017-12-20 21:44:54,131: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f12b53df890>], 'label': '8f0e45e6-ffb6-4a97-8ceb-0c05635ab6fd'}
2017-12-20 21:44:54,167: 21:44:54 | 3 of 25 ERROR creating incremental model blog_dbt_dev.parsely_all_events [ERROR in 0.11s]
2017-12-20 21:44:54,168: 21:44:54 | 4 of 25 SKIP relation blog_dbt_dev.parsely_base_events............... [SKIP]
2017-12-20 21:44:54,168: 21:44:54 | 5 of 25 SKIP relation blog_dbt_dev.parsely_bot_traffic............... [SKIP]
2017-12-20 21:44:54,169: 21:44:54 | 6 of 25 SKIP relation blog_dbt_dev.parsely_custom_events............. [SKIP]
2017-12-20 21:44:54,169: 21:44:54 | 7 of 25 SKIP relation blog_dbt_dev.parsely_errors.................... [SKIP]
2017-12-20 21:44:54,170: 21:44:54 | 8 of 25 SKIP relation blog_dbt_dev.parsely_post_content.............. [SKIP]
2017-12-20 21:44:54,170: 21:44:54 | 9 of 25 SKIP relation blog_dbt_dev.parsely_video_content............. [SKIP]
2017-12-20 21:44:54,171: 21:44:54 | 10 of 25 SKIP relation blog_dbt_dev.parsely_entry_exit_urls.......... [SKIP]
2017-12-20 21:44:54,171: 21:44:54 | 11 of 25 SKIP relation blog_dbt_dev.parsely_incoming_videoviews...... [SKIP]
2017-12-20 21:44:54,171: 21:44:54 | 12 of 25 SKIP relation blog_dbt_dev.parsely_event_ids................ [SKIP]
2017-12-20 21:44:54,172: 21:44:54 | 13 of 25 SKIP relation blog_dbt_dev.parsely_videoviews_sessionized... [SKIP]
2017-12-20 21:44:54,172: 21:44:54 | 14 of 25 SKIP relation blog_dbt_dev.parsely_pageview_hanging_engagedtime [SKIP]
2017-12-20 21:44:54,173: 21:44:54 | 15 of 25 SKIP relation blog_dbt_dev.parsely_videoview_hanging_engagedtime [SKIP]
2017-12-20 21:44:54,173: 21:44:54 | 16 of 25 SKIP relation blog_dbt_dev.parsely_incoming_pageviews....... [SKIP]
2017-12-20 21:44:54,174: 21:44:54 | 17 of 25 SKIP relation blog_dbt_dev.parsely_pageviews_sessionized.... [SKIP]
2017-12-20 21:44:54,174: 21:44:54 | 18 of 25 SKIP relation blog_dbt_dev.parsely_videoview_engagedtime.... [SKIP]
2017-12-20 21:44:54,175: 21:44:54 | 19 of 25 SKIP relation blog_dbt_dev.parsely_videoview_behavior_workflow [SKIP]
2017-12-20 21:44:54,175: 21:44:54 | 20 of 25 SKIP relation blog_dbt_dev.parsely_campaigns................ [SKIP]
2017-12-20 21:44:54,176: 21:44:54 | 21 of 25 SKIP relation blog_dbt_dev.parsely_users.................... [SKIP]
2017-12-20 21:44:54,176: 21:44:54 | 22 of 25 SKIP relation blog_dbt_dev.parsely_pageview_engagedtime..... [SKIP]
2017-12-20 21:44:54,177: 21:44:54 | 23 of 25 SKIP relation blog_dbt_dev.parsely_incoming_sessions........ [SKIP]
2017-12-20 21:44:54,177: 21:44:54 | 24 of 25 SKIP relation blog_dbt_dev.parsely_pageview_behavior_workflow [SKIP]
2017-12-20 21:44:54,178: 21:44:54 | 25 of 25 SKIP relation blog_dbt_dev.parsely_sessions................. [SKIP]
2017-12-20 21:44:54,270: Using redshift connection "master".
2017-12-20 21:44:54,270: On master: BEGIN
2017-12-20 21:44:54,272: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:44:54,272: On master: COMMIT
2017-12-20 21:44:54,272: Using redshift connection "master".
2017-12-20 21:44:54,273: On master: COMMIT
2017-12-20 21:44:54,274: SQL status: COMMIT in 0.00 seconds
2017-12-20 21:44:54,274: Compiling operation.parsely.parsely-on-run-end-0
2017-12-20 21:44:54,283: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-20 21:44:54,284: Using redshift connection "master".
2017-12-20 21:44:54,284: On master:  select 1 
2017-12-20 21:44:54,286: SQL status: SELECT in 0.00 seconds
2017-12-20 21:44:54,287: 21:44:54 | 
2017-12-20 21:44:54,287: 21:44:54 | Finished running 10 view models, 15 incremental models in 61.79s.
2017-12-20 21:44:54,288: 
2017-12-20 21:44:54,288: Completed with 1 errors:
2017-12-20 21:44:54,288: 
2017-12-20 21:44:54,288: Database Error in model parsely_all_events (models/base/parsely_all_events.sql)
2017-12-20 21:44:54,289:   syntax error at or near "with"
2017-12-20 21:44:54,289:   LINE 20: with timezone_convert as (
2017-12-20 21:44:54,289:            ^
2017-12-20 21:44:54,290:   compiled SQL at target/run/parsely/base/parsely_all_events.sql
2017-12-20 21:44:54,290: 
Done. PASS=2 ERROR=1 SKIP=22 TOTAL=25
2017-12-20 21:44:54,290: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f12b5477250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f12b54774d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f12c252e910>], 'label': 'end'}
2017-12-20 21:44:54,327: Flushing usage events
2017-12-20 21:46:41,187: Tracking: tracking
2017-12-20 21:46:41,187: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa812910250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa8129104d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa812910310>], 'label': 'start'}
2017-12-20 21:46:41,248: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-20 21:46:41,263: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-20 21:46:41,265: Parsing core.sql
2017-12-20 21:46:41,276: Parsing etc/get_custom_schema.sql
2017-12-20 21:46:41,281: Parsing schema_tests/relationships.sql
2017-12-20 21:46:41,283: Parsing schema_tests/accepted_values.sql
2017-12-20 21:46:41,286: Parsing schema_tests/not_null.sql
2017-12-20 21:46:41,288: Parsing schema_tests/unique.sql
2017-12-20 21:46:41,290: Parsing materializations/wrapper.sql
2017-12-20 21:46:41,292: Parsing materializations/archive.sql
2017-12-20 21:46:41,320: Parsing materializations/table.sql
2017-12-20 21:46:41,337: Parsing materializations/helpers.sql
2017-12-20 21:46:41,352: Parsing materializations/bigquery.sql
2017-12-20 21:46:41,365: Parsing materializations/view.sql
2017-12-20 21:46:41,378: Parsing materializations/incremental.sql
2017-12-20 21:46:41,402: Parsing adapters/redshift.sql
2017-12-20 21:46:41,419: Parsing adapters/bigquery.sql
2017-12-20 21:46:41,424: Parsing adapters/postgres.sql
2017-12-20 21:46:41,426: Parsing adapters/common.sql
2017-12-20 21:46:41,445: Parsing model.parsely.parsely_audit
2017-12-20 21:46:41,446: Parsing model.parsely.parsely_video_content
2017-12-20 21:46:41,449: Parsing model.parsely.parsely_post_content
2017-12-20 21:46:41,452: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-20 21:46:41,454: Parsing model.parsely.parsely_rawdata
2017-12-20 21:46:41,457: Parsing model.parsely.calendar
2017-12-20 21:46:41,458: Parsing model.parsely.parsely_all_events
2017-12-20 21:46:41,467: Acquiring new redshift connection "parsely_all_events".
2017-12-20 21:46:41,467: Opening a new connection (0 currently allocated)
2017-12-20 21:46:41,508: Using redshift connection "parsely_all_events".
2017-12-20 21:46:41,508: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:41,534: SQL status: SELECT in 0.03 seconds
2017-12-20 21:46:41,539: Parsing model.parsely.parsely_event_ids
2017-12-20 21:46:41,542: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-20 21:46:41,544: Parsing model.parsely.parsely_base_events
2017-12-20 21:46:41,547: Acquiring new redshift connection "parsely_base_events".
2017-12-20 21:46:41,548: Re-using an available connection from the pool.
2017-12-20 21:46:41,548: Using redshift connection "parsely_base_events".
2017-12-20 21:46:41,548: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:41,568: SQL status: SELECT in 0.02 seconds
2017-12-20 21:46:41,569: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-20 21:46:41,574: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-20 21:46:41,579: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-20 21:46:41,581: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-20 21:46:41,583: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-20 21:46:41,585: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-20 21:46:41,591: Parsing model.parsely.parsely_incoming_pageviews
2017-12-20 21:46:41,598: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-20 21:46:41,603: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-20 21:46:41,603: Re-using an available connection from the pool.
2017-12-20 21:46:41,603: Using redshift connection "parsely_pageviews_sessionized".
2017-12-20 21:46:41,604: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:41,624: SQL status: SELECT in 0.02 seconds
2017-12-20 21:46:41,625: Parsing model.parsely.parsely_incoming_videoviews
2017-12-20 21:46:41,631: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-20 21:46:41,636: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-20 21:46:41,636: Re-using an available connection from the pool.
2017-12-20 21:46:41,636: Using redshift connection "parsely_videoviews_sessionized".
2017-12-20 21:46:41,637: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:41,657: SQL status: SELECT in 0.02 seconds
2017-12-20 21:46:41,658: Parsing model.parsely.parsely_incoming_users
2017-12-20 21:46:41,661: Parsing model.parsely.parsely_users
2017-12-20 21:46:41,666: Acquiring new redshift connection "parsely_users".
2017-12-20 21:46:41,666: Re-using an available connection from the pool.
2017-12-20 21:46:41,666: Using redshift connection "parsely_users".
2017-12-20 21:46:41,666: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:41,687: SQL status: SELECT in 0.02 seconds
2017-12-20 21:46:41,688: Parsing model.parsely.parsely_errors
2017-12-20 21:46:41,692: Parsing model.parsely.parsely_bot_traffic
2017-12-20 21:46:41,696: Parsing model.parsely.parsely_custom_events
2017-12-20 21:46:41,701: Parsing model.parsely.parsely_incoming_sessions
2017-12-20 21:46:41,704: Parsing model.parsely.parsely_entry_exit_urls
2017-12-20 21:46:41,707: Parsing model.parsely.parsely_sessions
2017-12-20 21:46:41,712: Acquiring new redshift connection "parsely_sessions".
2017-12-20 21:46:41,712: Re-using an available connection from the pool.
2017-12-20 21:46:41,713: Using redshift connection "parsely_sessions".
2017-12-20 21:46:41,713: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:41,732: SQL status: SELECT in 0.02 seconds
2017-12-20 21:46:41,733: Parsing model.parsely.parsely_campaigns
2017-12-20 21:46:41,736: Acquiring new redshift connection "parsely_campaigns".
2017-12-20 21:46:41,737: Re-using an available connection from the pool.
2017-12-20 21:46:41,737: Using redshift connection "parsely_campaigns".
2017-12-20 21:46:41,737: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:41,755: SQL status: SELECT in 0.02 seconds
2017-12-20 21:46:41,760: Parsing operation.parsely.parsely-on-run-end-0
2017-12-20 21:46:41,766: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-20 21:46:41,773: 
2017-12-20 21:46:41,775: Acquiring new redshift connection "master".
2017-12-20 21:46:41,775: Re-using an available connection from the pool.
2017-12-20 21:46:41,775: Using redshift connection "master".
2017-12-20 21:46:41,776: On master: select distinct nspname from pg_namespace
2017-12-20 21:46:41,778: SQL status: SELECT in 0.00 seconds
2017-12-20 21:46:41,780: Using redshift connection "master".
2017-12-20 21:46:41,780: On master: BEGIN
2017-12-20 21:46:41,782: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:46:41,782: On master: COMMIT
2017-12-20 21:46:41,782: Using redshift connection "master".
2017-12-20 21:46:41,782: On master: COMMIT
2017-12-20 21:46:41,783: SQL status: COMMIT in 0.00 seconds
2017-12-20 21:46:41,789: 21:46:41 | Concurrency: 1 threads (target='dev')
2017-12-20 21:46:41,789: 21:46:41 | 
2017-12-20 21:46:41,789: Using redshift connection "master".
2017-12-20 21:46:41,789: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:41,809: SQL status: SELECT in 0.02 seconds
2017-12-20 21:46:41,881: 21:46:41 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-20 21:46:41,881: Compiling model.parsely.calendar
2017-12-20 21:46:41,886: Writing injected SQL for node "model.parsely.calendar"
2017-12-20 21:46:41,887: Acquiring new redshift connection "calendar".
2017-12-20 21:46:41,887: Opening a new connection (1 currently allocated)
2017-12-20 21:46:41,899: Using redshift connection "calendar".
2017-12-20 21:46:41,899: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:41,924: SQL status: SELECT in 0.03 seconds
2017-12-20 21:46:41,926: Writing runtime SQL for node "model.parsely.calendar"
2017-12-20 21:46:41,927: Using redshift connection "calendar".
2017-12-20 21:46:41,927: On calendar: BEGIN
2017-12-20 21:46:41,928: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:46:41,928: Using redshift connection "calendar".
2017-12-20 21:46:41,929: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-20 21:46:41,985: SQL status: CREATE VIEW in 0.06 seconds
2017-12-20 21:46:41,985: On calendar: COMMIT
2017-12-20 21:46:41,985: Using redshift connection "calendar".
2017-12-20 21:46:41,985: On calendar: COMMIT
2017-12-20 21:46:42,202: SQL status: COMMIT in 0.22 seconds
2017-12-20 21:46:42,202: Using redshift connection "calendar".
2017-12-20 21:46:42,202: On calendar: BEGIN
2017-12-20 21:46:42,204: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:46:42,204: Using redshift connection "calendar".
2017-12-20 21:46:42,204: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-20 21:46:42,249: SQL status: DROP VIEW in 0.04 seconds
2017-12-20 21:46:42,249: On calendar: COMMIT
2017-12-20 21:46:42,249: Using redshift connection "calendar".
2017-12-20 21:46:42,249: On calendar: COMMIT
2017-12-20 21:46:42,402: SQL status: COMMIT in 0.15 seconds
2017-12-20 21:46:42,402: Using redshift connection "calendar".
2017-12-20 21:46:42,402: On calendar: BEGIN
2017-12-20 21:46:42,404: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:46:42,404: Using redshift connection "calendar".
2017-12-20 21:46:42,405: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-20 21:46:42,409: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 21:46:42,409: On calendar: COMMIT
2017-12-20 21:46:42,409: Using redshift connection "calendar".
2017-12-20 21:46:42,409: On calendar: COMMIT
2017-12-20 21:46:42,578: SQL status: COMMIT in 0.17 seconds
2017-12-20 21:46:42,578: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa812803690>], 'label': '17c6aac9-9697-4fca-976d-e01a943d2962'}
2017-12-20 21:46:42,606: 21:46:42 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 0.70s]
2017-12-20 21:46:42,606: 21:46:42 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-20 21:46:42,606: Compiling model.parsely.parsely_rawdata
2017-12-20 21:46:42,612: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-20 21:46:42,613: Acquiring new redshift connection "parsely_rawdata".
2017-12-20 21:46:42,613: Re-using an available connection from the pool.
2017-12-20 21:46:42,613: Using redshift connection "parsely_rawdata".
2017-12-20 21:46:42,613: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:42,633: SQL status: SELECT in 0.02 seconds
2017-12-20 21:46:42,633: Using redshift connection "parsely_rawdata".
2017-12-20 21:46:42,633: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:46:42,642: SQL status: SELECT in 0.01 seconds
2017-12-20 21:46:42,643: Using redshift connection "parsely_rawdata".
2017-12-20 21:46:42,643: On parsely_rawdata: BEGIN
2017-12-20 21:46:42,645: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:46:42,645: Using redshift connection "parsely_rawdata".
2017-12-20 21:46:42,645: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-20 21:47:11,664: SQL status: SELECT in 29.02 seconds
2017-12-20 21:47:11,664: Using redshift connection "parsely_rawdata".
2017-12-20 21:47:11,664: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-20 21:47:11,866: SQL status: SELECT in 0.20 seconds
2017-12-20 21:47:11,866: Using redshift connection "parsely_rawdata".
2017-12-20 21:47:11,866: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-20 21:47:11,964: SQL status: SELECT in 0.10 seconds
2017-12-20 21:47:11,965: Using redshift connection "parsely_rawdata".
2017-12-20 21:47:11,965: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-20 21:47:12,061: SQL status: SELECT in 0.10 seconds
2017-12-20 21:47:12,064: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-20 21:47:12,065: Using redshift connection "parsely_rawdata".
2017-12-20 21:47:12,065: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-20 21:47:42,887: SQL status: INSERT 0 996095 in 30.82 seconds
2017-12-20 21:47:42,888: On parsely_rawdata: COMMIT
2017-12-20 21:47:42,888: Using redshift connection "parsely_rawdata".
2017-12-20 21:47:42,888: On parsely_rawdata: COMMIT
2017-12-20 21:47:45,359: SQL status: COMMIT in 2.47 seconds
2017-12-20 21:47:45,359: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa8128031d0>], 'label': '17c6aac9-9697-4fca-976d-e01a943d2962'}
2017-12-20 21:47:45,423: 21:47:45 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 996095 in 62.75s]
2017-12-20 21:47:45,424: 21:47:45 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-20 21:47:45,424: Compiling model.parsely.parsely_all_events
2017-12-20 21:47:45,432: Acquiring new redshift connection "parsely_all_events".
2017-12-20 21:47:45,432: Re-using an available connection from the pool.
2017-12-20 21:47:45,432: Using redshift connection "parsely_all_events".
2017-12-20 21:47:45,432: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:47:45,448: SQL status: SELECT in 0.02 seconds
2017-12-20 21:47:45,456: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-20 21:47:45,457: Using redshift connection "parsely_all_events".
2017-12-20 21:47:45,457: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:47:45,472: SQL status: SELECT in 0.01 seconds
2017-12-20 21:47:45,472: Using redshift connection "parsely_all_events".
2017-12-20 21:47:45,472: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:47:45,485: SQL status: SELECT in 0.01 seconds
2017-12-20 21:47:45,488: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-20 21:47:45,489: Using redshift connection "parsely_all_events".
2017-12-20 21:47:45,489: On parsely_all_events: BEGIN
2017-12-20 21:47:45,491: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:47:45,491: Using redshift connection "parsely_all_events".
2017-12-20 21:47:45,491: On parsely_all_events: 
    
  

  create  table "blog_dbt_dev"."parsely_all_events"
  
  
  as (
    

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone(America/New_York, ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone(America/New_York, ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone(America/New_York, ts_session_last) as ts_session_last_tz,
--      meatadata_pub_date_tmsp
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(meatadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as meatadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone(America/New_York, (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
  );
2017-12-20 21:47:45,496: Postgres error: column "america" does not exist in new_events

2017-12-20 21:47:45,496: On parsely_all_events: ROLLBACK
2017-12-20 21:47:45,497: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa812878590>], 'label': '17c6aac9-9697-4fca-976d-e01a943d2962'}
2017-12-20 21:47:45,526: 21:47:45 | 3 of 25 ERROR creating incremental model blog_dbt_dev.parsely_all_events [ERROR in 0.07s]
2017-12-20 21:47:45,527: 21:47:45 | 4 of 25 SKIP relation blog_dbt_dev.parsely_base_events............... [SKIP]
2017-12-20 21:47:45,527: 21:47:45 | 5 of 25 SKIP relation blog_dbt_dev.parsely_bot_traffic............... [SKIP]
2017-12-20 21:47:45,528: 21:47:45 | 6 of 25 SKIP relation blog_dbt_dev.parsely_custom_events............. [SKIP]
2017-12-20 21:47:45,528: 21:47:45 | 7 of 25 SKIP relation blog_dbt_dev.parsely_errors.................... [SKIP]
2017-12-20 21:47:45,529: 21:47:45 | 8 of 25 SKIP relation blog_dbt_dev.parsely_post_content.............. [SKIP]
2017-12-20 21:47:45,529: 21:47:45 | 9 of 25 SKIP relation blog_dbt_dev.parsely_video_content............. [SKIP]
2017-12-20 21:47:45,529: 21:47:45 | 10 of 25 SKIP relation blog_dbt_dev.parsely_entry_exit_urls.......... [SKIP]
2017-12-20 21:47:45,530: 21:47:45 | 11 of 25 SKIP relation blog_dbt_dev.parsely_incoming_videoviews...... [SKIP]
2017-12-20 21:47:45,530: 21:47:45 | 12 of 25 SKIP relation blog_dbt_dev.parsely_event_ids................ [SKIP]
2017-12-20 21:47:45,530: 21:47:45 | 13 of 25 SKIP relation blog_dbt_dev.parsely_videoviews_sessionized... [SKIP]
2017-12-20 21:47:45,531: 21:47:45 | 14 of 25 SKIP relation blog_dbt_dev.parsely_pageview_hanging_engagedtime [SKIP]
2017-12-20 21:47:45,531: 21:47:45 | 15 of 25 SKIP relation blog_dbt_dev.parsely_videoview_hanging_engagedtime [SKIP]
2017-12-20 21:47:45,531: 21:47:45 | 16 of 25 SKIP relation blog_dbt_dev.parsely_incoming_pageviews....... [SKIP]
2017-12-20 21:47:45,532: 21:47:45 | 17 of 25 SKIP relation blog_dbt_dev.parsely_pageviews_sessionized.... [SKIP]
2017-12-20 21:47:45,532: 21:47:45 | 18 of 25 SKIP relation blog_dbt_dev.parsely_videoview_engagedtime.... [SKIP]
2017-12-20 21:47:45,533: 21:47:45 | 19 of 25 SKIP relation blog_dbt_dev.parsely_videoview_behavior_workflow [SKIP]
2017-12-20 21:47:45,533: 21:47:45 | 20 of 25 SKIP relation blog_dbt_dev.parsely_campaigns................ [SKIP]
2017-12-20 21:47:45,534: 21:47:45 | 21 of 25 SKIP relation blog_dbt_dev.parsely_users.................... [SKIP]
2017-12-20 21:47:45,534: 21:47:45 | 22 of 25 SKIP relation blog_dbt_dev.parsely_pageview_engagedtime..... [SKIP]
2017-12-20 21:47:45,534: 21:47:45 | 23 of 25 SKIP relation blog_dbt_dev.parsely_incoming_sessions........ [SKIP]
2017-12-20 21:47:45,535: 21:47:45 | 24 of 25 SKIP relation blog_dbt_dev.parsely_pageview_behavior_workflow [SKIP]
2017-12-20 21:47:45,535: 21:47:45 | 25 of 25 SKIP relation blog_dbt_dev.parsely_sessions................. [SKIP]
2017-12-20 21:47:45,602: Using redshift connection "master".
2017-12-20 21:47:45,602: On master: BEGIN
2017-12-20 21:47:45,604: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:47:45,604: On master: COMMIT
2017-12-20 21:47:45,604: Using redshift connection "master".
2017-12-20 21:47:45,604: On master: COMMIT
2017-12-20 21:47:45,606: SQL status: COMMIT in 0.00 seconds
2017-12-20 21:47:45,606: Compiling operation.parsely.parsely-on-run-end-0
2017-12-20 21:47:45,611: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-20 21:47:45,611: Using redshift connection "master".
2017-12-20 21:47:45,612: On master:  select 1 
2017-12-20 21:47:45,613: SQL status: SELECT in 0.00 seconds
2017-12-20 21:47:45,614: 21:47:45 | 
2017-12-20 21:47:45,614: 21:47:45 | Finished running 10 view models, 15 incremental models in 63.82s.
2017-12-20 21:47:45,614: 
2017-12-20 21:47:45,614: Completed with 1 errors:
2017-12-20 21:47:45,615: 
2017-12-20 21:47:45,615: Database Error in model parsely_all_events (models/base/parsely_all_events.sql)
2017-12-20 21:47:45,615:   column "america" does not exist in new_events
2017-12-20 21:47:45,615:   compiled SQL at target/run/parsely/base/parsely_all_events.sql
2017-12-20 21:47:45,615: 
Done. PASS=2 ERROR=1 SKIP=22 TOTAL=25
2017-12-20 21:47:45,616: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa812910250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa8129104d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa81f9c7910>], 'label': 'end'}
2017-12-20 21:47:45,645: Flushing usage events
2017-12-20 21:49:48,656: Tracking: tracking
2017-12-20 21:49:48,657: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe930f52250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe930f524d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe930f52310>], 'label': 'start'}
2017-12-20 21:49:48,743: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-20 21:49:48,759: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-20 21:49:48,760: Parsing core.sql
2017-12-20 21:49:48,771: Parsing etc/get_custom_schema.sql
2017-12-20 21:49:48,776: Parsing schema_tests/relationships.sql
2017-12-20 21:49:48,778: Parsing schema_tests/accepted_values.sql
2017-12-20 21:49:48,781: Parsing schema_tests/not_null.sql
2017-12-20 21:49:48,783: Parsing schema_tests/unique.sql
2017-12-20 21:49:48,784: Parsing materializations/wrapper.sql
2017-12-20 21:49:48,787: Parsing materializations/archive.sql
2017-12-20 21:49:48,815: Parsing materializations/table.sql
2017-12-20 21:49:48,832: Parsing materializations/helpers.sql
2017-12-20 21:49:48,846: Parsing materializations/bigquery.sql
2017-12-20 21:49:48,859: Parsing materializations/view.sql
2017-12-20 21:49:48,872: Parsing materializations/incremental.sql
2017-12-20 21:49:48,896: Parsing adapters/redshift.sql
2017-12-20 21:49:48,913: Parsing adapters/bigquery.sql
2017-12-20 21:49:48,917: Parsing adapters/postgres.sql
2017-12-20 21:49:48,920: Parsing adapters/common.sql
2017-12-20 21:49:48,938: Parsing model.parsely.parsely_audit
2017-12-20 21:49:48,939: Parsing model.parsely.parsely_video_content
2017-12-20 21:49:48,942: Parsing model.parsely.parsely_post_content
2017-12-20 21:49:48,945: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-20 21:49:48,948: Parsing model.parsely.parsely_rawdata
2017-12-20 21:49:48,952: Parsing model.parsely.calendar
2017-12-20 21:49:48,954: Parsing model.parsely.parsely_all_events
2017-12-20 21:49:48,968: Acquiring new redshift connection "parsely_all_events".
2017-12-20 21:49:48,969: Opening a new connection (0 currently allocated)
2017-12-20 21:49:49,022: Using redshift connection "parsely_all_events".
2017-12-20 21:49:49,022: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:49,049: SQL status: SELECT in 0.03 seconds
2017-12-20 21:49:49,056: Parsing model.parsely.parsely_event_ids
2017-12-20 21:49:49,058: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-20 21:49:49,060: Parsing model.parsely.parsely_base_events
2017-12-20 21:49:49,064: Acquiring new redshift connection "parsely_base_events".
2017-12-20 21:49:49,064: Re-using an available connection from the pool.
2017-12-20 21:49:49,064: Using redshift connection "parsely_base_events".
2017-12-20 21:49:49,064: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:49,085: SQL status: SELECT in 0.02 seconds
2017-12-20 21:49:49,086: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-20 21:49:49,092: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-20 21:49:49,096: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-20 21:49:49,098: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-20 21:49:49,100: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-20 21:49:49,103: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-20 21:49:49,108: Parsing model.parsely.parsely_incoming_pageviews
2017-12-20 21:49:49,115: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-20 21:49:49,120: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-20 21:49:49,120: Re-using an available connection from the pool.
2017-12-20 21:49:49,120: Using redshift connection "parsely_pageviews_sessionized".
2017-12-20 21:49:49,120: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:49,141: SQL status: SELECT in 0.02 seconds
2017-12-20 21:49:49,141: Parsing model.parsely.parsely_incoming_videoviews
2017-12-20 21:49:49,148: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-20 21:49:49,153: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-20 21:49:49,153: Re-using an available connection from the pool.
2017-12-20 21:49:49,153: Using redshift connection "parsely_videoviews_sessionized".
2017-12-20 21:49:49,153: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:49,173: SQL status: SELECT in 0.02 seconds
2017-12-20 21:49:49,173: Parsing model.parsely.parsely_incoming_users
2017-12-20 21:49:49,176: Parsing model.parsely.parsely_users
2017-12-20 21:49:49,181: Acquiring new redshift connection "parsely_users".
2017-12-20 21:49:49,181: Re-using an available connection from the pool.
2017-12-20 21:49:49,181: Using redshift connection "parsely_users".
2017-12-20 21:49:49,181: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:49,201: SQL status: SELECT in 0.02 seconds
2017-12-20 21:49:49,202: Parsing model.parsely.parsely_errors
2017-12-20 21:49:49,205: Parsing model.parsely.parsely_bot_traffic
2017-12-20 21:49:49,209: Parsing model.parsely.parsely_custom_events
2017-12-20 21:49:49,214: Parsing model.parsely.parsely_incoming_sessions
2017-12-20 21:49:49,218: Parsing model.parsely.parsely_entry_exit_urls
2017-12-20 21:49:49,220: Parsing model.parsely.parsely_sessions
2017-12-20 21:49:49,226: Acquiring new redshift connection "parsely_sessions".
2017-12-20 21:49:49,226: Re-using an available connection from the pool.
2017-12-20 21:49:49,226: Using redshift connection "parsely_sessions".
2017-12-20 21:49:49,226: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:49,247: SQL status: SELECT in 0.02 seconds
2017-12-20 21:49:49,247: Parsing model.parsely.parsely_campaigns
2017-12-20 21:49:49,251: Acquiring new redshift connection "parsely_campaigns".
2017-12-20 21:49:49,251: Re-using an available connection from the pool.
2017-12-20 21:49:49,251: Using redshift connection "parsely_campaigns".
2017-12-20 21:49:49,251: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:49,271: SQL status: SELECT in 0.02 seconds
2017-12-20 21:49:49,277: Parsing operation.parsely.parsely-on-run-end-0
2017-12-20 21:49:49,282: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-20 21:49:49,289: 
2017-12-20 21:49:49,292: Acquiring new redshift connection "master".
2017-12-20 21:49:49,292: Re-using an available connection from the pool.
2017-12-20 21:49:49,292: Using redshift connection "master".
2017-12-20 21:49:49,292: On master: select distinct nspname from pg_namespace
2017-12-20 21:49:49,294: SQL status: SELECT in 0.00 seconds
2017-12-20 21:49:49,297: Using redshift connection "master".
2017-12-20 21:49:49,297: On master: BEGIN
2017-12-20 21:49:49,298: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:49:49,299: On master: COMMIT
2017-12-20 21:49:49,299: Using redshift connection "master".
2017-12-20 21:49:49,299: On master: COMMIT
2017-12-20 21:49:49,300: SQL status: COMMIT in 0.00 seconds
2017-12-20 21:49:49,305: 21:49:49 | Concurrency: 1 threads (target='dev')
2017-12-20 21:49:49,306: 21:49:49 | 
2017-12-20 21:49:49,306: Using redshift connection "master".
2017-12-20 21:49:49,306: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:49,327: SQL status: SELECT in 0.02 seconds
2017-12-20 21:49:49,398: 21:49:49 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-20 21:49:49,399: Compiling model.parsely.calendar
2017-12-20 21:49:49,403: Writing injected SQL for node "model.parsely.calendar"
2017-12-20 21:49:49,404: Acquiring new redshift connection "calendar".
2017-12-20 21:49:49,404: Opening a new connection (1 currently allocated)
2017-12-20 21:49:49,416: Using redshift connection "calendar".
2017-12-20 21:49:49,416: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:49,441: SQL status: SELECT in 0.03 seconds
2017-12-20 21:49:49,443: Writing runtime SQL for node "model.parsely.calendar"
2017-12-20 21:49:49,444: Using redshift connection "calendar".
2017-12-20 21:49:49,444: On calendar: BEGIN
2017-12-20 21:49:49,446: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:49:49,446: Using redshift connection "calendar".
2017-12-20 21:49:49,446: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-20 21:49:50,286: SQL status: CREATE VIEW in 0.84 seconds
2017-12-20 21:49:50,286: On calendar: COMMIT
2017-12-20 21:49:50,286: Using redshift connection "calendar".
2017-12-20 21:49:50,286: On calendar: COMMIT
2017-12-20 21:49:50,817: SQL status: COMMIT in 0.53 seconds
2017-12-20 21:49:50,817: Using redshift connection "calendar".
2017-12-20 21:49:50,817: On calendar: BEGIN
2017-12-20 21:49:50,819: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:49:50,819: Using redshift connection "calendar".
2017-12-20 21:49:50,819: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-20 21:49:50,825: SQL status: DROP VIEW in 0.01 seconds
2017-12-20 21:49:50,825: On calendar: COMMIT
2017-12-20 21:49:50,825: Using redshift connection "calendar".
2017-12-20 21:49:50,825: On calendar: COMMIT
2017-12-20 21:49:51,144: SQL status: COMMIT in 0.32 seconds
2017-12-20 21:49:51,144: Using redshift connection "calendar".
2017-12-20 21:49:51,144: On calendar: BEGIN
2017-12-20 21:49:51,146: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:49:51,146: Using redshift connection "calendar".
2017-12-20 21:49:51,146: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-20 21:49:51,155: SQL status: ALTER TABLE in 0.01 seconds
2017-12-20 21:49:51,155: On calendar: COMMIT
2017-12-20 21:49:51,155: Using redshift connection "calendar".
2017-12-20 21:49:51,156: On calendar: COMMIT
2017-12-20 21:49:51,961: SQL status: COMMIT in 0.81 seconds
2017-12-20 21:49:51,961: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe930e45690>], 'label': 'c74f1af0-e2bc-4fb2-80ec-00477f8209da'}
2017-12-20 21:49:51,991: 21:49:51 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 2.56s]
2017-12-20 21:49:51,991: 21:49:51 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-20 21:49:51,991: Compiling model.parsely.parsely_rawdata
2017-12-20 21:49:51,997: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-20 21:49:51,998: Acquiring new redshift connection "parsely_rawdata".
2017-12-20 21:49:51,998: Re-using an available connection from the pool.
2017-12-20 21:49:51,998: Using redshift connection "parsely_rawdata".
2017-12-20 21:49:51,998: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:52,017: SQL status: SELECT in 0.02 seconds
2017-12-20 21:49:52,018: Using redshift connection "parsely_rawdata".
2017-12-20 21:49:52,018: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:49:52,028: SQL status: SELECT in 0.01 seconds
2017-12-20 21:49:52,028: Using redshift connection "parsely_rawdata".
2017-12-20 21:49:52,028: On parsely_rawdata: BEGIN
2017-12-20 21:49:52,030: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:49:52,030: Using redshift connection "parsely_rawdata".
2017-12-20 21:49:52,031: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-20 21:50:23,125: SQL status: SELECT in 31.09 seconds
2017-12-20 21:50:23,125: Using redshift connection "parsely_rawdata".
2017-12-20 21:50:23,125: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-20 21:50:23,348: SQL status: SELECT in 0.22 seconds
2017-12-20 21:50:23,349: Using redshift connection "parsely_rawdata".
2017-12-20 21:50:23,349: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-20 21:50:23,447: SQL status: SELECT in 0.10 seconds
2017-12-20 21:50:23,448: Using redshift connection "parsely_rawdata".
2017-12-20 21:50:23,448: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-20 21:50:23,544: SQL status: SELECT in 0.10 seconds
2017-12-20 21:50:23,547: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-20 21:50:23,548: Using redshift connection "parsely_rawdata".
2017-12-20 21:50:23,548: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-20 21:50:53,504: SQL status: INSERT 0 996095 in 29.96 seconds
2017-12-20 21:50:53,505: On parsely_rawdata: COMMIT
2017-12-20 21:50:53,505: Using redshift connection "parsely_rawdata".
2017-12-20 21:50:53,505: On parsely_rawdata: COMMIT
2017-12-20 21:50:56,041: SQL status: COMMIT in 2.54 seconds
2017-12-20 21:50:56,042: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe930e45110>], 'label': 'c74f1af0-e2bc-4fb2-80ec-00477f8209da'}
2017-12-20 21:50:56,115: 21:50:56 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 996095 in 64.05s]
2017-12-20 21:50:56,115: 21:50:56 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-20 21:50:56,115: Compiling model.parsely.parsely_all_events
2017-12-20 21:50:56,124: Acquiring new redshift connection "parsely_all_events".
2017-12-20 21:50:56,124: Re-using an available connection from the pool.
2017-12-20 21:50:56,124: Using redshift connection "parsely_all_events".
2017-12-20 21:50:56,124: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:50:56,138: SQL status: SELECT in 0.01 seconds
2017-12-20 21:50:56,147: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-20 21:50:56,148: Using redshift connection "parsely_all_events".
2017-12-20 21:50:56,148: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:50:56,161: SQL status: SELECT in 0.01 seconds
2017-12-20 21:50:56,162: Using redshift connection "parsely_all_events".
2017-12-20 21:50:56,162: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:50:56,175: SQL status: SELECT in 0.01 seconds
2017-12-20 21:50:56,178: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-20 21:50:56,178: Using redshift connection "parsely_all_events".
2017-12-20 21:50:56,178: On parsely_all_events: BEGIN
2017-12-20 21:50:56,180: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:50:56,180: Using redshift connection "parsely_all_events".
2017-12-20 21:50:56,180: On parsely_all_events: 
    
  

  create  table "blog_dbt_dev"."parsely_all_events"
  
  
  as (
    

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      meatadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(meatadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as meatadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
  );
2017-12-20 21:50:56,185: Postgres error: column "meatadata_pub_date_tmsp" does not exist in new_events

2017-12-20 21:50:56,185: On parsely_all_events: ROLLBACK
2017-12-20 21:50:56,187: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe930eba790>], 'label': 'c74f1af0-e2bc-4fb2-80ec-00477f8209da'}
2017-12-20 21:50:56,215: 21:50:56 | 3 of 25 ERROR creating incremental model blog_dbt_dev.parsely_all_events [ERROR in 0.07s]
2017-12-20 21:50:56,216: 21:50:56 | 4 of 25 SKIP relation blog_dbt_dev.parsely_base_events............... [SKIP]
2017-12-20 21:50:56,216: 21:50:56 | 5 of 25 SKIP relation blog_dbt_dev.parsely_bot_traffic............... [SKIP]
2017-12-20 21:50:56,216: 21:50:56 | 6 of 25 SKIP relation blog_dbt_dev.parsely_custom_events............. [SKIP]
2017-12-20 21:50:56,217: 21:50:56 | 7 of 25 SKIP relation blog_dbt_dev.parsely_errors.................... [SKIP]
2017-12-20 21:50:56,217: 21:50:56 | 8 of 25 SKIP relation blog_dbt_dev.parsely_post_content.............. [SKIP]
2017-12-20 21:50:56,218: 21:50:56 | 9 of 25 SKIP relation blog_dbt_dev.parsely_video_content............. [SKIP]
2017-12-20 21:50:56,218: 21:50:56 | 10 of 25 SKIP relation blog_dbt_dev.parsely_entry_exit_urls.......... [SKIP]
2017-12-20 21:50:56,218: 21:50:56 | 11 of 25 SKIP relation blog_dbt_dev.parsely_incoming_videoviews...... [SKIP]
2017-12-20 21:50:56,219: 21:50:56 | 12 of 25 SKIP relation blog_dbt_dev.parsely_event_ids................ [SKIP]
2017-12-20 21:50:56,219: 21:50:56 | 13 of 25 SKIP relation blog_dbt_dev.parsely_videoviews_sessionized... [SKIP]
2017-12-20 21:50:56,219: 21:50:56 | 14 of 25 SKIP relation blog_dbt_dev.parsely_pageview_hanging_engagedtime [SKIP]
2017-12-20 21:50:56,220: 21:50:56 | 15 of 25 SKIP relation blog_dbt_dev.parsely_videoview_hanging_engagedtime [SKIP]
2017-12-20 21:50:56,220: 21:50:56 | 16 of 25 SKIP relation blog_dbt_dev.parsely_incoming_pageviews....... [SKIP]
2017-12-20 21:50:56,221: 21:50:56 | 17 of 25 SKIP relation blog_dbt_dev.parsely_pageviews_sessionized.... [SKIP]
2017-12-20 21:50:56,221: 21:50:56 | 18 of 25 SKIP relation blog_dbt_dev.parsely_videoview_engagedtime.... [SKIP]
2017-12-20 21:50:56,222: 21:50:56 | 19 of 25 SKIP relation blog_dbt_dev.parsely_videoview_behavior_workflow [SKIP]
2017-12-20 21:50:56,222: 21:50:56 | 20 of 25 SKIP relation blog_dbt_dev.parsely_campaigns................ [SKIP]
2017-12-20 21:50:56,222: 21:50:56 | 21 of 25 SKIP relation blog_dbt_dev.parsely_users.................... [SKIP]
2017-12-20 21:50:56,223: 21:50:56 | 22 of 25 SKIP relation blog_dbt_dev.parsely_pageview_engagedtime..... [SKIP]
2017-12-20 21:50:56,223: 21:50:56 | 23 of 25 SKIP relation blog_dbt_dev.parsely_incoming_sessions........ [SKIP]
2017-12-20 21:50:56,224: 21:50:56 | 24 of 25 SKIP relation blog_dbt_dev.parsely_pageview_behavior_workflow [SKIP]
2017-12-20 21:50:56,224: 21:50:56 | 25 of 25 SKIP relation blog_dbt_dev.parsely_sessions................. [SKIP]
2017-12-20 21:50:56,323: Using redshift connection "master".
2017-12-20 21:50:56,324: On master: BEGIN
2017-12-20 21:50:56,326: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:50:56,326: On master: COMMIT
2017-12-20 21:50:56,326: Using redshift connection "master".
2017-12-20 21:50:56,326: On master: COMMIT
2017-12-20 21:50:56,327: SQL status: COMMIT in 0.00 seconds
2017-12-20 21:50:56,327: Compiling operation.parsely.parsely-on-run-end-0
2017-12-20 21:50:56,332: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-20 21:50:56,333: Using redshift connection "master".
2017-12-20 21:50:56,333: On master:  select 1 
2017-12-20 21:50:56,335: SQL status: SELECT in 0.00 seconds
2017-12-20 21:50:56,335: 21:50:56 | 
2017-12-20 21:50:56,335: 21:50:56 | Finished running 10 view models, 15 incremental models in 67.02s.
2017-12-20 21:50:56,336: 
2017-12-20 21:50:56,336: Completed with 1 errors:
2017-12-20 21:50:56,336: 
2017-12-20 21:50:56,336: Database Error in model parsely_all_events (models/base/parsely_all_events.sql)
2017-12-20 21:50:56,337:   column "meatadata_pub_date_tmsp" does not exist in new_events
2017-12-20 21:50:56,337:   compiled SQL at target/run/parsely/base/parsely_all_events.sql
2017-12-20 21:50:56,337: 
Done. PASS=2 ERROR=1 SKIP=22 TOTAL=25
2017-12-20 21:50:56,337: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe930f52250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe930f524d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe93e009910>], 'label': 'end'}
2017-12-20 21:50:56,367: Flushing usage events
2017-12-20 21:52:07,346: Tracking: tracking
2017-12-20 21:52:07,347: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df41c250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df41c4d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df41c310>], 'label': 'start'}
2017-12-20 21:52:07,399: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-20 21:52:07,415: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-20 21:52:07,417: Parsing core.sql
2017-12-20 21:52:07,428: Parsing etc/get_custom_schema.sql
2017-12-20 21:52:07,433: Parsing schema_tests/relationships.sql
2017-12-20 21:52:07,435: Parsing schema_tests/accepted_values.sql
2017-12-20 21:52:07,438: Parsing schema_tests/not_null.sql
2017-12-20 21:52:07,440: Parsing schema_tests/unique.sql
2017-12-20 21:52:07,441: Parsing materializations/wrapper.sql
2017-12-20 21:52:07,444: Parsing materializations/archive.sql
2017-12-20 21:52:07,472: Parsing materializations/table.sql
2017-12-20 21:52:07,489: Parsing materializations/helpers.sql
2017-12-20 21:52:07,504: Parsing materializations/bigquery.sql
2017-12-20 21:52:07,517: Parsing materializations/view.sql
2017-12-20 21:52:07,530: Parsing materializations/incremental.sql
2017-12-20 21:52:07,554: Parsing adapters/redshift.sql
2017-12-20 21:52:07,571: Parsing adapters/bigquery.sql
2017-12-20 21:52:07,575: Parsing adapters/postgres.sql
2017-12-20 21:52:07,578: Parsing adapters/common.sql
2017-12-20 21:52:07,596: Parsing model.parsely.parsely_audit
2017-12-20 21:52:07,597: Parsing model.parsely.parsely_video_content
2017-12-20 21:52:07,600: Parsing model.parsely.parsely_post_content
2017-12-20 21:52:07,603: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-20 21:52:07,606: Parsing model.parsely.parsely_rawdata
2017-12-20 21:52:07,608: Parsing model.parsely.calendar
2017-12-20 21:52:07,610: Parsing model.parsely.parsely_all_events
2017-12-20 21:52:07,618: Acquiring new redshift connection "parsely_all_events".
2017-12-20 21:52:07,618: Opening a new connection (0 currently allocated)
2017-12-20 21:52:07,669: Using redshift connection "parsely_all_events".
2017-12-20 21:52:07,669: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:07,695: SQL status: SELECT in 0.03 seconds
2017-12-20 21:52:07,700: Parsing model.parsely.parsely_event_ids
2017-12-20 21:52:07,702: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-20 21:52:07,705: Parsing model.parsely.parsely_base_events
2017-12-20 21:52:07,708: Acquiring new redshift connection "parsely_base_events".
2017-12-20 21:52:07,708: Re-using an available connection from the pool.
2017-12-20 21:52:07,708: Using redshift connection "parsely_base_events".
2017-12-20 21:52:07,708: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:07,729: SQL status: SELECT in 0.02 seconds
2017-12-20 21:52:07,730: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-20 21:52:07,736: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-20 21:52:07,740: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-20 21:52:07,742: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-20 21:52:07,744: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-20 21:52:07,747: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-20 21:52:07,752: Parsing model.parsely.parsely_incoming_pageviews
2017-12-20 21:52:07,759: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-20 21:52:07,764: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-20 21:52:07,764: Re-using an available connection from the pool.
2017-12-20 21:52:07,764: Using redshift connection "parsely_pageviews_sessionized".
2017-12-20 21:52:07,764: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:07,786: SQL status: SELECT in 0.02 seconds
2017-12-20 21:52:07,786: Parsing model.parsely.parsely_incoming_videoviews
2017-12-20 21:52:07,793: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-20 21:52:07,798: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-20 21:52:07,798: Re-using an available connection from the pool.
2017-12-20 21:52:07,798: Using redshift connection "parsely_videoviews_sessionized".
2017-12-20 21:52:07,798: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:07,820: SQL status: SELECT in 0.02 seconds
2017-12-20 21:52:07,820: Parsing model.parsely.parsely_incoming_users
2017-12-20 21:52:07,823: Parsing model.parsely.parsely_users
2017-12-20 21:52:07,828: Acquiring new redshift connection "parsely_users".
2017-12-20 21:52:07,828: Re-using an available connection from the pool.
2017-12-20 21:52:07,828: Using redshift connection "parsely_users".
2017-12-20 21:52:07,828: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:07,849: SQL status: SELECT in 0.02 seconds
2017-12-20 21:52:07,850: Parsing model.parsely.parsely_errors
2017-12-20 21:52:07,854: Parsing model.parsely.parsely_bot_traffic
2017-12-20 21:52:07,858: Parsing model.parsely.parsely_custom_events
2017-12-20 21:52:07,862: Parsing model.parsely.parsely_incoming_sessions
2017-12-20 21:52:07,866: Parsing model.parsely.parsely_entry_exit_urls
2017-12-20 21:52:07,869: Parsing model.parsely.parsely_sessions
2017-12-20 21:52:07,874: Acquiring new redshift connection "parsely_sessions".
2017-12-20 21:52:07,874: Re-using an available connection from the pool.
2017-12-20 21:52:07,874: Using redshift connection "parsely_sessions".
2017-12-20 21:52:07,874: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:07,896: SQL status: SELECT in 0.02 seconds
2017-12-20 21:52:07,896: Parsing model.parsely.parsely_campaigns
2017-12-20 21:52:07,900: Acquiring new redshift connection "parsely_campaigns".
2017-12-20 21:52:07,900: Re-using an available connection from the pool.
2017-12-20 21:52:07,900: Using redshift connection "parsely_campaigns".
2017-12-20 21:52:07,900: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:07,921: SQL status: SELECT in 0.02 seconds
2017-12-20 21:52:07,926: Parsing operation.parsely.parsely-on-run-end-0
2017-12-20 21:52:07,931: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-20 21:52:07,938: 
2017-12-20 21:52:07,941: Acquiring new redshift connection "master".
2017-12-20 21:52:07,941: Re-using an available connection from the pool.
2017-12-20 21:52:07,941: Using redshift connection "master".
2017-12-20 21:52:07,941: On master: select distinct nspname from pg_namespace
2017-12-20 21:52:07,944: SQL status: SELECT in 0.00 seconds
2017-12-20 21:52:07,946: Using redshift connection "master".
2017-12-20 21:52:07,946: On master: BEGIN
2017-12-20 21:52:07,948: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:52:07,948: On master: COMMIT
2017-12-20 21:52:07,948: Using redshift connection "master".
2017-12-20 21:52:07,948: On master: COMMIT
2017-12-20 21:52:07,950: SQL status: COMMIT in 0.00 seconds
2017-12-20 21:52:07,955: 21:52:07 | Concurrency: 1 threads (target='dev')
2017-12-20 21:52:07,955: 21:52:07 | 
2017-12-20 21:52:07,956: Using redshift connection "master".
2017-12-20 21:52:07,956: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:07,977: SQL status: SELECT in 0.02 seconds
2017-12-20 21:52:08,048: 21:52:08 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-20 21:52:08,049: Compiling model.parsely.calendar
2017-12-20 21:52:08,053: Writing injected SQL for node "model.parsely.calendar"
2017-12-20 21:52:08,054: Acquiring new redshift connection "calendar".
2017-12-20 21:52:08,055: Opening a new connection (1 currently allocated)
2017-12-20 21:52:08,067: Using redshift connection "calendar".
2017-12-20 21:52:08,067: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:08,093: SQL status: SELECT in 0.03 seconds
2017-12-20 21:52:08,095: Writing runtime SQL for node "model.parsely.calendar"
2017-12-20 21:52:08,096: Using redshift connection "calendar".
2017-12-20 21:52:08,096: On calendar: BEGIN
2017-12-20 21:52:08,098: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:52:08,098: Using redshift connection "calendar".
2017-12-20 21:52:08,098: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-20 21:52:08,192: SQL status: CREATE VIEW in 0.09 seconds
2017-12-20 21:52:08,193: On calendar: COMMIT
2017-12-20 21:52:08,193: Using redshift connection "calendar".
2017-12-20 21:52:08,193: On calendar: COMMIT
2017-12-20 21:52:08,382: SQL status: COMMIT in 0.19 seconds
2017-12-20 21:52:08,382: Using redshift connection "calendar".
2017-12-20 21:52:08,382: On calendar: BEGIN
2017-12-20 21:52:08,384: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:52:08,384: Using redshift connection "calendar".
2017-12-20 21:52:08,384: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-20 21:52:08,557: SQL status: DROP VIEW in 0.17 seconds
2017-12-20 21:52:08,557: On calendar: COMMIT
2017-12-20 21:52:08,558: Using redshift connection "calendar".
2017-12-20 21:52:08,558: On calendar: COMMIT
2017-12-20 21:52:09,149: SQL status: COMMIT in 0.59 seconds
2017-12-20 21:52:09,149: Using redshift connection "calendar".
2017-12-20 21:52:09,149: On calendar: BEGIN
2017-12-20 21:52:09,151: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:52:09,152: Using redshift connection "calendar".
2017-12-20 21:52:09,152: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-20 21:52:09,365: SQL status: ALTER TABLE in 0.21 seconds
2017-12-20 21:52:09,365: On calendar: COMMIT
2017-12-20 21:52:09,365: Using redshift connection "calendar".
2017-12-20 21:52:09,365: On calendar: COMMIT
2017-12-20 21:52:09,964: SQL status: COMMIT in 0.60 seconds
2017-12-20 21:52:09,965: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df30f690>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:52:09,998: 21:52:09 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.92s]
2017-12-20 21:52:09,998: 21:52:09 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-20 21:52:09,999: Compiling model.parsely.parsely_rawdata
2017-12-20 21:52:10,004: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-20 21:52:10,006: Acquiring new redshift connection "parsely_rawdata".
2017-12-20 21:52:10,006: Re-using an available connection from the pool.
2017-12-20 21:52:10,006: Using redshift connection "parsely_rawdata".
2017-12-20 21:52:10,006: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:10,025: SQL status: SELECT in 0.02 seconds
2017-12-20 21:52:10,026: Using redshift connection "parsely_rawdata".
2017-12-20 21:52:10,026: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:52:10,035: SQL status: SELECT in 0.01 seconds
2017-12-20 21:52:10,036: Using redshift connection "parsely_rawdata".
2017-12-20 21:52:10,036: On parsely_rawdata: BEGIN
2017-12-20 21:52:10,038: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:52:10,038: Using redshift connection "parsely_rawdata".
2017-12-20 21:52:10,038: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-20 21:52:36,668: SQL status: SELECT in 26.63 seconds
2017-12-20 21:52:36,669: Using redshift connection "parsely_rawdata".
2017-12-20 21:52:36,669: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-20 21:52:36,866: SQL status: SELECT in 0.20 seconds
2017-12-20 21:52:36,866: Using redshift connection "parsely_rawdata".
2017-12-20 21:52:36,867: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-20 21:52:36,963: SQL status: SELECT in 0.10 seconds
2017-12-20 21:52:36,964: Using redshift connection "parsely_rawdata".
2017-12-20 21:52:36,964: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-20 21:52:37,061: SQL status: SELECT in 0.10 seconds
2017-12-20 21:52:37,065: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-20 21:52:37,065: Using redshift connection "parsely_rawdata".
2017-12-20 21:52:37,065: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-20 21:53:07,982: SQL status: INSERT 0 996095 in 30.92 seconds
2017-12-20 21:53:07,982: On parsely_rawdata: COMMIT
2017-12-20 21:53:07,983: Using redshift connection "parsely_rawdata".
2017-12-20 21:53:07,983: On parsely_rawdata: COMMIT
2017-12-20 21:53:09,625: SQL status: COMMIT in 1.64 seconds
2017-12-20 21:53:09,626: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df30f1d0>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:53:09,673: 21:53:09 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 996095 in 59.63s]
2017-12-20 21:53:09,673: 21:53:09 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-20 21:53:09,673: Compiling model.parsely.parsely_all_events
2017-12-20 21:53:09,682: Acquiring new redshift connection "parsely_all_events".
2017-12-20 21:53:09,682: Re-using an available connection from the pool.
2017-12-20 21:53:09,682: Using redshift connection "parsely_all_events".
2017-12-20 21:53:09,682: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:53:09,697: SQL status: SELECT in 0.01 seconds
2017-12-20 21:53:09,705: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-20 21:53:09,706: Using redshift connection "parsely_all_events".
2017-12-20 21:53:09,706: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:53:09,720: SQL status: SELECT in 0.01 seconds
2017-12-20 21:53:09,721: Using redshift connection "parsely_all_events".
2017-12-20 21:53:09,721: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:53:09,735: SQL status: SELECT in 0.01 seconds
2017-12-20 21:53:09,737: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-20 21:53:09,738: Using redshift connection "parsely_all_events".
2017-12-20 21:53:09,738: On parsely_all_events: BEGIN
2017-12-20 21:53:09,740: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:53:09,740: Using redshift connection "parsely_all_events".
2017-12-20 21:53:09,740: On parsely_all_events: 
    
  

  create  table "blog_dbt_dev"."parsely_all_events"
  
  
  as (
    

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
  );
2017-12-20 21:55:35,940: SQL status: SELECT in 146.20 seconds
2017-12-20 21:55:35,940: On parsely_all_events: COMMIT
2017-12-20 21:55:35,940: Using redshift connection "parsely_all_events".
2017-12-20 21:55:35,940: On parsely_all_events: COMMIT
2017-12-20 21:55:41,368: SQL status: COMMIT in 5.43 seconds
2017-12-20 21:55:41,369: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df384f90>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:55:41,498: 21:55:41 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [SELECT in 151.70s]
2017-12-20 21:55:41,498: 21:55:41 | 4 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-20 21:55:41,498: Compiling model.parsely.parsely_base_events
2017-12-20 21:55:41,502: Acquiring new redshift connection "parsely_base_events".
2017-12-20 21:55:41,502: Re-using an available connection from the pool.
2017-12-20 21:55:41,502: Using redshift connection "parsely_base_events".
2017-12-20 21:55:41,502: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:41,521: SQL status: SELECT in 0.02 seconds
2017-12-20 21:55:41,525: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-20 21:55:41,526: Using redshift connection "parsely_base_events".
2017-12-20 21:55:41,526: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:41,539: SQL status: SELECT in 0.01 seconds
2017-12-20 21:55:41,541: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-20 21:55:41,542: Using redshift connection "parsely_base_events".
2017-12-20 21:55:41,542: On parsely_base_events: BEGIN
2017-12-20 21:55:41,544: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:55:41,544: Using redshift connection "parsely_base_events".
2017-12-20 21:55:41,544: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
     --running for the first time
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-20 21:55:41,607: SQL status: CREATE VIEW in 0.06 seconds
2017-12-20 21:55:41,607: Using redshift connection "parsely_base_events".
2017-12-20 21:55:41,607: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-20 21:55:41,611: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 21:55:41,611: On parsely_base_events: COMMIT
2017-12-20 21:55:41,611: Using redshift connection "parsely_base_events".
2017-12-20 21:55:41,611: On parsely_base_events: COMMIT
2017-12-20 21:55:41,932: SQL status: COMMIT in 0.32 seconds
2017-12-20 21:55:41,932: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df30ff50>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:55:41,958: 21:55:41 | 4 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 0.43s]
2017-12-20 21:55:41,959: 21:55:41 | 5 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-20 21:55:41,959: Compiling model.parsely.parsely_bot_traffic
2017-12-20 21:55:41,966: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-20 21:55:41,967: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-20 21:55:41,967: Re-using an available connection from the pool.
2017-12-20 21:55:41,967: Using redshift connection "parsely_bot_traffic".
2017-12-20 21:55:41,967: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:41,982: SQL status: SELECT in 0.01 seconds
2017-12-20 21:55:41,983: Using redshift connection "parsely_bot_traffic".
2017-12-20 21:55:41,983: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:41,996: SQL status: SELECT in 0.01 seconds
2017-12-20 21:55:41,998: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-20 21:55:41,998: Using redshift connection "parsely_bot_traffic".
2017-12-20 21:55:41,998: On parsely_bot_traffic: BEGIN
2017-12-20 21:55:42,000: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:55:42,000: Using redshift connection "parsely_bot_traffic".
2017-12-20 21:55:42,001: On parsely_bot_traffic: 
    
  

  create  table "blog_dbt_dev"."parsely_bot_traffic"
  
  
  as (
    --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    meatadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
  );
2017-12-20 21:55:42,004: Postgres error: column "meatadata_pub_date_tmsp_tz" does not exist in bot_traffic

2017-12-20 21:55:42,004: On parsely_bot_traffic: ROLLBACK
2017-12-20 21:55:42,006: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df3d1f50>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:55:42,033: 21:55:42 | 5 of 25 ERROR creating incremental model blog_dbt_dev.parsely_bot_traffic [ERROR in 0.05s]
2017-12-20 21:55:42,034: 21:55:42 | 6 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-20 21:55:42,034: Compiling model.parsely.parsely_custom_events
2017-12-20 21:55:42,042: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-20 21:55:42,044: Acquiring new redshift connection "parsely_custom_events".
2017-12-20 21:55:42,044: Re-using an available connection from the pool.
2017-12-20 21:55:42,044: Using redshift connection "parsely_custom_events".
2017-12-20 21:55:42,044: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:42,058: SQL status: SELECT in 0.01 seconds
2017-12-20 21:55:42,058: Using redshift connection "parsely_custom_events".
2017-12-20 21:55:42,058: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:42,071: SQL status: SELECT in 0.01 seconds
2017-12-20 21:55:42,073: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-20 21:55:42,074: Using redshift connection "parsely_custom_events".
2017-12-20 21:55:42,074: On parsely_custom_events: BEGIN
2017-12-20 21:55:42,076: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:55:42,076: Using redshift connection "parsely_custom_events".
2017-12-20 21:55:42,076: On parsely_custom_events: 
    
  

  create  table "blog_dbt_dev"."parsely_custom_events"
  
  
  as (
    -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    meatadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
  );
2017-12-20 21:55:42,081: Postgres error: column "meatadata_pub_date_tmsp_tz" does not exist in custom_events, custom_publish_read_time_xf, unnamed_join

2017-12-20 21:55:42,081: On parsely_custom_events: ROLLBACK
2017-12-20 21:55:42,082: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df384d50>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:55:42,111: 21:55:42 | 6 of 25 ERROR creating incremental model blog_dbt_dev.parsely_custom_events [ERROR in 0.05s]
2017-12-20 21:55:42,112: 21:55:42 | 7 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-20 21:55:42,112: Compiling model.parsely.parsely_errors
2017-12-20 21:55:42,119: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-20 21:55:42,120: Acquiring new redshift connection "parsely_errors".
2017-12-20 21:55:42,120: Re-using an available connection from the pool.
2017-12-20 21:55:42,120: Using redshift connection "parsely_errors".
2017-12-20 21:55:42,120: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:42,134: SQL status: SELECT in 0.01 seconds
2017-12-20 21:55:42,135: Using redshift connection "parsely_errors".
2017-12-20 21:55:42,135: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:42,147: SQL status: SELECT in 0.01 seconds
2017-12-20 21:55:42,149: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-20 21:55:42,150: Using redshift connection "parsely_errors".
2017-12-20 21:55:42,150: On parsely_errors: BEGIN
2017-12-20 21:55:42,151: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:55:42,152: Using redshift connection "parsely_errors".
2017-12-20 21:55:42,152: On parsely_errors: 
    
  

  create  table "blog_dbt_dev"."parsely_errors"
  
  
  as (
    -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    meatadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
  );
2017-12-20 21:55:42,155: Postgres error: column "meatadata_pub_date_tmsp_tz" does not exist in error_events

2017-12-20 21:55:42,155: On parsely_errors: ROLLBACK
2017-12-20 21:55:42,157: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df2fe550>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:55:42,186: 21:55:42 | 7 of 25 ERROR creating incremental model blog_dbt_dev.parsely_errors. [ERROR in 0.04s]
2017-12-20 21:55:42,187: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-20 21:55:42,192: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-20 21:55:42,193: 21:55:42 | 8 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-20 21:55:42,193: Compiling model.parsely.parsely_post_content
2017-12-20 21:55:42,199: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-20 21:55:42,200: Acquiring new redshift connection "parsely_post_content".
2017-12-20 21:55:42,200: Re-using an available connection from the pool.
2017-12-20 21:55:42,200: Using redshift connection "parsely_post_content".
2017-12-20 21:55:42,200: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:42,214: SQL status: SELECT in 0.01 seconds
2017-12-20 21:55:42,215: Using redshift connection "parsely_post_content".
2017-12-20 21:55:42,215: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:42,228: SQL status: SELECT in 0.01 seconds
2017-12-20 21:55:42,230: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-20 21:55:42,230: Using redshift connection "parsely_post_content".
2017-12-20 21:55:42,230: On parsely_post_content: BEGIN
2017-12-20 21:55:42,232: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:55:42,232: Using redshift connection "parsely_post_content".
2017-12-20 21:55:42,232: On parsely_post_content: 
    
  

  create  table "blog_dbt_dev"."parsely_post_content"
  
  
  as (
    -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
  );
2017-12-20 21:55:59,061: SQL status: SELECT in 16.83 seconds
2017-12-20 21:55:59,062: On parsely_post_content: COMMIT
2017-12-20 21:55:59,062: Using redshift connection "parsely_post_content".
2017-12-20 21:55:59,062: On parsely_post_content: COMMIT
2017-12-20 21:55:59,835: SQL status: COMMIT in 0.77 seconds
2017-12-20 21:55:59,836: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df30fe50>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:55:59,863: 21:55:59 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [SELECT in 17.64s]
2017-12-20 21:55:59,863: 21:55:59 | 9 of 25 START incremental model blog_dbt_dev.parsely_video_content... [RUN]
2017-12-20 21:55:59,864: Compiling model.parsely.parsely_video_content
2017-12-20 21:55:59,869: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-20 21:55:59,871: Acquiring new redshift connection "parsely_video_content".
2017-12-20 21:55:59,871: Re-using an available connection from the pool.
2017-12-20 21:55:59,871: Using redshift connection "parsely_video_content".
2017-12-20 21:55:59,871: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:59,887: SQL status: SELECT in 0.02 seconds
2017-12-20 21:55:59,887: Using redshift connection "parsely_video_content".
2017-12-20 21:55:59,888: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:55:59,901: SQL status: SELECT in 0.01 seconds
2017-12-20 21:55:59,903: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-20 21:55:59,903: Using redshift connection "parsely_video_content".
2017-12-20 21:55:59,903: On parsely_video_content: BEGIN
2017-12-20 21:55:59,905: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:55:59,905: Using redshift connection "parsely_video_content".
2017-12-20 21:55:59,906: On parsely_video_content: 
    
  

  create  table "blog_dbt_dev"."parsely_video_content"
  
  
  as (
    -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
  );
2017-12-20 21:56:12,197: SQL status: SELECT in 12.29 seconds
2017-12-20 21:56:12,198: On parsely_video_content: COMMIT
2017-12-20 21:56:12,198: Using redshift connection "parsely_video_content".
2017-12-20 21:56:12,198: On parsely_video_content: COMMIT
2017-12-20 21:56:13,287: SQL status: COMMIT in 1.09 seconds
2017-12-20 21:56:13,287: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df2fe990>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:56:13,315: 21:56:13 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [SELECT in 13.42s]
2017-12-20 21:56:13,315: 21:56:13 | 10 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-20 21:56:13,316: Compiling model.parsely.parsely_entry_exit_urls
2017-12-20 21:56:13,321: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-20 21:56:13,322: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-20 21:56:13,322: Re-using an available connection from the pool.
2017-12-20 21:56:13,323: Using redshift connection "parsely_entry_exit_urls".
2017-12-20 21:56:13,323: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:56:13,340: SQL status: SELECT in 0.02 seconds
2017-12-20 21:56:13,341: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-20 21:56:13,342: Using redshift connection "parsely_entry_exit_urls".
2017-12-20 21:56:13,342: On parsely_entry_exit_urls: BEGIN
2017-12-20 21:56:13,344: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:56:13,344: Using redshift connection "parsely_entry_exit_urls".
2017-12-20 21:56:13,344: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action_tz
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action_tz

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-20 21:56:13,347: Postgres error: column st.first_ts_action_tz does not exist

2017-12-20 21:56:13,347: On parsely_entry_exit_urls: ROLLBACK
2017-12-20 21:56:13,349: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df30f110>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:56:13,378: 21:56:13 | 10 of 25 ERROR creating view model blog_dbt_dev.parsely_entry_exit_urls [ERROR in 0.03s]
2017-12-20 21:56:13,378: 21:56:13 | 11 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-20 21:56:13,379: Compiling model.parsely.parsely_incoming_videoviews
2017-12-20 21:56:13,388: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-20 21:56:13,389: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-20 21:56:13,389: Re-using an available connection from the pool.
2017-12-20 21:56:13,390: Using redshift connection "parsely_incoming_videoviews".
2017-12-20 21:56:13,390: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:56:13,405: SQL status: SELECT in 0.02 seconds
2017-12-20 21:56:13,409: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-20 21:56:13,410: Using redshift connection "parsely_incoming_videoviews".
2017-12-20 21:56:13,410: On parsely_incoming_videoviews: BEGIN
2017-12-20 21:56:13,412: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:56:13,412: Using redshift connection "parsely_incoming_videoviews".
2017-12-20 21:56:13,412: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as watch_time

    from video_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    meatadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    meatadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-20 21:56:13,419: Postgres error: relation "video_events" does not exist

2017-12-20 21:56:13,419: On parsely_incoming_videoviews: ROLLBACK
2017-12-20 21:56:13,420: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df36d510>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:56:13,449: 21:56:13 | 11 of 25 ERROR creating view model blog_dbt_dev.parsely_incoming_videoviews [ERROR in 0.04s]
2017-12-20 21:56:13,449: 21:56:13 | 12 of 25 START incremental model blog_dbt_dev.parsely_event_ids...... [RUN]
2017-12-20 21:56:13,449: Compiling model.parsely.parsely_event_ids
2017-12-20 21:56:13,454: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-20 21:56:13,455: Acquiring new redshift connection "parsely_event_ids".
2017-12-20 21:56:13,455: Re-using an available connection from the pool.
2017-12-20 21:56:13,455: Using redshift connection "parsely_event_ids".
2017-12-20 21:56:13,455: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:56:13,470: SQL status: SELECT in 0.02 seconds
2017-12-20 21:56:13,471: Using redshift connection "parsely_event_ids".
2017-12-20 21:56:13,471: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:56:13,484: SQL status: SELECT in 0.01 seconds
2017-12-20 21:56:13,485: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-20 21:56:13,486: Using redshift connection "parsely_event_ids".
2017-12-20 21:56:13,486: On parsely_event_ids: BEGIN
2017-12-20 21:56:13,488: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:56:13,488: Using redshift connection "parsely_event_ids".
2017-12-20 21:56:13,488: On parsely_event_ids: 
    
  

  create  table "blog_dbt_dev"."parsely_event_ids"
  
  
  as (
    

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
  );
2017-12-20 21:56:19,588: SQL status: SELECT in 6.10 seconds
2017-12-20 21:56:19,589: On parsely_event_ids: COMMIT
2017-12-20 21:56:19,590: Using redshift connection "parsely_event_ids".
2017-12-20 21:56:19,590: On parsely_event_ids: COMMIT
2017-12-20 21:56:19,969: SQL status: COMMIT in 0.38 seconds
2017-12-20 21:56:19,970: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df384ad0>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:56:19,998: 21:56:19 | 12 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids. [SELECT in 6.52s]
2017-12-20 21:56:19,998: 21:56:19 | 13 of 25 SKIP relation blog_dbt_dev.parsely_videoviews_sessionized... [SKIP]
2017-12-20 21:56:19,999: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-20 21:56:20,021: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-20 21:56:20,022: 21:56:20 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-20 21:56:20,022: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-20 21:56:20,034: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-20 21:56:20,035: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 21:56:20,035: Re-using an available connection from the pool.
2017-12-20 21:56:20,035: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 21:56:20,035: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:56:20,052: SQL status: SELECT in 0.02 seconds
2017-12-20 21:56:20,054: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-20 21:56:20,055: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 21:56:20,055: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-20 21:56:20,057: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:56:20,057: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 21:56:20,057: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-20 21:56:20,141: SQL status: CREATE VIEW in 0.08 seconds
2017-12-20 21:56:20,141: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 21:56:20,141: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-20 21:56:20,145: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 21:56:20,146: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-20 21:56:20,146: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 21:56:20,146: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-20 21:56:20,401: SQL status: COMMIT in 0.25 seconds
2017-12-20 21:56:20,401: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df376610>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:56:20,432: 21:56:20 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.38s]
2017-12-20 21:56:20,433: 21:56:20 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-20 21:56:20,433: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-20 21:56:20,460: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-20 21:56:20,462: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 21:56:20,462: Re-using an available connection from the pool.
2017-12-20 21:56:20,462: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 21:56:20,462: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:56:20,475: SQL status: SELECT in 0.01 seconds
2017-12-20 21:56:20,478: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-20 21:56:20,479: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 21:56:20,479: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-20 21:56:20,481: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:56:20,481: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 21:56:20,481: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-20 21:56:20,636: SQL status: CREATE VIEW in 0.15 seconds
2017-12-20 21:56:20,636: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 21:56:20,636: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-20 21:56:20,641: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 21:56:20,641: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-20 21:56:20,642: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 21:56:20,642: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-20 21:56:20,879: SQL status: COMMIT in 0.24 seconds
2017-12-20 21:56:20,879: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df3d1390>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:56:20,908: 21:56:20 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.45s]
2017-12-20 21:56:20,908: 21:56:20 | 16 of 25 SKIP relation blog_dbt_dev.parsely_incoming_pageviews....... [SKIP]
2017-12-20 21:56:20,909: 21:56:20 | 17 of 25 SKIP relation blog_dbt_dev.parsely_pageviews_sessionized.... [SKIP]
2017-12-20 21:56:20,909: 21:56:20 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-20 21:56:20,909: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-20 21:56:20,952: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-20 21:56:20,953: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-20 21:56:20,953: Re-using an available connection from the pool.
2017-12-20 21:56:20,953: Using redshift connection "parsely_videoview_engagedtime".
2017-12-20 21:56:20,953: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:56:20,968: SQL status: SELECT in 0.01 seconds
2017-12-20 21:56:20,970: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-20 21:56:20,971: Using redshift connection "parsely_videoview_engagedtime".
2017-12-20 21:56:20,971: On parsely_videoview_engagedtime: BEGIN
2017-12-20 21:56:20,973: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:56:20,973: Using redshift connection "parsely_videoview_engagedtime".
2017-12-20 21:56:20,973: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-20 21:56:22,501: SQL status: CREATE VIEW in 1.53 seconds
2017-12-20 21:56:22,502: Using redshift connection "parsely_videoview_engagedtime".
2017-12-20 21:56:22,502: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-20 21:56:22,506: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 21:56:22,506: On parsely_videoview_engagedtime: COMMIT
2017-12-20 21:56:22,506: Using redshift connection "parsely_videoview_engagedtime".
2017-12-20 21:56:22,506: On parsely_videoview_engagedtime: COMMIT
2017-12-20 21:56:22,728: SQL status: COMMIT in 0.22 seconds
2017-12-20 21:56:22,729: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df415690>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:56:22,762: 21:56:22 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.82s]
2017-12-20 21:56:22,762: 21:56:22 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-20 21:56:22,763: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-20 21:56:22,771: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-20 21:56:22,772: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-20 21:56:22,772: Re-using an available connection from the pool.
2017-12-20 21:56:22,773: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-20 21:56:22,773: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:56:22,787: SQL status: SELECT in 0.01 seconds
2017-12-20 21:56:22,787: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-20 21:56:22,787: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:56:22,801: SQL status: SELECT in 0.01 seconds
2017-12-20 21:56:22,804: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-20 21:56:22,804: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-20 21:56:22,804: On parsely_videoview_behavior_workflow: BEGIN
2017-12-20 21:56:22,806: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:56:22,806: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-20 21:56:22,806: On parsely_videoview_behavior_workflow: 
    
  

  create  table "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  
  
  as (
    -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as watch_time

    from video_events

)

select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
  );
2017-12-20 21:57:44,632: Postgres error: Invalid digit, Value '-', Pos 4, Type: Long 
DETAIL:  
  -----------------------------------------------
  error:  Invalid digit, Value '-', Pos 4, Type: Long 
  code:      1207
  context:   2017-08-29
  query:     96145
  location:  :0
  process:   query0_90 [pid=0]
  -----------------------------------------------


2017-12-20 21:57:44,632: On parsely_videoview_behavior_workflow: ROLLBACK
2017-12-20 21:57:44,637: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df3d1bd0>], 'label': '4cf9052d-34f5-40d4-8b1f-0af3269e79b2'}
2017-12-20 21:57:44,703: 21:57:44 | 19 of 25 ERROR creating incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [ERROR in 81.87s]
2017-12-20 21:57:44,703: 21:57:44 | 20 of 25 SKIP relation blog_dbt_dev.parsely_campaigns................ [SKIP]
2017-12-20 21:57:44,704: 21:57:44 | 21 of 25 SKIP relation blog_dbt_dev.parsely_users.................... [SKIP]
2017-12-20 21:57:44,704: 21:57:44 | 22 of 25 SKIP relation blog_dbt_dev.parsely_pageview_engagedtime..... [SKIP]
2017-12-20 21:57:44,705: 21:57:44 | 23 of 25 SKIP relation blog_dbt_dev.parsely_incoming_sessions........ [SKIP]
2017-12-20 21:57:44,705: 21:57:44 | 24 of 25 SKIP relation blog_dbt_dev.parsely_pageview_behavior_workflow [SKIP]
2017-12-20 21:57:44,705: 21:57:44 | 25 of 25 SKIP relation blog_dbt_dev.parsely_sessions................. [SKIP]
2017-12-20 21:57:44,776: Using redshift connection "master".
2017-12-20 21:57:44,776: On master: BEGIN
2017-12-20 21:57:44,779: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:57:44,779: On master: COMMIT
2017-12-20 21:57:44,779: Using redshift connection "master".
2017-12-20 21:57:44,779: On master: COMMIT
2017-12-20 21:57:44,780: SQL status: COMMIT in 0.00 seconds
2017-12-20 21:57:44,781: Compiling operation.parsely.parsely-on-run-end-0
2017-12-20 21:57:44,785: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-20 21:57:44,786: Using redshift connection "master".
2017-12-20 21:57:44,786: On master:  select 1 
2017-12-20 21:57:44,788: SQL status: SELECT in 0.00 seconds
2017-12-20 21:57:44,788: 21:57:44 | 
2017-12-20 21:57:44,788: 21:57:44 | Finished running 10 view models, 15 incremental models in 336.82s.
2017-12-20 21:57:44,789: 
2017-12-20 21:57:44,789: Completed with 6 errors:
2017-12-20 21:57:44,789: 
2017-12-20 21:57:44,789: Database Error in model parsely_bot_traffic (models/excluded_events/parsely_bot_traffic.sql)
2017-12-20 21:57:44,790:   column "meatadata_pub_date_tmsp_tz" does not exist in bot_traffic
2017-12-20 21:57:44,790:   compiled SQL at target/run/parsely/excluded_events/parsely_bot_traffic.sql
2017-12-20 21:57:44,790: 
2017-12-20 21:57:44,790: Database Error in model parsely_custom_events (models/custom/parsely_custom_events.sql)
2017-12-20 21:57:44,790:   column "meatadata_pub_date_tmsp_tz" does not exist in custom_events, custom_publish_read_time_xf, unnamed_join
2017-12-20 21:57:44,790:   compiled SQL at target/run/parsely/custom/parsely_custom_events.sql
2017-12-20 21:57:44,791: 
2017-12-20 21:57:44,791: Database Error in model parsely_errors (models/excluded_events/parsely_errors.sql)
2017-12-20 21:57:44,791:   column "meatadata_pub_date_tmsp_tz" does not exist in error_events
2017-12-20 21:57:44,791:   compiled SQL at target/run/parsely/excluded_events/parsely_errors.sql
2017-12-20 21:57:44,791: 
2017-12-20 21:57:44,791: Database Error in model parsely_entry_exit_urls (models/sessions/parsely_entry_exit_urls.sql)
2017-12-20 21:57:44,792:   column st.first_ts_action_tz does not exist
2017-12-20 21:57:44,792:   compiled SQL at target/run/parsely/sessions/parsely_entry_exit_urls.sql
2017-12-20 21:57:44,792: 
2017-12-20 21:57:44,792: Database Error in model parsely_incoming_videoviews (models/videoviews/parsely_incoming_videoviews.sql)
2017-12-20 21:57:44,792:   relation "video_events" does not exist
2017-12-20 21:57:44,792:   compiled SQL at target/run/parsely/videoviews/parsely_incoming_videoviews.sql
2017-12-20 21:57:44,792: 
2017-12-20 21:57:44,793: Database Error in model parsely_videoview_behavior_workflow (models/behavior_workflow/parsely_videoview_behavior_workflow.sql)
2017-12-20 21:57:44,793:   Invalid digit, Value '-', Pos 4, Type: Long 
2017-12-20 21:57:44,793:   DETAIL:  
2017-12-20 21:57:44,793:     -----------------------------------------------
2017-12-20 21:57:44,793:     error:  Invalid digit, Value '-', Pos 4, Type: Long 
2017-12-20 21:57:44,793:     code:      1207
2017-12-20 21:57:44,793:     context:   2017-08-29
2017-12-20 21:57:44,794:     query:     96145
2017-12-20 21:57:44,794:     location:  :0
2017-12-20 21:57:44,794:     process:   query0_90 [pid=0]
2017-12-20 21:57:44,794:     -----------------------------------------------
2017-12-20 21:57:44,794:   compiled SQL at target/run/parsely/behavior_workflow/parsely_videoview_behavior_workflow.sql
2017-12-20 21:57:44,794: 
Done. PASS=10 ERROR=6 SKIP=9 TOTAL=25
2017-12-20 21:57:44,795: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df41c250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8df41c4d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fe8ec4d3910>], 'label': 'end'}
2017-12-20 21:57:44,827: Flushing usage events
2017-12-20 21:59:26,291: Tracking: tracking
2017-12-20 21:59:26,291: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb28602a250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb28602a4d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb28602a310>], 'label': 'start'}
2017-12-20 21:59:26,395: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-20 21:59:26,411: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-20 21:59:26,413: Parsing core.sql
2017-12-20 21:59:26,424: Parsing etc/get_custom_schema.sql
2017-12-20 21:59:26,429: Parsing schema_tests/relationships.sql
2017-12-20 21:59:26,431: Parsing schema_tests/accepted_values.sql
2017-12-20 21:59:26,434: Parsing schema_tests/not_null.sql
2017-12-20 21:59:26,436: Parsing schema_tests/unique.sql
2017-12-20 21:59:26,438: Parsing materializations/wrapper.sql
2017-12-20 21:59:26,440: Parsing materializations/archive.sql
2017-12-20 21:59:26,468: Parsing materializations/table.sql
2017-12-20 21:59:26,485: Parsing materializations/helpers.sql
2017-12-20 21:59:26,500: Parsing materializations/bigquery.sql
2017-12-20 21:59:26,513: Parsing materializations/view.sql
2017-12-20 21:59:26,526: Parsing materializations/incremental.sql
2017-12-20 21:59:26,550: Parsing adapters/redshift.sql
2017-12-20 21:59:26,567: Parsing adapters/bigquery.sql
2017-12-20 21:59:26,572: Parsing adapters/postgres.sql
2017-12-20 21:59:26,574: Parsing adapters/common.sql
2017-12-20 21:59:26,593: Parsing model.parsely.parsely_audit
2017-12-20 21:59:26,594: Parsing model.parsely.parsely_video_content
2017-12-20 21:59:26,597: Parsing model.parsely.parsely_post_content
2017-12-20 21:59:26,600: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-20 21:59:26,603: Parsing model.parsely.parsely_rawdata
2017-12-20 21:59:26,605: Parsing model.parsely.calendar
2017-12-20 21:59:26,607: Parsing model.parsely.parsely_all_events
2017-12-20 21:59:26,615: Acquiring new redshift connection "parsely_all_events".
2017-12-20 21:59:26,615: Opening a new connection (0 currently allocated)
2017-12-20 21:59:26,666: Using redshift connection "parsely_all_events".
2017-12-20 21:59:26,667: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:26,692: SQL status: SELECT in 0.03 seconds
2017-12-20 21:59:26,698: Parsing model.parsely.parsely_event_ids
2017-12-20 21:59:26,700: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-20 21:59:26,703: Parsing model.parsely.parsely_base_events
2017-12-20 21:59:26,706: Acquiring new redshift connection "parsely_base_events".
2017-12-20 21:59:26,706: Re-using an available connection from the pool.
2017-12-20 21:59:26,706: Using redshift connection "parsely_base_events".
2017-12-20 21:59:26,707: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:26,728: SQL status: SELECT in 0.02 seconds
2017-12-20 21:59:26,729: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-20 21:59:26,734: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-20 21:59:26,738: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-20 21:59:26,740: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-20 21:59:26,742: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-20 21:59:26,745: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-20 21:59:26,751: Parsing model.parsely.parsely_incoming_pageviews
2017-12-20 21:59:26,758: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-20 21:59:26,763: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-20 21:59:26,763: Re-using an available connection from the pool.
2017-12-20 21:59:26,763: Using redshift connection "parsely_pageviews_sessionized".
2017-12-20 21:59:26,763: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:26,784: SQL status: SELECT in 0.02 seconds
2017-12-20 21:59:26,784: Parsing model.parsely.parsely_incoming_videoviews
2017-12-20 21:59:26,791: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-20 21:59:26,795: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-20 21:59:26,795: Re-using an available connection from the pool.
2017-12-20 21:59:26,795: Using redshift connection "parsely_videoviews_sessionized".
2017-12-20 21:59:26,796: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:26,816: SQL status: SELECT in 0.02 seconds
2017-12-20 21:59:26,817: Parsing model.parsely.parsely_incoming_users
2017-12-20 21:59:26,819: Parsing model.parsely.parsely_users
2017-12-20 21:59:26,824: Acquiring new redshift connection "parsely_users".
2017-12-20 21:59:26,824: Re-using an available connection from the pool.
2017-12-20 21:59:26,825: Using redshift connection "parsely_users".
2017-12-20 21:59:26,825: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:26,845: SQL status: SELECT in 0.02 seconds
2017-12-20 21:59:26,846: Parsing model.parsely.parsely_errors
2017-12-20 21:59:26,850: Parsing model.parsely.parsely_bot_traffic
2017-12-20 21:59:26,854: Parsing model.parsely.parsely_custom_events
2017-12-20 21:59:26,859: Parsing model.parsely.parsely_incoming_sessions
2017-12-20 21:59:26,862: Parsing model.parsely.parsely_entry_exit_urls
2017-12-20 21:59:26,865: Parsing model.parsely.parsely_sessions
2017-12-20 21:59:26,870: Acquiring new redshift connection "parsely_sessions".
2017-12-20 21:59:26,870: Re-using an available connection from the pool.
2017-12-20 21:59:26,870: Using redshift connection "parsely_sessions".
2017-12-20 21:59:26,871: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:26,892: SQL status: SELECT in 0.02 seconds
2017-12-20 21:59:26,892: Parsing model.parsely.parsely_campaigns
2017-12-20 21:59:26,896: Acquiring new redshift connection "parsely_campaigns".
2017-12-20 21:59:26,896: Re-using an available connection from the pool.
2017-12-20 21:59:26,896: Using redshift connection "parsely_campaigns".
2017-12-20 21:59:26,896: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:26,917: SQL status: SELECT in 0.02 seconds
2017-12-20 21:59:26,922: Parsing operation.parsely.parsely-on-run-end-0
2017-12-20 21:59:26,927: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-20 21:59:26,934: 
2017-12-20 21:59:26,937: Acquiring new redshift connection "master".
2017-12-20 21:59:26,937: Re-using an available connection from the pool.
2017-12-20 21:59:26,937: Using redshift connection "master".
2017-12-20 21:59:26,937: On master: select distinct nspname from pg_namespace
2017-12-20 21:59:26,939: SQL status: SELECT in 0.00 seconds
2017-12-20 21:59:26,942: Using redshift connection "master".
2017-12-20 21:59:26,942: On master: BEGIN
2017-12-20 21:59:26,944: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:59:26,944: On master: COMMIT
2017-12-20 21:59:26,944: Using redshift connection "master".
2017-12-20 21:59:26,944: On master: COMMIT
2017-12-20 21:59:26,946: SQL status: COMMIT in 0.00 seconds
2017-12-20 21:59:26,951: 21:59:26 | Concurrency: 1 threads (target='dev')
2017-12-20 21:59:26,951: 21:59:26 | 
2017-12-20 21:59:26,951: Using redshift connection "master".
2017-12-20 21:59:26,951: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:26,972: SQL status: SELECT in 0.02 seconds
2017-12-20 21:59:27,045: 21:59:27 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-20 21:59:27,045: Compiling model.parsely.calendar
2017-12-20 21:59:27,050: Writing injected SQL for node "model.parsely.calendar"
2017-12-20 21:59:27,051: Acquiring new redshift connection "calendar".
2017-12-20 21:59:27,051: Opening a new connection (1 currently allocated)
2017-12-20 21:59:27,063: Using redshift connection "calendar".
2017-12-20 21:59:27,063: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:27,089: SQL status: SELECT in 0.03 seconds
2017-12-20 21:59:27,091: Writing runtime SQL for node "model.parsely.calendar"
2017-12-20 21:59:27,091: Using redshift connection "calendar".
2017-12-20 21:59:27,092: On calendar: BEGIN
2017-12-20 21:59:27,093: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:59:27,093: Using redshift connection "calendar".
2017-12-20 21:59:27,093: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-20 21:59:28,138: SQL status: CREATE VIEW in 1.04 seconds
2017-12-20 21:59:28,138: On calendar: COMMIT
2017-12-20 21:59:28,139: Using redshift connection "calendar".
2017-12-20 21:59:28,139: On calendar: COMMIT
2017-12-20 21:59:28,690: SQL status: COMMIT in 0.55 seconds
2017-12-20 21:59:28,691: Using redshift connection "calendar".
2017-12-20 21:59:28,691: On calendar: BEGIN
2017-12-20 21:59:28,693: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:59:28,693: Using redshift connection "calendar".
2017-12-20 21:59:28,693: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-20 21:59:29,145: SQL status: DROP VIEW in 0.45 seconds
2017-12-20 21:59:29,145: On calendar: COMMIT
2017-12-20 21:59:29,145: Using redshift connection "calendar".
2017-12-20 21:59:29,145: On calendar: COMMIT
2017-12-20 21:59:30,469: SQL status: COMMIT in 1.32 seconds
2017-12-20 21:59:30,470: Using redshift connection "calendar".
2017-12-20 21:59:30,470: On calendar: BEGIN
2017-12-20 21:59:30,472: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:59:30,472: Using redshift connection "calendar".
2017-12-20 21:59:30,472: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-20 21:59:30,513: SQL status: ALTER TABLE in 0.04 seconds
2017-12-20 21:59:30,513: On calendar: COMMIT
2017-12-20 21:59:30,513: Using redshift connection "calendar".
2017-12-20 21:59:30,513: On calendar: COMMIT
2017-12-20 21:59:30,715: SQL status: COMMIT in 0.20 seconds
2017-12-20 21:59:30,715: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f1d690>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 21:59:30,768: 21:59:30 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 3.67s]
2017-12-20 21:59:30,769: 21:59:30 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-20 21:59:30,769: Compiling model.parsely.parsely_rawdata
2017-12-20 21:59:30,774: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-20 21:59:30,775: Acquiring new redshift connection "parsely_rawdata".
2017-12-20 21:59:30,775: Re-using an available connection from the pool.
2017-12-20 21:59:30,776: Using redshift connection "parsely_rawdata".
2017-12-20 21:59:30,776: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:30,795: SQL status: SELECT in 0.02 seconds
2017-12-20 21:59:30,796: Using redshift connection "parsely_rawdata".
2017-12-20 21:59:30,796: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 21:59:30,805: SQL status: SELECT in 0.01 seconds
2017-12-20 21:59:30,806: Using redshift connection "parsely_rawdata".
2017-12-20 21:59:30,806: On parsely_rawdata: BEGIN
2017-12-20 21:59:30,808: SQL status: BEGIN in 0.00 seconds
2017-12-20 21:59:30,808: Using redshift connection "parsely_rawdata".
2017-12-20 21:59:30,808: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-20 21:59:56,262: SQL status: SELECT in 25.45 seconds
2017-12-20 21:59:56,263: Using redshift connection "parsely_rawdata".
2017-12-20 21:59:56,263: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-20 21:59:56,492: SQL status: SELECT in 0.23 seconds
2017-12-20 21:59:56,493: Using redshift connection "parsely_rawdata".
2017-12-20 21:59:56,493: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-20 21:59:56,588: SQL status: SELECT in 0.10 seconds
2017-12-20 21:59:56,589: Using redshift connection "parsely_rawdata".
2017-12-20 21:59:56,589: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-20 21:59:56,685: SQL status: SELECT in 0.10 seconds
2017-12-20 21:59:56,688: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-20 21:59:56,688: Using redshift connection "parsely_rawdata".
2017-12-20 21:59:56,688: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-20 22:00:28,764: SQL status: INSERT 0 996095 in 32.08 seconds
2017-12-20 22:00:28,765: On parsely_rawdata: COMMIT
2017-12-20 22:00:28,765: Using redshift connection "parsely_rawdata".
2017-12-20 22:00:28,765: On parsely_rawdata: COMMIT
2017-12-20 22:00:30,973: SQL status: COMMIT in 2.21 seconds
2017-12-20 22:00:30,974: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f1d1d0>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:00:31,035: 22:00:31 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 996095 in 60.20s]
2017-12-20 22:00:31,040: 22:00:31 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-20 22:00:31,040: Compiling model.parsely.parsely_all_events
2017-12-20 22:00:31,071: Acquiring new redshift connection "parsely_all_events".
2017-12-20 22:00:31,071: Re-using an available connection from the pool.
2017-12-20 22:00:31,072: Using redshift connection "parsely_all_events".
2017-12-20 22:00:31,072: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:00:31,086: SQL status: SELECT in 0.01 seconds
2017-12-20 22:00:31,105: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-20 22:00:31,106: Using redshift connection "parsely_all_events".
2017-12-20 22:00:31,107: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:00:31,121: SQL status: SELECT in 0.01 seconds
2017-12-20 22:00:31,122: Using redshift connection "parsely_all_events".
2017-12-20 22:00:31,122: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:00:31,138: SQL status: SELECT in 0.02 seconds
2017-12-20 22:00:31,142: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-20 22:00:31,143: Using redshift connection "parsely_all_events".
2017-12-20 22:00:31,143: On parsely_all_events: BEGIN
2017-12-20 22:00:31,148: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:00:31,148: Using redshift connection "parsely_all_events".
2017-12-20 22:00:31,148: On parsely_all_events: 
    
  

  create  table "blog_dbt_dev"."parsely_all_events"
  
  
  as (
    

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
  );
2017-12-20 22:02:31,862: SQL status: SELECT in 120.71 seconds
2017-12-20 22:02:31,862: On parsely_all_events: COMMIT
2017-12-20 22:02:31,863: Using redshift connection "parsely_all_events".
2017-12-20 22:02:31,863: On parsely_all_events: COMMIT
2017-12-20 22:02:36,662: SQL status: COMMIT in 4.80 seconds
2017-12-20 22:02:36,663: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f92f90>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:02:36,769: 22:02:36 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [SELECT in 125.62s]
2017-12-20 22:02:36,772: 22:02:36 | 4 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-20 22:02:36,773: Compiling model.parsely.parsely_base_events
2017-12-20 22:02:36,779: Acquiring new redshift connection "parsely_base_events".
2017-12-20 22:02:36,779: Re-using an available connection from the pool.
2017-12-20 22:02:36,779: Using redshift connection "parsely_base_events".
2017-12-20 22:02:36,779: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:02:36,796: SQL status: SELECT in 0.02 seconds
2017-12-20 22:02:36,803: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-20 22:02:36,812: Using redshift connection "parsely_base_events".
2017-12-20 22:02:36,812: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:02:36,826: SQL status: SELECT in 0.01 seconds
2017-12-20 22:02:36,829: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-20 22:02:36,830: Using redshift connection "parsely_base_events".
2017-12-20 22:02:36,830: On parsely_base_events: BEGIN
2017-12-20 22:02:36,836: SQL status: BEGIN in 0.01 seconds
2017-12-20 22:02:36,836: Using redshift connection "parsely_base_events".
2017-12-20 22:02:36,836: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
     --running for the first time
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-20 22:02:37,992: SQL status: CREATE VIEW in 1.16 seconds
2017-12-20 22:02:37,993: Using redshift connection "parsely_base_events".
2017-12-20 22:02:37,993: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-20 22:02:37,997: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 22:02:37,997: On parsely_base_events: COMMIT
2017-12-20 22:02:37,997: Using redshift connection "parsely_base_events".
2017-12-20 22:02:37,998: On parsely_base_events: COMMIT
2017-12-20 22:02:38,275: SQL status: COMMIT in 0.28 seconds
2017-12-20 22:02:38,275: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f1df50>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:02:38,322: 22:02:38 | 4 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 1.50s]
2017-12-20 22:02:38,322: 22:02:38 | 5 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-20 22:02:38,322: Compiling model.parsely.parsely_bot_traffic
2017-12-20 22:02:38,352: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-20 22:02:38,354: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-20 22:02:38,354: Re-using an available connection from the pool.
2017-12-20 22:02:38,355: Using redshift connection "parsely_bot_traffic".
2017-12-20 22:02:38,355: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:02:38,368: SQL status: SELECT in 0.01 seconds
2017-12-20 22:02:38,369: Using redshift connection "parsely_bot_traffic".
2017-12-20 22:02:38,369: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:02:38,383: SQL status: SELECT in 0.01 seconds
2017-12-20 22:02:38,386: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-20 22:02:38,387: Using redshift connection "parsely_bot_traffic".
2017-12-20 22:02:38,387: On parsely_bot_traffic: BEGIN
2017-12-20 22:02:38,396: SQL status: BEGIN in 0.01 seconds
2017-12-20 22:02:38,396: Using redshift connection "parsely_bot_traffic".
2017-12-20 22:02:38,396: On parsely_bot_traffic: 
    
  

  create  table "blog_dbt_dev"."parsely_bot_traffic"
  
  
  as (
    --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
  );
2017-12-20 22:03:20,793: SQL status: SELECT in 42.40 seconds
2017-12-20 22:03:20,794: On parsely_bot_traffic: COMMIT
2017-12-20 22:03:20,794: Using redshift connection "parsely_bot_traffic".
2017-12-20 22:03:20,794: On parsely_bot_traffic: COMMIT
2017-12-20 22:03:22,666: SQL status: COMMIT in 1.87 seconds
2017-12-20 22:03:22,667: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f1df50>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:03:22,758: 22:03:22 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [SELECT in 44.34s]
2017-12-20 22:03:22,759: 22:03:22 | 6 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-20 22:03:22,759: Compiling model.parsely.parsely_custom_events
2017-12-20 22:03:22,784: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-20 22:03:22,786: Acquiring new redshift connection "parsely_custom_events".
2017-12-20 22:03:22,787: Re-using an available connection from the pool.
2017-12-20 22:03:22,787: Using redshift connection "parsely_custom_events".
2017-12-20 22:03:22,787: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:03:22,804: SQL status: SELECT in 0.02 seconds
2017-12-20 22:03:22,804: Using redshift connection "parsely_custom_events".
2017-12-20 22:03:22,804: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:03:22,818: SQL status: SELECT in 0.01 seconds
2017-12-20 22:03:22,822: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-20 22:03:22,823: Using redshift connection "parsely_custom_events".
2017-12-20 22:03:22,823: On parsely_custom_events: BEGIN
2017-12-20 22:03:22,825: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:03:22,825: Using redshift connection "parsely_custom_events".
2017-12-20 22:03:22,825: On parsely_custom_events: 
    
  

  create  table "blog_dbt_dev"."parsely_custom_events"
  
  
  as (
    -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
  );
2017-12-20 22:03:57,285: SQL status: SELECT in 34.46 seconds
2017-12-20 22:03:57,286: On parsely_custom_events: COMMIT
2017-12-20 22:03:57,286: Using redshift connection "parsely_custom_events".
2017-12-20 22:03:57,286: On parsely_custom_events: COMMIT
2017-12-20 22:03:57,605: SQL status: COMMIT in 0.32 seconds
2017-12-20 22:03:57,606: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f1df50>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:03:57,666: 22:03:57 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [SELECT in 34.85s]
2017-12-20 22:03:57,666: 22:03:57 | 7 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-20 22:03:57,667: Compiling model.parsely.parsely_errors
2017-12-20 22:03:57,685: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-20 22:03:57,687: Acquiring new redshift connection "parsely_errors".
2017-12-20 22:03:57,696: Re-using an available connection from the pool.
2017-12-20 22:03:57,696: Using redshift connection "parsely_errors".
2017-12-20 22:03:57,696: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:03:57,713: SQL status: SELECT in 0.02 seconds
2017-12-20 22:03:57,714: Using redshift connection "parsely_errors".
2017-12-20 22:03:57,714: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:03:57,727: SQL status: SELECT in 0.01 seconds
2017-12-20 22:03:57,731: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-20 22:03:57,732: Using redshift connection "parsely_errors".
2017-12-20 22:03:57,733: On parsely_errors: BEGIN
2017-12-20 22:03:57,734: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:03:57,735: Using redshift connection "parsely_errors".
2017-12-20 22:03:57,735: On parsely_errors: 
    
  

  create  table "blog_dbt_dev"."parsely_errors"
  
  
  as (
    -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
  );
2017-12-20 22:04:27,029: SQL status: SELECT in 29.29 seconds
2017-12-20 22:04:27,030: On parsely_errors: COMMIT
2017-12-20 22:04:27,030: Using redshift connection "parsely_errors".
2017-12-20 22:04:27,030: On parsely_errors: COMMIT
2017-12-20 22:04:28,548: SQL status: COMMIT in 1.52 seconds
2017-12-20 22:04:28,549: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f0c550>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:04:28,635: 22:04:28 | 7 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [SELECT in 30.88s]
2017-12-20 22:04:28,636: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-20 22:04:28,666: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-20 22:04:28,671: 22:04:28 | 8 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-20 22:04:28,672: Compiling model.parsely.parsely_post_content
2017-12-20 22:04:28,700: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-20 22:04:28,701: Acquiring new redshift connection "parsely_post_content".
2017-12-20 22:04:28,702: Re-using an available connection from the pool.
2017-12-20 22:04:28,702: Using redshift connection "parsely_post_content".
2017-12-20 22:04:28,702: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:28,719: SQL status: SELECT in 0.02 seconds
2017-12-20 22:04:28,719: Using redshift connection "parsely_post_content".
2017-12-20 22:04:28,719: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:28,733: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:28,736: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-20 22:04:28,737: Using redshift connection "parsely_post_content".
2017-12-20 22:04:28,737: On parsely_post_content: BEGIN
2017-12-20 22:04:28,739: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:04:28,739: Using redshift connection "parsely_post_content".
2017-12-20 22:04:28,739: On parsely_post_content: 
    
  

  create  table "blog_dbt_dev"."parsely_post_content"
  
  
  as (
    -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
  );
2017-12-20 22:04:30,781: SQL status: SELECT in 2.04 seconds
2017-12-20 22:04:30,782: On parsely_post_content: COMMIT
2017-12-20 22:04:30,782: Using redshift connection "parsely_post_content".
2017-12-20 22:04:30,782: On parsely_post_content: COMMIT
2017-12-20 22:04:31,540: SQL status: COMMIT in 0.76 seconds
2017-12-20 22:04:31,540: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f2cdd0>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:04:31,595: 22:04:31 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [SELECT in 2.87s]
2017-12-20 22:04:31,595: 22:04:31 | 9 of 25 START incremental model blog_dbt_dev.parsely_video_content... [RUN]
2017-12-20 22:04:31,596: Compiling model.parsely.parsely_video_content
2017-12-20 22:04:31,614: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-20 22:04:31,615: Acquiring new redshift connection "parsely_video_content".
2017-12-20 22:04:31,615: Re-using an available connection from the pool.
2017-12-20 22:04:31,616: Using redshift connection "parsely_video_content".
2017-12-20 22:04:31,616: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:31,630: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:31,630: Using redshift connection "parsely_video_content".
2017-12-20 22:04:31,630: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:31,644: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:31,647: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-20 22:04:31,647: Using redshift connection "parsely_video_content".
2017-12-20 22:04:31,648: On parsely_video_content: BEGIN
2017-12-20 22:04:31,649: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:04:31,650: Using redshift connection "parsely_video_content".
2017-12-20 22:04:31,650: On parsely_video_content: 
    
  

  create  table "blog_dbt_dev"."parsely_video_content"
  
  
  as (
    -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
  );
2017-12-20 22:04:33,071: SQL status: SELECT in 1.42 seconds
2017-12-20 22:04:33,072: On parsely_video_content: COMMIT
2017-12-20 22:04:33,072: Using redshift connection "parsely_video_content".
2017-12-20 22:04:33,072: On parsely_video_content: COMMIT
2017-12-20 22:04:33,723: SQL status: COMMIT in 0.65 seconds
2017-12-20 22:04:33,723: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f2c610>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:04:33,789: 22:04:33 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [SELECT in 2.13s]
2017-12-20 22:04:33,790: 22:04:33 | 10 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-20 22:04:33,790: Compiling model.parsely.parsely_entry_exit_urls
2017-12-20 22:04:33,810: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-20 22:04:33,811: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-20 22:04:33,811: Re-using an available connection from the pool.
2017-12-20 22:04:33,811: Using redshift connection "parsely_entry_exit_urls".
2017-12-20 22:04:33,811: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:33,825: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:33,830: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-20 22:04:33,830: Using redshift connection "parsely_entry_exit_urls".
2017-12-20 22:04:33,830: On parsely_entry_exit_urls: BEGIN
2017-12-20 22:04:33,833: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:04:33,833: Using redshift connection "parsely_entry_exit_urls".
2017-12-20 22:04:33,833: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action_tz
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action_tz

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-20 22:04:33,836: Postgres error: column st.first_ts_action_tz does not exist

2017-12-20 22:04:33,837: On parsely_entry_exit_urls: ROLLBACK
2017-12-20 22:04:33,839: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb286023250>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:04:33,892: 22:04:33 | 10 of 25 ERROR creating view model blog_dbt_dev.parsely_entry_exit_urls [ERROR in 0.05s]
2017-12-20 22:04:33,893: 22:04:33 | 11 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-20 22:04:33,893: Compiling model.parsely.parsely_incoming_videoviews
2017-12-20 22:04:33,928: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-20 22:04:33,930: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-20 22:04:33,930: Re-using an available connection from the pool.
2017-12-20 22:04:33,930: Using redshift connection "parsely_incoming_videoviews".
2017-12-20 22:04:33,930: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:33,957: SQL status: SELECT in 0.03 seconds
2017-12-20 22:04:33,964: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-20 22:04:33,970: Using redshift connection "parsely_incoming_videoviews".
2017-12-20 22:04:33,970: On parsely_incoming_videoviews: BEGIN
2017-12-20 22:04:33,976: SQL status: BEGIN in 0.01 seconds
2017-12-20 22:04:33,976: Using redshift connection "parsely_incoming_videoviews".
2017-12-20 22:04:33,976: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as watch_time

    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-20 22:04:34,130: SQL status: CREATE VIEW in 0.15 seconds
2017-12-20 22:04:34,131: Using redshift connection "parsely_incoming_videoviews".
2017-12-20 22:04:34,131: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-20 22:04:34,135: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 22:04:34,135: On parsely_incoming_videoviews: COMMIT
2017-12-20 22:04:34,136: Using redshift connection "parsely_incoming_videoviews".
2017-12-20 22:04:34,136: On parsely_incoming_videoviews: COMMIT
2017-12-20 22:04:34,331: SQL status: COMMIT in 0.20 seconds
2017-12-20 22:04:34,332: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f0c490>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:04:34,421: 22:04:34 | 11 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.44s]
2017-12-20 22:04:34,423: 22:04:34 | 12 of 25 START incremental model blog_dbt_dev.parsely_event_ids...... [RUN]
2017-12-20 22:04:34,423: Compiling model.parsely.parsely_event_ids
2017-12-20 22:04:34,443: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-20 22:04:34,443: Acquiring new redshift connection "parsely_event_ids".
2017-12-20 22:04:34,444: Re-using an available connection from the pool.
2017-12-20 22:04:34,444: Using redshift connection "parsely_event_ids".
2017-12-20 22:04:34,444: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:34,458: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:34,459: Using redshift connection "parsely_event_ids".
2017-12-20 22:04:34,459: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:34,473: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:34,476: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-20 22:04:34,476: Using redshift connection "parsely_event_ids".
2017-12-20 22:04:34,477: On parsely_event_ids: BEGIN
2017-12-20 22:04:34,479: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:04:34,479: Using redshift connection "parsely_event_ids".
2017-12-20 22:04:34,479: On parsely_event_ids: 
    
  

  create  table "blog_dbt_dev"."parsely_event_ids"
  
  
  as (
    

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
  );
2017-12-20 22:04:35,569: SQL status: SELECT in 1.09 seconds
2017-12-20 22:04:35,570: On parsely_event_ids: COMMIT
2017-12-20 22:04:35,570: Using redshift connection "parsely_event_ids".
2017-12-20 22:04:35,570: On parsely_event_ids: COMMIT
2017-12-20 22:04:36,106: SQL status: COMMIT in 0.54 seconds
2017-12-20 22:04:36,107: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f92ed0>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:04:36,161: 22:04:36 | 12 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids. [SELECT in 1.68s]
2017-12-20 22:04:36,172: 22:04:36 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-20 22:04:36,172: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-20 22:04:36,181: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-20 22:04:36,181: Re-using an available connection from the pool.
2017-12-20 22:04:36,182: Using redshift connection "parsely_videoviews_sessionized".
2017-12-20 22:04:36,182: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:36,196: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:36,201: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-20 22:04:36,203: Using redshift connection "parsely_videoviews_sessionized".
2017-12-20 22:04:36,203: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:36,217: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:36,218: Using redshift connection "parsely_videoviews_sessionized".
2017-12-20 22:04:36,218: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:36,232: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:36,235: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-20 22:04:36,236: Using redshift connection "parsely_videoviews_sessionized".
2017-12-20 22:04:36,236: On parsely_videoviews_sessionized: BEGIN
2017-12-20 22:04:36,238: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:04:36,238: Using redshift connection "parsely_videoviews_sessionized".
2017-12-20 22:04:36,238: On parsely_videoviews_sessionized: 
    
  

  create  table "blog_dbt_dev"."parsely_videoviews_sessionized"
  
  
  as (
    

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




-- initial run, don't merge
merged as (

    select
      *
    from incoming_videoviews
)



select
  *
from merged
  );
2017-12-20 22:04:46,976: Postgres error: Invalid digit, Value '-', Pos 4, Type: Long 
DETAIL:  
  -----------------------------------------------
  error:  Invalid digit, Value '-', Pos 4, Type: Long 
  code:      1207
  context:   2016-01-20
  query:     96204
  location:  :0
  process:   query0_101 [pid=0]
  -----------------------------------------------


2017-12-20 22:04:46,976: On parsely_videoviews_sessionized: ROLLBACK
2017-12-20 22:04:46,978: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb286023290>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:04:47,025: 22:04:47 | 13 of 25 ERROR creating incremental model blog_dbt_dev.parsely_videoviews_sessionized [ERROR in 10.81s]
2017-12-20 22:04:47,025: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-20 22:04:47,067: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-20 22:04:47,068: 22:04:47 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-20 22:04:47,068: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-20 22:04:47,092: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-20 22:04:47,093: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 22:04:47,093: Re-using an available connection from the pool.
2017-12-20 22:04:47,093: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 22:04:47,093: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:47,111: SQL status: SELECT in 0.02 seconds
2017-12-20 22:04:47,114: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-20 22:04:47,115: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 22:04:47,115: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-20 22:04:47,117: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:04:47,117: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 22:04:47,117: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-20 22:04:47,189: SQL status: CREATE VIEW in 0.07 seconds
2017-12-20 22:04:47,189: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 22:04:47,189: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-20 22:04:47,193: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 22:04:47,193: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-20 22:04:47,193: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-20 22:04:47,193: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-20 22:04:47,385: SQL status: COMMIT in 0.19 seconds
2017-12-20 22:04:47,385: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f2c390>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:04:47,429: 22:04:47 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.32s]
2017-12-20 22:04:47,430: 22:04:47 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-20 22:04:47,430: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-20 22:04:47,487: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-20 22:04:47,489: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 22:04:47,489: Re-using an available connection from the pool.
2017-12-20 22:04:47,489: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 22:04:47,489: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:47,503: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:47,508: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-20 22:04:47,509: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 22:04:47,509: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-20 22:04:47,511: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:04:47,511: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 22:04:47,512: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-20 22:04:47,588: SQL status: CREATE VIEW in 0.08 seconds
2017-12-20 22:04:47,588: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 22:04:47,588: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-20 22:04:47,592: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 22:04:47,592: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-20 22:04:47,593: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-20 22:04:47,593: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-20 22:04:47,777: SQL status: COMMIT in 0.18 seconds
2017-12-20 22:04:47,778: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f56690>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:04:47,818: 22:04:47 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.35s]
2017-12-20 22:04:47,818: 22:04:47 | 16 of 25 SKIP relation blog_dbt_dev.parsely_incoming_pageviews....... [SKIP]
2017-12-20 22:04:47,822: 22:04:47 | 17 of 25 SKIP relation blog_dbt_dev.parsely_pageviews_sessionized.... [SKIP]
2017-12-20 22:04:47,822: 22:04:47 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-20 22:04:47,823: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-20 22:04:47,948: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-20 22:04:47,950: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-20 22:04:47,950: Re-using an available connection from the pool.
2017-12-20 22:04:47,950: Using redshift connection "parsely_videoview_engagedtime".
2017-12-20 22:04:47,950: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:47,965: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:47,969: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-20 22:04:47,970: Using redshift connection "parsely_videoview_engagedtime".
2017-12-20 22:04:47,970: On parsely_videoview_engagedtime: BEGIN
2017-12-20 22:04:47,972: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:04:47,972: Using redshift connection "parsely_videoview_engagedtime".
2017-12-20 22:04:47,972: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-20 22:04:49,104: SQL status: CREATE VIEW in 1.13 seconds
2017-12-20 22:04:49,104: Using redshift connection "parsely_videoview_engagedtime".
2017-12-20 22:04:49,104: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-20 22:04:49,108: SQL status: ALTER TABLE in 0.00 seconds
2017-12-20 22:04:49,109: On parsely_videoview_engagedtime: COMMIT
2017-12-20 22:04:49,109: Using redshift connection "parsely_videoview_engagedtime".
2017-12-20 22:04:49,109: On parsely_videoview_engagedtime: COMMIT
2017-12-20 22:04:49,377: SQL status: COMMIT in 0.27 seconds
2017-12-20 22:04:49,377: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f56b10>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:04:49,437: 22:04:49 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.55s]
2017-12-20 22:04:49,438: 22:04:49 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-20 22:04:49,448: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-20 22:04:49,488: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-20 22:04:49,490: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-20 22:04:49,490: Re-using an available connection from the pool.
2017-12-20 22:04:49,490: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-20 22:04:49,490: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:49,505: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:49,505: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-20 22:04:49,505: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-20 22:04:49,519: SQL status: SELECT in 0.01 seconds
2017-12-20 22:04:49,536: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-20 22:04:49,537: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-20 22:04:49,538: On parsely_videoview_behavior_workflow: BEGIN
2017-12-20 22:04:49,540: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:04:49,540: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-20 22:04:49,540: On parsely_videoview_behavior_workflow: 
    
  

  create  table "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  
  
  as (
    -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as watch_time

    from video_events

)

select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
  );
2017-12-20 22:05:09,891: Postgres error: Invalid digit, Value '-', Pos 4, Type: Long 
DETAIL:  
  -----------------------------------------------
  error:  Invalid digit, Value '-', Pos 4, Type: Long 
  code:      1207
  context:   2017-08-29
  query:     96205
  location:  :0
  process:   query0_55 [pid=0]
  -----------------------------------------------


2017-12-20 22:05:09,891: On parsely_videoview_behavior_workflow: ROLLBACK
2017-12-20 22:05:09,896: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb285f56110>], 'label': 'b0d423c9-2312-4ac8-8b22-9b9e56ea97f2'}
2017-12-20 22:05:09,951: 22:05:09 | 19 of 25 ERROR creating incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [ERROR in 20.45s]
2017-12-20 22:05:09,951: 22:05:09 | 20 of 25 SKIP relation blog_dbt_dev.parsely_campaigns................ [SKIP]
2017-12-20 22:05:09,952: 22:05:09 | 21 of 25 SKIP relation blog_dbt_dev.parsely_users.................... [SKIP]
2017-12-20 22:05:09,952: 22:05:09 | 22 of 25 SKIP relation blog_dbt_dev.parsely_pageview_engagedtime..... [SKIP]
2017-12-20 22:05:09,953: 22:05:09 | 23 of 25 SKIP relation blog_dbt_dev.parsely_incoming_sessions........ [SKIP]
2017-12-20 22:05:09,953: 22:05:09 | 24 of 25 SKIP relation blog_dbt_dev.parsely_pageview_behavior_workflow [SKIP]
2017-12-20 22:05:09,954: 22:05:09 | 25 of 25 SKIP relation blog_dbt_dev.parsely_sessions................. [SKIP]
2017-12-20 22:05:09,965: Using redshift connection "master".
2017-12-20 22:05:09,965: On master: BEGIN
2017-12-20 22:05:09,968: SQL status: BEGIN in 0.00 seconds
2017-12-20 22:05:09,968: On master: COMMIT
2017-12-20 22:05:09,968: Using redshift connection "master".
2017-12-20 22:05:09,968: On master: COMMIT
2017-12-20 22:05:09,970: SQL status: COMMIT in 0.00 seconds
2017-12-20 22:05:09,970: Compiling operation.parsely.parsely-on-run-end-0
2017-12-20 22:05:09,982: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-20 22:05:09,983: Using redshift connection "master".
2017-12-20 22:05:09,983: On master:  select 1 
2017-12-20 22:05:09,992: SQL status: SELECT in 0.01 seconds
2017-12-20 22:05:09,992: 22:05:09 | 
2017-12-20 22:05:09,993: 22:05:09 | Finished running 10 view models, 15 incremental models in 343.01s.
2017-12-20 22:05:09,993: 
2017-12-20 22:05:09,994: Completed with 3 errors:
2017-12-20 22:05:09,994: 
2017-12-20 22:05:09,994: Database Error in model parsely_entry_exit_urls (models/sessions/parsely_entry_exit_urls.sql)
2017-12-20 22:05:09,994:   column st.first_ts_action_tz does not exist
2017-12-20 22:05:09,995:   compiled SQL at target/run/parsely/sessions/parsely_entry_exit_urls.sql
2017-12-20 22:05:09,995: 
2017-12-20 22:05:09,995: Database Error in model parsely_videoviews_sessionized (models/videoviews/parsely_videoviews_sessionized.sql)
2017-12-20 22:05:09,995:   Invalid digit, Value '-', Pos 4, Type: Long 
2017-12-20 22:05:09,995:   DETAIL:  
2017-12-20 22:05:09,996:     -----------------------------------------------
2017-12-20 22:05:09,996:     error:  Invalid digit, Value '-', Pos 4, Type: Long 
2017-12-20 22:05:09,996:     code:      1207
2017-12-20 22:05:09,996:     context:   2016-01-20
2017-12-20 22:05:09,996:     query:     96204
2017-12-20 22:05:09,997:     location:  :0
2017-12-20 22:05:09,997:     process:   query0_101 [pid=0]
2017-12-20 22:05:09,997:     -----------------------------------------------
2017-12-20 22:05:09,997:   compiled SQL at target/run/parsely/videoviews/parsely_videoviews_sessionized.sql
2017-12-20 22:05:09,998: 
2017-12-20 22:05:09,998: Database Error in model parsely_videoview_behavior_workflow (models/behavior_workflow/parsely_videoview_behavior_workflow.sql)
2017-12-20 22:05:09,998:   Invalid digit, Value '-', Pos 4, Type: Long 
2017-12-20 22:05:09,998:   DETAIL:  
2017-12-20 22:05:09,998:     -----------------------------------------------
2017-12-20 22:05:09,999:     error:  Invalid digit, Value '-', Pos 4, Type: Long 
2017-12-20 22:05:09,999:     code:      1207
2017-12-20 22:05:09,999:     context:   2017-08-29
2017-12-20 22:05:09,999:     query:     96205
2017-12-20 22:05:09,999:     location:  :0
2017-12-20 22:05:10,000:     process:   query0_55 [pid=0]
2017-12-20 22:05:10,000:     -----------------------------------------------
2017-12-20 22:05:10,006:   compiled SQL at target/run/parsely/behavior_workflow/parsely_videoview_behavior_workflow.sql
2017-12-20 22:05:10,006: 
Done. PASS=14 ERROR=3 SKIP=8 TOTAL=25
2017-12-20 22:05:10,006: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb28602a250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb28602a4d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fb2930e1910>], 'label': 'end'}
2017-12-20 22:05:10,061: Flushing usage events
2017-12-21 03:49:53,540: Tracking: tracking
2017-12-21 03:49:53,541: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f032dadb250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f032dadb4d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f032dadb310>], 'label': 'start'}
2017-12-21 03:49:53,605: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 03:49:53,621: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 03:49:53,622: Parsing core.sql
2017-12-21 03:49:53,633: Parsing etc/get_custom_schema.sql
2017-12-21 03:49:53,638: Parsing schema_tests/relationships.sql
2017-12-21 03:49:53,640: Parsing schema_tests/accepted_values.sql
2017-12-21 03:49:53,645: Parsing schema_tests/not_null.sql
2017-12-21 03:49:53,646: Parsing schema_tests/unique.sql
2017-12-21 03:49:53,658: Parsing materializations/wrapper.sql
2017-12-21 03:49:53,661: Parsing materializations/archive.sql
2017-12-21 03:49:53,688: Parsing materializations/table.sql
2017-12-21 03:49:53,705: Parsing materializations/helpers.sql
2017-12-21 03:49:53,720: Parsing materializations/bigquery.sql
2017-12-21 03:49:53,733: Parsing materializations/view.sql
2017-12-21 03:49:53,746: Parsing materializations/incremental.sql
2017-12-21 03:49:53,770: Parsing adapters/redshift.sql
2017-12-21 03:49:53,787: Parsing adapters/bigquery.sql
2017-12-21 03:49:53,792: Parsing adapters/postgres.sql
2017-12-21 03:49:53,794: Parsing adapters/common.sql
2017-12-21 03:49:53,813: Parsing model.parsely.parsely_audit
2017-12-21 03:49:53,815: Parsing model.parsely.parsely_video_content
2017-12-21 03:49:53,818: Parsing model.parsely.parsely_post_content
2017-12-21 03:49:53,820: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 03:49:53,823: Parsing model.parsely.parsely_rawdata
2017-12-21 03:49:53,826: Parsing model.parsely.calendar
2017-12-21 03:49:53,827: Parsing model.parsely.parsely_all_events
2017-12-21 03:49:53,835: Acquiring new redshift connection "parsely_all_events".
2017-12-21 03:49:53,835: Opening a new connection (0 currently allocated)
2017-12-21 03:49:53,866: Using redshift connection "parsely_all_events".
2017-12-21 03:49:53,866: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:49:53,891: SQL status: SELECT in 0.02 seconds
2017-12-21 03:49:53,897: Parsing model.parsely.parsely_event_ids
2017-12-21 03:49:53,899: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 03:49:53,901: Parsing model.parsely.parsely_base_events
2017-12-21 03:49:53,905: Acquiring new redshift connection "parsely_base_events".
2017-12-21 03:49:53,905: Re-using an available connection from the pool.
2017-12-21 03:49:53,905: Using redshift connection "parsely_base_events".
2017-12-21 03:49:53,905: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:49:53,924: SQL status: SELECT in 0.02 seconds
2017-12-21 03:49:53,925: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 03:49:53,930: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 03:49:53,934: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 03:49:53,936: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 03:49:53,938: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 03:49:53,941: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 03:49:53,947: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 03:49:53,954: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 03:49:53,959: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:49:53,959: Re-using an available connection from the pool.
2017-12-21 03:49:53,959: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:49:53,959: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:49:53,977: SQL status: SELECT in 0.02 seconds
2017-12-21 03:49:53,977: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 03:49:53,984: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 03:49:53,989: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:49:53,989: Re-using an available connection from the pool.
2017-12-21 03:49:53,989: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:49:53,989: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:49:54,006: SQL status: SELECT in 0.02 seconds
2017-12-21 03:49:54,006: Parsing model.parsely.parsely_incoming_users
2017-12-21 03:49:54,009: Parsing model.parsely.parsely_users
2017-12-21 03:49:54,014: Acquiring new redshift connection "parsely_users".
2017-12-21 03:49:54,014: Re-using an available connection from the pool.
2017-12-21 03:49:54,014: Using redshift connection "parsely_users".
2017-12-21 03:49:54,014: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:49:54,030: SQL status: SELECT in 0.02 seconds
2017-12-21 03:49:54,031: Parsing model.parsely.parsely_errors
2017-12-21 03:49:54,035: Parsing model.parsely.parsely_bot_traffic
2017-12-21 03:49:54,039: Parsing model.parsely.parsely_custom_events
2017-12-21 03:49:54,044: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 03:49:54,047: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 03:49:54,050: Parsing model.parsely.parsely_sessions
2017-12-21 03:49:54,055: Acquiring new redshift connection "parsely_sessions".
2017-12-21 03:49:54,055: Re-using an available connection from the pool.
2017-12-21 03:49:54,055: Using redshift connection "parsely_sessions".
2017-12-21 03:49:54,056: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:49:54,072: SQL status: SELECT in 0.02 seconds
2017-12-21 03:49:54,072: Parsing model.parsely.parsely_campaigns
2017-12-21 03:49:54,076: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 03:49:54,076: Re-using an available connection from the pool.
2017-12-21 03:49:54,076: Using redshift connection "parsely_campaigns".
2017-12-21 03:49:54,076: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:49:54,093: SQL status: SELECT in 0.02 seconds
2017-12-21 03:49:54,098: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 03:49:54,103: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 03:49:54,107: 
2017-12-21 03:49:54,110: Acquiring new redshift connection "master".
2017-12-21 03:49:54,110: Re-using an available connection from the pool.
2017-12-21 03:49:54,110: Using redshift connection "master".
2017-12-21 03:49:54,110: On master: select distinct nspname from pg_namespace
2017-12-21 03:49:54,112: SQL status: SELECT in 0.00 seconds
2017-12-21 03:49:54,115: Using redshift connection "master".
2017-12-21 03:49:54,115: On master: BEGIN
2017-12-21 03:49:54,116: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:49:54,116: On master: COMMIT
2017-12-21 03:49:54,116: Using redshift connection "master".
2017-12-21 03:49:54,116: On master: COMMIT
2017-12-21 03:49:54,118: SQL status: COMMIT in 0.00 seconds
2017-12-21 03:49:54,123: 03:49:54 | Concurrency: 1 threads (target='dev')
2017-12-21 03:49:54,123: 03:49:54 | 
2017-12-21 03:49:54,124: Using redshift connection "master".
2017-12-21 03:49:54,124: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:49:54,141: SQL status: SELECT in 0.02 seconds
2017-12-21 03:49:54,154: 03:49:54 | 1 of 3 START view model blog_dbt_dev.parsely_entry_exit_urls......... [RUN]
2017-12-21 03:49:54,154: Compiling model.parsely.parsely_entry_exit_urls
2017-12-21 03:49:54,160: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 03:49:54,161: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-21 03:49:54,161: Opening a new connection (1 currently allocated)
2017-12-21 03:49:54,173: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 03:49:54,173: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:49:54,196: SQL status: SELECT in 0.02 seconds
2017-12-21 03:49:54,198: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 03:49:54,198: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 03:49:54,198: On parsely_entry_exit_urls: BEGIN
2017-12-21 03:49:54,200: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:49:54,200: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 03:49:54,200: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-21 03:49:54,233: SQL status: CREATE VIEW in 0.03 seconds
2017-12-21 03:49:54,233: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 03:49:54,233: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2017-12-21 03:49:54,236: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 03:49:54,236: On parsely_entry_exit_urls: COMMIT
2017-12-21 03:49:54,236: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 03:49:54,236: On parsely_entry_exit_urls: COMMIT
2017-12-21 03:49:54,658: SQL status: COMMIT in 0.42 seconds
2017-12-21 03:49:54,658: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f032da357d0>], 'label': '736f1a02-c608-4eff-bdfe-a4b21b362014'}
2017-12-21 03:49:54,686: 03:49:54 | 1 of 3 OK created view model blog_dbt_dev.parsely_entry_exit_urls.... [CREATE VIEW in 0.50s]
2017-12-21 03:49:54,686: Compiling model.parsely.parsely_incoming_users
2017-12-21 03:49:54,692: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 03:49:54,693: 03:49:54 | 2 of 3 START view model blog_dbt_dev.parsely_incoming_sessions....... [RUN]
2017-12-21 03:49:54,693: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 03:49:54,699: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 03:49:54,701: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 03:49:54,701: Re-using an available connection from the pool.
2017-12-21 03:49:54,701: Using redshift connection "parsely_incoming_sessions".
2017-12-21 03:49:54,701: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:49:54,722: SQL status: SELECT in 0.02 seconds
2017-12-21 03:49:54,724: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 03:49:54,725: Using redshift connection "parsely_incoming_sessions".
2017-12-21 03:49:54,725: On parsely_incoming_sessions: BEGIN
2017-12-21 03:49:54,727: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:49:54,727: Using redshift connection "parsely_incoming_sessions".
2017-12-21 03:49:54,727: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 03:49:54,731: Postgres error: relation "blog_dbt_dev.parsely_pageviews_sessionized" does not exist

2017-12-21 03:49:54,731: On parsely_incoming_sessions: ROLLBACK
2017-12-21 03:49:54,732: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f032dad4310>], 'label': '736f1a02-c608-4eff-bdfe-a4b21b362014'}
2017-12-21 03:49:54,758: 03:49:54 | 2 of 3 ERROR creating view model blog_dbt_dev.parsely_incoming_sessions [ERROR in 0.04s]
2017-12-21 03:49:54,759: 03:49:54 | 3 of 3 SKIP relation blog_dbt_dev.parsely_sessions................... [SKIP]
2017-12-21 03:49:54,857: Using redshift connection "master".
2017-12-21 03:49:54,858: On master: BEGIN
2017-12-21 03:49:54,860: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:49:54,860: On master: COMMIT
2017-12-21 03:49:54,860: Using redshift connection "master".
2017-12-21 03:49:54,860: On master: COMMIT
2017-12-21 03:49:54,861: SQL status: COMMIT in 0.00 seconds
2017-12-21 03:49:54,861: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 03:49:54,866: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 03:49:54,867: Using redshift connection "master".
2017-12-21 03:49:54,867: On master:  select 1 
2017-12-21 03:49:54,869: SQL status: SELECT in 0.00 seconds
2017-12-21 03:49:54,869: 03:49:54 | 
2017-12-21 03:49:54,869: 03:49:54 | Finished running 2 view models, 1 incremental models in 0.74s.
2017-12-21 03:49:54,870: 
2017-12-21 03:49:54,870: Completed with 1 errors:
2017-12-21 03:49:54,870: 
2017-12-21 03:49:54,870: Database Error in model parsely_incoming_sessions (models/sessions/parsely_incoming_sessions.sql)
2017-12-21 03:49:54,870:   relation "blog_dbt_dev.parsely_pageviews_sessionized" does not exist
2017-12-21 03:49:54,870:   compiled SQL at target/run/parsely/sessions/parsely_incoming_sessions.sql
2017-12-21 03:49:54,871: 
Done. PASS=1 ERROR=1 SKIP=1 TOTAL=3
2017-12-21 03:49:54,871: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f032dadb250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f032dadb4d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f033ab92910>], 'label': 'end'}
2017-12-21 03:49:54,905: Flushing usage events
2017-12-21 03:50:21,053: Tracking: tracking
2017-12-21 03:50:21,053: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7b8f0a8250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7b8f0a84d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7b8f0a8310>], 'label': 'start'}
2017-12-21 03:50:21,091: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 03:50:21,107: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 03:50:21,120: Parsing core.sql
2017-12-21 03:50:21,131: Parsing etc/get_custom_schema.sql
2017-12-21 03:50:21,136: Parsing schema_tests/relationships.sql
2017-12-21 03:50:21,138: Parsing schema_tests/accepted_values.sql
2017-12-21 03:50:21,141: Parsing schema_tests/not_null.sql
2017-12-21 03:50:21,143: Parsing schema_tests/unique.sql
2017-12-21 03:50:21,145: Parsing materializations/wrapper.sql
2017-12-21 03:50:21,147: Parsing materializations/archive.sql
2017-12-21 03:50:21,175: Parsing materializations/table.sql
2017-12-21 03:50:21,192: Parsing materializations/helpers.sql
2017-12-21 03:50:21,207: Parsing materializations/bigquery.sql
2017-12-21 03:50:21,219: Parsing materializations/view.sql
2017-12-21 03:50:21,233: Parsing materializations/incremental.sql
2017-12-21 03:50:21,257: Parsing adapters/redshift.sql
2017-12-21 03:50:21,274: Parsing adapters/bigquery.sql
2017-12-21 03:50:21,278: Parsing adapters/postgres.sql
2017-12-21 03:50:21,281: Parsing adapters/common.sql
2017-12-21 03:50:21,299: Parsing model.parsely.parsely_audit
2017-12-21 03:50:21,300: Parsing model.parsely.parsely_video_content
2017-12-21 03:50:21,303: Parsing model.parsely.parsely_post_content
2017-12-21 03:50:21,306: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 03:50:21,309: Parsing model.parsely.parsely_rawdata
2017-12-21 03:50:21,311: Parsing model.parsely.calendar
2017-12-21 03:50:21,313: Parsing model.parsely.parsely_all_events
2017-12-21 03:50:21,321: Acquiring new redshift connection "parsely_all_events".
2017-12-21 03:50:21,321: Opening a new connection (0 currently allocated)
2017-12-21 03:50:21,334: Using redshift connection "parsely_all_events".
2017-12-21 03:50:21,334: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:21,359: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:21,364: Parsing model.parsely.parsely_event_ids
2017-12-21 03:50:21,366: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 03:50:21,369: Parsing model.parsely.parsely_base_events
2017-12-21 03:50:21,372: Acquiring new redshift connection "parsely_base_events".
2017-12-21 03:50:21,372: Re-using an available connection from the pool.
2017-12-21 03:50:21,372: Using redshift connection "parsely_base_events".
2017-12-21 03:50:21,372: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:21,393: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:21,394: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 03:50:21,399: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 03:50:21,403: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 03:50:21,405: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 03:50:21,407: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 03:50:21,410: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 03:50:21,416: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 03:50:21,423: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 03:50:21,428: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:50:21,428: Re-using an available connection from the pool.
2017-12-21 03:50:21,428: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:50:21,428: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:21,446: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:21,446: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 03:50:21,453: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 03:50:21,458: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:50:21,458: Re-using an available connection from the pool.
2017-12-21 03:50:21,458: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:50:21,458: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:21,475: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:21,475: Parsing model.parsely.parsely_incoming_users
2017-12-21 03:50:21,478: Parsing model.parsely.parsely_users
2017-12-21 03:50:21,483: Acquiring new redshift connection "parsely_users".
2017-12-21 03:50:21,483: Re-using an available connection from the pool.
2017-12-21 03:50:21,483: Using redshift connection "parsely_users".
2017-12-21 03:50:21,483: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:21,502: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:21,503: Parsing model.parsely.parsely_errors
2017-12-21 03:50:21,507: Parsing model.parsely.parsely_bot_traffic
2017-12-21 03:50:21,511: Parsing model.parsely.parsely_custom_events
2017-12-21 03:50:21,515: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 03:50:21,519: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 03:50:21,522: Parsing model.parsely.parsely_sessions
2017-12-21 03:50:21,527: Acquiring new redshift connection "parsely_sessions".
2017-12-21 03:50:21,527: Re-using an available connection from the pool.
2017-12-21 03:50:21,527: Using redshift connection "parsely_sessions".
2017-12-21 03:50:21,527: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:21,547: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:21,547: Parsing model.parsely.parsely_campaigns
2017-12-21 03:50:21,551: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 03:50:21,551: Re-using an available connection from the pool.
2017-12-21 03:50:21,551: Using redshift connection "parsely_campaigns".
2017-12-21 03:50:21,551: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:21,567: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:21,573: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 03:50:21,578: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 03:50:21,582: 
2017-12-21 03:50:21,585: Acquiring new redshift connection "master".
2017-12-21 03:50:21,585: Re-using an available connection from the pool.
2017-12-21 03:50:21,585: Using redshift connection "master".
2017-12-21 03:50:21,585: On master: select distinct nspname from pg_namespace
2017-12-21 03:50:21,587: SQL status: SELECT in 0.00 seconds
2017-12-21 03:50:21,590: Using redshift connection "master".
2017-12-21 03:50:21,590: On master: BEGIN
2017-12-21 03:50:21,591: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:50:21,591: On master: COMMIT
2017-12-21 03:50:21,591: Using redshift connection "master".
2017-12-21 03:50:21,591: On master: COMMIT
2017-12-21 03:50:21,593: SQL status: COMMIT in 0.00 seconds
2017-12-21 03:50:21,598: 03:50:21 | Concurrency: 1 threads (target='dev')
2017-12-21 03:50:21,598: 03:50:21 | 
2017-12-21 03:50:21,599: Using redshift connection "master".
2017-12-21 03:50:21,599: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:21,618: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:21,636: 03:50:21 | 1 of 6 START view model blog_dbt_dev.parsely_incoming_pageviews...... [RUN]
2017-12-21 03:50:21,637: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 03:50:21,647: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 03:50:21,648: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 03:50:21,648: Opening a new connection (1 currently allocated)
2017-12-21 03:50:21,660: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 03:50:21,660: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:21,685: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:21,690: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 03:50:21,691: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 03:50:21,691: On parsely_incoming_pageviews: BEGIN
2017-12-21 03:50:21,692: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:50:21,693: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 03:50:21,693: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 03:50:21,701: Postgres error: relation "blog_dbt_dev.parsely_videoviews_sessionized" does not exist

2017-12-21 03:50:21,701: On parsely_incoming_pageviews: ROLLBACK
2017-12-21 03:50:21,702: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7b8f010f90>], 'label': '2bb524f8-7d68-433b-9d7b-7d87ed244b49'}
2017-12-21 03:50:21,731: 03:50:21 | 1 of 6 ERROR creating view model blog_dbt_dev.parsely_incoming_pageviews [ERROR in 0.07s]
2017-12-21 03:50:21,732: 03:50:21 | 2 of 6 SKIP relation blog_dbt_dev.parsely_pageviews_sessionized...... [SKIP]
2017-12-21 03:50:21,732: 03:50:21 | 3 of 6 SKIP relation blog_dbt_dev.parsely_campaigns.................. [SKIP]
2017-12-21 03:50:21,733: 03:50:21 | 4 of 6 SKIP relation blog_dbt_dev.parsely_users...................... [SKIP]
2017-12-21 03:50:21,733: 03:50:21 | 5 of 6 SKIP relation blog_dbt_dev.parsely_incoming_sessions.......... [SKIP]
2017-12-21 03:50:21,734: 03:50:21 | 6 of 6 SKIP relation blog_dbt_dev.parsely_sessions................... [SKIP]
2017-12-21 03:50:21,739: Using redshift connection "master".
2017-12-21 03:50:21,739: On master: BEGIN
2017-12-21 03:50:21,741: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:50:21,741: On master: COMMIT
2017-12-21 03:50:21,741: Using redshift connection "master".
2017-12-21 03:50:21,742: On master: COMMIT
2017-12-21 03:50:21,743: SQL status: COMMIT in 0.00 seconds
2017-12-21 03:50:21,743: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 03:50:21,748: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 03:50:21,748: Using redshift connection "master".
2017-12-21 03:50:21,749: On master:  select 1 
2017-12-21 03:50:21,750: SQL status: SELECT in 0.00 seconds
2017-12-21 03:50:21,751: 03:50:21 | 
2017-12-21 03:50:21,751: 03:50:21 | Finished running 2 view models, 4 incremental models in 0.14s.
2017-12-21 03:50:21,751: 
2017-12-21 03:50:21,751: Completed with 1 errors:
2017-12-21 03:50:21,752: 
2017-12-21 03:50:21,752: Database Error in model parsely_incoming_pageviews (models/pageviews/parsely_incoming_pageviews.sql)
2017-12-21 03:50:21,752:   relation "blog_dbt_dev.parsely_videoviews_sessionized" does not exist
2017-12-21 03:50:21,752:   compiled SQL at target/run/parsely/pageviews/parsely_incoming_pageviews.sql
2017-12-21 03:50:21,752: 
Done. PASS=0 ERROR=1 SKIP=5 TOTAL=6
2017-12-21 03:50:21,753: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7b8f0a8250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7b8f0a84d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f7b9c15f910>], 'label': 'end'}
2017-12-21 03:50:21,781: Flushing usage events
2017-12-21 03:50:36,494: Tracking: tracking
2017-12-21 03:50:36,494: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f64a9934250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f64a99344d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f64a9934310>], 'label': 'start'}
2017-12-21 03:50:36,531: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 03:50:36,547: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 03:50:36,548: Parsing core.sql
2017-12-21 03:50:36,559: Parsing etc/get_custom_schema.sql
2017-12-21 03:50:36,564: Parsing schema_tests/relationships.sql
2017-12-21 03:50:36,566: Parsing schema_tests/accepted_values.sql
2017-12-21 03:50:36,569: Parsing schema_tests/not_null.sql
2017-12-21 03:50:36,571: Parsing schema_tests/unique.sql
2017-12-21 03:50:36,573: Parsing materializations/wrapper.sql
2017-12-21 03:50:36,576: Parsing materializations/archive.sql
2017-12-21 03:50:36,603: Parsing materializations/table.sql
2017-12-21 03:50:36,620: Parsing materializations/helpers.sql
2017-12-21 03:50:36,635: Parsing materializations/bigquery.sql
2017-12-21 03:50:36,647: Parsing materializations/view.sql
2017-12-21 03:50:36,661: Parsing materializations/incremental.sql
2017-12-21 03:50:36,685: Parsing adapters/redshift.sql
2017-12-21 03:50:36,702: Parsing adapters/bigquery.sql
2017-12-21 03:50:36,706: Parsing adapters/postgres.sql
2017-12-21 03:50:36,709: Parsing adapters/common.sql
2017-12-21 03:50:36,727: Parsing model.parsely.parsely_audit
2017-12-21 03:50:36,728: Parsing model.parsely.parsely_video_content
2017-12-21 03:50:36,731: Parsing model.parsely.parsely_post_content
2017-12-21 03:50:36,734: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 03:50:36,736: Parsing model.parsely.parsely_rawdata
2017-12-21 03:50:36,739: Parsing model.parsely.calendar
2017-12-21 03:50:36,740: Parsing model.parsely.parsely_all_events
2017-12-21 03:50:36,748: Acquiring new redshift connection "parsely_all_events".
2017-12-21 03:50:36,748: Opening a new connection (0 currently allocated)
2017-12-21 03:50:36,761: Using redshift connection "parsely_all_events".
2017-12-21 03:50:36,761: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:36,785: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:36,791: Parsing model.parsely.parsely_event_ids
2017-12-21 03:50:36,793: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 03:50:36,795: Parsing model.parsely.parsely_base_events
2017-12-21 03:50:36,799: Acquiring new redshift connection "parsely_base_events".
2017-12-21 03:50:36,799: Re-using an available connection from the pool.
2017-12-21 03:50:36,799: Using redshift connection "parsely_base_events".
2017-12-21 03:50:36,799: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:36,816: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:36,817: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 03:50:36,822: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 03:50:36,827: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 03:50:36,829: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 03:50:36,830: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 03:50:36,833: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 03:50:36,839: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 03:50:36,846: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 03:50:36,851: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:50:36,851: Re-using an available connection from the pool.
2017-12-21 03:50:36,851: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:50:36,851: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:36,868: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:36,868: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 03:50:36,875: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 03:50:36,880: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:50:36,880: Re-using an available connection from the pool.
2017-12-21 03:50:36,880: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:50:36,880: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:36,900: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:36,900: Parsing model.parsely.parsely_incoming_users
2017-12-21 03:50:36,903: Parsing model.parsely.parsely_users
2017-12-21 03:50:36,908: Acquiring new redshift connection "parsely_users".
2017-12-21 03:50:36,908: Re-using an available connection from the pool.
2017-12-21 03:50:36,908: Using redshift connection "parsely_users".
2017-12-21 03:50:36,908: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:36,925: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:36,925: Parsing model.parsely.parsely_errors
2017-12-21 03:50:36,929: Parsing model.parsely.parsely_bot_traffic
2017-12-21 03:50:36,933: Parsing model.parsely.parsely_custom_events
2017-12-21 03:50:36,938: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 03:50:36,941: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 03:50:36,944: Parsing model.parsely.parsely_sessions
2017-12-21 03:50:36,949: Acquiring new redshift connection "parsely_sessions".
2017-12-21 03:50:36,949: Re-using an available connection from the pool.
2017-12-21 03:50:36,950: Using redshift connection "parsely_sessions".
2017-12-21 03:50:36,950: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:36,966: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:36,967: Parsing model.parsely.parsely_campaigns
2017-12-21 03:50:36,970: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 03:50:36,970: Re-using an available connection from the pool.
2017-12-21 03:50:36,970: Using redshift connection "parsely_campaigns".
2017-12-21 03:50:36,971: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:36,988: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:36,993: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 03:50:36,998: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 03:50:37,003: 
2017-12-21 03:50:37,005: Acquiring new redshift connection "master".
2017-12-21 03:50:37,005: Re-using an available connection from the pool.
2017-12-21 03:50:37,006: Using redshift connection "master".
2017-12-21 03:50:37,006: On master: select distinct nspname from pg_namespace
2017-12-21 03:50:37,008: SQL status: SELECT in 0.00 seconds
2017-12-21 03:50:37,010: Using redshift connection "master".
2017-12-21 03:50:37,011: On master: BEGIN
2017-12-21 03:50:37,012: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:50:37,012: On master: COMMIT
2017-12-21 03:50:37,012: Using redshift connection "master".
2017-12-21 03:50:37,012: On master: COMMIT
2017-12-21 03:50:37,014: SQL status: COMMIT in 0.00 seconds
2017-12-21 03:50:37,019: 03:50:37 | Concurrency: 1 threads (target='dev')
2017-12-21 03:50:37,019: 03:50:37 | 
2017-12-21 03:50:37,019: Using redshift connection "master".
2017-12-21 03:50:37,020: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:37,039: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:37,063: 03:50:37 | 1 of 8 START view model blog_dbt_dev.parsely_incoming_videoviews..... [RUN]
2017-12-21 03:50:37,063: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 03:50:37,073: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 03:50:37,074: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:37,074: Opening a new connection (1 currently allocated)
2017-12-21 03:50:37,086: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:37,086: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:37,109: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:37,113: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 03:50:37,114: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:37,114: On parsely_incoming_videoviews: BEGIN
2017-12-21 03:50:37,115: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:50:37,115: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:37,115: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as watch_time

    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 03:50:37,225: SQL status: CREATE VIEW in 0.11 seconds
2017-12-21 03:50:37,225: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:50:37,225: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:37,225: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:50:37,417: SQL status: COMMIT in 0.19 seconds
2017-12-21 03:50:37,417: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:37,417: On parsely_incoming_videoviews: BEGIN
2017-12-21 03:50:37,419: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:50:37,420: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:37,420: On parsely_incoming_videoviews: drop view if exists "blog_dbt_dev"."parsely_incoming_videoviews" cascade
2017-12-21 03:50:37,888: SQL status: DROP VIEW in 0.47 seconds
2017-12-21 03:50:37,888: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:50:37,889: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:37,889: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:50:38,418: SQL status: COMMIT in 0.53 seconds
2017-12-21 03:50:38,419: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:38,419: On parsely_incoming_videoviews: BEGIN
2017-12-21 03:50:38,421: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:50:38,421: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:38,421: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 03:50:38,429: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 03:50:38,429: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:50:38,429: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:50:38,430: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:50:38,628: SQL status: COMMIT in 0.20 seconds
2017-12-21 03:50:38,628: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f64a989cdd0>], 'label': '403d6962-4914-4738-a527-aaaa9c6680fe'}
2017-12-21 03:50:38,662: 03:50:38 | 1 of 8 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.56s]
2017-12-21 03:50:38,662: 03:50:38 | 2 of 8 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 03:50:38,663: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 03:50:38,668: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:50:38,668: Re-using an available connection from the pool.
2017-12-21 03:50:38,668: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:50:38,668: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:38,689: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:38,692: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 03:50:38,693: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:50:38,693: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:38,712: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:38,712: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:50:38,712: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:50:38,732: SQL status: SELECT in 0.02 seconds
2017-12-21 03:50:38,733: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 03:50:38,734: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:50:38,734: On parsely_videoviews_sessionized: BEGIN
2017-12-21 03:50:38,736: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:50:38,736: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:50:38,736: On parsely_videoviews_sessionized: 
    
  

  create  table "blog_dbt_dev"."parsely_videoviews_sessionized"
  
  
  as (
    

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




-- initial run, don't merge
merged as (

    select
      *
    from incoming_videoviews
)



select
  *
from merged
  );
2017-12-21 03:50:41,577: Postgres error: Invalid digit, Value '-', Pos 4, Type: Long 
DETAIL:  
  -----------------------------------------------
  error:  Invalid digit, Value '-', Pos 4, Type: Long 
  code:      1207
  context:   2016-01-20
  query:     97076
  location:  :0
  process:   query0_89 [pid=0]
  -----------------------------------------------


2017-12-21 03:50:41,577: On parsely_videoviews_sessionized: ROLLBACK
2017-12-21 03:50:41,579: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f64a9834450>], 'label': '403d6962-4914-4738-a527-aaaa9c6680fe'}
2017-12-21 03:50:41,608: 03:50:41 | 2 of 8 ERROR creating incremental model blog_dbt_dev.parsely_videoviews_sessionized [ERROR in 2.92s]
2017-12-21 03:50:41,609: 03:50:41 | 3 of 8 SKIP relation blog_dbt_dev.parsely_incoming_pageviews......... [SKIP]
2017-12-21 03:50:41,609: 03:50:41 | 4 of 8 SKIP relation blog_dbt_dev.parsely_pageviews_sessionized...... [SKIP]
2017-12-21 03:50:41,610: 03:50:41 | 5 of 8 SKIP relation blog_dbt_dev.parsely_campaigns.................. [SKIP]
2017-12-21 03:50:41,610: 03:50:41 | 6 of 8 SKIP relation blog_dbt_dev.parsely_users...................... [SKIP]
2017-12-21 03:50:41,610: 03:50:41 | 7 of 8 SKIP relation blog_dbt_dev.parsely_incoming_sessions.......... [SKIP]
2017-12-21 03:50:41,611: 03:50:41 | 8 of 8 SKIP relation blog_dbt_dev.parsely_sessions................... [SKIP]
2017-12-21 03:50:41,675: Using redshift connection "master".
2017-12-21 03:50:41,675: On master: BEGIN
2017-12-21 03:50:41,677: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:50:41,677: On master: COMMIT
2017-12-21 03:50:41,678: Using redshift connection "master".
2017-12-21 03:50:41,678: On master: COMMIT
2017-12-21 03:50:41,679: SQL status: COMMIT in 0.00 seconds
2017-12-21 03:50:41,679: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 03:50:41,684: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 03:50:41,685: Using redshift connection "master".
2017-12-21 03:50:41,685: On master:  select 1 
2017-12-21 03:50:41,687: SQL status: SELECT in 0.00 seconds
2017-12-21 03:50:41,687: 03:50:41 | 
2017-12-21 03:50:41,688: 03:50:41 | Finished running 3 view models, 5 incremental models in 4.66s.
2017-12-21 03:50:41,688: 
2017-12-21 03:50:41,688: Completed with 1 errors:
2017-12-21 03:50:41,689: 
2017-12-21 03:50:41,689: Database Error in model parsely_videoviews_sessionized (models/videoviews/parsely_videoviews_sessionized.sql)
2017-12-21 03:50:41,689:   Invalid digit, Value '-', Pos 4, Type: Long 
2017-12-21 03:50:41,689:   DETAIL:  
2017-12-21 03:50:41,689:     -----------------------------------------------
2017-12-21 03:50:41,689:     error:  Invalid digit, Value '-', Pos 4, Type: Long 
2017-12-21 03:50:41,690:     code:      1207
2017-12-21 03:50:41,690:     context:   2016-01-20
2017-12-21 03:50:41,690:     query:     97076
2017-12-21 03:50:41,690:     location:  :0
2017-12-21 03:50:41,690:     process:   query0_89 [pid=0]
2017-12-21 03:50:41,690:     -----------------------------------------------
2017-12-21 03:50:41,690:   compiled SQL at target/run/parsely/videoviews/parsely_videoviews_sessionized.sql
2017-12-21 03:50:41,691: 
Done. PASS=1 ERROR=1 SKIP=6 TOTAL=8
2017-12-21 03:50:41,691: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f64a9934250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f64a99344d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f64b69eb910>], 'label': 'end'}
2017-12-21 03:50:41,719: Flushing usage events
2017-12-21 03:54:04,307: Tracking: tracking
2017-12-21 03:54:04,447: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7c4a250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7c4a4d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7c4a310>], 'label': 'start'}
2017-12-21 03:54:04,512: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 03:54:04,528: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 03:54:04,529: Parsing core.sql
2017-12-21 03:54:04,541: Parsing etc/get_custom_schema.sql
2017-12-21 03:54:04,546: Parsing schema_tests/relationships.sql
2017-12-21 03:54:04,548: Parsing schema_tests/accepted_values.sql
2017-12-21 03:54:04,551: Parsing schema_tests/not_null.sql
2017-12-21 03:54:04,552: Parsing schema_tests/unique.sql
2017-12-21 03:54:04,554: Parsing materializations/wrapper.sql
2017-12-21 03:54:04,557: Parsing materializations/archive.sql
2017-12-21 03:54:04,585: Parsing materializations/table.sql
2017-12-21 03:54:04,602: Parsing materializations/helpers.sql
2017-12-21 03:54:04,616: Parsing materializations/bigquery.sql
2017-12-21 03:54:04,629: Parsing materializations/view.sql
2017-12-21 03:54:04,642: Parsing materializations/incremental.sql
2017-12-21 03:54:04,666: Parsing adapters/redshift.sql
2017-12-21 03:54:04,683: Parsing adapters/bigquery.sql
2017-12-21 03:54:04,687: Parsing adapters/postgres.sql
2017-12-21 03:54:04,690: Parsing adapters/common.sql
2017-12-21 03:54:04,708: Parsing model.parsely.parsely_audit
2017-12-21 03:54:04,709: Parsing model.parsely.parsely_video_content
2017-12-21 03:54:04,712: Parsing model.parsely.parsely_post_content
2017-12-21 03:54:04,715: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 03:54:04,717: Parsing model.parsely.parsely_rawdata
2017-12-21 03:54:04,720: Parsing model.parsely.calendar
2017-12-21 03:54:04,721: Parsing model.parsely.parsely_all_events
2017-12-21 03:54:04,730: Acquiring new redshift connection "parsely_all_events".
2017-12-21 03:54:04,730: Opening a new connection (0 currently allocated)
2017-12-21 03:54:04,759: Using redshift connection "parsely_all_events".
2017-12-21 03:54:04,759: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:04,785: SQL status: SELECT in 0.03 seconds
2017-12-21 03:54:04,790: Parsing model.parsely.parsely_event_ids
2017-12-21 03:54:04,792: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 03:54:04,795: Parsing model.parsely.parsely_base_events
2017-12-21 03:54:04,798: Acquiring new redshift connection "parsely_base_events".
2017-12-21 03:54:04,798: Re-using an available connection from the pool.
2017-12-21 03:54:04,799: Using redshift connection "parsely_base_events".
2017-12-21 03:54:04,799: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:04,816: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:04,817: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 03:54:04,822: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 03:54:04,826: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 03:54:04,828: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 03:54:04,830: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 03:54:04,833: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 03:54:04,839: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 03:54:04,845: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 03:54:04,850: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:54:04,851: Re-using an available connection from the pool.
2017-12-21 03:54:04,851: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:54:04,851: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:04,869: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:04,870: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 03:54:04,876: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 03:54:04,881: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:54:04,881: Re-using an available connection from the pool.
2017-12-21 03:54:04,881: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:54:04,881: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:04,901: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:04,901: Parsing model.parsely.parsely_incoming_users
2017-12-21 03:54:04,904: Parsing model.parsely.parsely_users
2017-12-21 03:54:04,909: Acquiring new redshift connection "parsely_users".
2017-12-21 03:54:04,909: Re-using an available connection from the pool.
2017-12-21 03:54:04,909: Using redshift connection "parsely_users".
2017-12-21 03:54:04,909: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:04,926: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:04,926: Parsing model.parsely.parsely_errors
2017-12-21 03:54:04,930: Parsing model.parsely.parsely_bot_traffic
2017-12-21 03:54:04,934: Parsing model.parsely.parsely_custom_events
2017-12-21 03:54:04,939: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 03:54:04,942: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 03:54:04,945: Parsing model.parsely.parsely_sessions
2017-12-21 03:54:04,950: Acquiring new redshift connection "parsely_sessions".
2017-12-21 03:54:04,951: Re-using an available connection from the pool.
2017-12-21 03:54:04,951: Using redshift connection "parsely_sessions".
2017-12-21 03:54:04,951: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:04,971: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:04,971: Parsing model.parsely.parsely_campaigns
2017-12-21 03:54:04,975: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 03:54:04,975: Re-using an available connection from the pool.
2017-12-21 03:54:04,975: Using redshift connection "parsely_campaigns".
2017-12-21 03:54:04,975: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:04,996: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:05,001: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 03:54:05,007: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 03:54:05,012: 
2017-12-21 03:54:05,014: Acquiring new redshift connection "master".
2017-12-21 03:54:05,014: Re-using an available connection from the pool.
2017-12-21 03:54:05,014: Using redshift connection "master".
2017-12-21 03:54:05,015: On master: select distinct nspname from pg_namespace
2017-12-21 03:54:05,017: SQL status: SELECT in 0.00 seconds
2017-12-21 03:54:05,019: Using redshift connection "master".
2017-12-21 03:54:05,019: On master: BEGIN
2017-12-21 03:54:05,021: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:54:05,021: On master: COMMIT
2017-12-21 03:54:05,021: Using redshift connection "master".
2017-12-21 03:54:05,021: On master: COMMIT
2017-12-21 03:54:05,022: SQL status: COMMIT in 0.00 seconds
2017-12-21 03:54:05,028: 03:54:05 | Concurrency: 1 threads (target='dev')
2017-12-21 03:54:05,028: 03:54:05 | 
2017-12-21 03:54:05,028: Using redshift connection "master".
2017-12-21 03:54:05,028: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:05,048: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:05,072: 03:54:05 | 1 of 8 START view model blog_dbt_dev.parsely_incoming_videoviews..... [RUN]
2017-12-21 03:54:05,072: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 03:54:05,082: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 03:54:05,083: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:05,083: Opening a new connection (1 currently allocated)
2017-12-21 03:54:05,095: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:05,095: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:05,122: SQL status: SELECT in 0.03 seconds
2017-12-21 03:54:05,125: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 03:54:05,127: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:05,127: On parsely_incoming_videoviews: BEGIN
2017-12-21 03:54:05,128: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:54:05,128: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:05,128: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 03:54:06,166: SQL status: CREATE VIEW in 1.04 seconds
2017-12-21 03:54:06,166: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:54:06,167: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:06,167: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:54:06,479: SQL status: COMMIT in 0.31 seconds
2017-12-21 03:54:06,480: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:06,480: On parsely_incoming_videoviews: BEGIN
2017-12-21 03:54:06,482: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:54:06,482: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:06,482: On parsely_incoming_videoviews: drop view if exists "blog_dbt_dev"."parsely_incoming_videoviews" cascade
2017-12-21 03:54:06,530: SQL status: DROP VIEW in 0.05 seconds
2017-12-21 03:54:06,530: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:54:06,530: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:06,530: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:54:06,771: SQL status: COMMIT in 0.24 seconds
2017-12-21 03:54:06,772: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:06,772: On parsely_incoming_videoviews: BEGIN
2017-12-21 03:54:06,774: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:54:06,774: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:06,774: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 03:54:06,780: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 03:54:06,780: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:54:06,780: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 03:54:06,780: On parsely_incoming_videoviews: COMMIT
2017-12-21 03:54:07,030: SQL status: COMMIT in 0.25 seconds
2017-12-21 03:54:07,031: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7bb2dd0>], 'label': 'd0c1f4e6-64bb-4a49-bbd1-fc64f197877b'}
2017-12-21 03:54:07,056: 03:54:07 | 1 of 8 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.96s]
2017-12-21 03:54:07,057: 03:54:07 | 2 of 8 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 03:54:07,057: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 03:54:07,062: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:54:07,062: Re-using an available connection from the pool.
2017-12-21 03:54:07,062: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:54:07,062: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:07,082: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:07,085: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 03:54:07,086: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:54:07,086: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:07,105: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:07,105: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:54:07,105: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:07,124: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:07,126: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 03:54:07,126: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:54:07,127: On parsely_videoviews_sessionized: BEGIN
2017-12-21 03:54:07,128: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:54:07,128: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:54:07,129: On parsely_videoviews_sessionized: 
    
  

  create  table "blog_dbt_dev"."parsely_videoviews_sessionized"
  
  
  as (
    

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




-- initial run, don't merge
merged as (

    select
      *
    from incoming_videoviews
)



select
  *
from merged
  );
2017-12-21 03:54:48,802: SQL status: SELECT in 41.67 seconds
2017-12-21 03:54:48,803: On parsely_videoviews_sessionized: COMMIT
2017-12-21 03:54:48,803: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 03:54:48,803: On parsely_videoviews_sessionized: COMMIT
2017-12-21 03:54:50,522: SQL status: COMMIT in 1.72 seconds
2017-12-21 03:54:50,523: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7c43290>], 'label': 'd0c1f4e6-64bb-4a49-bbd1-fc64f197877b'}
2017-12-21 03:54:50,552: 03:54:50 | 2 of 8 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [SELECT in 43.47s]
2017-12-21 03:54:50,553: 03:54:50 | 3 of 8 START view model blog_dbt_dev.parsely_incoming_pageviews...... [RUN]
2017-12-21 03:54:50,553: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 03:54:50,563: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 03:54:50,565: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 03:54:50,565: Re-using an available connection from the pool.
2017-12-21 03:54:50,565: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 03:54:50,565: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:50,584: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:50,587: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 03:54:50,588: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 03:54:50,588: On parsely_incoming_pageviews: BEGIN
2017-12-21 03:54:50,590: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:54:50,590: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 03:54:50,590: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 03:54:50,686: SQL status: CREATE VIEW in 0.10 seconds
2017-12-21 03:54:50,686: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 03:54:50,686: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2017-12-21 03:54:50,691: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 03:54:50,691: On parsely_incoming_pageviews: COMMIT
2017-12-21 03:54:50,691: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 03:54:50,691: On parsely_incoming_pageviews: COMMIT
2017-12-21 03:54:50,958: SQL status: COMMIT in 0.27 seconds
2017-12-21 03:54:50,959: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7c43350>], 'label': 'd0c1f4e6-64bb-4a49-bbd1-fc64f197877b'}
2017-12-21 03:54:50,983: 03:54:50 | 3 of 8 OK created view model blog_dbt_dev.parsely_incoming_pageviews. [CREATE VIEW in 0.41s]
2017-12-21 03:54:50,983: 03:54:50 | 4 of 8 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2017-12-21 03:54:50,983: Compiling model.parsely.parsely_pageviews_sessionized
2017-12-21 03:54:50,988: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:54:50,988: Re-using an available connection from the pool.
2017-12-21 03:54:50,988: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:54:50,988: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:51,006: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:51,009: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 03:54:51,010: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:54:51,010: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:51,025: SQL status: SELECT in 0.02 seconds
2017-12-21 03:54:51,026: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:54:51,026: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:54:51,041: SQL status: SELECT in 0.01 seconds
2017-12-21 03:54:51,042: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 03:54:51,043: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:54:51,043: On parsely_pageviews_sessionized: BEGIN
2017-12-21 03:54:51,045: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:54:51,045: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:54:51,045: On parsely_pageviews_sessionized: 
    
  

  create  table "blog_dbt_dev"."parsely_pageviews_sessionized"
  
  
  as (
    

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




-- initial run, don't merge
merged as (

    select
      *
    from incoming_pageviews
)



select
  *
from merged
  );
2017-12-21 03:56:03,950: SQL status: SELECT in 72.91 seconds
2017-12-21 03:56:03,951: On parsely_pageviews_sessionized: COMMIT
2017-12-21 03:56:03,951: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 03:56:03,951: On parsely_pageviews_sessionized: COMMIT
2017-12-21 03:56:06,678: SQL status: COMMIT in 2.73 seconds
2017-12-21 03:56:06,679: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7c432d0>], 'label': 'd0c1f4e6-64bb-4a49-bbd1-fc64f197877b'}
2017-12-21 03:56:06,727: 03:56:06 | 4 of 8 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [SELECT in 75.70s]
2017-12-21 03:56:06,727: 03:56:06 | 5 of 8 START incremental model blog_dbt_dev.parsely_campaigns........ [RUN]
2017-12-21 03:56:06,727: Compiling model.parsely.parsely_campaigns
2017-12-21 03:56:06,731: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 03:56:06,731: Re-using an available connection from the pool.
2017-12-21 03:56:06,731: Using redshift connection "parsely_campaigns".
2017-12-21 03:56:06,731: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:56:06,752: SQL status: SELECT in 0.02 seconds
2017-12-21 03:56:06,755: Writing injected SQL for node "model.parsely.parsely_campaigns"
2017-12-21 03:56:06,756: Using redshift connection "parsely_campaigns".
2017-12-21 03:56:06,756: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:56:06,778: SQL status: SELECT in 0.02 seconds
2017-12-21 03:56:06,778: Using redshift connection "parsely_campaigns".
2017-12-21 03:56:06,778: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:56:06,800: SQL status: SELECT in 0.02 seconds
2017-12-21 03:56:06,802: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2017-12-21 03:56:06,802: Using redshift connection "parsely_campaigns".
2017-12-21 03:56:06,802: On parsely_campaigns: BEGIN
2017-12-21 03:56:06,804: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:56:06,805: Using redshift connection "parsely_campaigns".
2017-12-21 03:56:06,805: On parsely_campaigns: 
    
  

  create  table "blog_dbt_dev"."parsely_campaigns"
  
  
  as (
    -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



-- initial run, don't merge
merged as (

    select
      *
    from incoming_campaigns
),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
  );
2017-12-21 03:56:15,778: SQL status: SELECT in 8.97 seconds
2017-12-21 03:56:15,779: On parsely_campaigns: COMMIT
2017-12-21 03:56:15,779: Using redshift connection "parsely_campaigns".
2017-12-21 03:56:15,779: On parsely_campaigns: COMMIT
2017-12-21 03:56:16,234: SQL status: COMMIT in 0.45 seconds
2017-12-21 03:56:16,235: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7bb2b90>], 'label': 'd0c1f4e6-64bb-4a49-bbd1-fc64f197877b'}
2017-12-21 03:56:16,260: 03:56:16 | 5 of 8 OK created incremental model blog_dbt_dev.parsely_campaigns... [SELECT in 9.51s]
2017-12-21 03:56:16,261: Compiling model.parsely.parsely_incoming_users
2017-12-21 03:56:16,266: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 03:56:16,267: 03:56:16 | 6 of 8 START incremental model blog_dbt_dev.parsely_users............ [RUN]
2017-12-21 03:56:16,267: Compiling model.parsely.parsely_users
2017-12-21 03:56:16,272: Acquiring new redshift connection "parsely_users".
2017-12-21 03:56:16,273: Re-using an available connection from the pool.
2017-12-21 03:56:16,273: Using redshift connection "parsely_users".
2017-12-21 03:56:16,273: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:56:16,295: SQL status: SELECT in 0.02 seconds
2017-12-21 03:56:16,324: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 03:56:16,326: Using redshift connection "parsely_users".
2017-12-21 03:56:16,326: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:56:16,347: SQL status: SELECT in 0.02 seconds
2017-12-21 03:56:16,348: Using redshift connection "parsely_users".
2017-12-21 03:56:16,348: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:56:16,369: SQL status: SELECT in 0.02 seconds
2017-12-21 03:56:16,372: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 03:56:16,373: Using redshift connection "parsely_users".
2017-12-21 03:56:16,373: On parsely_users: BEGIN
2017-12-21 03:56:16,375: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:56:16,375: Using redshift connection "parsely_users".
2017-12-21 03:56:16,375: On parsely_users: 
    
  

  create  table "blog_dbt_dev"."parsely_users"
  
  
  as (
    -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3,4
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3,4
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      visitor_ip,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3,4
),



-- initial run, don't merge
merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        date(min(last_timestamp)) as date_first_seen,
        date(max(last_timestamp)) as date_last_seen,
        -- metrics to aggregate
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from incoming_users
    group by 1,2,3,4
)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    visitor_ip,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
  );
2017-12-21 03:56:30,787: SQL status: SELECT in 14.41 seconds
2017-12-21 03:56:30,787: On parsely_users: COMMIT
2017-12-21 03:56:30,787: Using redshift connection "parsely_users".
2017-12-21 03:56:30,787: On parsely_users: COMMIT
2017-12-21 03:56:31,078: SQL status: COMMIT in 0.29 seconds
2017-12-21 03:56:31,078: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7bb2390>], 'label': 'd0c1f4e6-64bb-4a49-bbd1-fc64f197877b'}
2017-12-21 03:56:31,105: 03:56:31 | 6 of 8 OK created incremental model blog_dbt_dev.parsely_users....... [SELECT in 14.81s]
2017-12-21 03:56:31,105: 03:56:31 | 7 of 8 START view model blog_dbt_dev.parsely_incoming_sessions....... [RUN]
2017-12-21 03:56:31,105: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 03:56:31,112: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 03:56:31,113: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 03:56:31,113: Re-using an available connection from the pool.
2017-12-21 03:56:31,113: Using redshift connection "parsely_incoming_sessions".
2017-12-21 03:56:31,113: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:56:31,135: SQL status: SELECT in 0.02 seconds
2017-12-21 03:56:31,138: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 03:56:31,139: Using redshift connection "parsely_incoming_sessions".
2017-12-21 03:56:31,139: On parsely_incoming_sessions: BEGIN
2017-12-21 03:56:31,141: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:56:31,141: Using redshift connection "parsely_incoming_sessions".
2017-12-21 03:56:31,141: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 03:56:31,209: SQL status: CREATE VIEW in 0.07 seconds
2017-12-21 03:56:31,209: Using redshift connection "parsely_incoming_sessions".
2017-12-21 03:56:31,209: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 03:56:31,212: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 03:56:31,213: On parsely_incoming_sessions: COMMIT
2017-12-21 03:56:31,213: Using redshift connection "parsely_incoming_sessions".
2017-12-21 03:56:31,213: On parsely_incoming_sessions: COMMIT
2017-12-21 03:56:31,378: SQL status: COMMIT in 0.17 seconds
2017-12-21 03:56:31,379: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7bfd850>], 'label': 'd0c1f4e6-64bb-4a49-bbd1-fc64f197877b'}
2017-12-21 03:56:31,406: 03:56:31 | 7 of 8 OK created view model blog_dbt_dev.parsely_incoming_sessions.. [CREATE VIEW in 0.27s]
2017-12-21 03:56:31,406: 03:56:31 | 8 of 8 START incremental model blog_dbt_dev.parsely_sessions......... [RUN]
2017-12-21 03:56:31,406: Compiling model.parsely.parsely_sessions
2017-12-21 03:56:31,412: Acquiring new redshift connection "parsely_sessions".
2017-12-21 03:56:31,412: Re-using an available connection from the pool.
2017-12-21 03:56:31,412: Using redshift connection "parsely_sessions".
2017-12-21 03:56:31,412: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:56:31,434: SQL status: SELECT in 0.02 seconds
2017-12-21 03:56:31,437: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 03:56:31,439: Using redshift connection "parsely_sessions".
2017-12-21 03:56:31,439: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:56:31,461: SQL status: SELECT in 0.02 seconds
2017-12-21 03:56:31,461: Using redshift connection "parsely_sessions".
2017-12-21 03:56:31,461: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 03:56:31,482: SQL status: SELECT in 0.02 seconds
2017-12-21 03:56:31,484: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 03:56:31,485: Using redshift connection "parsely_sessions".
2017-12-21 03:56:31,485: On parsely_sessions: BEGIN
2017-12-21 03:56:31,487: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:56:31,487: Using redshift connection "parsely_sessions".
2017-12-21 03:56:31,487: On parsely_sessions: 
    
  

  create  table "blog_dbt_dev"."parsely_sessions"
  
  
  as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




-- initial run, don't merge
merged as (

    select
      *
    from incoming_sessions
)



select
    * --and derviced fields
from merged
  );
2017-12-21 03:57:23,691: SQL status: SELECT in 52.20 seconds
2017-12-21 03:57:23,691: On parsely_sessions: COMMIT
2017-12-21 03:57:23,691: Using redshift connection "parsely_sessions".
2017-12-21 03:57:23,691: On parsely_sessions: COMMIT
2017-12-21 03:57:25,121: SQL status: COMMIT in 1.43 seconds
2017-12-21 03:57:25,121: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7bfd390>], 'label': 'd0c1f4e6-64bb-4a49-bbd1-fc64f197877b'}
2017-12-21 03:57:25,180: 03:57:25 | 8 of 8 OK created incremental model blog_dbt_dev.parsely_sessions.... [SELECT in 53.71s]
2017-12-21 03:57:25,242: Using redshift connection "master".
2017-12-21 03:57:25,242: On master: BEGIN
2017-12-21 03:57:25,245: SQL status: BEGIN in 0.00 seconds
2017-12-21 03:57:25,245: On master: COMMIT
2017-12-21 03:57:25,245: Using redshift connection "master".
2017-12-21 03:57:25,245: On master: COMMIT
2017-12-21 03:57:25,247: SQL status: COMMIT in 0.00 seconds
2017-12-21 03:57:25,247: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 03:57:25,252: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 03:57:25,253: Using redshift connection "master".
2017-12-21 03:57:25,253: On master:  select 1 
2017-12-21 03:57:25,255: SQL status: SELECT in 0.00 seconds
2017-12-21 03:57:25,255: 03:57:25 | 
2017-12-21 03:57:25,255: 03:57:25 | Finished running 3 view models, 5 incremental models in 200.22s.
2017-12-21 03:57:25,255: 
2017-12-21 03:57:25,256: Completed successfully
2017-12-21 03:57:25,256: 
Done. PASS=8 ERROR=0 SKIP=0 TOTAL=8
2017-12-21 03:57:25,256: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7c4a250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7c4a4d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fdda7c31990>], 'label': 'end'}
2017-12-21 03:57:25,286: Flushing usage events
2017-12-21 14:55:06,050: Tracking: tracking
2017-12-21 14:55:06,050: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46828e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46828f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46828ed0>], 'label': 'start'}
2017-12-21 14:55:06,098: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 14:55:06,114: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 14:55:06,116: Parsing core.sql
2017-12-21 14:55:06,127: Parsing etc/get_custom_schema.sql
2017-12-21 14:55:06,132: Parsing schema_tests/relationships.sql
2017-12-21 14:55:06,134: Parsing schema_tests/accepted_values.sql
2017-12-21 14:55:06,137: Parsing schema_tests/not_null.sql
2017-12-21 14:55:06,139: Parsing schema_tests/unique.sql
2017-12-21 14:55:06,141: Parsing materializations/wrapper.sql
2017-12-21 14:55:06,144: Parsing materializations/archive.sql
2017-12-21 14:55:06,172: Parsing materializations/table.sql
2017-12-21 14:55:06,189: Parsing materializations/helpers.sql
2017-12-21 14:55:06,204: Parsing materializations/bigquery.sql
2017-12-21 14:55:06,216: Parsing materializations/view.sql
2017-12-21 14:55:06,230: Parsing materializations/incremental.sql
2017-12-21 14:55:06,254: Parsing adapters/redshift.sql
2017-12-21 14:55:06,272: Parsing adapters/bigquery.sql
2017-12-21 14:55:06,276: Parsing adapters/postgres.sql
2017-12-21 14:55:06,279: Parsing adapters/common.sql
2017-12-21 14:55:06,297: Parsing model.parsely.parsely_audit
2017-12-21 14:55:06,298: Parsing model.parsely.parsely_video_content
2017-12-21 14:55:06,301: Parsing model.parsely.parsely_post_content
2017-12-21 14:55:06,304: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 14:55:06,307: Parsing model.parsely.parsely_rawdata
2017-12-21 14:55:06,310: Parsing model.parsely.calendar
2017-12-21 14:55:06,311: Parsing model.parsely.parsely_all_events
2017-12-21 14:55:06,319: Acquiring new redshift connection "parsely_all_events".
2017-12-21 14:55:06,319: Opening a new connection (0 currently allocated)
2017-12-21 14:55:06,332: Using redshift connection "parsely_all_events".
2017-12-21 14:55:06,332: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:06,357: SQL status: SELECT in 0.02 seconds
2017-12-21 14:55:06,362: Parsing model.parsely.parsely_event_ids
2017-12-21 14:55:06,364: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 14:55:06,367: Parsing model.parsely.parsely_base_events
2017-12-21 14:55:06,370: Acquiring new redshift connection "parsely_base_events".
2017-12-21 14:55:06,370: Re-using an available connection from the pool.
2017-12-21 14:55:06,371: Using redshift connection "parsely_base_events".
2017-12-21 14:55:06,371: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:06,389: SQL status: SELECT in 0.02 seconds
2017-12-21 14:55:06,390: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 14:55:06,395: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 14:55:06,400: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 14:55:06,402: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 14:55:06,403: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 14:55:06,406: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 14:55:06,412: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 14:55:06,419: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 14:55:06,424: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 14:55:06,424: Re-using an available connection from the pool.
2017-12-21 14:55:06,424: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 14:55:06,425: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:06,444: SQL status: SELECT in 0.02 seconds
2017-12-21 14:55:06,444: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 14:55:06,451: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 14:55:06,456: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 14:55:06,456: Re-using an available connection from the pool.
2017-12-21 14:55:06,456: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 14:55:06,456: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:06,476: SQL status: SELECT in 0.02 seconds
2017-12-21 14:55:06,477: Parsing model.parsely.parsely_incoming_users
2017-12-21 14:55:06,480: Parsing model.parsely.parsely_users
2017-12-21 14:55:06,485: Acquiring new redshift connection "parsely_users".
2017-12-21 14:55:06,485: Re-using an available connection from the pool.
2017-12-21 14:55:06,485: Using redshift connection "parsely_users".
2017-12-21 14:55:06,485: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:06,503: SQL status: SELECT in 0.02 seconds
2017-12-21 14:55:06,503: Parsing model.parsely.parsely_errors
2017-12-21 14:55:06,507: Parsing model.parsely.parsely_bot_traffic
2017-12-21 14:55:06,511: Parsing model.parsely.parsely_custom_events
2017-12-21 14:55:06,516: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 14:55:06,520: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 14:55:06,522: Parsing model.parsely.parsely_sessions
2017-12-21 14:55:06,528: Acquiring new redshift connection "parsely_sessions".
2017-12-21 14:55:06,528: Re-using an available connection from the pool.
2017-12-21 14:55:06,528: Using redshift connection "parsely_sessions".
2017-12-21 14:55:06,528: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:06,546: SQL status: SELECT in 0.02 seconds
2017-12-21 14:55:06,546: Parsing model.parsely.parsely_campaigns
2017-12-21 14:55:06,550: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 14:55:06,550: Re-using an available connection from the pool.
2017-12-21 14:55:06,550: Using redshift connection "parsely_campaigns".
2017-12-21 14:55:06,550: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:06,568: SQL status: SELECT in 0.02 seconds
2017-12-21 14:55:06,573: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 14:55:06,579: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 14:55:06,586: 
2017-12-21 14:55:06,589: Acquiring new redshift connection "master".
2017-12-21 14:55:06,589: Re-using an available connection from the pool.
2017-12-21 14:55:06,589: Using redshift connection "master".
2017-12-21 14:55:06,589: On master: select distinct nspname from pg_namespace
2017-12-21 14:55:06,591: SQL status: SELECT in 0.00 seconds
2017-12-21 14:55:06,594: Using redshift connection "master".
2017-12-21 14:55:06,594: On master: BEGIN
2017-12-21 14:55:06,595: SQL status: BEGIN in 0.00 seconds
2017-12-21 14:55:06,595: On master: COMMIT
2017-12-21 14:55:06,595: Using redshift connection "master".
2017-12-21 14:55:06,596: On master: COMMIT
2017-12-21 14:55:06,597: SQL status: COMMIT in 0.00 seconds
2017-12-21 14:55:06,602: 14:55:06 | Concurrency: 1 threads (target='dev')
2017-12-21 14:55:06,603: 14:55:06 | 
2017-12-21 14:55:06,603: Using redshift connection "master".
2017-12-21 14:55:06,603: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:06,621: SQL status: SELECT in 0.02 seconds
2017-12-21 14:55:06,694: 14:55:06 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-21 14:55:06,694: Compiling model.parsely.calendar
2017-12-21 14:55:06,701: Writing injected SQL for node "model.parsely.calendar"
2017-12-21 14:55:06,702: Acquiring new redshift connection "calendar".
2017-12-21 14:55:06,702: Opening a new connection (1 currently allocated)
2017-12-21 14:55:06,713: Using redshift connection "calendar".
2017-12-21 14:55:06,713: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:06,740: SQL status: SELECT in 0.03 seconds
2017-12-21 14:55:06,742: Writing runtime SQL for node "model.parsely.calendar"
2017-12-21 14:55:06,743: Using redshift connection "calendar".
2017-12-21 14:55:06,743: On calendar: BEGIN
2017-12-21 14:55:06,744: SQL status: BEGIN in 0.00 seconds
2017-12-21 14:55:06,744: Using redshift connection "calendar".
2017-12-21 14:55:06,744: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-21 14:55:06,831: SQL status: CREATE VIEW in 0.09 seconds
2017-12-21 14:55:06,832: On calendar: COMMIT
2017-12-21 14:55:06,832: Using redshift connection "calendar".
2017-12-21 14:55:06,832: On calendar: COMMIT
2017-12-21 14:55:07,065: SQL status: COMMIT in 0.23 seconds
2017-12-21 14:55:07,065: Using redshift connection "calendar".
2017-12-21 14:55:07,066: On calendar: BEGIN
2017-12-21 14:55:07,067: SQL status: BEGIN in 0.00 seconds
2017-12-21 14:55:07,068: Using redshift connection "calendar".
2017-12-21 14:55:07,068: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-21 14:55:07,074: SQL status: DROP VIEW in 0.01 seconds
2017-12-21 14:55:07,074: On calendar: COMMIT
2017-12-21 14:55:07,074: Using redshift connection "calendar".
2017-12-21 14:55:07,074: On calendar: COMMIT
2017-12-21 14:55:07,266: SQL status: COMMIT in 0.19 seconds
2017-12-21 14:55:07,266: Using redshift connection "calendar".
2017-12-21 14:55:07,266: On calendar: BEGIN
2017-12-21 14:55:07,268: SQL status: BEGIN in 0.00 seconds
2017-12-21 14:55:07,268: Using redshift connection "calendar".
2017-12-21 14:55:07,268: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-21 14:55:07,272: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 14:55:07,272: On calendar: COMMIT
2017-12-21 14:55:07,272: Using redshift connection "calendar".
2017-12-21 14:55:07,272: On calendar: COMMIT
2017-12-21 14:55:07,441: SQL status: COMMIT in 0.17 seconds
2017-12-21 14:55:07,441: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46716310>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 14:55:07,471: 14:55:07 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 0.75s]
2017-12-21 14:55:07,471: 14:55:07 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-21 14:55:07,471: Compiling model.parsely.parsely_rawdata
2017-12-21 14:55:07,477: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-21 14:55:07,478: Acquiring new redshift connection "parsely_rawdata".
2017-12-21 14:55:07,478: Re-using an available connection from the pool.
2017-12-21 14:55:07,478: Using redshift connection "parsely_rawdata".
2017-12-21 14:55:07,478: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:07,499: SQL status: SELECT in 0.02 seconds
2017-12-21 14:55:07,499: Using redshift connection "parsely_rawdata".
2017-12-21 14:55:07,499: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:55:07,509: SQL status: SELECT in 0.01 seconds
2017-12-21 14:55:07,509: Using redshift connection "parsely_rawdata".
2017-12-21 14:55:07,509: On parsely_rawdata: BEGIN
2017-12-21 14:55:07,511: SQL status: BEGIN in 0.00 seconds
2017-12-21 14:55:07,511: Using redshift connection "parsely_rawdata".
2017-12-21 14:55:07,511: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 14:55:34,889: SQL status: SELECT in 27.38 seconds
2017-12-21 14:55:34,889: Using redshift connection "parsely_rawdata".
2017-12-21 14:55:34,889: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-21 14:55:35,058: SQL status: SELECT in 0.17 seconds
2017-12-21 14:55:35,059: Using redshift connection "parsely_rawdata".
2017-12-21 14:55:35,059: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 14:55:35,158: SQL status: SELECT in 0.10 seconds
2017-12-21 14:55:35,159: Using redshift connection "parsely_rawdata".
2017-12-21 14:55:35,159: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 14:55:35,264: SQL status: SELECT in 0.10 seconds
2017-12-21 14:55:35,267: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-21 14:55:35,268: Using redshift connection "parsely_rawdata".
2017-12-21 14:55:35,268: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-21 14:56:04,429: SQL status: INSERT 0 998431 in 29.16 seconds
2017-12-21 14:56:04,429: On parsely_rawdata: COMMIT
2017-12-21 14:56:04,432: Using redshift connection "parsely_rawdata".
2017-12-21 14:56:04,432: On parsely_rawdata: COMMIT
2017-12-21 14:56:06,610: SQL status: COMMIT in 2.18 seconds
2017-12-21 14:56:06,610: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46822250>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 14:56:06,660: 14:56:06 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 998431 in 59.14s]
2017-12-21 14:56:06,660: 14:56:06 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-21 14:56:06,660: Compiling model.parsely.parsely_all_events
2017-12-21 14:56:06,669: Acquiring new redshift connection "parsely_all_events".
2017-12-21 14:56:06,669: Re-using an available connection from the pool.
2017-12-21 14:56:06,669: Using redshift connection "parsely_all_events".
2017-12-21 14:56:06,669: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:56:06,683: SQL status: SELECT in 0.01 seconds
2017-12-21 14:56:06,691: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-21 14:56:06,692: Using redshift connection "parsely_all_events".
2017-12-21 14:56:06,693: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:56:06,706: SQL status: SELECT in 0.01 seconds
2017-12-21 14:56:06,707: Using redshift connection "parsely_all_events".
2017-12-21 14:56:06,707: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:56:06,721: SQL status: SELECT in 0.01 seconds
2017-12-21 14:56:06,723: Using redshift connection "parsely_all_events".
2017-12-21 14:56:06,723: On parsely_all_events: BEGIN
2017-12-21 14:56:06,725: SQL status: BEGIN in 0.00 seconds
2017-12-21 14:56:06,725: Using redshift connection "parsely_all_events".
2017-12-21 14:56:06,725: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 14:58:07,026: SQL status: SELECT in 120.30 seconds
2017-12-21 14:58:07,027: Using redshift connection "parsely_all_events".
2017-12-21 14:58:07,027: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2017-12-21 14:58:07,185: SQL status: SELECT in 0.16 seconds
2017-12-21 14:58:07,185: Using redshift connection "parsely_all_events".
2017-12-21 14:58:07,186: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 14:58:07,283: SQL status: SELECT in 0.10 seconds
2017-12-21 14:58:07,284: Using redshift connection "parsely_all_events".
2017-12-21 14:58:07,285: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 14:58:07,384: SQL status: SELECT in 0.10 seconds
2017-12-21 14:58:07,387: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-21 14:58:07,388: Using redshift connection "parsely_all_events".
2017-12-21 14:58:07,388: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2017-12-21 14:58:44,821: SQL status: INSERT 0 882943 in 37.43 seconds
2017-12-21 14:58:44,821: On parsely_all_events: COMMIT
2017-12-21 14:58:44,822: Using redshift connection "parsely_all_events".
2017-12-21 14:58:44,822: On parsely_all_events: COMMIT
2017-12-21 14:58:47,197: SQL status: COMMIT in 2.38 seconds
2017-12-21 14:58:47,198: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f4680f990>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 14:58:47,345: 14:58:47 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 882943 in 160.54s]
2017-12-21 14:58:47,346: 14:58:47 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-21 14:58:47,346: Compiling model.parsely.parsely_bot_traffic
2017-12-21 14:58:47,353: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 14:58:47,354: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-21 14:58:47,354: Re-using an available connection from the pool.
2017-12-21 14:58:47,354: Using redshift connection "parsely_bot_traffic".
2017-12-21 14:58:47,354: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:58:47,373: SQL status: SELECT in 0.02 seconds
2017-12-21 14:58:47,374: Using redshift connection "parsely_bot_traffic".
2017-12-21 14:58:47,374: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:58:47,387: SQL status: SELECT in 0.01 seconds
2017-12-21 14:58:47,388: Using redshift connection "parsely_bot_traffic".
2017-12-21 14:58:47,389: On parsely_bot_traffic: BEGIN
2017-12-21 14:58:47,390: SQL status: BEGIN in 0.00 seconds
2017-12-21 14:58:47,390: Using redshift connection "parsely_bot_traffic".
2017-12-21 14:58:47,391: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 14:59:23,538: SQL status: SELECT in 36.15 seconds
2017-12-21 14:59:23,538: Using redshift connection "parsely_bot_traffic".
2017-12-21 14:59:23,541: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2017-12-21 14:59:23,717: SQL status: SELECT in 0.18 seconds
2017-12-21 14:59:23,717: Using redshift connection "parsely_bot_traffic".
2017-12-21 14:59:23,717: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 14:59:23,826: SQL status: SELECT in 0.11 seconds
2017-12-21 14:59:23,827: Using redshift connection "parsely_bot_traffic".
2017-12-21 14:59:23,827: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 14:59:23,928: SQL status: SELECT in 0.10 seconds
2017-12-21 14:59:23,931: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 14:59:23,932: Using redshift connection "parsely_bot_traffic".
2017-12-21 14:59:23,932: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2017-12-21 14:59:39,319: SQL status: INSERT 0 4 in 15.39 seconds
2017-12-21 14:59:39,319: On parsely_bot_traffic: COMMIT
2017-12-21 14:59:39,320: Using redshift connection "parsely_bot_traffic".
2017-12-21 14:59:39,320: On parsely_bot_traffic: COMMIT
2017-12-21 14:59:40,442: SQL status: COMMIT in 1.12 seconds
2017-12-21 14:59:40,442: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46822150>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 14:59:40,745: 14:59:40 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 53.10s]
2017-12-21 14:59:40,745: 14:59:40 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-21 14:59:40,746: Compiling model.parsely.parsely_custom_events
2017-12-21 14:59:40,753: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-21 14:59:40,755: Acquiring new redshift connection "parsely_custom_events".
2017-12-21 14:59:40,755: Re-using an available connection from the pool.
2017-12-21 14:59:40,755: Using redshift connection "parsely_custom_events".
2017-12-21 14:59:40,755: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:59:40,774: SQL status: SELECT in 0.02 seconds
2017-12-21 14:59:40,774: Using redshift connection "parsely_custom_events".
2017-12-21 14:59:40,774: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 14:59:40,789: SQL status: SELECT in 0.01 seconds
2017-12-21 14:59:40,790: Using redshift connection "parsely_custom_events".
2017-12-21 14:59:40,791: On parsely_custom_events: BEGIN
2017-12-21 14:59:40,792: SQL status: BEGIN in 0.00 seconds
2017-12-21 14:59:40,792: Using redshift connection "parsely_custom_events".
2017-12-21 14:59:40,793: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:00:13,235: SQL status: SELECT in 32.44 seconds
2017-12-21 15:00:13,235: Using redshift connection "parsely_custom_events".
2017-12-21 15:00:13,235: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2017-12-21 15:00:13,427: SQL status: SELECT in 0.19 seconds
2017-12-21 15:00:13,428: Using redshift connection "parsely_custom_events".
2017-12-21 15:00:13,428: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:00:13,546: SQL status: SELECT in 0.12 seconds
2017-12-21 15:00:13,547: Using redshift connection "parsely_custom_events".
2017-12-21 15:00:13,547: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:00:13,658: SQL status: SELECT in 0.11 seconds
2017-12-21 15:00:13,674: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-21 15:00:13,675: Using redshift connection "parsely_custom_events".
2017-12-21 15:00:13,675: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2017-12-21 15:00:41,307: SQL status: INSERT 0 0 in 27.63 seconds
2017-12-21 15:00:41,308: On parsely_custom_events: COMMIT
2017-12-21 15:00:41,308: Using redshift connection "parsely_custom_events".
2017-12-21 15:00:41,308: On parsely_custom_events: COMMIT
2017-12-21 15:00:41,507: SQL status: COMMIT in 0.20 seconds
2017-12-21 15:00:41,507: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f467d2710>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:00:41,577: 15:00:41 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 60.76s]
2017-12-21 15:00:41,578: 15:00:41 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-21 15:00:41,578: Compiling model.parsely.parsely_errors
2017-12-21 15:00:41,594: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-21 15:00:41,596: Acquiring new redshift connection "parsely_errors".
2017-12-21 15:00:41,608: Re-using an available connection from the pool.
2017-12-21 15:00:41,608: Using redshift connection "parsely_errors".
2017-12-21 15:00:41,608: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:00:41,625: SQL status: SELECT in 0.02 seconds
2017-12-21 15:00:41,626: Using redshift connection "parsely_errors".
2017-12-21 15:00:41,626: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:00:41,639: SQL status: SELECT in 0.01 seconds
2017-12-21 15:00:41,642: Using redshift connection "parsely_errors".
2017-12-21 15:00:41,642: On parsely_errors: BEGIN
2017-12-21 15:00:41,648: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:00:41,648: Using redshift connection "parsely_errors".
2017-12-21 15:00:41,648: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:01:10,759: SQL status: SELECT in 29.11 seconds
2017-12-21 15:01:10,760: Using redshift connection "parsely_errors".
2017-12-21 15:01:10,760: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2017-12-21 15:01:10,909: SQL status: SELECT in 0.15 seconds
2017-12-21 15:01:10,910: Using redshift connection "parsely_errors".
2017-12-21 15:01:10,910: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:01:11,016: SQL status: SELECT in 0.11 seconds
2017-12-21 15:01:11,018: Using redshift connection "parsely_errors".
2017-12-21 15:01:11,018: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:01:11,122: SQL status: SELECT in 0.10 seconds
2017-12-21 15:01:11,127: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-21 15:01:11,132: Using redshift connection "parsely_errors".
2017-12-21 15:01:11,132: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2017-12-21 15:01:11,790: SQL status: INSERT 0 2 in 0.66 seconds
2017-12-21 15:01:11,791: On parsely_errors: COMMIT
2017-12-21 15:01:11,791: Using redshift connection "parsely_errors".
2017-12-21 15:01:11,791: On parsely_errors: COMMIT
2017-12-21 15:01:12,772: SQL status: COMMIT in 0.98 seconds
2017-12-21 15:01:12,773: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46780990>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:01:12,823: 15:01:12 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 31.20s]
2017-12-21 15:01:12,824: 15:01:12 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-21 15:01:12,824: Compiling model.parsely.parsely_base_events
2017-12-21 15:01:12,831: Acquiring new redshift connection "parsely_base_events".
2017-12-21 15:01:12,831: Re-using an available connection from the pool.
2017-12-21 15:01:12,831: Using redshift connection "parsely_base_events".
2017-12-21 15:01:12,831: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:12,846: SQL status: SELECT in 0.01 seconds
2017-12-21 15:01:12,853: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-21 15:01:12,854: Using redshift connection "parsely_base_events".
2017-12-21 15:01:12,854: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:12,869: SQL status: SELECT in 0.01 seconds
2017-12-21 15:01:12,871: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-21 15:01:12,872: Using redshift connection "parsely_base_events".
2017-12-21 15:01:12,872: On parsely_base_events: BEGIN
2017-12-21 15:01:12,876: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:01:12,876: Using redshift connection "parsely_base_events".
2017-12-21 15:01:12,876: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-21 15:01:13,298: SQL status: CREATE VIEW in 0.42 seconds
2017-12-21 15:01:13,299: On parsely_base_events: COMMIT
2017-12-21 15:01:13,299: Using redshift connection "parsely_base_events".
2017-12-21 15:01:13,299: On parsely_base_events: COMMIT
2017-12-21 15:01:13,615: SQL status: COMMIT in 0.32 seconds
2017-12-21 15:01:13,615: Using redshift connection "parsely_base_events".
2017-12-21 15:01:13,615: On parsely_base_events: BEGIN
2017-12-21 15:01:13,617: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:01:13,618: Using redshift connection "parsely_base_events".
2017-12-21 15:01:13,618: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2017-12-21 15:01:13,883: SQL status: DROP VIEW in 0.26 seconds
2017-12-21 15:01:13,883: On parsely_base_events: COMMIT
2017-12-21 15:01:13,883: Using redshift connection "parsely_base_events".
2017-12-21 15:01:13,883: On parsely_base_events: COMMIT
2017-12-21 15:01:14,248: SQL status: COMMIT in 0.36 seconds
2017-12-21 15:01:14,248: Using redshift connection "parsely_base_events".
2017-12-21 15:01:14,248: On parsely_base_events: BEGIN
2017-12-21 15:01:14,252: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:01:14,252: Using redshift connection "parsely_base_events".
2017-12-21 15:01:14,252: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-21 15:01:14,355: SQL status: ALTER TABLE in 0.10 seconds
2017-12-21 15:01:14,355: On parsely_base_events: COMMIT
2017-12-21 15:01:14,355: Using redshift connection "parsely_base_events".
2017-12-21 15:01:14,356: On parsely_base_events: COMMIT
2017-12-21 15:01:14,806: SQL status: COMMIT in 0.45 seconds
2017-12-21 15:01:14,807: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46780390>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:01:14,850: 15:01:14 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 1.98s]
2017-12-21 15:01:14,850: 15:01:14 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2017-12-21 15:01:14,851: Compiling model.parsely.parsely_event_ids
2017-12-21 15:01:14,863: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-21 15:01:14,866: Acquiring new redshift connection "parsely_event_ids".
2017-12-21 15:01:14,866: Re-using an available connection from the pool.
2017-12-21 15:01:14,866: Using redshift connection "parsely_event_ids".
2017-12-21 15:01:14,866: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:14,882: SQL status: SELECT in 0.02 seconds
2017-12-21 15:01:14,883: Using redshift connection "parsely_event_ids".
2017-12-21 15:01:14,883: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:14,897: SQL status: SELECT in 0.01 seconds
2017-12-21 15:01:14,898: Using redshift connection "parsely_event_ids".
2017-12-21 15:01:14,899: On parsely_event_ids: BEGIN
2017-12-21 15:01:14,900: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:01:14,901: Using redshift connection "parsely_event_ids".
2017-12-21 15:01:14,901: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:01:17,438: SQL status: SELECT in 2.54 seconds
2017-12-21 15:01:17,439: Using redshift connection "parsely_event_ids".
2017-12-21 15:01:17,439: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2017-12-21 15:01:17,618: SQL status: SELECT in 0.18 seconds
2017-12-21 15:01:17,618: Using redshift connection "parsely_event_ids".
2017-12-21 15:01:17,618: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:01:17,722: SQL status: SELECT in 0.10 seconds
2017-12-21 15:01:17,722: Using redshift connection "parsely_event_ids".
2017-12-21 15:01:17,722: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:01:17,822: SQL status: SELECT in 0.10 seconds
2017-12-21 15:01:17,824: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-21 15:01:17,825: Using redshift connection "parsely_event_ids".
2017-12-21 15:01:17,825: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2017-12-21 15:01:18,515: SQL status: INSERT 0 882939 in 0.69 seconds
2017-12-21 15:01:18,516: On parsely_event_ids: COMMIT
2017-12-21 15:01:18,516: Using redshift connection "parsely_event_ids".
2017-12-21 15:01:18,516: On parsely_event_ids: COMMIT
2017-12-21 15:01:18,882: SQL status: COMMIT in 0.37 seconds
2017-12-21 15:01:18,883: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46780390>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:01:18,928: 15:01:18 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 882939 in 4.03s]
2017-12-21 15:01:18,932: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-21 15:01:18,952: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-21 15:01:18,960: 15:01:18 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-21 15:01:18,960: Compiling model.parsely.parsely_post_content
2017-12-21 15:01:18,978: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-21 15:01:18,979: Acquiring new redshift connection "parsely_post_content".
2017-12-21 15:01:18,979: Re-using an available connection from the pool.
2017-12-21 15:01:18,979: Using redshift connection "parsely_post_content".
2017-12-21 15:01:18,980: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:18,994: SQL status: SELECT in 0.01 seconds
2017-12-21 15:01:18,994: Using redshift connection "parsely_post_content".
2017-12-21 15:01:18,994: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:19,008: SQL status: SELECT in 0.01 seconds
2017-12-21 15:01:19,010: Using redshift connection "parsely_post_content".
2017-12-21 15:01:19,010: On parsely_post_content: BEGIN
2017-12-21 15:01:19,012: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:01:19,012: Using redshift connection "parsely_post_content".
2017-12-21 15:01:19,012: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:01:29,924: SQL status: SELECT in 10.91 seconds
2017-12-21 15:01:29,925: Using redshift connection "parsely_post_content".
2017-12-21 15:01:29,925: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2017-12-21 15:01:30,106: SQL status: SELECT in 0.18 seconds
2017-12-21 15:01:30,107: Using redshift connection "parsely_post_content".
2017-12-21 15:01:30,107: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:01:30,221: SQL status: SELECT in 0.11 seconds
2017-12-21 15:01:30,222: Using redshift connection "parsely_post_content".
2017-12-21 15:01:30,222: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:01:30,333: SQL status: SELECT in 0.11 seconds
2017-12-21 15:01:30,336: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-21 15:01:30,337: Using redshift connection "parsely_post_content".
2017-12-21 15:01:30,337: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2017-12-21 15:01:36,401: SQL status: INSERT 0 872 in 6.06 seconds
2017-12-21 15:01:36,402: On parsely_post_content: COMMIT
2017-12-21 15:01:36,402: Using redshift connection "parsely_post_content".
2017-12-21 15:01:36,402: On parsely_post_content: COMMIT
2017-12-21 15:01:36,956: SQL status: COMMIT in 0.55 seconds
2017-12-21 15:01:36,957: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46822150>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:01:37,008: 15:01:37 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 872 in 18.00s]
2017-12-21 15:01:37,008: 15:01:37 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2017-12-21 15:01:37,009: Compiling model.parsely.parsely_video_content
2017-12-21 15:01:37,031: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-21 15:01:37,032: Acquiring new redshift connection "parsely_video_content".
2017-12-21 15:01:37,033: Re-using an available connection from the pool.
2017-12-21 15:01:37,033: Using redshift connection "parsely_video_content".
2017-12-21 15:01:37,033: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:37,051: SQL status: SELECT in 0.02 seconds
2017-12-21 15:01:37,052: Using redshift connection "parsely_video_content".
2017-12-21 15:01:37,052: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:37,065: SQL status: SELECT in 0.01 seconds
2017-12-21 15:01:37,067: Using redshift connection "parsely_video_content".
2017-12-21 15:01:37,067: On parsely_video_content: BEGIN
2017-12-21 15:01:37,069: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:01:37,069: Using redshift connection "parsely_video_content".
2017-12-21 15:01:37,070: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:01:47,955: SQL status: SELECT in 10.89 seconds
2017-12-21 15:01:47,955: Using redshift connection "parsely_video_content".
2017-12-21 15:01:47,956: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2017-12-21 15:01:48,138: SQL status: SELECT in 0.18 seconds
2017-12-21 15:01:48,138: Using redshift connection "parsely_video_content".
2017-12-21 15:01:48,139: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:01:48,249: SQL status: SELECT in 0.11 seconds
2017-12-21 15:01:48,250: Using redshift connection "parsely_video_content".
2017-12-21 15:01:48,250: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:01:48,357: SQL status: SELECT in 0.11 seconds
2017-12-21 15:01:48,359: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-21 15:01:48,360: Using redshift connection "parsely_video_content".
2017-12-21 15:01:48,360: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2017-12-21 15:01:51,820: SQL status: INSERT 0 465 in 3.46 seconds
2017-12-21 15:01:51,820: On parsely_video_content: COMMIT
2017-12-21 15:01:51,821: Using redshift connection "parsely_video_content".
2017-12-21 15:01:51,821: On parsely_video_content: COMMIT
2017-12-21 15:01:52,290: SQL status: COMMIT in 0.47 seconds
2017-12-21 15:01:52,291: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46822150>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:01:52,351: 15:01:52 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 465 in 15.28s]
2017-12-21 15:01:52,354: 15:01:52 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-21 15:01:52,354: Compiling model.parsely.parsely_entry_exit_urls
2017-12-21 15:01:52,381: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 15:01:52,382: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-21 15:01:52,382: Re-using an available connection from the pool.
2017-12-21 15:01:52,383: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:01:52,383: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:52,400: SQL status: SELECT in 0.02 seconds
2017-12-21 15:01:52,403: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 15:01:52,404: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:01:52,404: On parsely_entry_exit_urls: BEGIN
2017-12-21 15:01:52,410: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:01:52,410: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:01:52,410: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-21 15:01:52,479: SQL status: CREATE VIEW in 0.07 seconds
2017-12-21 15:01:52,479: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:01:52,479: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2017-12-21 15:01:52,482: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:01:52,482: On parsely_entry_exit_urls: COMMIT
2017-12-21 15:01:52,483: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:01:52,483: On parsely_entry_exit_urls: COMMIT
2017-12-21 15:01:52,766: SQL status: COMMIT in 0.28 seconds
2017-12-21 15:01:52,766: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46822150>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:01:52,811: 15:01:52 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.41s]
2017-12-21 15:01:52,811: 15:01:52 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-21 15:01:52,812: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 15:01:52,860: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 15:01:52,862: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 15:01:52,862: Re-using an available connection from the pool.
2017-12-21 15:01:52,863: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:01:52,863: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:52,878: SQL status: SELECT in 0.01 seconds
2017-12-21 15:01:52,883: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 15:01:52,885: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:01:52,885: On parsely_incoming_videoviews: BEGIN
2017-12-21 15:01:52,889: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:01:52,889: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:01:52,890: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 15:01:52,980: SQL status: CREATE VIEW in 0.09 seconds
2017-12-21 15:01:52,981: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:01:52,981: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 15:01:52,985: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:01:52,985: On parsely_incoming_videoviews: COMMIT
2017-12-21 15:01:52,986: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:01:52,986: On parsely_incoming_videoviews: COMMIT
2017-12-21 15:01:53,216: SQL status: COMMIT in 0.23 seconds
2017-12-21 15:01:53,217: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46822150>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:01:53,270: 15:01:53 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.40s]
2017-12-21 15:01:53,276: 15:01:53 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 15:01:53,276: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 15:01:53,301: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:01:53,301: Re-using an available connection from the pool.
2017-12-21 15:01:53,301: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:01:53,301: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:53,316: SQL status: SELECT in 0.02 seconds
2017-12-21 15:01:53,327: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 15:01:53,345: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:01:53,345: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:53,359: SQL status: SELECT in 0.01 seconds
2017-12-21 15:01:53,360: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:01:53,360: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:01:53,375: SQL status: SELECT in 0.01 seconds
2017-12-21 15:01:53,378: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:01:53,378: On parsely_videoviews_sessionized: BEGIN
2017-12-21 15:01:53,380: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:01:53,380: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:01:53,380: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:03:02,339: SQL status: SELECT in 68.96 seconds
2017-12-21 15:03:02,339: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:03:02,339: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2017-12-21 15:03:02,578: SQL status: SELECT in 0.24 seconds
2017-12-21 15:03:02,579: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:03:02,579: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:03:02,679: SQL status: SELECT in 0.10 seconds
2017-12-21 15:03:02,681: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:03:02,681: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:03:02,780: SQL status: SELECT in 0.10 seconds
2017-12-21 15:03:02,786: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 15:03:02,787: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:03:02,787: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 15:03:25,937: SQL status: INSERT 0 141 in 23.15 seconds
2017-12-21 15:03:25,938: On parsely_videoviews_sessionized: COMMIT
2017-12-21 15:03:25,938: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:03:25,938: On parsely_videoviews_sessionized: COMMIT
2017-12-21 15:03:27,381: SQL status: COMMIT in 1.44 seconds
2017-12-21 15:03:27,382: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46777bd0>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:03:27,476: 15:03:27 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 141 in 94.11s]
2017-12-21 15:03:27,481: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-21 15:03:27,592: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-21 15:03:27,593: 15:03:27 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-21 15:03:27,600: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 15:03:27,665: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 15:03:27,666: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:03:27,666: Re-using an available connection from the pool.
2017-12-21 15:03:27,666: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:03:27,666: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:03:27,685: SQL status: SELECT in 0.02 seconds
2017-12-21 15:03:27,688: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 15:03:27,689: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:03:27,690: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-21 15:03:27,695: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:03:27,695: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:03:27,695: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-21 15:03:28,452: SQL status: CREATE VIEW in 0.76 seconds
2017-12-21 15:03:28,453: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:03:28,453: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-21 15:03:28,456: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:03:28,456: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 15:03:28,456: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:03:28,456: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 15:03:28,990: SQL status: COMMIT in 0.53 seconds
2017-12-21 15:03:28,990: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f467dd710>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:03:29,038: 15:03:29 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.39s]
2017-12-21 15:03:29,040: 15:03:29 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-21 15:03:29,040: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 15:03:29,126: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 15:03:29,128: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:03:29,128: Re-using an available connection from the pool.
2017-12-21 15:03:29,128: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:03:29,128: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:03:29,144: SQL status: SELECT in 0.02 seconds
2017-12-21 15:03:29,148: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 15:03:29,151: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:03:29,151: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-21 15:03:29,153: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:03:29,153: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:03:29,153: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-21 15:03:29,319: SQL status: CREATE VIEW in 0.17 seconds
2017-12-21 15:03:29,320: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:03:29,320: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-21 15:03:29,324: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:03:29,324: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 15:03:29,324: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:03:29,324: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 15:03:29,699: SQL status: COMMIT in 0.37 seconds
2017-12-21 15:03:29,699: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f467169d0>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:03:29,749: 15:03:29 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.66s]
2017-12-21 15:03:29,750: 15:03:29 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2017-12-21 15:03:29,750: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 15:03:29,792: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 15:03:29,801: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 15:03:29,801: Re-using an available connection from the pool.
2017-12-21 15:03:29,801: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:03:29,801: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:03:29,815: SQL status: SELECT in 0.01 seconds
2017-12-21 15:03:29,833: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 15:03:29,834: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:03:29,834: On parsely_incoming_pageviews: BEGIN
2017-12-21 15:03:29,836: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:03:29,836: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:03:29,837: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 15:03:30,360: SQL status: CREATE VIEW in 0.52 seconds
2017-12-21 15:03:30,361: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:03:30,361: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2017-12-21 15:03:30,366: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:03:30,366: On parsely_incoming_pageviews: COMMIT
2017-12-21 15:03:30,366: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:03:30,366: On parsely_incoming_pageviews: COMMIT
2017-12-21 15:03:30,891: SQL status: COMMIT in 0.52 seconds
2017-12-21 15:03:30,891: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f467169d0>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:03:30,938: 15:03:30 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.14s]
2017-12-21 15:03:30,944: 15:03:30 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2017-12-21 15:03:30,945: Compiling model.parsely.parsely_pageviews_sessionized
2017-12-21 15:03:30,953: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:03:30,953: Re-using an available connection from the pool.
2017-12-21 15:03:30,953: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:03:30,954: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:03:30,967: SQL status: SELECT in 0.01 seconds
2017-12-21 15:03:30,982: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 15:03:30,984: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:03:30,984: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:03:30,997: SQL status: SELECT in 0.01 seconds
2017-12-21 15:03:30,998: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:03:30,998: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:03:31,011: SQL status: SELECT in 0.01 seconds
2017-12-21 15:03:31,014: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:03:31,014: On parsely_pageviews_sessionized: BEGIN
2017-12-21 15:03:31,016: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:03:31,016: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:03:31,016: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:05:46,458: SQL status: SELECT in 135.44 seconds
2017-12-21 15:05:46,459: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:05:46,459: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2017-12-21 15:05:46,615: SQL status: SELECT in 0.16 seconds
2017-12-21 15:05:46,615: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:05:46,615: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:05:46,725: SQL status: SELECT in 0.11 seconds
2017-12-21 15:05:46,726: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:05:46,726: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:05:46,834: SQL status: SELECT in 0.11 seconds
2017-12-21 15:05:46,840: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 15:05:46,849: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:05:46,849: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 15:06:08,820: SQL status: INSERT 0 105007 in 21.97 seconds
2017-12-21 15:06:08,821: On parsely_pageviews_sessionized: COMMIT
2017-12-21 15:06:08,821: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:06:08,821: On parsely_pageviews_sessionized: COMMIT
2017-12-21 15:06:10,005: SQL status: COMMIT in 1.18 seconds
2017-12-21 15:06:10,006: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46716fd0>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:06:10,070: 15:06:10 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 105007 in 159.06s]
2017-12-21 15:06:10,071: 15:06:10 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-21 15:06:10,071: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-21 15:06:10,255: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 15:06:10,264: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:06:10,264: Re-using an available connection from the pool.
2017-12-21 15:06:10,264: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:06:10,265: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:06:10,286: SQL status: SELECT in 0.02 seconds
2017-12-21 15:06:10,291: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 15:06:10,292: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:06:10,292: On parsely_videoview_engagedtime: BEGIN
2017-12-21 15:06:10,302: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:06:10,302: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:06:10,302: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-21 15:06:10,399: SQL status: CREATE VIEW in 0.10 seconds
2017-12-21 15:06:10,400: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:06:10,400: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-21 15:06:10,405: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:06:10,405: On parsely_videoview_engagedtime: COMMIT
2017-12-21 15:06:10,405: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:06:10,405: On parsely_videoview_engagedtime: COMMIT
2017-12-21 15:06:10,649: SQL status: COMMIT in 0.24 seconds
2017-12-21 15:06:10,650: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46716fd0>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:06:10,706: 15:06:10 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.58s]
2017-12-21 15:06:10,712: 15:06:10 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-21 15:06:10,712: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-21 15:06:10,744: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 15:06:10,746: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:06:10,746: Re-using an available connection from the pool.
2017-12-21 15:06:10,747: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:06:10,747: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:06:10,768: SQL status: SELECT in 0.02 seconds
2017-12-21 15:06:10,769: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:06:10,769: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:06:10,790: SQL status: SELECT in 0.02 seconds
2017-12-21 15:06:10,795: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 15:06:10,804: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:06:10,804: On parsely_videoview_behavior_workflow: BEGIN
2017-12-21 15:06:10,806: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:06:10,807: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:06:10,807: On parsely_videoview_behavior_workflow: 
    
  

  create  table "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  
  
  as (
    -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
  );
2017-12-21 15:07:20,473: SQL status: SELECT in 69.67 seconds
2017-12-21 15:07:20,474: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 15:07:20,474: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:07:20,474: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 15:07:21,958: SQL status: COMMIT in 1.48 seconds
2017-12-21 15:07:21,959: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f4680f990>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:07:22,025: 15:07:22 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [SELECT in 71.25s]
2017-12-21 15:07:22,026: 15:07:22 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2017-12-21 15:07:22,026: Compiling model.parsely.parsely_campaigns
2017-12-21 15:07:22,034: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 15:07:22,034: Re-using an available connection from the pool.
2017-12-21 15:07:22,034: Using redshift connection "parsely_campaigns".
2017-12-21 15:07:22,034: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:07:22,059: SQL status: SELECT in 0.02 seconds
2017-12-21 15:07:22,065: Writing injected SQL for node "model.parsely.parsely_campaigns"
2017-12-21 15:07:22,066: Using redshift connection "parsely_campaigns".
2017-12-21 15:07:22,067: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:07:22,088: SQL status: SELECT in 0.02 seconds
2017-12-21 15:07:22,089: Using redshift connection "parsely_campaigns".
2017-12-21 15:07:22,089: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:07:22,110: SQL status: SELECT in 0.02 seconds
2017-12-21 15:07:22,113: Using redshift connection "parsely_campaigns".
2017-12-21 15:07:22,113: On parsely_campaigns: BEGIN
2017-12-21 15:07:22,115: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:07:22,115: Using redshift connection "parsely_campaigns".
2017-12-21 15:07:22,115: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:07:29,374: SQL status: SELECT in 7.26 seconds
2017-12-21 15:07:29,374: Using redshift connection "parsely_campaigns".
2017-12-21 15:07:29,376: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2017-12-21 15:07:30,208: SQL status: SELECT in 0.83 seconds
2017-12-21 15:07:30,208: Using redshift connection "parsely_campaigns".
2017-12-21 15:07:30,208: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:07:30,315: SQL status: SELECT in 0.11 seconds
2017-12-21 15:07:30,315: Using redshift connection "parsely_campaigns".
2017-12-21 15:07:30,316: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:07:30,422: SQL status: SELECT in 0.11 seconds
2017-12-21 15:07:30,424: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2017-12-21 15:07:30,425: Using redshift connection "parsely_campaigns".
2017-12-21 15:07:30,425: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2017-12-21 15:07:30,717: SQL status: INSERT 0 371 in 0.29 seconds
2017-12-21 15:07:30,718: On parsely_campaigns: COMMIT
2017-12-21 15:07:30,718: Using redshift connection "parsely_campaigns".
2017-12-21 15:07:30,718: On parsely_campaigns: COMMIT
2017-12-21 15:07:31,354: SQL status: COMMIT in 0.64 seconds
2017-12-21 15:07:31,355: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f467d2410>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:07:31,414: 15:07:31 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 371 in 9.33s]
2017-12-21 15:07:31,415: Compiling model.parsely.parsely_incoming_users
2017-12-21 15:07:31,446: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 15:07:31,456: 15:07:31 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2017-12-21 15:07:31,456: Compiling model.parsely.parsely_users
2017-12-21 15:07:31,475: Acquiring new redshift connection "parsely_users".
2017-12-21 15:07:31,475: Re-using an available connection from the pool.
2017-12-21 15:07:31,475: Using redshift connection "parsely_users".
2017-12-21 15:07:31,475: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:07:31,496: SQL status: SELECT in 0.02 seconds
2017-12-21 15:07:31,590: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 15:07:31,592: Using redshift connection "parsely_users".
2017-12-21 15:07:31,592: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:07:31,613: SQL status: SELECT in 0.02 seconds
2017-12-21 15:07:31,614: Using redshift connection "parsely_users".
2017-12-21 15:07:31,614: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:07:31,634: SQL status: SELECT in 0.02 seconds
2017-12-21 15:07:31,638: Using redshift connection "parsely_users".
2017-12-21 15:07:31,638: On parsely_users: BEGIN
2017-12-21 15:07:31,640: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:07:31,640: Using redshift connection "parsely_users".
2017-12-21 15:07:31,641: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3,4
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3,4
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      visitor_ip,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3,4
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id, visitor_ip)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3,4


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    visitor_ip,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:07:41,964: SQL status: SELECT in 10.32 seconds
2017-12-21 15:07:41,964: Using redshift connection "parsely_users".
2017-12-21 15:07:41,964: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2017-12-21 15:07:42,107: SQL status: SELECT in 0.14 seconds
2017-12-21 15:07:42,107: Using redshift connection "parsely_users".
2017-12-21 15:07:42,108: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:07:42,214: SQL status: SELECT in 0.11 seconds
2017-12-21 15:07:42,215: Using redshift connection "parsely_users".
2017-12-21 15:07:42,215: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:07:42,320: SQL status: SELECT in 0.10 seconds
2017-12-21 15:07:42,322: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 15:07:42,323: Using redshift connection "parsely_users".
2017-12-21 15:07:42,323: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2017-12-21 15:07:42,739: SQL status: INSERT 0 58394 in 0.42 seconds
2017-12-21 15:07:42,740: On parsely_users: COMMIT
2017-12-21 15:07:42,740: Using redshift connection "parsely_users".
2017-12-21 15:07:42,740: On parsely_users: COMMIT
2017-12-21 15:07:43,336: SQL status: COMMIT in 0.60 seconds
2017-12-21 15:07:43,336: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46708210>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:07:43,377: 15:07:43 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 58394 in 11.88s]
2017-12-21 15:07:43,378: 15:07:43 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2017-12-21 15:07:43,378: Compiling model.parsely.parsely_pageview_engagedtime
2017-12-21 15:07:43,447: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 15:07:43,449: Acquiring new redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:07:43,449: Re-using an available connection from the pool.
2017-12-21 15:07:43,449: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:07:43,450: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:07:43,471: SQL status: SELECT in 0.02 seconds
2017-12-21 15:07:43,475: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 15:07:43,476: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:07:43,476: On parsely_pageview_engagedtime: BEGIN
2017-12-21 15:07:43,478: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:07:43,478: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:07:43,479: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2017-12-21 15:07:45,063: SQL status: CREATE VIEW in 1.58 seconds
2017-12-21 15:07:45,064: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:07:45,064: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2017-12-21 15:07:45,069: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:07:45,069: On parsely_pageview_engagedtime: COMMIT
2017-12-21 15:07:45,069: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:07:45,069: On parsely_pageview_engagedtime: COMMIT
2017-12-21 15:07:45,331: SQL status: COMMIT in 0.26 seconds
2017-12-21 15:07:45,332: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f4680f990>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:07:45,377: 15:07:45 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 1.95s]
2017-12-21 15:07:45,378: 15:07:45 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2017-12-21 15:07:45,378: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 15:07:45,396: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 15:07:45,397: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 15:07:45,398: Re-using an available connection from the pool.
2017-12-21 15:07:45,398: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:07:45,398: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:07:45,418: SQL status: SELECT in 0.02 seconds
2017-12-21 15:07:45,422: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 15:07:45,423: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:07:45,424: On parsely_incoming_sessions: BEGIN
2017-12-21 15:07:45,426: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:07:45,426: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:07:45,426: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 15:07:45,882: SQL status: CREATE VIEW in 0.46 seconds
2017-12-21 15:07:45,883: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:07:45,883: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 15:07:45,886: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:07:45,886: On parsely_incoming_sessions: COMMIT
2017-12-21 15:07:45,887: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:07:45,887: On parsely_incoming_sessions: COMMIT
2017-12-21 15:07:46,117: SQL status: COMMIT in 0.23 seconds
2017-12-21 15:07:46,117: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46708210>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:07:46,163: 15:07:46 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.74s]
2017-12-21 15:07:46,164: 15:07:46 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2017-12-21 15:07:46,164: Compiling model.parsely.parsely_pageview_behavior_workflow
2017-12-21 15:07:46,180: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 15:07:46,182: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:07:46,182: Re-using an available connection from the pool.
2017-12-21 15:07:46,182: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:07:46,182: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:07:46,204: SQL status: SELECT in 0.02 seconds
2017-12-21 15:07:46,205: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:07:46,205: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:07:46,226: SQL status: SELECT in 0.02 seconds
2017-12-21 15:07:46,230: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 15:07:46,231: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:07:46,231: On parsely_pageview_behavior_workflow: BEGIN
2017-12-21 15:07:46,233: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:07:46,234: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:07:46,234: On parsely_pageview_behavior_workflow: 
    
  

  create  table "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  
  
  as (
    -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
  );
2017-12-21 15:09:13,150: SQL status: SELECT in 86.92 seconds
2017-12-21 15:09:13,151: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 15:09:13,151: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:09:13,151: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 15:09:14,378: SQL status: COMMIT in 1.23 seconds
2017-12-21 15:09:14,379: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46708d50>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:09:14,449: 15:09:14 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [SELECT in 88.22s]
2017-12-21 15:09:14,456: 15:09:14 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2017-12-21 15:09:14,456: Compiling model.parsely.parsely_sessions
2017-12-21 15:09:14,478: Acquiring new redshift connection "parsely_sessions".
2017-12-21 15:09:14,478: Re-using an available connection from the pool.
2017-12-21 15:09:14,478: Using redshift connection "parsely_sessions".
2017-12-21 15:09:14,478: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:09:14,498: SQL status: SELECT in 0.02 seconds
2017-12-21 15:09:14,504: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 15:09:14,506: Using redshift connection "parsely_sessions".
2017-12-21 15:09:14,506: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:09:14,527: SQL status: SELECT in 0.02 seconds
2017-12-21 15:09:14,528: Using redshift connection "parsely_sessions".
2017-12-21 15:09:14,528: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:09:14,556: SQL status: SELECT in 0.03 seconds
2017-12-21 15:09:14,566: Using redshift connection "parsely_sessions".
2017-12-21 15:09:14,567: On parsely_sessions: BEGIN
2017-12-21 15:09:14,569: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:09:14,569: Using redshift connection "parsely_sessions".
2017-12-21 15:09:14,569: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:10:24,288: SQL status: SELECT in 69.72 seconds
2017-12-21 15:10:24,289: Using redshift connection "parsely_sessions".
2017-12-21 15:10:24,289: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2017-12-21 15:10:24,616: SQL status: SELECT in 0.33 seconds
2017-12-21 15:10:24,617: Using redshift connection "parsely_sessions".
2017-12-21 15:10:24,617: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:10:24,730: SQL status: SELECT in 0.11 seconds
2017-12-21 15:10:24,732: Using redshift connection "parsely_sessions".
2017-12-21 15:10:24,732: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:10:24,855: SQL status: SELECT in 0.12 seconds
2017-12-21 15:10:24,860: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 15:10:24,861: Using redshift connection "parsely_sessions".
2017-12-21 15:10:24,861: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2017-12-21 15:10:40,608: SQL status: INSERT 0 85382 in 15.75 seconds
2017-12-21 15:10:40,608: On parsely_sessions: COMMIT
2017-12-21 15:10:40,608: Using redshift connection "parsely_sessions".
2017-12-21 15:10:40,609: On parsely_sessions: COMMIT
2017-12-21 15:10:41,793: SQL status: COMMIT in 1.18 seconds
2017-12-21 15:10:41,793: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f4680f990>], 'label': '57c80af2-56be-45be-adc1-744fb003b858'}
2017-12-21 15:10:41,873: 15:10:41 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 85382 in 87.34s]
2017-12-21 15:10:41,944: Using redshift connection "master".
2017-12-21 15:10:41,944: On master: BEGIN
2017-12-21 15:10:41,947: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:10:41,947: On master: COMMIT
2017-12-21 15:10:41,947: Using redshift connection "master".
2017-12-21 15:10:41,947: On master: COMMIT
2017-12-21 15:10:41,949: SQL status: COMMIT in 0.00 seconds
2017-12-21 15:10:41,949: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 15:10:41,958: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 15:10:41,959: Using redshift connection "master".
2017-12-21 15:10:41,960: On master:  select 1 
2017-12-21 15:10:41,962: SQL status: SELECT in 0.00 seconds
2017-12-21 15:10:41,962: 15:10:41 | 
2017-12-21 15:10:41,962: 15:10:41 | Finished running 10 view models, 15 incremental models in 935.34s.
2017-12-21 15:10:41,963: 
2017-12-21 15:10:41,963: Completed successfully
2017-12-21 15:10:41,963: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2017-12-21 15:10:41,964: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46828e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f46828f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0f4680f950>], 'label': 'end'}
2017-12-21 15:10:41,998: Flushing usage events
2017-12-21 15:10:51,006: Tracking: tracking
2017-12-21 15:10:51,006: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da028ce10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da028cf90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da028ced0>], 'label': 'start'}
2017-12-21 15:10:51,063: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 15:10:51,110: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 15:10:51,113: Parsing core.sql
2017-12-21 15:10:51,167: Parsing etc/get_custom_schema.sql
2017-12-21 15:10:51,191: Parsing schema_tests/relationships.sql
2017-12-21 15:10:51,204: Parsing schema_tests/accepted_values.sql
2017-12-21 15:10:51,210: Parsing schema_tests/not_null.sql
2017-12-21 15:10:51,221: Parsing schema_tests/unique.sql
2017-12-21 15:10:51,224: Parsing materializations/wrapper.sql
2017-12-21 15:10:51,238: Parsing materializations/archive.sql
2017-12-21 15:10:51,355: Parsing materializations/table.sql
2017-12-21 15:10:51,391: Parsing materializations/helpers.sql
2017-12-21 15:10:51,423: Parsing materializations/bigquery.sql
2017-12-21 15:10:51,451: Parsing materializations/view.sql
2017-12-21 15:10:51,480: Parsing materializations/incremental.sql
2017-12-21 15:10:51,532: Parsing adapters/redshift.sql
2017-12-21 15:10:51,568: Parsing adapters/bigquery.sql
2017-12-21 15:10:51,577: Parsing adapters/postgres.sql
2017-12-21 15:10:51,583: Parsing adapters/common.sql
2017-12-21 15:10:51,622: Parsing model.parsely.parsely_audit
2017-12-21 15:10:51,624: Parsing model.parsely.parsely_video_content
2017-12-21 15:10:51,630: Parsing model.parsely.parsely_post_content
2017-12-21 15:10:51,636: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 15:10:51,641: Parsing model.parsely.parsely_rawdata
2017-12-21 15:10:51,645: Parsing model.parsely.calendar
2017-12-21 15:10:51,648: Parsing model.parsely.parsely_all_events
2017-12-21 15:10:51,664: Acquiring new redshift connection "parsely_all_events".
2017-12-21 15:10:51,665: Opening a new connection (0 currently allocated)
2017-12-21 15:10:51,686: Using redshift connection "parsely_all_events".
2017-12-21 15:10:51,686: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:51,714: SQL status: SELECT in 0.03 seconds
2017-12-21 15:10:51,732: Parsing model.parsely.parsely_event_ids
2017-12-21 15:10:51,744: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 15:10:51,757: Parsing model.parsely.parsely_base_events
2017-12-21 15:10:51,773: Acquiring new redshift connection "parsely_base_events".
2017-12-21 15:10:51,774: Re-using an available connection from the pool.
2017-12-21 15:10:51,774: Using redshift connection "parsely_base_events".
2017-12-21 15:10:51,774: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:51,796: SQL status: SELECT in 0.02 seconds
2017-12-21 15:10:51,798: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 15:10:51,816: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 15:10:51,832: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 15:10:51,836: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 15:10:51,847: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 15:10:51,861: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 15:10:51,871: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 15:10:51,884: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 15:10:51,894: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:10:51,894: Re-using an available connection from the pool.
2017-12-21 15:10:51,894: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:10:51,894: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:51,915: SQL status: SELECT in 0.02 seconds
2017-12-21 15:10:51,917: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 15:10:51,929: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 15:10:51,935: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:10:51,935: Re-using an available connection from the pool.
2017-12-21 15:10:51,935: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:10:51,935: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:51,955: SQL status: SELECT in 0.02 seconds
2017-12-21 15:10:51,956: Parsing model.parsely.parsely_incoming_users
2017-12-21 15:10:51,960: Parsing model.parsely.parsely_users
2017-12-21 15:10:51,965: Acquiring new redshift connection "parsely_users".
2017-12-21 15:10:51,965: Re-using an available connection from the pool.
2017-12-21 15:10:51,965: Using redshift connection "parsely_users".
2017-12-21 15:10:51,965: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:51,985: SQL status: SELECT in 0.02 seconds
2017-12-21 15:10:51,987: Parsing model.parsely.parsely_errors
2017-12-21 15:10:51,993: Parsing model.parsely.parsely_bot_traffic
2017-12-21 15:10:52,005: Parsing model.parsely.parsely_custom_events
2017-12-21 15:10:52,030: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 15:10:52,060: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 15:10:52,065: Parsing model.parsely.parsely_sessions
2017-12-21 15:10:52,099: Acquiring new redshift connection "parsely_sessions".
2017-12-21 15:10:52,099: Re-using an available connection from the pool.
2017-12-21 15:10:52,099: Using redshift connection "parsely_sessions".
2017-12-21 15:10:52,100: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:52,121: SQL status: SELECT in 0.02 seconds
2017-12-21 15:10:52,121: Parsing model.parsely.parsely_campaigns
2017-12-21 15:10:52,137: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 15:10:52,137: Re-using an available connection from the pool.
2017-12-21 15:10:52,137: Using redshift connection "parsely_campaigns".
2017-12-21 15:10:52,137: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:52,158: SQL status: SELECT in 0.02 seconds
2017-12-21 15:10:52,178: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 15:10:52,196: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 15:10:52,222: 
2017-12-21 15:10:52,237: Acquiring new redshift connection "master".
2017-12-21 15:10:52,237: Re-using an available connection from the pool.
2017-12-21 15:10:52,237: Using redshift connection "master".
2017-12-21 15:10:52,237: On master: select distinct nspname from pg_namespace
2017-12-21 15:10:52,244: SQL status: SELECT in 0.01 seconds
2017-12-21 15:10:52,249: Using redshift connection "master".
2017-12-21 15:10:52,249: On master: BEGIN
2017-12-21 15:10:52,251: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:10:52,251: On master: COMMIT
2017-12-21 15:10:52,251: Using redshift connection "master".
2017-12-21 15:10:52,251: On master: COMMIT
2017-12-21 15:10:52,253: SQL status: COMMIT in 0.00 seconds
2017-12-21 15:10:52,270: 15:10:52 | Concurrency: 1 threads (target='dev')
2017-12-21 15:10:52,271: 15:10:52 | 
2017-12-21 15:10:52,271: Using redshift connection "master".
2017-12-21 15:10:52,271: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:52,293: SQL status: SELECT in 0.02 seconds
2017-12-21 15:10:52,559: 15:10:52 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-21 15:10:52,559: Compiling model.parsely.calendar
2017-12-21 15:10:52,574: Writing injected SQL for node "model.parsely.calendar"
2017-12-21 15:10:52,576: Acquiring new redshift connection "calendar".
2017-12-21 15:10:52,576: Opening a new connection (1 currently allocated)
2017-12-21 15:10:52,609: Using redshift connection "calendar".
2017-12-21 15:10:52,609: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:52,635: SQL status: SELECT in 0.03 seconds
2017-12-21 15:10:52,637: Writing runtime SQL for node "model.parsely.calendar"
2017-12-21 15:10:52,638: Using redshift connection "calendar".
2017-12-21 15:10:52,638: On calendar: BEGIN
2017-12-21 15:10:52,640: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:10:52,640: Using redshift connection "calendar".
2017-12-21 15:10:52,640: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-21 15:10:52,702: SQL status: CREATE VIEW in 0.06 seconds
2017-12-21 15:10:52,703: On calendar: COMMIT
2017-12-21 15:10:52,703: Using redshift connection "calendar".
2017-12-21 15:10:52,703: On calendar: COMMIT
2017-12-21 15:10:52,906: SQL status: COMMIT in 0.20 seconds
2017-12-21 15:10:52,907: Using redshift connection "calendar".
2017-12-21 15:10:52,907: On calendar: BEGIN
2017-12-21 15:10:52,909: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:10:52,909: Using redshift connection "calendar".
2017-12-21 15:10:52,909: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-21 15:10:52,915: SQL status: DROP VIEW in 0.01 seconds
2017-12-21 15:10:52,916: On calendar: COMMIT
2017-12-21 15:10:52,916: Using redshift connection "calendar".
2017-12-21 15:10:52,916: On calendar: COMMIT
2017-12-21 15:10:53,463: SQL status: COMMIT in 0.55 seconds
2017-12-21 15:10:53,463: Using redshift connection "calendar".
2017-12-21 15:10:53,464: On calendar: BEGIN
2017-12-21 15:10:53,465: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:10:53,466: Using redshift connection "calendar".
2017-12-21 15:10:53,466: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-21 15:10:53,695: SQL status: ALTER TABLE in 0.23 seconds
2017-12-21 15:10:53,695: On calendar: COMMIT
2017-12-21 15:10:53,695: Using redshift connection "calendar".
2017-12-21 15:10:53,696: On calendar: COMMIT
2017-12-21 15:10:54,340: SQL status: COMMIT in 0.64 seconds
2017-12-21 15:10:54,341: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da017ac10>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:10:54,382: 15:10:54 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.78s]
2017-12-21 15:10:54,382: 15:10:54 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-21 15:10:54,383: Compiling model.parsely.parsely_rawdata
2017-12-21 15:10:54,401: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-21 15:10:54,402: Acquiring new redshift connection "parsely_rawdata".
2017-12-21 15:10:54,403: Re-using an available connection from the pool.
2017-12-21 15:10:54,403: Using redshift connection "parsely_rawdata".
2017-12-21 15:10:54,403: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:54,423: SQL status: SELECT in 0.02 seconds
2017-12-21 15:10:54,423: Using redshift connection "parsely_rawdata".
2017-12-21 15:10:54,423: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:10:54,433: SQL status: SELECT in 0.01 seconds
2017-12-21 15:10:54,435: Using redshift connection "parsely_rawdata".
2017-12-21 15:10:54,435: On parsely_rawdata: BEGIN
2017-12-21 15:10:54,437: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:10:54,437: Using redshift connection "parsely_rawdata".
2017-12-21 15:10:54,437: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:11:22,974: SQL status: SELECT in 28.54 seconds
2017-12-21 15:11:22,974: Using redshift connection "parsely_rawdata".
2017-12-21 15:11:22,974: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-21 15:11:23,163: SQL status: SELECT in 0.19 seconds
2017-12-21 15:11:23,164: Using redshift connection "parsely_rawdata".
2017-12-21 15:11:23,164: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:11:23,276: SQL status: SELECT in 0.11 seconds
2017-12-21 15:11:23,278: Using redshift connection "parsely_rawdata".
2017-12-21 15:11:23,278: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:11:23,391: SQL status: SELECT in 0.11 seconds
2017-12-21 15:11:23,397: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-21 15:11:23,398: Using redshift connection "parsely_rawdata".
2017-12-21 15:11:23,398: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-21 15:11:55,291: SQL status: INSERT 0 1000039 in 31.89 seconds
2017-12-21 15:11:55,292: On parsely_rawdata: COMMIT
2017-12-21 15:11:55,292: Using redshift connection "parsely_rawdata".
2017-12-21 15:11:55,292: On parsely_rawdata: COMMIT
2017-12-21 15:11:57,471: SQL status: COMMIT in 2.18 seconds
2017-12-21 15:11:57,472: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da0286290>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:11:57,557: 15:11:57 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1000039 in 63.09s]
2017-12-21 15:11:57,564: 15:11:57 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-21 15:11:57,564: Compiling model.parsely.parsely_all_events
2017-12-21 15:11:57,598: Acquiring new redshift connection "parsely_all_events".
2017-12-21 15:11:57,608: Re-using an available connection from the pool.
2017-12-21 15:11:57,608: Using redshift connection "parsely_all_events".
2017-12-21 15:11:57,608: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:11:57,625: SQL status: SELECT in 0.02 seconds
2017-12-21 15:11:57,664: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-21 15:11:57,666: Using redshift connection "parsely_all_events".
2017-12-21 15:11:57,666: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:11:57,682: SQL status: SELECT in 0.02 seconds
2017-12-21 15:11:57,683: Using redshift connection "parsely_all_events".
2017-12-21 15:11:57,683: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:11:57,698: SQL status: SELECT in 0.01 seconds
2017-12-21 15:11:57,702: Using redshift connection "parsely_all_events".
2017-12-21 15:11:57,712: On parsely_all_events: BEGIN
2017-12-21 15:11:57,714: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:11:57,715: Using redshift connection "parsely_all_events".
2017-12-21 15:11:57,715: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:13:39,678: SQL status: SELECT in 101.96 seconds
2017-12-21 15:13:39,679: Using redshift connection "parsely_all_events".
2017-12-21 15:13:39,679: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2017-12-21 15:13:39,849: SQL status: SELECT in 0.17 seconds
2017-12-21 15:13:39,850: Using redshift connection "parsely_all_events".
2017-12-21 15:13:39,850: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:13:39,962: SQL status: SELECT in 0.11 seconds
2017-12-21 15:13:39,964: Using redshift connection "parsely_all_events".
2017-12-21 15:13:39,964: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:13:40,076: SQL status: SELECT in 0.11 seconds
2017-12-21 15:13:40,082: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-21 15:13:40,082: Using redshift connection "parsely_all_events".
2017-12-21 15:13:40,083: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2017-12-21 15:13:57,478: SQL status: INSERT 0 884551 in 17.40 seconds
2017-12-21 15:13:57,479: On parsely_all_events: COMMIT
2017-12-21 15:13:57,479: Using redshift connection "parsely_all_events".
2017-12-21 15:13:57,479: On parsely_all_events: COMMIT
2017-12-21 15:13:59,392: SQL status: COMMIT in 1.91 seconds
2017-12-21 15:13:59,393: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01f46d0>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:13:59,466: 15:13:59 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 884551 in 121.83s]
2017-12-21 15:13:59,467: 15:13:59 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-21 15:13:59,467: Compiling model.parsely.parsely_bot_traffic
2017-12-21 15:13:59,479: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 15:13:59,481: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-21 15:13:59,481: Re-using an available connection from the pool.
2017-12-21 15:13:59,482: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:13:59,482: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:13:59,498: SQL status: SELECT in 0.02 seconds
2017-12-21 15:13:59,499: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:13:59,499: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:13:59,512: SQL status: SELECT in 0.01 seconds
2017-12-21 15:13:59,515: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:13:59,515: On parsely_bot_traffic: BEGIN
2017-12-21 15:13:59,517: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:13:59,517: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:13:59,518: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:14:15,252: SQL status: SELECT in 15.73 seconds
2017-12-21 15:14:15,252: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:14:15,253: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2017-12-21 15:14:15,414: SQL status: SELECT in 0.16 seconds
2017-12-21 15:14:15,415: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:14:15,415: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:14:15,518: SQL status: SELECT in 0.10 seconds
2017-12-21 15:14:15,520: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:14:15,520: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:14:15,620: SQL status: SELECT in 0.10 seconds
2017-12-21 15:14:15,627: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 15:14:15,628: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:14:15,628: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2017-12-21 15:14:18,098: SQL status: INSERT 0 4 in 2.47 seconds
2017-12-21 15:14:18,099: On parsely_bot_traffic: COMMIT
2017-12-21 15:14:18,099: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:14:18,099: On parsely_bot_traffic: COMMIT
2017-12-21 15:14:19,241: SQL status: COMMIT in 1.14 seconds
2017-12-21 15:14:19,241: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da0286250>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:14:19,280: 15:14:19 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 19.77s]
2017-12-21 15:14:19,280: 15:14:19 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-21 15:14:19,281: Compiling model.parsely.parsely_custom_events
2017-12-21 15:14:19,295: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-21 15:14:19,297: Acquiring new redshift connection "parsely_custom_events".
2017-12-21 15:14:19,298: Re-using an available connection from the pool.
2017-12-21 15:14:19,298: Using redshift connection "parsely_custom_events".
2017-12-21 15:14:19,298: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:14:19,318: SQL status: SELECT in 0.02 seconds
2017-12-21 15:14:19,318: Using redshift connection "parsely_custom_events".
2017-12-21 15:14:19,318: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:14:19,332: SQL status: SELECT in 0.01 seconds
2017-12-21 15:14:19,334: Using redshift connection "parsely_custom_events".
2017-12-21 15:14:19,334: On parsely_custom_events: BEGIN
2017-12-21 15:14:19,336: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:14:19,336: Using redshift connection "parsely_custom_events".
2017-12-21 15:14:19,336: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:14:33,913: SQL status: SELECT in 14.58 seconds
2017-12-21 15:14:33,914: Using redshift connection "parsely_custom_events".
2017-12-21 15:14:33,914: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2017-12-21 15:14:34,528: SQL status: SELECT in 0.61 seconds
2017-12-21 15:14:34,528: Using redshift connection "parsely_custom_events".
2017-12-21 15:14:34,529: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:14:34,639: SQL status: SELECT in 0.11 seconds
2017-12-21 15:14:34,640: Using redshift connection "parsely_custom_events".
2017-12-21 15:14:34,640: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:14:34,752: SQL status: SELECT in 0.11 seconds
2017-12-21 15:14:34,759: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-21 15:14:34,760: Using redshift connection "parsely_custom_events".
2017-12-21 15:14:34,760: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2017-12-21 15:14:36,718: SQL status: INSERT 0 0 in 1.96 seconds
2017-12-21 15:14:36,718: On parsely_custom_events: COMMIT
2017-12-21 15:14:36,718: Using redshift connection "parsely_custom_events".
2017-12-21 15:14:36,719: On parsely_custom_events: COMMIT
2017-12-21 15:14:37,213: SQL status: COMMIT in 0.49 seconds
2017-12-21 15:14:37,214: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da02360d0>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:14:37,254: 15:14:37 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 17.93s]
2017-12-21 15:14:37,255: 15:14:37 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-21 15:14:37,255: Compiling model.parsely.parsely_errors
2017-12-21 15:14:37,268: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-21 15:14:37,270: Acquiring new redshift connection "parsely_errors".
2017-12-21 15:14:37,270: Re-using an available connection from the pool.
2017-12-21 15:14:37,270: Using redshift connection "parsely_errors".
2017-12-21 15:14:37,270: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:14:37,287: SQL status: SELECT in 0.02 seconds
2017-12-21 15:14:37,287: Using redshift connection "parsely_errors".
2017-12-21 15:14:37,288: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:14:37,301: SQL status: SELECT in 0.01 seconds
2017-12-21 15:14:37,303: Using redshift connection "parsely_errors".
2017-12-21 15:14:37,304: On parsely_errors: BEGIN
2017-12-21 15:14:37,306: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:14:37,306: Using redshift connection "parsely_errors".
2017-12-21 15:14:37,306: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:14:51,655: SQL status: SELECT in 14.35 seconds
2017-12-21 15:14:51,655: Using redshift connection "parsely_errors".
2017-12-21 15:14:51,655: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2017-12-21 15:14:51,847: SQL status: SELECT in 0.19 seconds
2017-12-21 15:14:51,847: Using redshift connection "parsely_errors".
2017-12-21 15:14:51,847: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:14:51,951: SQL status: SELECT in 0.10 seconds
2017-12-21 15:14:51,953: Using redshift connection "parsely_errors".
2017-12-21 15:14:51,953: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:14:52,056: SQL status: SELECT in 0.10 seconds
2017-12-21 15:14:52,062: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-21 15:14:52,063: Using redshift connection "parsely_errors".
2017-12-21 15:14:52,063: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2017-12-21 15:14:53,041: SQL status: INSERT 0 2 in 0.98 seconds
2017-12-21 15:14:53,042: On parsely_errors: COMMIT
2017-12-21 15:14:53,042: Using redshift connection "parsely_errors".
2017-12-21 15:14:53,042: On parsely_errors: COMMIT
2017-12-21 15:14:53,764: SQL status: COMMIT in 0.72 seconds
2017-12-21 15:14:53,765: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4810>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:14:53,800: 15:14:53 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 16.51s]
2017-12-21 15:14:53,800: 15:14:53 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-21 15:14:53,801: Compiling model.parsely.parsely_base_events
2017-12-21 15:14:53,808: Acquiring new redshift connection "parsely_base_events".
2017-12-21 15:14:53,808: Re-using an available connection from the pool.
2017-12-21 15:14:53,808: Using redshift connection "parsely_base_events".
2017-12-21 15:14:53,808: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:14:53,823: SQL status: SELECT in 0.01 seconds
2017-12-21 15:14:53,830: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-21 15:14:53,831: Using redshift connection "parsely_base_events".
2017-12-21 15:14:53,831: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:14:53,845: SQL status: SELECT in 0.01 seconds
2017-12-21 15:14:53,848: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-21 15:14:53,849: Using redshift connection "parsely_base_events".
2017-12-21 15:14:53,849: On parsely_base_events: BEGIN
2017-12-21 15:14:53,851: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:14:53,851: Using redshift connection "parsely_base_events".
2017-12-21 15:14:53,851: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-21 15:14:54,337: SQL status: CREATE VIEW in 0.49 seconds
2017-12-21 15:14:54,338: On parsely_base_events: COMMIT
2017-12-21 15:14:54,338: Using redshift connection "parsely_base_events".
2017-12-21 15:14:54,338: On parsely_base_events: COMMIT
2017-12-21 15:14:54,531: SQL status: COMMIT in 0.19 seconds
2017-12-21 15:14:54,531: Using redshift connection "parsely_base_events".
2017-12-21 15:14:54,531: On parsely_base_events: BEGIN
2017-12-21 15:14:54,533: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:14:54,534: Using redshift connection "parsely_base_events".
2017-12-21 15:14:54,534: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2017-12-21 15:14:55,592: SQL status: DROP VIEW in 1.06 seconds
2017-12-21 15:14:55,592: On parsely_base_events: COMMIT
2017-12-21 15:14:55,592: Using redshift connection "parsely_base_events".
2017-12-21 15:14:55,592: On parsely_base_events: COMMIT
2017-12-21 15:14:55,964: SQL status: COMMIT in 0.37 seconds
2017-12-21 15:14:55,964: Using redshift connection "parsely_base_events".
2017-12-21 15:14:55,965: On parsely_base_events: BEGIN
2017-12-21 15:14:55,967: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:14:55,967: Using redshift connection "parsely_base_events".
2017-12-21 15:14:55,967: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-21 15:14:56,138: SQL status: ALTER TABLE in 0.17 seconds
2017-12-21 15:14:56,138: On parsely_base_events: COMMIT
2017-12-21 15:14:56,138: Using redshift connection "parsely_base_events".
2017-12-21 15:14:56,138: On parsely_base_events: COMMIT
2017-12-21 15:14:56,956: SQL status: COMMIT in 0.82 seconds
2017-12-21 15:14:56,956: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4890>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:14:56,994: 15:14:56 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 3.16s]
2017-12-21 15:14:56,994: 15:14:56 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2017-12-21 15:14:56,995: Compiling model.parsely.parsely_event_ids
2017-12-21 15:14:57,004: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-21 15:14:57,007: Acquiring new redshift connection "parsely_event_ids".
2017-12-21 15:14:57,007: Re-using an available connection from the pool.
2017-12-21 15:14:57,007: Using redshift connection "parsely_event_ids".
2017-12-21 15:14:57,007: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:14:57,021: SQL status: SELECT in 0.01 seconds
2017-12-21 15:14:57,021: Using redshift connection "parsely_event_ids".
2017-12-21 15:14:57,021: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:14:57,035: SQL status: SELECT in 0.01 seconds
2017-12-21 15:14:57,037: Using redshift connection "parsely_event_ids".
2017-12-21 15:14:57,037: On parsely_event_ids: BEGIN
2017-12-21 15:14:57,039: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:14:57,039: Using redshift connection "parsely_event_ids".
2017-12-21 15:14:57,039: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:14:58,134: SQL status: SELECT in 1.09 seconds
2017-12-21 15:14:58,134: Using redshift connection "parsely_event_ids".
2017-12-21 15:14:58,134: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2017-12-21 15:14:58,354: SQL status: SELECT in 0.22 seconds
2017-12-21 15:14:58,354: Using redshift connection "parsely_event_ids".
2017-12-21 15:14:58,354: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:14:58,462: SQL status: SELECT in 0.11 seconds
2017-12-21 15:14:58,462: Using redshift connection "parsely_event_ids".
2017-12-21 15:14:58,463: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:14:58,566: SQL status: SELECT in 0.10 seconds
2017-12-21 15:14:58,568: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-21 15:14:58,570: Using redshift connection "parsely_event_ids".
2017-12-21 15:14:58,570: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2017-12-21 15:14:59,326: SQL status: INSERT 0 884547 in 0.76 seconds
2017-12-21 15:14:59,327: On parsely_event_ids: COMMIT
2017-12-21 15:14:59,327: Using redshift connection "parsely_event_ids".
2017-12-21 15:14:59,327: On parsely_event_ids: COMMIT
2017-12-21 15:14:59,846: SQL status: COMMIT in 0.52 seconds
2017-12-21 15:14:59,847: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4890>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:14:59,936: 15:14:59 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 884547 in 2.85s]
2017-12-21 15:14:59,937: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-21 15:14:59,947: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-21 15:14:59,948: 15:14:59 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-21 15:14:59,948: Compiling model.parsely.parsely_post_content
2017-12-21 15:14:59,959: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-21 15:14:59,960: Acquiring new redshift connection "parsely_post_content".
2017-12-21 15:14:59,961: Re-using an available connection from the pool.
2017-12-21 15:14:59,961: Using redshift connection "parsely_post_content".
2017-12-21 15:14:59,961: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:14:59,976: SQL status: SELECT in 0.01 seconds
2017-12-21 15:14:59,976: Using redshift connection "parsely_post_content".
2017-12-21 15:14:59,976: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:14:59,990: SQL status: SELECT in 0.01 seconds
2017-12-21 15:14:59,992: Using redshift connection "parsely_post_content".
2017-12-21 15:14:59,992: On parsely_post_content: BEGIN
2017-12-21 15:14:59,994: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:14:59,994: Using redshift connection "parsely_post_content".
2017-12-21 15:14:59,994: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:15:02,984: SQL status: SELECT in 2.99 seconds
2017-12-21 15:15:02,985: Using redshift connection "parsely_post_content".
2017-12-21 15:15:02,985: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2017-12-21 15:15:03,186: SQL status: SELECT in 0.20 seconds
2017-12-21 15:15:03,186: Using redshift connection "parsely_post_content".
2017-12-21 15:15:03,187: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:15:03,289: SQL status: SELECT in 0.10 seconds
2017-12-21 15:15:03,290: Using redshift connection "parsely_post_content".
2017-12-21 15:15:03,290: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:15:03,389: SQL status: SELECT in 0.10 seconds
2017-12-21 15:15:03,392: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-21 15:15:03,392: Using redshift connection "parsely_post_content".
2017-12-21 15:15:03,393: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2017-12-21 15:15:05,265: SQL status: INSERT 0 872 in 1.87 seconds
2017-12-21 15:15:05,266: On parsely_post_content: COMMIT
2017-12-21 15:15:05,266: Using redshift connection "parsely_post_content".
2017-12-21 15:15:05,266: On parsely_post_content: COMMIT
2017-12-21 15:15:06,118: SQL status: COMMIT in 0.85 seconds
2017-12-21 15:15:06,119: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4bd0>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:15:06,147: 15:15:06 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 872 in 6.17s]
2017-12-21 15:15:06,148: 15:15:06 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2017-12-21 15:15:06,148: Compiling model.parsely.parsely_video_content
2017-12-21 15:15:06,154: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-21 15:15:06,155: Acquiring new redshift connection "parsely_video_content".
2017-12-21 15:15:06,155: Re-using an available connection from the pool.
2017-12-21 15:15:06,155: Using redshift connection "parsely_video_content".
2017-12-21 15:15:06,155: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:06,173: SQL status: SELECT in 0.02 seconds
2017-12-21 15:15:06,174: Using redshift connection "parsely_video_content".
2017-12-21 15:15:06,174: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:06,187: SQL status: SELECT in 0.01 seconds
2017-12-21 15:15:06,189: Using redshift connection "parsely_video_content".
2017-12-21 15:15:06,189: On parsely_video_content: BEGIN
2017-12-21 15:15:06,191: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:15:06,191: Using redshift connection "parsely_video_content".
2017-12-21 15:15:06,191: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:15:09,368: SQL status: SELECT in 3.18 seconds
2017-12-21 15:15:09,368: Using redshift connection "parsely_video_content".
2017-12-21 15:15:09,368: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2017-12-21 15:15:09,499: SQL status: SELECT in 0.13 seconds
2017-12-21 15:15:09,500: Using redshift connection "parsely_video_content".
2017-12-21 15:15:09,500: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:15:09,602: SQL status: SELECT in 0.10 seconds
2017-12-21 15:15:09,603: Using redshift connection "parsely_video_content".
2017-12-21 15:15:09,603: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:15:09,700: SQL status: SELECT in 0.10 seconds
2017-12-21 15:15:09,703: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-21 15:15:09,704: Using redshift connection "parsely_video_content".
2017-12-21 15:15:09,704: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2017-12-21 15:15:10,037: SQL status: INSERT 0 465 in 0.33 seconds
2017-12-21 15:15:10,038: On parsely_video_content: COMMIT
2017-12-21 15:15:10,038: Using redshift connection "parsely_video_content".
2017-12-21 15:15:10,038: On parsely_video_content: COMMIT
2017-12-21 15:15:10,787: SQL status: COMMIT in 0.75 seconds
2017-12-21 15:15:10,787: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01902d0>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:15:10,814: 15:15:10 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 465 in 4.64s]
2017-12-21 15:15:10,814: 15:15:10 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-21 15:15:10,814: Compiling model.parsely.parsely_entry_exit_urls
2017-12-21 15:15:10,820: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 15:15:10,821: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-21 15:15:10,822: Re-using an available connection from the pool.
2017-12-21 15:15:10,822: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:15:10,822: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:10,836: SQL status: SELECT in 0.01 seconds
2017-12-21 15:15:10,838: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 15:15:10,838: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:15:10,838: On parsely_entry_exit_urls: BEGIN
2017-12-21 15:15:10,840: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:15:10,840: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:15:10,840: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-21 15:15:10,903: SQL status: CREATE VIEW in 0.06 seconds
2017-12-21 15:15:10,904: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:15:10,904: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2017-12-21 15:15:10,907: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:15:10,907: On parsely_entry_exit_urls: COMMIT
2017-12-21 15:15:10,907: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:15:10,907: On parsely_entry_exit_urls: COMMIT
2017-12-21 15:15:11,095: SQL status: COMMIT in 0.19 seconds
2017-12-21 15:15:11,096: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4390>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:15:11,179: 15:15:11 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.28s]
2017-12-21 15:15:11,179: 15:15:11 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-21 15:15:11,180: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 15:15:11,196: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 15:15:11,199: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 15:15:11,199: Re-using an available connection from the pool.
2017-12-21 15:15:11,199: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:15:11,199: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:11,213: SQL status: SELECT in 0.01 seconds
2017-12-21 15:15:11,218: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 15:15:11,220: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:15:11,220: On parsely_incoming_videoviews: BEGIN
2017-12-21 15:15:11,222: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:15:11,222: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:15:11,222: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 15:15:11,391: SQL status: CREATE VIEW in 0.17 seconds
2017-12-21 15:15:11,392: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:15:11,392: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 15:15:11,396: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:15:11,396: On parsely_incoming_videoviews: COMMIT
2017-12-21 15:15:11,396: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:15:11,396: On parsely_incoming_videoviews: COMMIT
2017-12-21 15:15:11,743: SQL status: COMMIT in 0.35 seconds
2017-12-21 15:15:11,743: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4390>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:15:11,782: 15:15:11 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.56s]
2017-12-21 15:15:11,782: 15:15:11 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 15:15:11,783: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 15:15:11,792: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:11,792: Re-using an available connection from the pool.
2017-12-21 15:15:11,793: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:11,793: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:11,810: SQL status: SELECT in 0.02 seconds
2017-12-21 15:15:11,816: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 15:15:11,818: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:11,819: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:11,832: SQL status: SELECT in 0.01 seconds
2017-12-21 15:15:11,833: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:11,833: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:11,846: SQL status: SELECT in 0.01 seconds
2017-12-21 15:15:11,848: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:11,848: On parsely_videoviews_sessionized: BEGIN
2017-12-21 15:15:11,850: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:15:11,850: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:11,850: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:15:38,605: SQL status: SELECT in 26.75 seconds
2017-12-21 15:15:38,605: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:38,605: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2017-12-21 15:15:38,811: SQL status: SELECT in 0.21 seconds
2017-12-21 15:15:38,812: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:38,812: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:15:38,922: SQL status: SELECT in 0.11 seconds
2017-12-21 15:15:38,923: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:38,923: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:15:39,035: SQL status: SELECT in 0.11 seconds
2017-12-21 15:15:39,042: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 15:15:39,043: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:39,043: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 15:15:42,474: SQL status: INSERT 0 141 in 3.43 seconds
2017-12-21 15:15:42,475: On parsely_videoviews_sessionized: COMMIT
2017-12-21 15:15:42,475: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:15:42,475: On parsely_videoviews_sessionized: COMMIT
2017-12-21 15:15:43,587: SQL status: COMMIT in 1.11 seconds
2017-12-21 15:15:43,588: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4890>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:15:43,622: 15:15:43 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 141 in 31.81s]
2017-12-21 15:15:43,622: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-21 15:15:43,668: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-21 15:15:43,669: 15:15:43 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-21 15:15:43,669: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 15:15:43,696: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 15:15:43,697: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:15:43,697: Re-using an available connection from the pool.
2017-12-21 15:15:43,698: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:15:43,698: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:43,719: SQL status: SELECT in 0.02 seconds
2017-12-21 15:15:43,723: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 15:15:43,723: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:15:43,723: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-21 15:15:43,725: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:15:43,725: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:15:43,726: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-21 15:15:43,870: SQL status: CREATE VIEW in 0.14 seconds
2017-12-21 15:15:43,871: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:15:43,871: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-21 15:15:43,875: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:15:43,875: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 15:15:43,875: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:15:43,875: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 15:15:44,313: SQL status: COMMIT in 0.44 seconds
2017-12-21 15:15:44,313: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da017aa50>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:15:44,338: 15:15:44 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.64s]
2017-12-21 15:15:44,339: 15:15:44 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-21 15:15:44,339: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 15:15:44,366: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 15:15:44,368: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:15:44,368: Re-using an available connection from the pool.
2017-12-21 15:15:44,368: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:15:44,368: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:44,389: SQL status: SELECT in 0.02 seconds
2017-12-21 15:15:44,392: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 15:15:44,392: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:15:44,392: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-21 15:15:44,394: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:15:44,394: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:15:44,394: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-21 15:15:44,636: SQL status: CREATE VIEW in 0.24 seconds
2017-12-21 15:15:44,636: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:15:44,636: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-21 15:15:44,641: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:15:44,642: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 15:15:44,642: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:15:44,642: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 15:15:45,053: SQL status: COMMIT in 0.41 seconds
2017-12-21 15:15:45,053: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da017a110>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:15:45,098: 15:15:45 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.71s]
2017-12-21 15:15:45,098: 15:15:45 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2017-12-21 15:15:45,098: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 15:15:45,117: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 15:15:45,120: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 15:15:45,120: Re-using an available connection from the pool.
2017-12-21 15:15:45,120: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:15:45,120: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:45,141: SQL status: SELECT in 0.02 seconds
2017-12-21 15:15:45,147: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 15:15:45,149: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:15:45,149: On parsely_incoming_pageviews: BEGIN
2017-12-21 15:15:45,151: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:15:45,151: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:15:45,151: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 15:15:45,613: SQL status: CREATE VIEW in 0.46 seconds
2017-12-21 15:15:45,613: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:15:45,613: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2017-12-21 15:15:45,737: SQL status: ALTER TABLE in 0.12 seconds
2017-12-21 15:15:45,737: On parsely_incoming_pageviews: COMMIT
2017-12-21 15:15:45,737: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:15:45,737: On parsely_incoming_pageviews: COMMIT
2017-12-21 15:15:45,940: SQL status: COMMIT in 0.20 seconds
2017-12-21 15:15:45,941: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da0236dd0>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:15:45,966: 15:15:45 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.84s]
2017-12-21 15:15:45,966: 15:15:45 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2017-12-21 15:15:45,966: Compiling model.parsely.parsely_pageviews_sessionized
2017-12-21 15:15:45,971: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:15:45,971: Re-using an available connection from the pool.
2017-12-21 15:15:45,971: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:15:45,971: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:45,992: SQL status: SELECT in 0.02 seconds
2017-12-21 15:15:45,998: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 15:15:46,000: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:15:46,000: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:46,020: SQL status: SELECT in 0.02 seconds
2017-12-21 15:15:46,021: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:15:46,021: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:15:46,040: SQL status: SELECT in 0.02 seconds
2017-12-21 15:15:46,043: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:15:46,043: On parsely_pageviews_sessionized: BEGIN
2017-12-21 15:15:46,045: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:15:46,045: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:15:46,046: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:17:30,651: SQL status: SELECT in 104.60 seconds
2017-12-21 15:17:30,651: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:17:30,651: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2017-12-21 15:17:30,839: SQL status: SELECT in 0.19 seconds
2017-12-21 15:17:30,840: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:17:30,840: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:17:30,950: SQL status: SELECT in 0.11 seconds
2017-12-21 15:17:30,951: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:17:30,951: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:17:31,062: SQL status: SELECT in 0.11 seconds
2017-12-21 15:17:31,065: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 15:17:31,066: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:17:31,066: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 15:17:35,409: SQL status: INSERT 0 105238 in 4.34 seconds
2017-12-21 15:17:35,409: On parsely_pageviews_sessionized: COMMIT
2017-12-21 15:17:35,409: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:17:35,410: On parsely_pageviews_sessionized: COMMIT
2017-12-21 15:17:36,601: SQL status: COMMIT in 1.19 seconds
2017-12-21 15:17:36,601: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4890>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:17:36,649: 15:17:36 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 105238 in 110.63s]
2017-12-21 15:17:36,649: 15:17:36 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-21 15:17:36,650: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-21 15:17:36,691: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 15:17:36,692: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:17:36,692: Re-using an available connection from the pool.
2017-12-21 15:17:36,692: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:17:36,692: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:17:36,714: SQL status: SELECT in 0.02 seconds
2017-12-21 15:17:36,716: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 15:17:36,717: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:17:36,717: On parsely_videoview_engagedtime: BEGIN
2017-12-21 15:17:36,719: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:17:36,719: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:17:36,719: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-21 15:17:36,795: SQL status: CREATE VIEW in 0.08 seconds
2017-12-21 15:17:36,795: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:17:36,795: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-21 15:17:36,800: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:17:36,801: On parsely_videoview_engagedtime: COMMIT
2017-12-21 15:17:36,801: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:17:36,801: On parsely_videoview_engagedtime: COMMIT
2017-12-21 15:17:36,984: SQL status: COMMIT in 0.18 seconds
2017-12-21 15:17:36,985: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4890>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:17:37,009: 15:17:37 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.33s]
2017-12-21 15:17:37,009: 15:17:37 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-21 15:17:37,009: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-21 15:17:37,018: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 15:17:37,019: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:17:37,019: Re-using an available connection from the pool.
2017-12-21 15:17:37,019: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:17:37,019: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:17:37,040: SQL status: SELECT in 0.02 seconds
2017-12-21 15:17:37,041: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:17:37,041: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:17:37,062: SQL status: SELECT in 0.02 seconds
2017-12-21 15:17:37,064: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:17:37,064: On parsely_videoview_behavior_workflow: BEGIN
2017-12-21 15:17:37,066: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:17:37,066: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:17:37,066: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:18:49,265: SQL status: SELECT in 72.20 seconds
2017-12-21 15:18:49,265: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:18:49,266: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 15:18:49,430: SQL status: SELECT in 0.16 seconds
2017-12-21 15:18:49,431: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:18:49,431: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:18:49,543: SQL status: SELECT in 0.11 seconds
2017-12-21 15:18:49,544: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:18:49,544: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:18:49,658: SQL status: SELECT in 0.11 seconds
2017-12-21 15:18:49,662: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 15:18:49,663: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:18:49,663: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 15:19:07,855: SQL status: INSERT 0 139 in 18.19 seconds
2017-12-21 15:19:07,855: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 15:19:07,855: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:19:07,855: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 15:19:09,292: SQL status: COMMIT in 1.44 seconds
2017-12-21 15:19:09,293: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da0236810>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:19:09,336: 15:19:09 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 139 in 92.28s]
2017-12-21 15:19:09,336: 15:19:09 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2017-12-21 15:19:09,337: Compiling model.parsely.parsely_campaigns
2017-12-21 15:19:09,340: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 15:19:09,341: Re-using an available connection from the pool.
2017-12-21 15:19:09,341: Using redshift connection "parsely_campaigns".
2017-12-21 15:19:09,341: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:19:09,365: SQL status: SELECT in 0.02 seconds
2017-12-21 15:19:09,369: Writing injected SQL for node "model.parsely.parsely_campaigns"
2017-12-21 15:19:09,370: Using redshift connection "parsely_campaigns".
2017-12-21 15:19:09,370: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:19:09,393: SQL status: SELECT in 0.02 seconds
2017-12-21 15:19:09,394: Using redshift connection "parsely_campaigns".
2017-12-21 15:19:09,394: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:19:09,416: SQL status: SELECT in 0.02 seconds
2017-12-21 15:19:09,417: Using redshift connection "parsely_campaigns".
2017-12-21 15:19:09,417: On parsely_campaigns: BEGIN
2017-12-21 15:19:09,419: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:19:09,419: Using redshift connection "parsely_campaigns".
2017-12-21 15:19:09,419: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:19:10,991: SQL status: SELECT in 1.57 seconds
2017-12-21 15:19:10,991: Using redshift connection "parsely_campaigns".
2017-12-21 15:19:10,991: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2017-12-21 15:19:11,154: SQL status: SELECT in 0.16 seconds
2017-12-21 15:19:11,155: Using redshift connection "parsely_campaigns".
2017-12-21 15:19:11,155: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:19:11,261: SQL status: SELECT in 0.11 seconds
2017-12-21 15:19:11,261: Using redshift connection "parsely_campaigns".
2017-12-21 15:19:11,261: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:19:11,368: SQL status: SELECT in 0.11 seconds
2017-12-21 15:19:11,370: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2017-12-21 15:19:11,371: Using redshift connection "parsely_campaigns".
2017-12-21 15:19:11,371: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2017-12-21 15:19:11,513: SQL status: INSERT 0 372 in 0.14 seconds
2017-12-21 15:19:11,514: On parsely_campaigns: COMMIT
2017-12-21 15:19:11,514: Using redshift connection "parsely_campaigns".
2017-12-21 15:19:11,514: On parsely_campaigns: COMMIT
2017-12-21 15:19:12,266: SQL status: COMMIT in 0.75 seconds
2017-12-21 15:19:12,267: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da0273e90>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:19:12,296: 15:19:12 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 372 in 2.93s]
2017-12-21 15:19:12,297: Compiling model.parsely.parsely_incoming_users
2017-12-21 15:19:12,302: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 15:19:12,303: 15:19:12 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2017-12-21 15:19:12,304: Compiling model.parsely.parsely_users
2017-12-21 15:19:12,310: Acquiring new redshift connection "parsely_users".
2017-12-21 15:19:12,310: Re-using an available connection from the pool.
2017-12-21 15:19:12,310: Using redshift connection "parsely_users".
2017-12-21 15:19:12,310: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:19:12,331: SQL status: SELECT in 0.02 seconds
2017-12-21 15:19:12,373: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 15:19:12,374: Using redshift connection "parsely_users".
2017-12-21 15:19:12,374: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:19:12,396: SQL status: SELECT in 0.02 seconds
2017-12-21 15:19:12,396: Using redshift connection "parsely_users".
2017-12-21 15:19:12,396: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:19:12,416: SQL status: SELECT in 0.02 seconds
2017-12-21 15:19:12,419: Using redshift connection "parsely_users".
2017-12-21 15:19:12,419: On parsely_users: BEGIN
2017-12-21 15:19:12,421: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:19:12,421: Using redshift connection "parsely_users".
2017-12-21 15:19:12,421: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3,4
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3,4
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      visitor_ip,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3,4
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id, visitor_ip)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3,4


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    visitor_ip,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:19:16,654: SQL status: SELECT in 4.23 seconds
2017-12-21 15:19:16,655: Using redshift connection "parsely_users".
2017-12-21 15:19:16,655: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2017-12-21 15:19:17,089: SQL status: SELECT in 0.43 seconds
2017-12-21 15:19:17,089: Using redshift connection "parsely_users".
2017-12-21 15:19:17,089: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:19:17,199: SQL status: SELECT in 0.11 seconds
2017-12-21 15:19:17,199: Using redshift connection "parsely_users".
2017-12-21 15:19:17,199: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:19:17,306: SQL status: SELECT in 0.11 seconds
2017-12-21 15:19:17,308: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 15:19:17,308: Using redshift connection "parsely_users".
2017-12-21 15:19:17,309: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2017-12-21 15:19:17,596: SQL status: INSERT 0 58515 in 0.29 seconds
2017-12-21 15:19:17,596: On parsely_users: COMMIT
2017-12-21 15:19:17,596: Using redshift connection "parsely_users".
2017-12-21 15:19:17,596: On parsely_users: COMMIT
2017-12-21 15:19:18,595: SQL status: COMMIT in 1.00 seconds
2017-12-21 15:19:18,596: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4890>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:19:18,622: 15:19:18 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 58515 in 6.29s]
2017-12-21 15:19:18,623: 15:19:18 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2017-12-21 15:19:18,623: Compiling model.parsely.parsely_pageview_engagedtime
2017-12-21 15:19:18,655: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 15:19:18,658: Acquiring new redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:19:18,658: Re-using an available connection from the pool.
2017-12-21 15:19:18,658: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:19:18,658: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:19:18,679: SQL status: SELECT in 0.02 seconds
2017-12-21 15:19:18,681: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 15:19:18,682: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:19:18,682: On parsely_pageview_engagedtime: BEGIN
2017-12-21 15:19:18,684: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:19:18,684: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:19:18,684: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2017-12-21 15:19:20,411: SQL status: CREATE VIEW in 1.73 seconds
2017-12-21 15:19:20,412: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:19:20,412: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2017-12-21 15:19:20,416: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:19:20,416: On parsely_pageview_engagedtime: COMMIT
2017-12-21 15:19:20,416: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:19:20,416: On parsely_pageview_engagedtime: COMMIT
2017-12-21 15:19:20,746: SQL status: COMMIT in 0.33 seconds
2017-12-21 15:19:20,747: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da01e4890>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:19:20,773: 15:19:20 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 2.12s]
2017-12-21 15:19:20,773: 15:19:20 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2017-12-21 15:19:20,773: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 15:19:20,780: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 15:19:20,781: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 15:19:20,781: Re-using an available connection from the pool.
2017-12-21 15:19:20,781: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:19:20,781: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:19:20,803: SQL status: SELECT in 0.02 seconds
2017-12-21 15:19:20,806: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 15:19:20,806: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:19:20,806: On parsely_incoming_sessions: BEGIN
2017-12-21 15:19:20,808: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:19:20,808: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:19:20,809: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 15:19:20,878: SQL status: CREATE VIEW in 0.07 seconds
2017-12-21 15:19:20,878: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:19:20,878: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 15:19:20,883: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:19:20,883: On parsely_incoming_sessions: COMMIT
2017-12-21 15:19:20,883: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:19:20,883: On parsely_incoming_sessions: COMMIT
2017-12-21 15:19:21,239: SQL status: COMMIT in 0.36 seconds
2017-12-21 15:19:21,239: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da0273e90>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:19:21,268: 15:19:21 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.47s]
2017-12-21 15:19:21,269: 15:19:21 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2017-12-21 15:19:21,269: Compiling model.parsely.parsely_pageview_behavior_workflow
2017-12-21 15:19:21,277: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 15:19:21,279: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:19:21,279: Re-using an available connection from the pool.
2017-12-21 15:19:21,279: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:19:21,279: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:19:21,299: SQL status: SELECT in 0.02 seconds
2017-12-21 15:19:21,300: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:19:21,300: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:19:21,319: SQL status: SELECT in 0.02 seconds
2017-12-21 15:19:21,321: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:19:21,321: On parsely_pageview_behavior_workflow: BEGIN
2017-12-21 15:19:21,323: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:19:21,323: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:19:21,323: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:20:29,121: SQL status: SELECT in 67.80 seconds
2017-12-21 15:20:29,121: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:20:29,121: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 15:20:29,309: SQL status: SELECT in 0.19 seconds
2017-12-21 15:20:29,309: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:20:29,310: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:20:29,422: SQL status: SELECT in 0.11 seconds
2017-12-21 15:20:29,422: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:20:29,423: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:20:29,537: SQL status: SELECT in 0.11 seconds
2017-12-21 15:20:29,540: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 15:20:29,541: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:20:29,541: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 15:20:49,958: SQL status: INSERT 0 105218 in 20.42 seconds
2017-12-21 15:20:49,958: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 15:20:49,958: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:20:49,958: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 15:20:51,112: SQL status: COMMIT in 1.15 seconds
2017-12-21 15:20:51,113: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da0273e90>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:20:51,178: 15:20:51 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 105218 in 89.84s]
2017-12-21 15:20:51,179: 15:20:51 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2017-12-21 15:20:51,179: Compiling model.parsely.parsely_sessions
2017-12-21 15:20:51,185: Acquiring new redshift connection "parsely_sessions".
2017-12-21 15:20:51,185: Re-using an available connection from the pool.
2017-12-21 15:20:51,185: Using redshift connection "parsely_sessions".
2017-12-21 15:20:51,185: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:20:51,209: SQL status: SELECT in 0.02 seconds
2017-12-21 15:20:51,212: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 15:20:51,214: Using redshift connection "parsely_sessions".
2017-12-21 15:20:51,214: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:20:51,233: SQL status: SELECT in 0.02 seconds
2017-12-21 15:20:51,234: Using redshift connection "parsely_sessions".
2017-12-21 15:20:51,234: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:20:51,254: SQL status: SELECT in 0.02 seconds
2017-12-21 15:20:51,257: Using redshift connection "parsely_sessions".
2017-12-21 15:20:51,257: On parsely_sessions: BEGIN
2017-12-21 15:20:51,258: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:20:51,259: Using redshift connection "parsely_sessions".
2017-12-21 15:20:51,259: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:21:10,867: SQL status: SELECT in 19.61 seconds
2017-12-21 15:21:10,868: Using redshift connection "parsely_sessions".
2017-12-21 15:21:10,868: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2017-12-21 15:21:11,184: SQL status: SELECT in 0.32 seconds
2017-12-21 15:21:11,185: Using redshift connection "parsely_sessions".
2017-12-21 15:21:11,185: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:21:11,299: SQL status: SELECT in 0.11 seconds
2017-12-21 15:21:11,300: Using redshift connection "parsely_sessions".
2017-12-21 15:21:11,300: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:21:11,420: SQL status: SELECT in 0.12 seconds
2017-12-21 15:21:11,423: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 15:21:11,424: Using redshift connection "parsely_sessions".
2017-12-21 15:21:11,424: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2017-12-21 15:21:14,529: SQL status: INSERT 0 85550 in 3.10 seconds
2017-12-21 15:21:14,529: On parsely_sessions: COMMIT
2017-12-21 15:21:14,529: Using redshift connection "parsely_sessions".
2017-12-21 15:21:14,529: On parsely_sessions: COMMIT
2017-12-21 15:21:15,503: SQL status: COMMIT in 0.97 seconds
2017-12-21 15:21:15,503: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da0236110>], 'label': '10bff359-375a-4e83-9350-e8a78e7af8b7'}
2017-12-21 15:21:15,530: 15:21:15 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 85550 in 24.32s]
2017-12-21 15:21:15,545: Using redshift connection "master".
2017-12-21 15:21:15,545: On master: BEGIN
2017-12-21 15:21:15,547: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:21:15,547: On master: COMMIT
2017-12-21 15:21:15,547: Using redshift connection "master".
2017-12-21 15:21:15,547: On master: COMMIT
2017-12-21 15:21:15,549: SQL status: COMMIT in 0.00 seconds
2017-12-21 15:21:15,549: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 15:21:15,554: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 15:21:15,555: Using redshift connection "master".
2017-12-21 15:21:15,555: On master:  select 1 
2017-12-21 15:21:15,557: SQL status: SELECT in 0.00 seconds
2017-12-21 15:21:15,557: 15:21:15 | 
2017-12-21 15:21:15,558: 15:21:15 | Finished running 10 view models, 15 incremental models in 623.29s.
2017-12-21 15:21:15,558: 
2017-12-21 15:21:15,558: Completed successfully
2017-12-21 15:21:15,558: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2017-12-21 15:21:15,559: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da028ce10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da028cf90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f2da0273950>], 'label': 'end'}
2017-12-21 15:21:15,584: Flushing usage events
2017-12-21 15:21:23,398: Tracking: tracking
2017-12-21 15:21:23,398: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2456e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2456f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2456ed0>], 'label': 'start'}
2017-12-21 15:21:23,438: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 15:21:23,454: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 15:21:23,455: Parsing core.sql
2017-12-21 15:21:23,466: Parsing etc/get_custom_schema.sql
2017-12-21 15:21:23,471: Parsing schema_tests/relationships.sql
2017-12-21 15:21:23,474: Parsing schema_tests/accepted_values.sql
2017-12-21 15:21:23,477: Parsing schema_tests/not_null.sql
2017-12-21 15:21:23,478: Parsing schema_tests/unique.sql
2017-12-21 15:21:23,480: Parsing materializations/wrapper.sql
2017-12-21 15:21:23,483: Parsing materializations/archive.sql
2017-12-21 15:21:23,510: Parsing materializations/table.sql
2017-12-21 15:21:23,527: Parsing materializations/helpers.sql
2017-12-21 15:21:23,542: Parsing materializations/bigquery.sql
2017-12-21 15:21:23,555: Parsing materializations/view.sql
2017-12-21 15:21:23,568: Parsing materializations/incremental.sql
2017-12-21 15:21:23,593: Parsing adapters/redshift.sql
2017-12-21 15:21:23,609: Parsing adapters/bigquery.sql
2017-12-21 15:21:23,614: Parsing adapters/postgres.sql
2017-12-21 15:21:23,616: Parsing adapters/common.sql
2017-12-21 15:21:23,634: Parsing model.parsely.parsely_audit
2017-12-21 15:21:23,636: Parsing model.parsely.parsely_video_content
2017-12-21 15:21:23,639: Parsing model.parsely.parsely_post_content
2017-12-21 15:21:23,641: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 15:21:23,645: Parsing model.parsely.parsely_rawdata
2017-12-21 15:21:23,648: Parsing model.parsely.calendar
2017-12-21 15:21:23,649: Parsing model.parsely.parsely_all_events
2017-12-21 15:21:23,657: Acquiring new redshift connection "parsely_all_events".
2017-12-21 15:21:23,657: Opening a new connection (0 currently allocated)
2017-12-21 15:21:23,669: Using redshift connection "parsely_all_events".
2017-12-21 15:21:23,670: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:23,695: SQL status: SELECT in 0.03 seconds
2017-12-21 15:21:23,701: Parsing model.parsely.parsely_event_ids
2017-12-21 15:21:23,703: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 15:21:23,705: Parsing model.parsely.parsely_base_events
2017-12-21 15:21:23,709: Acquiring new redshift connection "parsely_base_events".
2017-12-21 15:21:23,709: Re-using an available connection from the pool.
2017-12-21 15:21:23,709: Using redshift connection "parsely_base_events".
2017-12-21 15:21:23,709: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:23,731: SQL status: SELECT in 0.02 seconds
2017-12-21 15:21:23,732: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 15:21:23,737: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 15:21:23,741: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 15:21:23,743: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 15:21:23,745: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 15:21:23,748: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 15:21:23,754: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 15:21:23,761: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 15:21:23,766: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:21:23,766: Re-using an available connection from the pool.
2017-12-21 15:21:23,766: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:21:23,766: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:23,787: SQL status: SELECT in 0.02 seconds
2017-12-21 15:21:23,788: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 15:21:23,795: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 15:21:23,799: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:21:23,799: Re-using an available connection from the pool.
2017-12-21 15:21:23,799: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:21:23,800: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:23,824: SQL status: SELECT in 0.02 seconds
2017-12-21 15:21:23,824: Parsing model.parsely.parsely_incoming_users
2017-12-21 15:21:23,827: Parsing model.parsely.parsely_users
2017-12-21 15:21:23,832: Acquiring new redshift connection "parsely_users".
2017-12-21 15:21:23,832: Re-using an available connection from the pool.
2017-12-21 15:21:23,832: Using redshift connection "parsely_users".
2017-12-21 15:21:23,832: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:23,854: SQL status: SELECT in 0.02 seconds
2017-12-21 15:21:23,855: Parsing model.parsely.parsely_errors
2017-12-21 15:21:23,858: Parsing model.parsely.parsely_bot_traffic
2017-12-21 15:21:23,862: Parsing model.parsely.parsely_custom_events
2017-12-21 15:21:23,867: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 15:21:23,871: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 15:21:23,873: Parsing model.parsely.parsely_sessions
2017-12-21 15:21:23,879: Acquiring new redshift connection "parsely_sessions".
2017-12-21 15:21:23,879: Re-using an available connection from the pool.
2017-12-21 15:21:23,879: Using redshift connection "parsely_sessions".
2017-12-21 15:21:23,879: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:23,901: SQL status: SELECT in 0.02 seconds
2017-12-21 15:21:23,901: Parsing model.parsely.parsely_campaigns
2017-12-21 15:21:23,905: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 15:21:23,905: Re-using an available connection from the pool.
2017-12-21 15:21:23,905: Using redshift connection "parsely_campaigns".
2017-12-21 15:21:23,905: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:23,926: SQL status: SELECT in 0.02 seconds
2017-12-21 15:21:23,931: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 15:21:23,937: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 15:21:23,944: 
2017-12-21 15:21:23,946: Acquiring new redshift connection "master".
2017-12-21 15:21:23,946: Re-using an available connection from the pool.
2017-12-21 15:21:23,947: Using redshift connection "master".
2017-12-21 15:21:23,947: On master: select distinct nspname from pg_namespace
2017-12-21 15:21:23,949: SQL status: SELECT in 0.00 seconds
2017-12-21 15:21:23,951: Using redshift connection "master".
2017-12-21 15:21:23,952: On master: BEGIN
2017-12-21 15:21:23,953: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:21:23,953: On master: COMMIT
2017-12-21 15:21:23,953: Using redshift connection "master".
2017-12-21 15:21:23,953: On master: COMMIT
2017-12-21 15:21:23,955: SQL status: COMMIT in 0.00 seconds
2017-12-21 15:21:23,960: 15:21:23 | Concurrency: 1 threads (target='dev')
2017-12-21 15:21:23,960: 15:21:23 | 
2017-12-21 15:21:23,960: Using redshift connection "master".
2017-12-21 15:21:23,961: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:23,983: SQL status: SELECT in 0.02 seconds
2017-12-21 15:21:24,054: 15:21:24 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-21 15:21:24,054: Compiling model.parsely.calendar
2017-12-21 15:21:24,059: Writing injected SQL for node "model.parsely.calendar"
2017-12-21 15:21:24,060: Acquiring new redshift connection "calendar".
2017-12-21 15:21:24,060: Opening a new connection (1 currently allocated)
2017-12-21 15:21:24,081: Using redshift connection "calendar".
2017-12-21 15:21:24,081: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:24,107: SQL status: SELECT in 0.03 seconds
2017-12-21 15:21:24,109: Writing runtime SQL for node "model.parsely.calendar"
2017-12-21 15:21:24,109: Using redshift connection "calendar".
2017-12-21 15:21:24,109: On calendar: BEGIN
2017-12-21 15:21:24,111: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:21:24,111: Using redshift connection "calendar".
2017-12-21 15:21:24,111: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-21 15:21:24,495: SQL status: CREATE VIEW in 0.38 seconds
2017-12-21 15:21:24,495: On calendar: COMMIT
2017-12-21 15:21:24,495: Using redshift connection "calendar".
2017-12-21 15:21:24,495: On calendar: COMMIT
2017-12-21 15:21:25,357: SQL status: COMMIT in 0.86 seconds
2017-12-21 15:21:25,357: Using redshift connection "calendar".
2017-12-21 15:21:25,357: On calendar: BEGIN
2017-12-21 15:21:25,359: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:21:25,359: Using redshift connection "calendar".
2017-12-21 15:21:25,359: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-21 15:21:25,780: SQL status: DROP VIEW in 0.42 seconds
2017-12-21 15:21:25,781: On calendar: COMMIT
2017-12-21 15:21:25,781: Using redshift connection "calendar".
2017-12-21 15:21:25,781: On calendar: COMMIT
2017-12-21 15:21:26,257: SQL status: COMMIT in 0.48 seconds
2017-12-21 15:21:26,257: Using redshift connection "calendar".
2017-12-21 15:21:26,258: On calendar: BEGIN
2017-12-21 15:21:26,259: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:21:26,260: Using redshift connection "calendar".
2017-12-21 15:21:26,260: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-21 15:21:26,273: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 15:21:26,273: On calendar: COMMIT
2017-12-21 15:21:26,273: Using redshift connection "calendar".
2017-12-21 15:21:26,273: On calendar: COMMIT
2017-12-21 15:21:26,630: SQL status: COMMIT in 0.36 seconds
2017-12-21 15:21:26,631: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2344c10>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:21:26,667: 15:21:26 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 2.58s]
2017-12-21 15:21:26,667: 15:21:26 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-21 15:21:26,668: Compiling model.parsely.parsely_rawdata
2017-12-21 15:21:26,673: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-21 15:21:26,674: Acquiring new redshift connection "parsely_rawdata".
2017-12-21 15:21:26,674: Re-using an available connection from the pool.
2017-12-21 15:21:26,675: Using redshift connection "parsely_rawdata".
2017-12-21 15:21:26,675: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:26,694: SQL status: SELECT in 0.02 seconds
2017-12-21 15:21:26,695: Using redshift connection "parsely_rawdata".
2017-12-21 15:21:26,695: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:21:26,704: SQL status: SELECT in 0.01 seconds
2017-12-21 15:21:26,705: Using redshift connection "parsely_rawdata".
2017-12-21 15:21:26,705: On parsely_rawdata: BEGIN
2017-12-21 15:21:26,707: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:21:26,707: Using redshift connection "parsely_rawdata".
2017-12-21 15:21:26,707: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:21:54,879: SQL status: SELECT in 28.17 seconds
2017-12-21 15:21:54,879: Using redshift connection "parsely_rawdata".
2017-12-21 15:21:54,880: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-21 15:21:55,240: SQL status: SELECT in 0.36 seconds
2017-12-21 15:21:55,241: Using redshift connection "parsely_rawdata".
2017-12-21 15:21:55,241: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:21:55,347: SQL status: SELECT in 0.11 seconds
2017-12-21 15:21:55,348: Using redshift connection "parsely_rawdata".
2017-12-21 15:21:55,348: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:21:55,449: SQL status: SELECT in 0.10 seconds
2017-12-21 15:21:55,451: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-21 15:21:55,452: Using redshift connection "parsely_rawdata".
2017-12-21 15:21:55,452: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-21 15:22:24,344: SQL status: INSERT 0 1003475 in 28.89 seconds
2017-12-21 15:22:24,344: On parsely_rawdata: COMMIT
2017-12-21 15:22:24,344: Using redshift connection "parsely_rawdata".
2017-12-21 15:22:24,344: On parsely_rawdata: COMMIT
2017-12-21 15:22:26,531: SQL status: COMMIT in 2.19 seconds
2017-12-21 15:22:26,532: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2450250>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:22:26,574: 15:22:26 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1003475 in 59.86s]
2017-12-21 15:22:26,574: 15:22:26 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-21 15:22:26,575: Compiling model.parsely.parsely_all_events
2017-12-21 15:22:26,587: Acquiring new redshift connection "parsely_all_events".
2017-12-21 15:22:26,587: Re-using an available connection from the pool.
2017-12-21 15:22:26,587: Using redshift connection "parsely_all_events".
2017-12-21 15:22:26,587: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:22:26,602: SQL status: SELECT in 0.02 seconds
2017-12-21 15:22:26,610: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-21 15:22:26,611: Using redshift connection "parsely_all_events".
2017-12-21 15:22:26,612: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:22:26,626: SQL status: SELECT in 0.01 seconds
2017-12-21 15:22:26,626: Using redshift connection "parsely_all_events".
2017-12-21 15:22:26,626: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:22:26,641: SQL status: SELECT in 0.01 seconds
2017-12-21 15:22:26,643: Using redshift connection "parsely_all_events".
2017-12-21 15:22:26,643: On parsely_all_events: BEGIN
2017-12-21 15:22:26,645: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:22:26,645: Using redshift connection "parsely_all_events".
2017-12-21 15:22:26,645: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:24:15,138: SQL status: SELECT in 108.49 seconds
2017-12-21 15:24:15,138: Using redshift connection "parsely_all_events".
2017-12-21 15:24:15,138: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2017-12-21 15:24:15,319: SQL status: SELECT in 0.18 seconds
2017-12-21 15:24:15,320: Using redshift connection "parsely_all_events".
2017-12-21 15:24:15,320: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:24:15,421: SQL status: SELECT in 0.10 seconds
2017-12-21 15:24:15,422: Using redshift connection "parsely_all_events".
2017-12-21 15:24:15,422: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:24:15,529: SQL status: SELECT in 0.11 seconds
2017-12-21 15:24:15,532: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-21 15:24:15,533: Using redshift connection "parsely_all_events".
2017-12-21 15:24:15,533: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2017-12-21 15:24:31,888: SQL status: INSERT 0 887987 in 16.35 seconds
2017-12-21 15:24:31,888: On parsely_all_events: COMMIT
2017-12-21 15:24:31,888: Using redshift connection "parsely_all_events".
2017-12-21 15:24:31,889: On parsely_all_events: COMMIT
2017-12-21 15:24:34,434: SQL status: COMMIT in 2.55 seconds
2017-12-21 15:24:34,434: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e243d990>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:24:34,472: 15:24:34 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 887987 in 127.86s]
2017-12-21 15:24:34,472: 15:24:34 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-21 15:24:34,473: Compiling model.parsely.parsely_bot_traffic
2017-12-21 15:24:34,479: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 15:24:34,480: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-21 15:24:34,480: Re-using an available connection from the pool.
2017-12-21 15:24:34,481: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:24:34,481: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:24:34,496: SQL status: SELECT in 0.02 seconds
2017-12-21 15:24:34,496: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:24:34,497: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:24:34,516: SQL status: SELECT in 0.02 seconds
2017-12-21 15:24:34,518: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:24:34,518: On parsely_bot_traffic: BEGIN
2017-12-21 15:24:34,519: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:24:34,520: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:24:34,520: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:24:55,443: SQL status: SELECT in 20.92 seconds
2017-12-21 15:24:55,443: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:24:55,444: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2017-12-21 15:24:55,599: SQL status: SELECT in 0.16 seconds
2017-12-21 15:24:55,599: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:24:55,600: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:24:55,714: SQL status: SELECT in 0.11 seconds
2017-12-21 15:24:55,715: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:24:55,715: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:24:55,826: SQL status: SELECT in 0.11 seconds
2017-12-21 15:24:55,829: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 15:24:55,830: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:24:55,830: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2017-12-21 15:24:56,965: SQL status: INSERT 0 4 in 1.14 seconds
2017-12-21 15:24:56,966: On parsely_bot_traffic: COMMIT
2017-12-21 15:24:56,966: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:24:56,966: On parsely_bot_traffic: COMMIT
2017-12-21 15:24:58,799: SQL status: COMMIT in 1.83 seconds
2017-12-21 15:24:58,800: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2344650>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:24:58,828: 15:24:58 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 24.33s]
2017-12-21 15:24:58,828: 15:24:58 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-21 15:24:58,829: Compiling model.parsely.parsely_custom_events
2017-12-21 15:24:58,837: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-21 15:24:58,838: Acquiring new redshift connection "parsely_custom_events".
2017-12-21 15:24:58,838: Re-using an available connection from the pool.
2017-12-21 15:24:58,838: Using redshift connection "parsely_custom_events".
2017-12-21 15:24:58,838: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:24:58,854: SQL status: SELECT in 0.02 seconds
2017-12-21 15:24:58,854: Using redshift connection "parsely_custom_events".
2017-12-21 15:24:58,854: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:24:58,869: SQL status: SELECT in 0.01 seconds
2017-12-21 15:24:58,871: Using redshift connection "parsely_custom_events".
2017-12-21 15:24:58,871: On parsely_custom_events: BEGIN
2017-12-21 15:24:58,873: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:24:58,873: Using redshift connection "parsely_custom_events".
2017-12-21 15:24:58,873: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:25:19,811: SQL status: SELECT in 20.94 seconds
2017-12-21 15:25:19,811: Using redshift connection "parsely_custom_events".
2017-12-21 15:25:19,811: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2017-12-21 15:25:19,960: SQL status: SELECT in 0.15 seconds
2017-12-21 15:25:19,960: Using redshift connection "parsely_custom_events".
2017-12-21 15:25:19,960: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:25:20,067: SQL status: SELECT in 0.11 seconds
2017-12-21 15:25:20,068: Using redshift connection "parsely_custom_events".
2017-12-21 15:25:20,068: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:25:20,180: SQL status: SELECT in 0.11 seconds
2017-12-21 15:25:20,183: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-21 15:25:20,184: Using redshift connection "parsely_custom_events".
2017-12-21 15:25:20,184: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2017-12-21 15:25:20,459: SQL status: INSERT 0 0 in 0.27 seconds
2017-12-21 15:25:20,459: On parsely_custom_events: COMMIT
2017-12-21 15:25:20,459: Using redshift connection "parsely_custom_events".
2017-12-21 15:25:20,460: On parsely_custom_events: COMMIT
2017-12-21 15:25:20,759: SQL status: COMMIT in 0.30 seconds
2017-12-21 15:25:20,759: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2400190>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:25:20,787: 15:25:20 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 21.93s]
2017-12-21 15:25:20,787: 15:25:20 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-21 15:25:20,787: Compiling model.parsely.parsely_errors
2017-12-21 15:25:20,794: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-21 15:25:20,795: Acquiring new redshift connection "parsely_errors".
2017-12-21 15:25:20,795: Re-using an available connection from the pool.
2017-12-21 15:25:20,796: Using redshift connection "parsely_errors".
2017-12-21 15:25:20,796: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:25:20,813: SQL status: SELECT in 0.02 seconds
2017-12-21 15:25:20,813: Using redshift connection "parsely_errors".
2017-12-21 15:25:20,813: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:25:20,828: SQL status: SELECT in 0.01 seconds
2017-12-21 15:25:20,829: Using redshift connection "parsely_errors".
2017-12-21 15:25:20,829: On parsely_errors: BEGIN
2017-12-21 15:25:20,831: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:25:20,831: Using redshift connection "parsely_errors".
2017-12-21 15:25:20,831: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:25:40,825: SQL status: SELECT in 19.99 seconds
2017-12-21 15:25:40,826: Using redshift connection "parsely_errors".
2017-12-21 15:25:40,826: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2017-12-21 15:25:41,288: SQL status: SELECT in 0.46 seconds
2017-12-21 15:25:41,289: Using redshift connection "parsely_errors".
2017-12-21 15:25:41,289: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:25:41,401: SQL status: SELECT in 0.11 seconds
2017-12-21 15:25:41,402: Using redshift connection "parsely_errors".
2017-12-21 15:25:41,402: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:25:41,511: SQL status: SELECT in 0.11 seconds
2017-12-21 15:25:41,514: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-21 15:25:41,515: Using redshift connection "parsely_errors".
2017-12-21 15:25:41,515: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2017-12-21 15:25:42,390: SQL status: INSERT 0 2 in 0.87 seconds
2017-12-21 15:25:42,390: On parsely_errors: COMMIT
2017-12-21 15:25:42,390: Using redshift connection "parsely_errors".
2017-12-21 15:25:42,390: On parsely_errors: COMMIT
2017-12-21 15:25:43,179: SQL status: COMMIT in 0.79 seconds
2017-12-21 15:25:43,180: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2336bd0>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:25:43,249: 15:25:43 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 22.39s]
2017-12-21 15:25:43,250: 15:25:43 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-21 15:25:43,250: Compiling model.parsely.parsely_base_events
2017-12-21 15:25:43,254: Acquiring new redshift connection "parsely_base_events".
2017-12-21 15:25:43,254: Re-using an available connection from the pool.
2017-12-21 15:25:43,254: Using redshift connection "parsely_base_events".
2017-12-21 15:25:43,254: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:25:43,269: SQL status: SELECT in 0.01 seconds
2017-12-21 15:25:43,273: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-21 15:25:43,274: Using redshift connection "parsely_base_events".
2017-12-21 15:25:43,274: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:25:43,288: SQL status: SELECT in 0.01 seconds
2017-12-21 15:25:43,290: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-21 15:25:43,291: Using redshift connection "parsely_base_events".
2017-12-21 15:25:43,291: On parsely_base_events: BEGIN
2017-12-21 15:25:43,292: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:25:43,293: Using redshift connection "parsely_base_events".
2017-12-21 15:25:43,293: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-21 15:25:44,728: SQL status: CREATE VIEW in 1.43 seconds
2017-12-21 15:25:44,728: On parsely_base_events: COMMIT
2017-12-21 15:25:44,728: Using redshift connection "parsely_base_events".
2017-12-21 15:25:44,728: On parsely_base_events: COMMIT
2017-12-21 15:25:45,562: SQL status: COMMIT in 0.83 seconds
2017-12-21 15:25:45,562: Using redshift connection "parsely_base_events".
2017-12-21 15:25:45,562: On parsely_base_events: BEGIN
2017-12-21 15:25:45,564: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:25:45,565: Using redshift connection "parsely_base_events".
2017-12-21 15:25:45,565: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2017-12-21 15:25:50,715: SQL status: DROP VIEW in 5.15 seconds
2017-12-21 15:25:50,715: On parsely_base_events: COMMIT
2017-12-21 15:25:50,715: Using redshift connection "parsely_base_events".
2017-12-21 15:25:50,715: On parsely_base_events: COMMIT
2017-12-21 15:25:52,082: SQL status: COMMIT in 1.37 seconds
2017-12-21 15:25:52,082: Using redshift connection "parsely_base_events".
2017-12-21 15:25:52,082: On parsely_base_events: BEGIN
2017-12-21 15:25:52,086: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:25:52,086: Using redshift connection "parsely_base_events".
2017-12-21 15:25:52,086: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-21 15:25:52,094: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 15:25:52,094: On parsely_base_events: COMMIT
2017-12-21 15:25:52,094: Using redshift connection "parsely_base_events".
2017-12-21 15:25:52,094: On parsely_base_events: COMMIT
2017-12-21 15:25:52,496: SQL status: COMMIT in 0.40 seconds
2017-12-21 15:25:52,496: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e243d990>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:25:52,522: 15:25:52 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 9.25s]
2017-12-21 15:25:52,523: 15:25:52 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2017-12-21 15:25:52,523: Compiling model.parsely.parsely_event_ids
2017-12-21 15:25:52,528: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-21 15:25:52,530: Acquiring new redshift connection "parsely_event_ids".
2017-12-21 15:25:52,530: Re-using an available connection from the pool.
2017-12-21 15:25:52,530: Using redshift connection "parsely_event_ids".
2017-12-21 15:25:52,530: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:25:52,575: SQL status: SELECT in 0.05 seconds
2017-12-21 15:25:52,576: Using redshift connection "parsely_event_ids".
2017-12-21 15:25:52,576: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:25:52,626: SQL status: SELECT in 0.05 seconds
2017-12-21 15:25:52,627: Using redshift connection "parsely_event_ids".
2017-12-21 15:25:52,627: On parsely_event_ids: BEGIN
2017-12-21 15:25:52,642: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:25:52,642: Using redshift connection "parsely_event_ids".
2017-12-21 15:25:52,642: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:25:54,824: SQL status: SELECT in 2.18 seconds
2017-12-21 15:25:54,824: Using redshift connection "parsely_event_ids".
2017-12-21 15:25:54,824: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2017-12-21 15:25:55,169: SQL status: SELECT in 0.34 seconds
2017-12-21 15:25:55,169: Using redshift connection "parsely_event_ids".
2017-12-21 15:25:55,169: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:25:55,397: SQL status: SELECT in 0.23 seconds
2017-12-21 15:25:55,397: Using redshift connection "parsely_event_ids".
2017-12-21 15:25:55,398: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:25:55,691: SQL status: SELECT in 0.29 seconds
2017-12-21 15:25:55,692: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-21 15:25:55,693: Using redshift connection "parsely_event_ids".
2017-12-21 15:25:55,693: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2017-12-21 15:25:58,001: SQL status: INSERT 0 887983 in 2.31 seconds
2017-12-21 15:25:58,001: On parsely_event_ids: COMMIT
2017-12-21 15:25:58,001: Using redshift connection "parsely_event_ids".
2017-12-21 15:25:58,002: On parsely_event_ids: COMMIT
2017-12-21 15:25:58,585: SQL status: COMMIT in 0.58 seconds
2017-12-21 15:25:58,585: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e243d990>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:25:58,611: 15:25:58 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 887983 in 6.06s]
2017-12-21 15:25:58,612: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-21 15:25:58,617: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-21 15:25:58,618: 15:25:58 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-21 15:25:58,618: Compiling model.parsely.parsely_post_content
2017-12-21 15:25:58,624: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-21 15:25:58,625: Acquiring new redshift connection "parsely_post_content".
2017-12-21 15:25:58,625: Re-using an available connection from the pool.
2017-12-21 15:25:58,625: Using redshift connection "parsely_post_content".
2017-12-21 15:25:58,625: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:25:58,643: SQL status: SELECT in 0.02 seconds
2017-12-21 15:25:58,643: Using redshift connection "parsely_post_content".
2017-12-21 15:25:58,643: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:25:58,679: SQL status: SELECT in 0.04 seconds
2017-12-21 15:25:58,681: Using redshift connection "parsely_post_content".
2017-12-21 15:25:58,681: On parsely_post_content: BEGIN
2017-12-21 15:25:58,683: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:25:58,684: Using redshift connection "parsely_post_content".
2017-12-21 15:25:58,684: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:26:10,676: SQL status: SELECT in 11.99 seconds
2017-12-21 15:26:10,677: Using redshift connection "parsely_post_content".
2017-12-21 15:26:10,677: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2017-12-21 15:26:11,155: SQL status: SELECT in 0.48 seconds
2017-12-21 15:26:11,155: Using redshift connection "parsely_post_content".
2017-12-21 15:26:11,155: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:26:11,452: SQL status: SELECT in 0.30 seconds
2017-12-21 15:26:11,453: Using redshift connection "parsely_post_content".
2017-12-21 15:26:11,453: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:26:11,768: SQL status: SELECT in 0.31 seconds
2017-12-21 15:26:11,770: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-21 15:26:11,770: Using redshift connection "parsely_post_content".
2017-12-21 15:26:11,770: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2017-12-21 15:26:12,493: SQL status: INSERT 0 873 in 0.72 seconds
2017-12-21 15:26:12,493: On parsely_post_content: COMMIT
2017-12-21 15:26:12,493: Using redshift connection "parsely_post_content".
2017-12-21 15:26:12,493: On parsely_post_content: COMMIT
2017-12-21 15:26:13,011: SQL status: COMMIT in 0.52 seconds
2017-12-21 15:26:13,011: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e23ae890>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:26:13,040: 15:26:13 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 873 in 14.39s]
2017-12-21 15:26:13,041: 15:26:13 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2017-12-21 15:26:13,041: Compiling model.parsely.parsely_video_content
2017-12-21 15:26:13,047: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-21 15:26:13,048: Acquiring new redshift connection "parsely_video_content".
2017-12-21 15:26:13,048: Re-using an available connection from the pool.
2017-12-21 15:26:13,048: Using redshift connection "parsely_video_content".
2017-12-21 15:26:13,048: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:26:13,091: SQL status: SELECT in 0.04 seconds
2017-12-21 15:26:13,092: Using redshift connection "parsely_video_content".
2017-12-21 15:26:13,092: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:26:13,155: SQL status: SELECT in 0.06 seconds
2017-12-21 15:26:13,156: Using redshift connection "parsely_video_content".
2017-12-21 15:26:13,156: On parsely_video_content: BEGIN
2017-12-21 15:26:13,165: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:26:13,165: Using redshift connection "parsely_video_content".
2017-12-21 15:26:13,165: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:26:23,759: SQL status: SELECT in 10.59 seconds
2017-12-21 15:26:23,759: Using redshift connection "parsely_video_content".
2017-12-21 15:26:23,759: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2017-12-21 15:26:24,093: SQL status: SELECT in 0.33 seconds
2017-12-21 15:26:24,094: Using redshift connection "parsely_video_content".
2017-12-21 15:26:24,094: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:26:24,378: SQL status: SELECT in 0.28 seconds
2017-12-21 15:26:24,378: Using redshift connection "parsely_video_content".
2017-12-21 15:26:24,378: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:26:24,664: SQL status: SELECT in 0.29 seconds
2017-12-21 15:26:24,666: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-21 15:26:24,666: Using redshift connection "parsely_video_content".
2017-12-21 15:26:24,666: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2017-12-21 15:26:25,429: SQL status: INSERT 0 465 in 0.76 seconds
2017-12-21 15:26:25,429: On parsely_video_content: COMMIT
2017-12-21 15:26:25,429: Using redshift connection "parsely_video_content".
2017-12-21 15:26:25,429: On parsely_video_content: COMMIT
2017-12-21 15:26:26,207: SQL status: COMMIT in 0.78 seconds
2017-12-21 15:26:26,207: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2344b90>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:26:26,235: 15:26:26 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 465 in 13.17s]
2017-12-21 15:26:26,236: 15:26:26 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-21 15:26:26,236: Compiling model.parsely.parsely_entry_exit_urls
2017-12-21 15:26:26,241: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 15:26:26,242: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-21 15:26:26,243: Re-using an available connection from the pool.
2017-12-21 15:26:26,243: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:26:26,243: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:26:26,285: SQL status: SELECT in 0.04 seconds
2017-12-21 15:26:26,287: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 15:26:26,287: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:26:26,287: On parsely_entry_exit_urls: BEGIN
2017-12-21 15:26:26,290: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:26:26,290: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:26:26,290: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-21 15:26:27,107: SQL status: CREATE VIEW in 0.82 seconds
2017-12-21 15:26:27,107: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:26:27,107: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2017-12-21 15:26:27,112: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:26:27,112: On parsely_entry_exit_urls: COMMIT
2017-12-21 15:26:27,112: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:26:27,112: On parsely_entry_exit_urls: COMMIT
2017-12-21 15:26:27,556: SQL status: COMMIT in 0.44 seconds
2017-12-21 15:26:27,556: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2344b90>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:26:27,585: 15:26:27 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 1.32s]
2017-12-21 15:26:27,585: 15:26:27 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-21 15:26:27,586: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 15:26:27,596: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 15:26:27,597: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 15:26:27,597: Re-using an available connection from the pool.
2017-12-21 15:26:27,597: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:26:27,597: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:26:27,632: SQL status: SELECT in 0.03 seconds
2017-12-21 15:26:27,635: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 15:26:27,636: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:26:27,636: On parsely_incoming_videoviews: BEGIN
2017-12-21 15:26:27,639: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:26:27,639: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:26:27,639: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 15:26:27,773: SQL status: CREATE VIEW in 0.13 seconds
2017-12-21 15:26:27,774: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:26:27,774: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 15:26:27,782: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 15:26:27,782: On parsely_incoming_videoviews: COMMIT
2017-12-21 15:26:27,782: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:26:27,782: On parsely_incoming_videoviews: COMMIT
2017-12-21 15:26:28,123: SQL status: COMMIT in 0.34 seconds
2017-12-21 15:26:28,124: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2344b90>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:26:28,150: 15:26:28 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.54s]
2017-12-21 15:26:28,151: 15:26:28 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 15:26:28,151: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 15:26:28,156: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:26:28,156: Re-using an available connection from the pool.
2017-12-21 15:26:28,156: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:26:28,156: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:26:28,184: SQL status: SELECT in 0.03 seconds
2017-12-21 15:26:28,187: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 15:26:28,188: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:26:28,188: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:26:28,209: SQL status: SELECT in 0.02 seconds
2017-12-21 15:26:28,209: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:26:28,209: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:26:28,225: SQL status: SELECT in 0.02 seconds
2017-12-21 15:26:28,227: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:26:28,227: On parsely_videoviews_sessionized: BEGIN
2017-12-21 15:26:28,229: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:26:28,229: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:26:28,229: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:27:21,593: SQL status: SELECT in 53.36 seconds
2017-12-21 15:27:21,594: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:27:21,594: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2017-12-21 15:27:21,993: SQL status: SELECT in 0.40 seconds
2017-12-21 15:27:21,994: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:27:21,994: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:27:22,106: SQL status: SELECT in 0.11 seconds
2017-12-21 15:27:22,107: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:27:22,107: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:27:22,215: SQL status: SELECT in 0.11 seconds
2017-12-21 15:27:22,218: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 15:27:22,219: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:27:22,219: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 15:27:23,580: SQL status: INSERT 0 141 in 1.36 seconds
2017-12-21 15:27:23,581: On parsely_videoviews_sessionized: COMMIT
2017-12-21 15:27:23,581: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:27:23,581: On parsely_videoviews_sessionized: COMMIT
2017-12-21 15:27:26,016: SQL status: COMMIT in 2.44 seconds
2017-12-21 15:27:26,017: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e23ae810>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:27:26,063: 15:27:26 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 141 in 57.87s]
2017-12-21 15:27:26,063: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-21 15:27:26,085: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-21 15:27:26,086: 15:27:26 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-21 15:27:26,086: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 15:27:26,098: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 15:27:26,099: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:27:26,099: Re-using an available connection from the pool.
2017-12-21 15:27:26,099: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:27:26,100: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:27:26,116: SQL status: SELECT in 0.02 seconds
2017-12-21 15:27:26,118: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 15:27:26,119: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:27:26,119: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-21 15:27:26,121: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:27:26,121: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:27:26,121: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-21 15:27:26,358: SQL status: CREATE VIEW in 0.24 seconds
2017-12-21 15:27:26,359: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:27:26,359: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-21 15:27:26,362: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:27:26,362: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 15:27:26,362: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:27:26,362: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 15:27:27,868: SQL status: COMMIT in 1.51 seconds
2017-12-21 15:27:27,868: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2344a90>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:27:27,894: 15:27:27 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.78s]
2017-12-21 15:27:27,895: 15:27:27 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-21 15:27:27,895: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 15:27:27,922: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 15:27:27,923: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:27:27,923: Re-using an available connection from the pool.
2017-12-21 15:27:27,923: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:27:27,923: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:27:27,937: SQL status: SELECT in 0.01 seconds
2017-12-21 15:27:27,940: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 15:27:27,940: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:27:27,940: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-21 15:27:27,942: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:27:27,942: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:27:27,942: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-21 15:27:31,479: SQL status: CREATE VIEW in 3.54 seconds
2017-12-21 15:27:31,479: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:27:31,479: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-21 15:27:31,483: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:27:31,483: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 15:27:31,483: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:27:31,483: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 15:27:32,830: SQL status: COMMIT in 1.35 seconds
2017-12-21 15:27:32,830: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e23ae850>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:27:32,864: 15:27:32 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 4.94s]
2017-12-21 15:27:32,864: 15:27:32 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2017-12-21 15:27:32,865: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 15:27:32,874: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 15:27:32,878: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 15:27:32,878: Re-using an available connection from the pool.
2017-12-21 15:27:32,878: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:27:32,878: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:27:32,891: SQL status: SELECT in 0.01 seconds
2017-12-21 15:27:32,895: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 15:27:32,895: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:27:32,895: On parsely_incoming_pageviews: BEGIN
2017-12-21 15:27:32,897: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:27:32,897: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:27:32,897: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 15:27:33,087: SQL status: CREATE VIEW in 0.19 seconds
2017-12-21 15:27:33,087: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:27:33,087: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2017-12-21 15:27:33,199: SQL status: ALTER TABLE in 0.11 seconds
2017-12-21 15:27:33,199: On parsely_incoming_pageviews: COMMIT
2017-12-21 15:27:33,200: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:27:33,200: On parsely_incoming_pageviews: COMMIT
2017-12-21 15:27:33,622: SQL status: COMMIT in 0.42 seconds
2017-12-21 15:27:33,623: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e23ae850>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:27:33,647: 15:27:33 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.76s]
2017-12-21 15:27:33,647: 15:27:33 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2017-12-21 15:27:33,647: Compiling model.parsely.parsely_pageviews_sessionized
2017-12-21 15:27:33,653: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:27:33,653: Re-using an available connection from the pool.
2017-12-21 15:27:33,653: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:27:33,653: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:27:33,667: SQL status: SELECT in 0.01 seconds
2017-12-21 15:27:33,671: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 15:27:33,672: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:27:33,672: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:27:33,685: SQL status: SELECT in 0.01 seconds
2017-12-21 15:27:33,685: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:27:33,685: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:27:33,698: SQL status: SELECT in 0.01 seconds
2017-12-21 15:27:33,700: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:27:33,700: On parsely_pageviews_sessionized: BEGIN
2017-12-21 15:27:33,702: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:27:33,702: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:27:33,702: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:29:34,253: SQL status: SELECT in 120.55 seconds
2017-12-21 15:29:34,253: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:29:34,253: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2017-12-21 15:29:34,414: SQL status: SELECT in 0.16 seconds
2017-12-21 15:29:34,414: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:29:34,414: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:29:34,526: SQL status: SELECT in 0.11 seconds
2017-12-21 15:29:34,527: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:29:34,527: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:29:34,637: SQL status: SELECT in 0.11 seconds
2017-12-21 15:29:34,641: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 15:29:34,641: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:29:34,642: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 15:29:37,490: SQL status: INSERT 0 105689 in 2.85 seconds
2017-12-21 15:29:37,490: On parsely_pageviews_sessionized: COMMIT
2017-12-21 15:29:37,491: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:29:37,491: On parsely_pageviews_sessionized: COMMIT
2017-12-21 15:29:39,070: SQL status: COMMIT in 1.58 seconds
2017-12-21 15:29:39,070: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e240bf10>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:29:39,153: 15:29:39 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 105689 in 125.42s]
2017-12-21 15:29:39,154: 15:29:39 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-21 15:29:39,154: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-21 15:29:39,196: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 15:29:39,197: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:29:39,197: Re-using an available connection from the pool.
2017-12-21 15:29:39,197: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:29:39,197: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:29:39,217: SQL status: SELECT in 0.02 seconds
2017-12-21 15:29:39,220: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 15:29:39,221: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:29:39,221: On parsely_videoview_engagedtime: BEGIN
2017-12-21 15:29:39,222: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:29:39,222: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:29:39,223: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-21 15:29:39,585: SQL status: CREATE VIEW in 0.36 seconds
2017-12-21 15:29:39,585: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:29:39,585: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-21 15:29:39,589: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:29:39,589: On parsely_videoview_engagedtime: COMMIT
2017-12-21 15:29:39,589: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:29:39,589: On parsely_videoview_engagedtime: COMMIT
2017-12-21 15:29:39,942: SQL status: COMMIT in 0.35 seconds
2017-12-21 15:29:39,942: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e240bf10>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:29:39,972: 15:29:39 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.79s]
2017-12-21 15:29:39,973: 15:29:39 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-21 15:29:39,973: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-21 15:29:39,981: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 15:29:39,982: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:29:39,982: Re-using an available connection from the pool.
2017-12-21 15:29:39,983: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:29:39,983: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:29:40,003: SQL status: SELECT in 0.02 seconds
2017-12-21 15:29:40,004: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:29:40,004: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:29:40,023: SQL status: SELECT in 0.02 seconds
2017-12-21 15:29:40,026: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:29:40,026: On parsely_videoview_behavior_workflow: BEGIN
2017-12-21 15:29:40,027: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:29:40,028: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:29:40,028: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:30:45,941: SQL status: SELECT in 65.91 seconds
2017-12-21 15:30:45,941: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:30:45,941: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 15:30:46,138: SQL status: SELECT in 0.20 seconds
2017-12-21 15:30:46,139: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:30:46,139: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:30:46,249: SQL status: SELECT in 0.11 seconds
2017-12-21 15:30:46,250: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:30:46,251: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:30:46,359: SQL status: SELECT in 0.11 seconds
2017-12-21 15:30:46,365: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 15:30:46,366: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:30:46,366: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 15:30:48,969: SQL status: INSERT 0 139 in 2.60 seconds
2017-12-21 15:30:48,969: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 15:30:48,969: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:30:48,969: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 15:30:50,843: SQL status: COMMIT in 1.87 seconds
2017-12-21 15:30:50,844: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2450290>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:30:50,911: 15:30:50 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 139 in 70.87s]
2017-12-21 15:30:50,911: 15:30:50 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2017-12-21 15:30:50,911: Compiling model.parsely.parsely_campaigns
2017-12-21 15:30:50,930: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 15:30:50,930: Re-using an available connection from the pool.
2017-12-21 15:30:50,930: Using redshift connection "parsely_campaigns".
2017-12-21 15:30:50,931: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:30:50,951: SQL status: SELECT in 0.02 seconds
2017-12-21 15:30:50,957: Writing injected SQL for node "model.parsely.parsely_campaigns"
2017-12-21 15:30:50,958: Using redshift connection "parsely_campaigns".
2017-12-21 15:30:50,958: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:30:50,977: SQL status: SELECT in 0.02 seconds
2017-12-21 15:30:50,978: Using redshift connection "parsely_campaigns".
2017-12-21 15:30:50,978: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:30:50,996: SQL status: SELECT in 0.02 seconds
2017-12-21 15:30:50,998: Using redshift connection "parsely_campaigns".
2017-12-21 15:30:50,998: On parsely_campaigns: BEGIN
2017-12-21 15:30:51,000: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:30:51,000: Using redshift connection "parsely_campaigns".
2017-12-21 15:30:51,000: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:30:52,350: SQL status: SELECT in 1.35 seconds
2017-12-21 15:30:52,351: Using redshift connection "parsely_campaigns".
2017-12-21 15:30:52,351: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2017-12-21 15:30:52,538: SQL status: SELECT in 0.19 seconds
2017-12-21 15:30:52,538: Using redshift connection "parsely_campaigns".
2017-12-21 15:30:52,538: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:30:52,642: SQL status: SELECT in 0.10 seconds
2017-12-21 15:30:52,643: Using redshift connection "parsely_campaigns".
2017-12-21 15:30:52,643: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:30:52,747: SQL status: SELECT in 0.10 seconds
2017-12-21 15:30:52,749: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2017-12-21 15:30:52,750: Using redshift connection "parsely_campaigns".
2017-12-21 15:30:52,750: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2017-12-21 15:30:52,888: SQL status: INSERT 0 373 in 0.14 seconds
2017-12-21 15:30:52,889: On parsely_campaigns: COMMIT
2017-12-21 15:30:52,889: Using redshift connection "parsely_campaigns".
2017-12-21 15:30:52,889: On parsely_campaigns: COMMIT
2017-12-21 15:30:53,420: SQL status: COMMIT in 0.53 seconds
2017-12-21 15:30:53,420: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2450290>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:30:53,476: 15:30:53 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 373 in 2.51s]
2017-12-21 15:30:53,476: Compiling model.parsely.parsely_incoming_users
2017-12-21 15:30:53,497: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 15:30:53,508: 15:30:53 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2017-12-21 15:30:53,508: Compiling model.parsely.parsely_users
2017-12-21 15:30:53,526: Acquiring new redshift connection "parsely_users".
2017-12-21 15:30:53,526: Re-using an available connection from the pool.
2017-12-21 15:30:53,526: Using redshift connection "parsely_users".
2017-12-21 15:30:53,526: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:30:53,547: SQL status: SELECT in 0.02 seconds
2017-12-21 15:30:53,763: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 15:30:53,766: Using redshift connection "parsely_users".
2017-12-21 15:30:53,766: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:30:53,786: SQL status: SELECT in 0.02 seconds
2017-12-21 15:30:53,786: Using redshift connection "parsely_users".
2017-12-21 15:30:53,786: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:30:53,804: SQL status: SELECT in 0.02 seconds
2017-12-21 15:30:53,808: Using redshift connection "parsely_users".
2017-12-21 15:30:53,808: On parsely_users: BEGIN
2017-12-21 15:30:53,810: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:30:53,810: Using redshift connection "parsely_users".
2017-12-21 15:30:53,810: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3,4
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3,4
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      visitor_ip,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3,4
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id, visitor_ip)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3,4


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    visitor_ip,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:30:55,751: SQL status: SELECT in 1.94 seconds
2017-12-21 15:30:55,752: Using redshift connection "parsely_users".
2017-12-21 15:30:55,752: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2017-12-21 15:30:55,953: SQL status: SELECT in 0.20 seconds
2017-12-21 15:30:55,953: Using redshift connection "parsely_users".
2017-12-21 15:30:55,953: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:30:56,074: SQL status: SELECT in 0.12 seconds
2017-12-21 15:30:56,075: Using redshift connection "parsely_users".
2017-12-21 15:30:56,075: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:30:56,181: SQL status: SELECT in 0.11 seconds
2017-12-21 15:30:56,183: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 15:30:56,184: Using redshift connection "parsely_users".
2017-12-21 15:30:56,185: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2017-12-21 15:30:56,467: SQL status: INSERT 0 58730 in 0.28 seconds
2017-12-21 15:30:56,467: On parsely_users: COMMIT
2017-12-21 15:30:56,467: Using redshift connection "parsely_users".
2017-12-21 15:30:56,468: On parsely_users: COMMIT
2017-12-21 15:30:56,800: SQL status: COMMIT in 0.33 seconds
2017-12-21 15:30:56,801: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e23a5e10>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:30:56,845: 15:30:56 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 58730 in 3.29s]
2017-12-21 15:30:56,852: 15:30:56 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2017-12-21 15:30:56,852: Compiling model.parsely.parsely_pageview_engagedtime
2017-12-21 15:30:56,988: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 15:30:56,990: Acquiring new redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:30:56,990: Re-using an available connection from the pool.
2017-12-21 15:30:56,991: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:30:56,991: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:30:57,011: SQL status: SELECT in 0.02 seconds
2017-12-21 15:30:57,015: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 15:30:57,016: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:30:57,016: On parsely_pageview_engagedtime: BEGIN
2017-12-21 15:30:57,018: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:30:57,019: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:30:57,019: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2017-12-21 15:30:57,104: SQL status: CREATE VIEW in 0.08 seconds
2017-12-21 15:30:57,104: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:30:57,104: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2017-12-21 15:30:57,108: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:30:57,109: On parsely_pageview_engagedtime: COMMIT
2017-12-21 15:30:57,109: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:30:57,109: On parsely_pageview_engagedtime: COMMIT
2017-12-21 15:30:57,300: SQL status: COMMIT in 0.19 seconds
2017-12-21 15:30:57,301: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e23a5e10>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:30:57,349: 15:30:57 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.45s]
2017-12-21 15:30:57,356: 15:30:57 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2017-12-21 15:30:57,356: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 15:30:57,376: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 15:30:57,377: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 15:30:57,377: Re-using an available connection from the pool.
2017-12-21 15:30:57,378: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:30:57,378: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:30:57,398: SQL status: SELECT in 0.02 seconds
2017-12-21 15:30:57,402: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 15:30:57,403: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:30:57,403: On parsely_incoming_sessions: BEGIN
2017-12-21 15:30:57,408: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:30:57,408: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:30:57,408: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 15:30:57,700: SQL status: CREATE VIEW in 0.29 seconds
2017-12-21 15:30:57,701: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:30:57,701: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 15:30:57,704: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:30:57,705: On parsely_incoming_sessions: COMMIT
2017-12-21 15:30:57,705: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:30:57,705: On parsely_incoming_sessions: COMMIT
2017-12-21 15:30:58,070: SQL status: COMMIT in 0.36 seconds
2017-12-21 15:30:58,070: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2450250>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:30:58,129: 15:30:58 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.71s]
2017-12-21 15:30:58,129: 15:30:58 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2017-12-21 15:30:58,129: Compiling model.parsely.parsely_pageview_behavior_workflow
2017-12-21 15:30:58,152: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 15:30:58,162: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:30:58,162: Re-using an available connection from the pool.
2017-12-21 15:30:58,162: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:30:58,162: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:30:58,183: SQL status: SELECT in 0.02 seconds
2017-12-21 15:30:58,184: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:30:58,184: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:30:58,203: SQL status: SELECT in 0.02 seconds
2017-12-21 15:30:58,206: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:30:58,206: On parsely_pageview_behavior_workflow: BEGIN
2017-12-21 15:30:58,208: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:30:58,208: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:30:58,208: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:31:55,227: SQL status: SELECT in 57.02 seconds
2017-12-21 15:31:55,227: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:31:55,228: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 15:31:55,387: SQL status: SELECT in 0.16 seconds
2017-12-21 15:31:55,388: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:31:55,388: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:31:55,501: SQL status: SELECT in 0.11 seconds
2017-12-21 15:31:55,502: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:31:55,502: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:31:55,614: SQL status: SELECT in 0.11 seconds
2017-12-21 15:31:55,621: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 15:31:55,626: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:31:55,626: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 15:32:00,534: SQL status: INSERT 0 105669 in 4.91 seconds
2017-12-21 15:32:00,535: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 15:32:00,535: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:32:00,535: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 15:32:01,900: SQL status: COMMIT in 1.36 seconds
2017-12-21 15:32:01,901: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2450290>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:32:01,985: 15:32:01 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 105669 in 63.77s]
2017-12-21 15:32:01,992: 15:32:01 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2017-12-21 15:32:01,992: Compiling model.parsely.parsely_sessions
2017-12-21 15:32:02,017: Acquiring new redshift connection "parsely_sessions".
2017-12-21 15:32:02,017: Re-using an available connection from the pool.
2017-12-21 15:32:02,017: Using redshift connection "parsely_sessions".
2017-12-21 15:32:02,017: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:02,042: SQL status: SELECT in 0.02 seconds
2017-12-21 15:32:02,048: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 15:32:02,058: Using redshift connection "parsely_sessions".
2017-12-21 15:32:02,058: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:02,085: SQL status: SELECT in 0.03 seconds
2017-12-21 15:32:02,086: Using redshift connection "parsely_sessions".
2017-12-21 15:32:02,086: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:02,108: SQL status: SELECT in 0.02 seconds
2017-12-21 15:32:02,113: Using redshift connection "parsely_sessions".
2017-12-21 15:32:02,113: On parsely_sessions: BEGIN
2017-12-21 15:32:02,120: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:32:02,120: Using redshift connection "parsely_sessions".
2017-12-21 15:32:02,120: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:32:18,702: SQL status: SELECT in 16.58 seconds
2017-12-21 15:32:18,702: Using redshift connection "parsely_sessions".
2017-12-21 15:32:18,702: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2017-12-21 15:32:18,985: SQL status: SELECT in 0.28 seconds
2017-12-21 15:32:18,986: Using redshift connection "parsely_sessions".
2017-12-21 15:32:18,986: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:32:19,098: SQL status: SELECT in 0.11 seconds
2017-12-21 15:32:19,099: Using redshift connection "parsely_sessions".
2017-12-21 15:32:19,099: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:32:19,215: SQL status: SELECT in 0.12 seconds
2017-12-21 15:32:19,219: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 15:32:20,813: Using redshift connection "parsely_sessions".
2017-12-21 15:32:20,814: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2017-12-21 15:32:22,259: SQL status: INSERT 0 85915 in 1.45 seconds
2017-12-21 15:32:22,260: On parsely_sessions: COMMIT
2017-12-21 15:32:22,260: Using redshift connection "parsely_sessions".
2017-12-21 15:32:22,260: On parsely_sessions: COMMIT
2017-12-21 15:32:23,364: SQL status: COMMIT in 1.10 seconds
2017-12-21 15:32:23,365: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e23a5e10>], 'label': 'bc9351f1-0ae7-4692-8812-acca28ef1f3b'}
2017-12-21 15:32:23,422: 15:32:23 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 85915 in 21.37s]
2017-12-21 15:32:23,477: Using redshift connection "master".
2017-12-21 15:32:23,477: On master: BEGIN
2017-12-21 15:32:23,484: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:32:23,484: On master: COMMIT
2017-12-21 15:32:23,484: Using redshift connection "master".
2017-12-21 15:32:23,484: On master: COMMIT
2017-12-21 15:32:23,486: SQL status: COMMIT in 0.00 seconds
2017-12-21 15:32:23,486: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 15:32:23,503: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 15:32:23,512: Using redshift connection "master".
2017-12-21 15:32:23,512: On master:  select 1 
2017-12-21 15:32:23,519: SQL status: SELECT in 0.01 seconds
2017-12-21 15:32:23,519: 15:32:23 | 
2017-12-21 15:32:23,519: 15:32:23 | Finished running 10 view models, 15 incremental models in 659.51s.
2017-12-21 15:32:23,520: 
2017-12-21 15:32:23,520: Completed successfully
2017-12-21 15:32:23,521: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2017-12-21 15:32:23,521: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2456e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e2456f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f74e243d950>], 'label': 'end'}
2017-12-21 15:32:23,577: Flushing usage events
2017-12-21 15:32:32,976: Tracking: tracking
2017-12-21 15:32:32,977: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4c32e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4c32f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4c32ed0>], 'label': 'start'}
2017-12-21 15:32:33,048: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 15:32:33,118: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 15:32:33,120: Parsing core.sql
2017-12-21 15:32:33,180: Parsing etc/get_custom_schema.sql
2017-12-21 15:32:33,196: Parsing schema_tests/relationships.sql
2017-12-21 15:32:33,201: Parsing schema_tests/accepted_values.sql
2017-12-21 15:32:33,218: Parsing schema_tests/not_null.sql
2017-12-21 15:32:33,230: Parsing schema_tests/unique.sql
2017-12-21 15:32:33,233: Parsing materializations/wrapper.sql
2017-12-21 15:32:33,245: Parsing materializations/archive.sql
2017-12-21 15:32:33,346: Parsing materializations/table.sql
2017-12-21 15:32:33,406: Parsing materializations/helpers.sql
2017-12-21 15:32:33,433: Parsing materializations/bigquery.sql
2017-12-21 15:32:33,460: Parsing materializations/view.sql
2017-12-21 15:32:33,501: Parsing materializations/incremental.sql
2017-12-21 15:32:33,560: Parsing adapters/redshift.sql
2017-12-21 15:32:33,607: Parsing adapters/bigquery.sql
2017-12-21 15:32:33,618: Parsing adapters/postgres.sql
2017-12-21 15:32:33,623: Parsing adapters/common.sql
2017-12-21 15:32:33,658: Parsing model.parsely.parsely_audit
2017-12-21 15:32:33,661: Parsing model.parsely.parsely_video_content
2017-12-21 15:32:33,666: Parsing model.parsely.parsely_post_content
2017-12-21 15:32:33,671: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 15:32:33,676: Parsing model.parsely.parsely_rawdata
2017-12-21 15:32:33,681: Parsing model.parsely.calendar
2017-12-21 15:32:33,683: Parsing model.parsely.parsely_all_events
2017-12-21 15:32:33,699: Acquiring new redshift connection "parsely_all_events".
2017-12-21 15:32:33,699: Opening a new connection (0 currently allocated)
2017-12-21 15:32:33,721: Using redshift connection "parsely_all_events".
2017-12-21 15:32:33,722: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:33,747: SQL status: SELECT in 0.03 seconds
2017-12-21 15:32:33,756: Parsing model.parsely.parsely_event_ids
2017-12-21 15:32:33,764: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 15:32:33,768: Parsing model.parsely.parsely_base_events
2017-12-21 15:32:33,781: Acquiring new redshift connection "parsely_base_events".
2017-12-21 15:32:33,781: Re-using an available connection from the pool.
2017-12-21 15:32:33,781: Using redshift connection "parsely_base_events".
2017-12-21 15:32:33,781: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:33,802: SQL status: SELECT in 0.02 seconds
2017-12-21 15:32:33,803: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 15:32:33,822: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 15:32:33,851: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 15:32:33,867: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 15:32:33,870: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 15:32:33,875: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 15:32:33,893: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 15:32:33,921: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 15:32:33,939: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:32:33,939: Re-using an available connection from the pool.
2017-12-21 15:32:33,940: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:32:33,940: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:33,961: SQL status: SELECT in 0.02 seconds
2017-12-21 15:32:33,962: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 15:32:33,981: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 15:32:33,994: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:32:33,994: Re-using an available connection from the pool.
2017-12-21 15:32:33,994: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:32:33,994: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:34,017: SQL status: SELECT in 0.02 seconds
2017-12-21 15:32:34,018: Parsing model.parsely.parsely_incoming_users
2017-12-21 15:32:34,023: Parsing model.parsely.parsely_users
2017-12-21 15:32:34,041: Acquiring new redshift connection "parsely_users".
2017-12-21 15:32:34,041: Re-using an available connection from the pool.
2017-12-21 15:32:34,041: Using redshift connection "parsely_users".
2017-12-21 15:32:34,041: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:34,062: SQL status: SELECT in 0.02 seconds
2017-12-21 15:32:34,063: Parsing model.parsely.parsely_errors
2017-12-21 15:32:34,070: Parsing model.parsely.parsely_bot_traffic
2017-12-21 15:32:34,096: Parsing model.parsely.parsely_custom_events
2017-12-21 15:32:34,113: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 15:32:34,123: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 15:32:34,137: Parsing model.parsely.parsely_sessions
2017-12-21 15:32:34,163: Acquiring new redshift connection "parsely_sessions".
2017-12-21 15:32:34,163: Re-using an available connection from the pool.
2017-12-21 15:32:34,164: Using redshift connection "parsely_sessions".
2017-12-21 15:32:34,164: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:34,184: SQL status: SELECT in 0.02 seconds
2017-12-21 15:32:34,185: Parsing model.parsely.parsely_campaigns
2017-12-21 15:32:34,191: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 15:32:34,191: Re-using an available connection from the pool.
2017-12-21 15:32:34,191: Using redshift connection "parsely_campaigns".
2017-12-21 15:32:34,191: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:34,210: SQL status: SELECT in 0.02 seconds
2017-12-21 15:32:34,221: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 15:32:34,230: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 15:32:34,243: 
2017-12-21 15:32:34,253: Acquiring new redshift connection "master".
2017-12-21 15:32:34,253: Re-using an available connection from the pool.
2017-12-21 15:32:34,253: Using redshift connection "master".
2017-12-21 15:32:34,253: On master: select distinct nspname from pg_namespace
2017-12-21 15:32:34,256: SQL status: SELECT in 0.00 seconds
2017-12-21 15:32:34,260: Using redshift connection "master".
2017-12-21 15:32:34,260: On master: BEGIN
2017-12-21 15:32:34,262: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:32:34,262: On master: COMMIT
2017-12-21 15:32:34,262: Using redshift connection "master".
2017-12-21 15:32:34,262: On master: COMMIT
2017-12-21 15:32:34,264: SQL status: COMMIT in 0.00 seconds
2017-12-21 15:32:34,273: 15:32:34 | Concurrency: 1 threads (target='dev')
2017-12-21 15:32:34,280: 15:32:34 | 
2017-12-21 15:32:34,280: Using redshift connection "master".
2017-12-21 15:32:34,281: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:34,301: SQL status: SELECT in 0.02 seconds
2017-12-21 15:32:34,497: 15:32:34 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-21 15:32:34,497: Compiling model.parsely.calendar
2017-12-21 15:32:34,513: Writing injected SQL for node "model.parsely.calendar"
2017-12-21 15:32:34,514: Acquiring new redshift connection "calendar".
2017-12-21 15:32:34,514: Opening a new connection (1 currently allocated)
2017-12-21 15:32:34,542: Using redshift connection "calendar".
2017-12-21 15:32:34,542: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:34,571: SQL status: SELECT in 0.03 seconds
2017-12-21 15:32:34,575: Writing runtime SQL for node "model.parsely.calendar"
2017-12-21 15:32:34,576: Using redshift connection "calendar".
2017-12-21 15:32:34,576: On calendar: BEGIN
2017-12-21 15:32:34,584: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:32:34,584: Using redshift connection "calendar".
2017-12-21 15:32:34,584: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-21 15:32:34,864: SQL status: CREATE VIEW in 0.28 seconds
2017-12-21 15:32:34,865: On calendar: COMMIT
2017-12-21 15:32:34,865: Using redshift connection "calendar".
2017-12-21 15:32:34,865: On calendar: COMMIT
2017-12-21 15:32:35,160: SQL status: COMMIT in 0.29 seconds
2017-12-21 15:32:35,160: Using redshift connection "calendar".
2017-12-21 15:32:35,160: On calendar: BEGIN
2017-12-21 15:32:35,162: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:32:35,162: Using redshift connection "calendar".
2017-12-21 15:32:35,163: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-21 15:32:35,169: SQL status: DROP VIEW in 0.01 seconds
2017-12-21 15:32:35,169: On calendar: COMMIT
2017-12-21 15:32:35,169: Using redshift connection "calendar".
2017-12-21 15:32:35,169: On calendar: COMMIT
2017-12-21 15:32:35,437: SQL status: COMMIT in 0.27 seconds
2017-12-21 15:32:35,437: Using redshift connection "calendar".
2017-12-21 15:32:35,438: On calendar: BEGIN
2017-12-21 15:32:35,439: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:32:35,440: Using redshift connection "calendar".
2017-12-21 15:32:35,440: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-21 15:32:35,444: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:32:35,444: On calendar: COMMIT
2017-12-21 15:32:35,445: Using redshift connection "calendar".
2017-12-21 15:32:35,445: On calendar: COMMIT
2017-12-21 15:32:35,729: SQL status: COMMIT in 0.28 seconds
2017-12-21 15:32:35,730: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b20310>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:32:35,778: 15:32:35 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.23s]
2017-12-21 15:32:35,779: 15:32:35 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-21 15:32:35,779: Compiling model.parsely.parsely_rawdata
2017-12-21 15:32:35,788: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-21 15:32:35,790: Acquiring new redshift connection "parsely_rawdata".
2017-12-21 15:32:35,790: Re-using an available connection from the pool.
2017-12-21 15:32:35,790: Using redshift connection "parsely_rawdata".
2017-12-21 15:32:35,790: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:35,810: SQL status: SELECT in 0.02 seconds
2017-12-21 15:32:35,811: Using redshift connection "parsely_rawdata".
2017-12-21 15:32:35,811: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:32:35,820: SQL status: SELECT in 0.01 seconds
2017-12-21 15:32:35,822: Using redshift connection "parsely_rawdata".
2017-12-21 15:32:35,822: On parsely_rawdata: BEGIN
2017-12-21 15:32:35,824: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:32:35,824: Using redshift connection "parsely_rawdata".
2017-12-21 15:32:35,824: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:33:06,314: SQL status: SELECT in 30.49 seconds
2017-12-21 15:33:06,314: Using redshift connection "parsely_rawdata".
2017-12-21 15:33:06,314: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-21 15:33:06,744: SQL status: SELECT in 0.43 seconds
2017-12-21 15:33:06,745: Using redshift connection "parsely_rawdata".
2017-12-21 15:33:06,746: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:33:07,061: SQL status: SELECT in 0.32 seconds
2017-12-21 15:33:07,062: Using redshift connection "parsely_rawdata".
2017-12-21 15:33:07,062: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:33:07,417: SQL status: SELECT in 0.35 seconds
2017-12-21 15:33:07,422: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-21 15:33:07,423: Using redshift connection "parsely_rawdata".
2017-12-21 15:33:07,423: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-21 15:33:42,183: SQL status: INSERT 0 1008737 in 34.76 seconds
2017-12-21 15:33:42,184: On parsely_rawdata: COMMIT
2017-12-21 15:33:42,184: Using redshift connection "parsely_rawdata".
2017-12-21 15:33:42,184: On parsely_rawdata: COMMIT
2017-12-21 15:33:44,692: SQL status: COMMIT in 2.51 seconds
2017-12-21 15:33:44,693: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4c2c290>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:33:44,760: 15:33:44 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1008737 in 68.91s]
2017-12-21 15:33:44,763: 15:33:44 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-21 15:33:44,763: Compiling model.parsely.parsely_all_events
2017-12-21 15:33:44,807: Acquiring new redshift connection "parsely_all_events".
2017-12-21 15:33:44,807: Re-using an available connection from the pool.
2017-12-21 15:33:44,807: Using redshift connection "parsely_all_events".
2017-12-21 15:33:44,807: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:33:44,821: SQL status: SELECT in 0.01 seconds
2017-12-21 15:33:44,856: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-21 15:33:44,858: Using redshift connection "parsely_all_events".
2017-12-21 15:33:44,858: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:33:44,871: SQL status: SELECT in 0.01 seconds
2017-12-21 15:33:44,872: Using redshift connection "parsely_all_events".
2017-12-21 15:33:44,872: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:33:44,884: SQL status: SELECT in 0.01 seconds
2017-12-21 15:33:44,888: Using redshift connection "parsely_all_events".
2017-12-21 15:33:44,888: On parsely_all_events: BEGIN
2017-12-21 15:33:44,890: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:33:44,890: Using redshift connection "parsely_all_events".
2017-12-21 15:33:44,890: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:35:46,108: SQL status: SELECT in 121.22 seconds
2017-12-21 15:35:46,109: Using redshift connection "parsely_all_events".
2017-12-21 15:35:46,109: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2017-12-21 15:35:46,511: SQL status: SELECT in 0.40 seconds
2017-12-21 15:35:46,512: Using redshift connection "parsely_all_events".
2017-12-21 15:35:46,512: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:35:46,627: SQL status: SELECT in 0.11 seconds
2017-12-21 15:35:46,629: Using redshift connection "parsely_all_events".
2017-12-21 15:35:46,629: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:35:46,740: SQL status: SELECT in 0.11 seconds
2017-12-21 15:35:46,747: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-21 15:35:46,764: Using redshift connection "parsely_all_events".
2017-12-21 15:35:46,764: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2017-12-21 15:36:03,860: SQL status: INSERT 0 893248 in 17.10 seconds
2017-12-21 15:36:03,861: On parsely_all_events: COMMIT
2017-12-21 15:36:03,861: Using redshift connection "parsely_all_events".
2017-12-21 15:36:03,861: On parsely_all_events: COMMIT
2017-12-21 15:36:07,240: SQL status: COMMIT in 3.38 seconds
2017-12-21 15:36:07,241: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b9ab90>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:36:07,284: 15:36:07 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 893248 in 142.48s]
2017-12-21 15:36:07,284: 15:36:07 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-21 15:36:07,285: Compiling model.parsely.parsely_bot_traffic
2017-12-21 15:36:07,324: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 15:36:07,326: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-21 15:36:07,326: Re-using an available connection from the pool.
2017-12-21 15:36:07,326: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:36:07,326: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:36:07,341: SQL status: SELECT in 0.01 seconds
2017-12-21 15:36:07,342: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:36:07,342: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:36:07,356: SQL status: SELECT in 0.01 seconds
2017-12-21 15:36:07,359: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:36:07,359: On parsely_bot_traffic: BEGIN
2017-12-21 15:36:07,361: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:36:07,361: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:36:07,361: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:36:33,106: SQL status: SELECT in 25.75 seconds
2017-12-21 15:36:33,107: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:36:33,107: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2017-12-21 15:36:33,551: SQL status: SELECT in 0.44 seconds
2017-12-21 15:36:33,552: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:36:33,552: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:36:33,659: SQL status: SELECT in 0.11 seconds
2017-12-21 15:36:33,660: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:36:33,661: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:36:33,771: SQL status: SELECT in 0.11 seconds
2017-12-21 15:36:33,777: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 15:36:33,778: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:36:33,778: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2017-12-21 15:36:35,110: SQL status: INSERT 0 4 in 1.33 seconds
2017-12-21 15:36:35,110: On parsely_bot_traffic: COMMIT
2017-12-21 15:36:35,110: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:36:35,111: On parsely_bot_traffic: COMMIT
2017-12-21 15:36:36,310: SQL status: COMMIT in 1.20 seconds
2017-12-21 15:36:36,310: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4c2c250>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:36:36,371: 15:36:36 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 29.03s]
2017-12-21 15:36:36,371: 15:36:36 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-21 15:36:36,371: Compiling model.parsely.parsely_custom_events
2017-12-21 15:36:36,394: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-21 15:36:36,404: Acquiring new redshift connection "parsely_custom_events".
2017-12-21 15:36:36,404: Re-using an available connection from the pool.
2017-12-21 15:36:36,405: Using redshift connection "parsely_custom_events".
2017-12-21 15:36:36,405: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:36:36,420: SQL status: SELECT in 0.02 seconds
2017-12-21 15:36:36,421: Using redshift connection "parsely_custom_events".
2017-12-21 15:36:36,421: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:36:36,435: SQL status: SELECT in 0.01 seconds
2017-12-21 15:36:36,438: Using redshift connection "parsely_custom_events".
2017-12-21 15:36:36,438: On parsely_custom_events: BEGIN
2017-12-21 15:36:36,446: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:36:36,446: Using redshift connection "parsely_custom_events".
2017-12-21 15:36:36,446: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:37:01,098: SQL status: SELECT in 24.65 seconds
2017-12-21 15:37:01,099: Using redshift connection "parsely_custom_events".
2017-12-21 15:37:01,099: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2017-12-21 15:37:01,243: SQL status: SELECT in 0.14 seconds
2017-12-21 15:37:01,244: Using redshift connection "parsely_custom_events".
2017-12-21 15:37:01,244: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:37:01,360: SQL status: SELECT in 0.12 seconds
2017-12-21 15:37:01,361: Using redshift connection "parsely_custom_events".
2017-12-21 15:37:01,362: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:37:01,473: SQL status: SELECT in 0.11 seconds
2017-12-21 15:37:01,479: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-21 15:37:01,480: Using redshift connection "parsely_custom_events".
2017-12-21 15:37:01,483: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2017-12-21 15:37:02,212: SQL status: INSERT 0 0 in 0.73 seconds
2017-12-21 15:37:02,212: On parsely_custom_events: COMMIT
2017-12-21 15:37:02,212: Using redshift connection "parsely_custom_events".
2017-12-21 15:37:02,213: On parsely_custom_events: COMMIT
2017-12-21 15:37:02,919: SQL status: COMMIT in 0.71 seconds
2017-12-21 15:37:02,919: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4bdc0d0>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:37:02,958: 15:37:02 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 26.55s]
2017-12-21 15:37:02,959: 15:37:02 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-21 15:37:02,959: Compiling model.parsely.parsely_errors
2017-12-21 15:37:02,971: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-21 15:37:02,975: Acquiring new redshift connection "parsely_errors".
2017-12-21 15:37:02,975: Re-using an available connection from the pool.
2017-12-21 15:37:02,975: Using redshift connection "parsely_errors".
2017-12-21 15:37:02,975: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:02,991: SQL status: SELECT in 0.02 seconds
2017-12-21 15:37:02,992: Using redshift connection "parsely_errors".
2017-12-21 15:37:02,992: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:03,005: SQL status: SELECT in 0.01 seconds
2017-12-21 15:37:03,008: Using redshift connection "parsely_errors".
2017-12-21 15:37:03,008: On parsely_errors: BEGIN
2017-12-21 15:37:03,012: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:37:03,012: Using redshift connection "parsely_errors".
2017-12-21 15:37:03,012: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:37:27,124: SQL status: SELECT in 24.11 seconds
2017-12-21 15:37:27,125: Using redshift connection "parsely_errors".
2017-12-21 15:37:27,125: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2017-12-21 15:37:27,263: SQL status: SELECT in 0.14 seconds
2017-12-21 15:37:27,264: Using redshift connection "parsely_errors".
2017-12-21 15:37:27,264: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:37:27,377: SQL status: SELECT in 0.11 seconds
2017-12-21 15:37:27,379: Using redshift connection "parsely_errors".
2017-12-21 15:37:27,379: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:37:27,485: SQL status: SELECT in 0.11 seconds
2017-12-21 15:37:27,491: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-21 15:37:27,492: Using redshift connection "parsely_errors".
2017-12-21 15:37:27,492: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2017-12-21 15:37:28,150: SQL status: INSERT 0 2 in 0.66 seconds
2017-12-21 15:37:28,150: On parsely_errors: COMMIT
2017-12-21 15:37:28,151: Using redshift connection "parsely_errors".
2017-12-21 15:37:28,151: On parsely_errors: COMMIT
2017-12-21 15:37:29,348: SQL status: COMMIT in 1.20 seconds
2017-12-21 15:37:29,348: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b8a850>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:37:29,413: 15:37:29 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 26.39s]
2017-12-21 15:37:29,420: 15:37:29 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-21 15:37:29,420: Compiling model.parsely.parsely_base_events
2017-12-21 15:37:29,427: Acquiring new redshift connection "parsely_base_events".
2017-12-21 15:37:29,427: Re-using an available connection from the pool.
2017-12-21 15:37:29,428: Using redshift connection "parsely_base_events".
2017-12-21 15:37:29,428: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:29,444: SQL status: SELECT in 0.02 seconds
2017-12-21 15:37:29,450: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-21 15:37:29,464: Using redshift connection "parsely_base_events".
2017-12-21 15:37:29,464: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:29,480: SQL status: SELECT in 0.02 seconds
2017-12-21 15:37:29,483: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-21 15:37:29,484: Using redshift connection "parsely_base_events".
2017-12-21 15:37:29,490: On parsely_base_events: BEGIN
2017-12-21 15:37:29,492: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:37:29,492: Using redshift connection "parsely_base_events".
2017-12-21 15:37:29,492: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-21 15:37:30,319: SQL status: CREATE VIEW in 0.83 seconds
2017-12-21 15:37:30,319: On parsely_base_events: COMMIT
2017-12-21 15:37:30,319: Using redshift connection "parsely_base_events".
2017-12-21 15:37:30,320: On parsely_base_events: COMMIT
2017-12-21 15:37:30,539: SQL status: COMMIT in 0.22 seconds
2017-12-21 15:37:30,540: Using redshift connection "parsely_base_events".
2017-12-21 15:37:30,540: On parsely_base_events: BEGIN
2017-12-21 15:37:30,542: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:37:30,542: Using redshift connection "parsely_base_events".
2017-12-21 15:37:30,542: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2017-12-21 15:37:32,221: SQL status: DROP VIEW in 1.68 seconds
2017-12-21 15:37:32,221: On parsely_base_events: COMMIT
2017-12-21 15:37:32,221: Using redshift connection "parsely_base_events".
2017-12-21 15:37:32,221: On parsely_base_events: COMMIT
2017-12-21 15:37:32,447: SQL status: COMMIT in 0.23 seconds
2017-12-21 15:37:32,448: Using redshift connection "parsely_base_events".
2017-12-21 15:37:32,448: On parsely_base_events: BEGIN
2017-12-21 15:37:32,450: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:37:32,450: Using redshift connection "parsely_base_events".
2017-12-21 15:37:32,450: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-21 15:37:32,455: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:37:32,455: On parsely_base_events: COMMIT
2017-12-21 15:37:32,455: Using redshift connection "parsely_base_events".
2017-12-21 15:37:32,456: On parsely_base_events: COMMIT
2017-12-21 15:37:32,656: SQL status: COMMIT in 0.20 seconds
2017-12-21 15:37:32,657: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b8a750>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:37:32,713: 15:37:32 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 3.24s]
2017-12-21 15:37:32,713: 15:37:32 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2017-12-21 15:37:32,716: Compiling model.parsely.parsely_event_ids
2017-12-21 15:37:32,737: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-21 15:37:32,739: Acquiring new redshift connection "parsely_event_ids".
2017-12-21 15:37:32,739: Re-using an available connection from the pool.
2017-12-21 15:37:32,740: Using redshift connection "parsely_event_ids".
2017-12-21 15:37:32,740: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:32,754: SQL status: SELECT in 0.01 seconds
2017-12-21 15:37:32,755: Using redshift connection "parsely_event_ids".
2017-12-21 15:37:32,755: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:32,769: SQL status: SELECT in 0.01 seconds
2017-12-21 15:37:32,771: Using redshift connection "parsely_event_ids".
2017-12-21 15:37:32,771: On parsely_event_ids: BEGIN
2017-12-21 15:37:32,773: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:37:32,773: Using redshift connection "parsely_event_ids".
2017-12-21 15:37:32,773: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:37:33,635: SQL status: SELECT in 0.86 seconds
2017-12-21 15:37:33,635: Using redshift connection "parsely_event_ids".
2017-12-21 15:37:33,636: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2017-12-21 15:37:33,781: SQL status: SELECT in 0.15 seconds
2017-12-21 15:37:33,781: Using redshift connection "parsely_event_ids".
2017-12-21 15:37:33,783: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:37:33,887: SQL status: SELECT in 0.10 seconds
2017-12-21 15:37:33,887: Using redshift connection "parsely_event_ids".
2017-12-21 15:37:33,887: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:37:33,988: SQL status: SELECT in 0.10 seconds
2017-12-21 15:37:33,989: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-21 15:37:33,990: Using redshift connection "parsely_event_ids".
2017-12-21 15:37:33,990: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2017-12-21 15:37:34,897: SQL status: INSERT 0 893244 in 0.91 seconds
2017-12-21 15:37:34,898: On parsely_event_ids: COMMIT
2017-12-21 15:37:34,898: Using redshift connection "parsely_event_ids".
2017-12-21 15:37:34,898: On parsely_event_ids: COMMIT
2017-12-21 15:37:35,324: SQL status: COMMIT in 0.43 seconds
2017-12-21 15:37:35,325: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b8a750>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:37:35,375: 15:37:35 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 893244 in 2.61s]
2017-12-21 15:37:35,380: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-21 15:37:35,401: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-21 15:37:35,402: 15:37:35 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-21 15:37:35,403: Compiling model.parsely.parsely_post_content
2017-12-21 15:37:35,421: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-21 15:37:35,422: Acquiring new redshift connection "parsely_post_content".
2017-12-21 15:37:35,423: Re-using an available connection from the pool.
2017-12-21 15:37:35,423: Using redshift connection "parsely_post_content".
2017-12-21 15:37:35,423: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:35,437: SQL status: SELECT in 0.01 seconds
2017-12-21 15:37:35,438: Using redshift connection "parsely_post_content".
2017-12-21 15:37:35,438: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:35,452: SQL status: SELECT in 0.01 seconds
2017-12-21 15:37:35,454: Using redshift connection "parsely_post_content".
2017-12-21 15:37:35,454: On parsely_post_content: BEGIN
2017-12-21 15:37:35,456: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:37:35,456: Using redshift connection "parsely_post_content".
2017-12-21 15:37:35,457: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:37:40,812: SQL status: SELECT in 5.35 seconds
2017-12-21 15:37:40,812: Using redshift connection "parsely_post_content".
2017-12-21 15:37:40,812: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2017-12-21 15:37:40,966: SQL status: SELECT in 0.15 seconds
2017-12-21 15:37:40,966: Using redshift connection "parsely_post_content".
2017-12-21 15:37:40,967: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:37:41,075: SQL status: SELECT in 0.11 seconds
2017-12-21 15:37:41,076: Using redshift connection "parsely_post_content".
2017-12-21 15:37:41,076: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:37:41,183: SQL status: SELECT in 0.11 seconds
2017-12-21 15:37:41,185: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-21 15:37:41,187: Using redshift connection "parsely_post_content".
2017-12-21 15:37:41,187: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2017-12-21 15:37:41,533: SQL status: INSERT 0 874 in 0.35 seconds
2017-12-21 15:37:41,533: On parsely_post_content: COMMIT
2017-12-21 15:37:41,533: Using redshift connection "parsely_post_content".
2017-12-21 15:37:41,533: On parsely_post_content: COMMIT
2017-12-21 15:37:43,290: SQL status: COMMIT in 1.76 seconds
2017-12-21 15:37:43,291: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b8a810>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:37:43,336: 15:37:43 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 874 in 7.89s]
2017-12-21 15:37:43,337: 15:37:43 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2017-12-21 15:37:43,343: Compiling model.parsely.parsely_video_content
2017-12-21 15:37:43,368: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-21 15:37:43,370: Acquiring new redshift connection "parsely_video_content".
2017-12-21 15:37:43,370: Re-using an available connection from the pool.
2017-12-21 15:37:43,370: Using redshift connection "parsely_video_content".
2017-12-21 15:37:43,370: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:43,385: SQL status: SELECT in 0.01 seconds
2017-12-21 15:37:43,386: Using redshift connection "parsely_video_content".
2017-12-21 15:37:43,386: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:43,400: SQL status: SELECT in 0.01 seconds
2017-12-21 15:37:43,402: Using redshift connection "parsely_video_content".
2017-12-21 15:37:43,402: On parsely_video_content: BEGIN
2017-12-21 15:37:43,404: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:37:43,404: Using redshift connection "parsely_video_content".
2017-12-21 15:37:43,404: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:37:52,352: SQL status: SELECT in 8.95 seconds
2017-12-21 15:37:52,352: Using redshift connection "parsely_video_content".
2017-12-21 15:37:52,352: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2017-12-21 15:37:52,517: SQL status: SELECT in 0.16 seconds
2017-12-21 15:37:52,518: Using redshift connection "parsely_video_content".
2017-12-21 15:37:52,518: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:37:52,621: SQL status: SELECT in 0.10 seconds
2017-12-21 15:37:52,622: Using redshift connection "parsely_video_content".
2017-12-21 15:37:52,622: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:37:52,722: SQL status: SELECT in 0.10 seconds
2017-12-21 15:37:52,725: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-21 15:37:52,726: Using redshift connection "parsely_video_content".
2017-12-21 15:37:52,726: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2017-12-21 15:37:53,091: SQL status: INSERT 0 465 in 0.36 seconds
2017-12-21 15:37:53,091: On parsely_video_content: COMMIT
2017-12-21 15:37:53,092: Using redshift connection "parsely_video_content".
2017-12-21 15:37:53,092: On parsely_video_content: COMMIT
2017-12-21 15:37:53,482: SQL status: COMMIT in 0.39 seconds
2017-12-21 15:37:53,483: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b442d0>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:37:53,515: 15:37:53 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 465 in 10.14s]
2017-12-21 15:37:53,516: 15:37:53 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-21 15:37:53,516: Compiling model.parsely.parsely_entry_exit_urls
2017-12-21 15:37:53,526: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 15:37:53,527: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-21 15:37:53,528: Re-using an available connection from the pool.
2017-12-21 15:37:53,528: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:37:53,528: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:53,544: SQL status: SELECT in 0.02 seconds
2017-12-21 15:37:53,546: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 15:37:53,547: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:37:53,547: On parsely_entry_exit_urls: BEGIN
2017-12-21 15:37:53,549: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:37:53,549: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:37:53,549: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-21 15:37:53,610: SQL status: CREATE VIEW in 0.06 seconds
2017-12-21 15:37:53,610: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:37:53,610: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2017-12-21 15:37:53,614: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:37:53,614: On parsely_entry_exit_urls: COMMIT
2017-12-21 15:37:53,614: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:37:53,614: On parsely_entry_exit_urls: COMMIT
2017-12-21 15:37:53,866: SQL status: COMMIT in 0.25 seconds
2017-12-21 15:37:53,868: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b8a890>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:37:53,907: 15:37:53 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.35s]
2017-12-21 15:37:53,908: 15:37:53 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-21 15:37:53,908: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 15:37:53,926: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 15:37:53,928: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 15:37:53,928: Re-using an available connection from the pool.
2017-12-21 15:37:53,928: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:37:53,928: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:53,944: SQL status: SELECT in 0.02 seconds
2017-12-21 15:37:53,950: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 15:37:53,951: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:37:53,951: On parsely_incoming_videoviews: BEGIN
2017-12-21 15:37:53,953: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:37:53,954: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:37:53,954: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 15:37:54,774: SQL status: CREATE VIEW in 0.82 seconds
2017-12-21 15:37:54,775: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:37:54,775: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 15:37:54,779: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:37:54,780: On parsely_incoming_videoviews: COMMIT
2017-12-21 15:37:54,780: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:37:54,780: On parsely_incoming_videoviews: COMMIT
2017-12-21 15:37:55,141: SQL status: COMMIT in 0.36 seconds
2017-12-21 15:37:55,142: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b8a890>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:37:55,177: 15:37:55 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.23s]
2017-12-21 15:37:55,178: 15:37:55 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 15:37:55,178: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 15:37:55,187: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:37:55,187: Re-using an available connection from the pool.
2017-12-21 15:37:55,188: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:37:55,188: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:55,204: SQL status: SELECT in 0.02 seconds
2017-12-21 15:37:55,210: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 15:37:55,212: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:37:55,212: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:55,228: SQL status: SELECT in 0.02 seconds
2017-12-21 15:37:55,229: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:37:55,229: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:37:55,245: SQL status: SELECT in 0.02 seconds
2017-12-21 15:37:55,248: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:37:55,248: On parsely_videoviews_sessionized: BEGIN
2017-12-21 15:37:55,250: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:37:55,250: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:37:55,250: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:38:27,766: SQL status: SELECT in 32.52 seconds
2017-12-21 15:38:27,766: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:38:27,767: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2017-12-21 15:38:27,951: SQL status: SELECT in 0.18 seconds
2017-12-21 15:38:27,953: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:38:27,953: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:38:28,058: SQL status: SELECT in 0.11 seconds
2017-12-21 15:38:28,059: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:38:28,060: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:38:28,171: SQL status: SELECT in 0.11 seconds
2017-12-21 15:38:28,178: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 15:38:28,179: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:38:28,179: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 15:38:29,248: SQL status: INSERT 0 142 in 1.07 seconds
2017-12-21 15:38:29,249: On parsely_videoviews_sessionized: COMMIT
2017-12-21 15:38:29,249: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:38:29,249: On parsely_videoviews_sessionized: COMMIT
2017-12-21 15:38:30,888: SQL status: COMMIT in 1.64 seconds
2017-12-21 15:38:30,889: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b8a750>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:38:30,978: 15:38:30 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 142 in 35.71s]
2017-12-21 15:38:30,979: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-21 15:38:31,023: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-21 15:38:31,024: 15:38:31 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-21 15:38:31,024: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 15:38:31,049: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 15:38:31,050: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:38:31,050: Re-using an available connection from the pool.
2017-12-21 15:38:31,051: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:38:31,051: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:38:31,067: SQL status: SELECT in 0.02 seconds
2017-12-21 15:38:31,070: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 15:38:31,071: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:38:31,071: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-21 15:38:31,073: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:38:31,074: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:38:31,074: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-21 15:38:31,436: SQL status: CREATE VIEW in 0.36 seconds
2017-12-21 15:38:31,437: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:38:31,437: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-21 15:38:31,440: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:38:31,440: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 15:38:31,440: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:38:31,441: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 15:38:31,666: SQL status: COMMIT in 0.23 seconds
2017-12-21 15:38:31,667: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b20f90>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:38:31,736: 15:38:31 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.64s]
2017-12-21 15:38:31,744: 15:38:31 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-21 15:38:31,744: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 15:38:31,879: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 15:38:31,890: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:38:31,890: Re-using an available connection from the pool.
2017-12-21 15:38:31,890: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:38:31,890: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:38:31,904: SQL status: SELECT in 0.01 seconds
2017-12-21 15:38:31,909: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 15:38:31,910: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:38:31,910: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-21 15:38:31,929: SQL status: BEGIN in 0.02 seconds
2017-12-21 15:38:31,929: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:38:31,929: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-21 15:38:31,971: SQL status: CREATE VIEW in 0.04 seconds
2017-12-21 15:38:31,972: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:38:31,972: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-21 15:38:31,976: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:38:31,976: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 15:38:31,976: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:38:31,976: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 15:38:32,347: SQL status: COMMIT in 0.37 seconds
2017-12-21 15:38:32,348: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b20990>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:38:32,400: 15:38:32 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.60s]
2017-12-21 15:38:32,400: 15:38:32 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2017-12-21 15:38:32,408: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 15:38:32,434: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 15:38:32,445: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 15:38:32,445: Re-using an available connection from the pool.
2017-12-21 15:38:32,445: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:38:32,445: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:38:32,459: SQL status: SELECT in 0.01 seconds
2017-12-21 15:38:32,465: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 15:38:32,466: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:38:32,466: On parsely_incoming_pageviews: BEGIN
2017-12-21 15:38:32,476: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:38:32,476: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:38:32,476: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 15:38:33,787: SQL status: CREATE VIEW in 1.31 seconds
2017-12-21 15:38:33,788: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:38:33,788: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2017-12-21 15:38:33,794: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 15:38:33,794: On parsely_incoming_pageviews: COMMIT
2017-12-21 15:38:33,795: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:38:33,795: On parsely_incoming_pageviews: COMMIT
2017-12-21 15:38:33,983: SQL status: COMMIT in 0.19 seconds
2017-12-21 15:38:33,984: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b20990>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:38:34,042: 15:38:34 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.58s]
2017-12-21 15:38:34,044: 15:38:34 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2017-12-21 15:38:34,045: Compiling model.parsely.parsely_pageviews_sessionized
2017-12-21 15:38:34,070: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:38:34,070: Re-using an available connection from the pool.
2017-12-21 15:38:34,070: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:38:34,070: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:38:34,085: SQL status: SELECT in 0.01 seconds
2017-12-21 15:38:34,094: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 15:38:34,096: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:38:34,097: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:38:34,111: SQL status: SELECT in 0.01 seconds
2017-12-21 15:38:34,112: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:38:34,112: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:38:34,127: SQL status: SELECT in 0.01 seconds
2017-12-21 15:38:34,130: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:38:34,131: On parsely_pageviews_sessionized: BEGIN
2017-12-21 15:38:34,133: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:38:34,133: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:38:34,133: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:40:46,963: SQL status: SELECT in 132.83 seconds
2017-12-21 15:40:46,963: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:40:46,963: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2017-12-21 15:40:47,159: SQL status: SELECT in 0.20 seconds
2017-12-21 15:40:47,160: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:40:47,160: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:40:47,271: SQL status: SELECT in 0.11 seconds
2017-12-21 15:40:47,272: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:40:47,272: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:40:47,385: SQL status: SELECT in 0.11 seconds
2017-12-21 15:40:47,391: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 15:40:47,392: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:40:47,392: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 15:40:50,286: SQL status: INSERT 0 106373 in 2.89 seconds
2017-12-21 15:40:50,287: On parsely_pageviews_sessionized: COMMIT
2017-12-21 15:40:50,287: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:40:50,287: On parsely_pageviews_sessionized: COMMIT
2017-12-21 15:40:52,027: SQL status: COMMIT in 1.74 seconds
2017-12-21 15:40:52,028: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4be76d0>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:40:52,101: 15:40:52 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 106373 in 137.98s]
2017-12-21 15:40:52,101: 15:40:52 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-21 15:40:52,108: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-21 15:40:52,318: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 15:40:52,320: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:40:52,320: Re-using an available connection from the pool.
2017-12-21 15:40:52,320: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:40:52,320: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:40:52,341: SQL status: SELECT in 0.02 seconds
2017-12-21 15:40:52,345: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 15:40:52,346: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:40:52,346: On parsely_videoview_engagedtime: BEGIN
2017-12-21 15:40:52,348: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:40:52,348: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:40:52,348: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-21 15:40:52,893: SQL status: CREATE VIEW in 0.54 seconds
2017-12-21 15:40:52,894: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:40:52,894: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-21 15:40:52,898: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:40:52,899: On parsely_videoview_engagedtime: COMMIT
2017-12-21 15:40:52,899: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:40:52,899: On parsely_videoview_engagedtime: COMMIT
2017-12-21 15:40:53,613: SQL status: COMMIT in 0.71 seconds
2017-12-21 15:40:53,613: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4be76d0>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:40:53,647: 15:40:53 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.51s]
2017-12-21 15:40:53,649: 15:40:53 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-21 15:40:53,649: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-21 15:40:53,665: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 15:40:53,667: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:40:53,667: Re-using an available connection from the pool.
2017-12-21 15:40:53,667: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:40:53,667: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:40:53,688: SQL status: SELECT in 0.02 seconds
2017-12-21 15:40:53,689: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:40:53,689: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:40:53,709: SQL status: SELECT in 0.02 seconds
2017-12-21 15:40:53,713: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:40:53,713: On parsely_videoview_behavior_workflow: BEGIN
2017-12-21 15:40:53,715: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:40:53,715: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:40:53,715: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:42:13,431: SQL status: SELECT in 79.72 seconds
2017-12-21 15:42:13,431: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:42:13,431: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 15:42:13,633: SQL status: SELECT in 0.20 seconds
2017-12-21 15:42:13,634: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:42:13,634: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:42:13,746: SQL status: SELECT in 0.11 seconds
2017-12-21 15:42:13,747: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:42:13,747: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:42:13,860: SQL status: SELECT in 0.11 seconds
2017-12-21 15:42:13,866: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 15:42:13,867: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:42:13,867: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 15:42:14,937: SQL status: INSERT 0 141 in 1.07 seconds
2017-12-21 15:42:14,938: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 15:42:14,938: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:42:14,938: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 15:42:16,157: SQL status: COMMIT in 1.22 seconds
2017-12-21 15:42:16,158: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b8a390>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:42:16,223: 15:42:16 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 141 in 82.51s]
2017-12-21 15:42:16,223: 15:42:16 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2017-12-21 15:42:16,223: Compiling model.parsely.parsely_campaigns
2017-12-21 15:42:16,231: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 15:42:16,231: Re-using an available connection from the pool.
2017-12-21 15:42:16,231: Using redshift connection "parsely_campaigns".
2017-12-21 15:42:16,231: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:42:16,252: SQL status: SELECT in 0.02 seconds
2017-12-21 15:42:16,258: Writing injected SQL for node "model.parsely.parsely_campaigns"
2017-12-21 15:42:16,260: Using redshift connection "parsely_campaigns".
2017-12-21 15:42:16,260: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:42:16,280: SQL status: SELECT in 0.02 seconds
2017-12-21 15:42:16,281: Using redshift connection "parsely_campaigns".
2017-12-21 15:42:16,281: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:42:16,301: SQL status: SELECT in 0.02 seconds
2017-12-21 15:42:16,303: Using redshift connection "parsely_campaigns".
2017-12-21 15:42:16,303: On parsely_campaigns: BEGIN
2017-12-21 15:42:16,305: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:42:16,305: Using redshift connection "parsely_campaigns".
2017-12-21 15:42:16,305: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:42:17,503: SQL status: SELECT in 1.20 seconds
2017-12-21 15:42:17,503: Using redshift connection "parsely_campaigns".
2017-12-21 15:42:17,503: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2017-12-21 15:42:17,671: SQL status: SELECT in 0.17 seconds
2017-12-21 15:42:17,671: Using redshift connection "parsely_campaigns".
2017-12-21 15:42:17,671: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:42:17,776: SQL status: SELECT in 0.10 seconds
2017-12-21 15:42:17,777: Using redshift connection "parsely_campaigns".
2017-12-21 15:42:17,777: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:42:17,883: SQL status: SELECT in 0.11 seconds
2017-12-21 15:42:17,885: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2017-12-21 15:42:17,886: Using redshift connection "parsely_campaigns".
2017-12-21 15:42:17,886: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2017-12-21 15:42:18,029: SQL status: INSERT 0 380 in 0.14 seconds
2017-12-21 15:42:18,029: On parsely_campaigns: COMMIT
2017-12-21 15:42:18,029: Using redshift connection "parsely_campaigns".
2017-12-21 15:42:18,029: On parsely_campaigns: COMMIT
2017-12-21 15:42:18,365: SQL status: COMMIT in 0.34 seconds
2017-12-21 15:42:18,366: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89bf5e8410>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:42:18,424: 15:42:18 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 380 in 2.14s]
2017-12-21 15:42:18,425: Compiling model.parsely.parsely_incoming_users
2017-12-21 15:42:18,450: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 15:42:18,460: 15:42:18 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2017-12-21 15:42:18,461: Compiling model.parsely.parsely_users
2017-12-21 15:42:18,470: Acquiring new redshift connection "parsely_users".
2017-12-21 15:42:18,471: Re-using an available connection from the pool.
2017-12-21 15:42:18,480: Using redshift connection "parsely_users".
2017-12-21 15:42:18,480: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:42:18,502: SQL status: SELECT in 0.02 seconds
2017-12-21 15:42:18,703: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 15:42:18,718: Using redshift connection "parsely_users".
2017-12-21 15:42:18,718: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:42:18,739: SQL status: SELECT in 0.02 seconds
2017-12-21 15:42:18,740: Using redshift connection "parsely_users".
2017-12-21 15:42:18,740: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:42:18,760: SQL status: SELECT in 0.02 seconds
2017-12-21 15:42:18,763: Using redshift connection "parsely_users".
2017-12-21 15:42:18,764: On parsely_users: BEGIN
2017-12-21 15:42:18,765: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:42:18,766: Using redshift connection "parsely_users".
2017-12-21 15:42:18,766: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3,4
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3,4
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      visitor_ip,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3,4
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id, visitor_ip)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3,4


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    visitor_ip,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:42:20,760: SQL status: SELECT in 1.99 seconds
2017-12-21 15:42:20,760: Using redshift connection "parsely_users".
2017-12-21 15:42:20,760: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2017-12-21 15:42:21,009: SQL status: SELECT in 0.25 seconds
2017-12-21 15:42:21,010: Using redshift connection "parsely_users".
2017-12-21 15:42:21,010: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:42:21,122: SQL status: SELECT in 0.11 seconds
2017-12-21 15:42:21,122: Using redshift connection "parsely_users".
2017-12-21 15:42:21,122: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:42:21,233: SQL status: SELECT in 0.11 seconds
2017-12-21 15:42:21,236: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 15:42:21,237: Using redshift connection "parsely_users".
2017-12-21 15:42:21,237: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2017-12-21 15:42:21,529: SQL status: INSERT 0 59053 in 0.29 seconds
2017-12-21 15:42:21,530: On parsely_users: COMMIT
2017-12-21 15:42:21,530: Using redshift connection "parsely_users".
2017-12-21 15:42:21,530: On parsely_users: COMMIT
2017-12-21 15:42:22,289: SQL status: COMMIT in 0.76 seconds
2017-12-21 15:42:22,289: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b44850>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:42:22,333: 15:42:22 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 59053 in 3.83s]
2017-12-21 15:42:22,333: 15:42:22 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2017-12-21 15:42:22,333: Compiling model.parsely.parsely_pageview_engagedtime
2017-12-21 15:42:22,400: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 15:42:22,402: Acquiring new redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:42:22,402: Re-using an available connection from the pool.
2017-12-21 15:42:22,402: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:42:22,402: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:42:22,424: SQL status: SELECT in 0.02 seconds
2017-12-21 15:42:22,428: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 15:42:22,429: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:42:22,429: On parsely_pageview_engagedtime: BEGIN
2017-12-21 15:42:22,440: SQL status: BEGIN in 0.01 seconds
2017-12-21 15:42:22,440: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:42:22,440: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2017-12-21 15:42:23,070: SQL status: CREATE VIEW in 0.63 seconds
2017-12-21 15:42:23,071: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:42:23,071: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2017-12-21 15:42:23,075: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:42:23,075: On parsely_pageview_engagedtime: COMMIT
2017-12-21 15:42:23,075: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:42:23,076: On parsely_pageview_engagedtime: COMMIT
2017-12-21 15:42:23,622: SQL status: COMMIT in 0.55 seconds
2017-12-21 15:42:23,623: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b20a50>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:42:23,656: 15:42:23 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 1.29s]
2017-12-21 15:42:23,656: 15:42:23 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2017-12-21 15:42:23,657: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 15:42:23,677: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 15:42:23,678: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 15:42:23,678: Re-using an available connection from the pool.
2017-12-21 15:42:23,679: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:42:23,679: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:42:23,700: SQL status: SELECT in 0.02 seconds
2017-12-21 15:42:23,704: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 15:42:23,709: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:42:23,709: On parsely_incoming_sessions: BEGIN
2017-12-21 15:42:23,712: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:42:23,713: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:42:23,713: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 15:42:23,790: SQL status: CREATE VIEW in 0.08 seconds
2017-12-21 15:42:23,791: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:42:23,791: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 15:42:23,794: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:42:23,794: On parsely_incoming_sessions: COMMIT
2017-12-21 15:42:23,794: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:42:23,795: On parsely_incoming_sessions: COMMIT
2017-12-21 15:42:23,989: SQL status: COMMIT in 0.19 seconds
2017-12-21 15:42:23,990: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89bf5e8410>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:42:24,047: 15:42:24 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.33s]
2017-12-21 15:42:24,048: 15:42:24 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2017-12-21 15:42:24,048: Compiling model.parsely.parsely_pageview_behavior_workflow
2017-12-21 15:42:24,072: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 15:42:24,089: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:42:24,090: Re-using an available connection from the pool.
2017-12-21 15:42:24,090: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:42:24,090: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:42:24,111: SQL status: SELECT in 0.02 seconds
2017-12-21 15:42:24,112: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:42:24,112: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:42:24,133: SQL status: SELECT in 0.02 seconds
2017-12-21 15:42:24,136: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:42:24,136: On parsely_pageview_behavior_workflow: BEGIN
2017-12-21 15:42:24,138: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:42:24,138: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:42:24,138: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:43:32,304: SQL status: SELECT in 68.17 seconds
2017-12-21 15:43:32,304: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:43:32,305: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 15:43:32,493: SQL status: SELECT in 0.19 seconds
2017-12-21 15:43:32,494: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:43:32,494: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:43:32,604: SQL status: SELECT in 0.11 seconds
2017-12-21 15:43:32,606: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:43:32,606: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:43:32,716: SQL status: SELECT in 0.11 seconds
2017-12-21 15:43:32,722: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 15:43:32,723: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:43:32,724: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 15:43:35,842: SQL status: INSERT 0 106381 in 3.12 seconds
2017-12-21 15:43:35,843: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 15:43:35,843: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:43:35,843: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 15:43:37,891: SQL status: COMMIT in 2.05 seconds
2017-12-21 15:43:37,892: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89bf5e8410>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:43:37,952: 15:43:37 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 106381 in 73.84s]
2017-12-21 15:43:37,952: 15:43:37 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2017-12-21 15:43:37,953: Compiling model.parsely.parsely_sessions
2017-12-21 15:43:37,966: Acquiring new redshift connection "parsely_sessions".
2017-12-21 15:43:37,966: Re-using an available connection from the pool.
2017-12-21 15:43:37,966: Using redshift connection "parsely_sessions".
2017-12-21 15:43:37,966: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:43:37,993: SQL status: SELECT in 0.03 seconds
2017-12-21 15:43:38,000: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 15:43:38,003: Using redshift connection "parsely_sessions".
2017-12-21 15:43:38,003: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:43:38,025: SQL status: SELECT in 0.02 seconds
2017-12-21 15:43:38,026: Using redshift connection "parsely_sessions".
2017-12-21 15:43:38,026: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:43:38,047: SQL status: SELECT in 0.02 seconds
2017-12-21 15:43:38,052: Using redshift connection "parsely_sessions".
2017-12-21 15:43:38,052: On parsely_sessions: BEGIN
2017-12-21 15:43:38,054: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:43:38,054: Using redshift connection "parsely_sessions".
2017-12-21 15:43:38,054: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:43:56,834: SQL status: SELECT in 18.78 seconds
2017-12-21 15:43:56,835: Using redshift connection "parsely_sessions".
2017-12-21 15:43:56,835: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2017-12-21 15:43:57,031: SQL status: SELECT in 0.20 seconds
2017-12-21 15:43:57,032: Using redshift connection "parsely_sessions".
2017-12-21 15:43:57,032: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:43:57,143: SQL status: SELECT in 0.11 seconds
2017-12-21 15:43:57,145: Using redshift connection "parsely_sessions".
2017-12-21 15:43:57,145: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:43:57,254: SQL status: SELECT in 0.11 seconds
2017-12-21 15:43:57,259: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 15:43:57,260: Using redshift connection "parsely_sessions".
2017-12-21 15:43:57,261: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2017-12-21 15:43:59,289: SQL status: INSERT 0 86422 in 2.03 seconds
2017-12-21 15:43:59,290: On parsely_sessions: COMMIT
2017-12-21 15:43:59,290: Using redshift connection "parsely_sessions".
2017-12-21 15:43:59,290: On parsely_sessions: COMMIT
2017-12-21 15:44:00,272: SQL status: COMMIT in 0.98 seconds
2017-12-21 15:44:00,273: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4b20110>], 'label': 'd0d038fe-d158-46d1-9c11-43a694afc139'}
2017-12-21 15:44:00,320: 15:44:00 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 86422 in 22.32s]
2017-12-21 15:44:00,349: Using redshift connection "master".
2017-12-21 15:44:00,350: On master: BEGIN
2017-12-21 15:44:00,352: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:44:00,352: On master: COMMIT
2017-12-21 15:44:00,352: Using redshift connection "master".
2017-12-21 15:44:00,352: On master: COMMIT
2017-12-21 15:44:00,354: SQL status: COMMIT in 0.00 seconds
2017-12-21 15:44:00,354: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 15:44:00,361: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 15:44:00,361: Using redshift connection "master".
2017-12-21 15:44:00,361: On master:  select 1 
2017-12-21 15:44:00,363: SQL status: SELECT in 0.00 seconds
2017-12-21 15:44:00,363: 15:44:00 | 
2017-12-21 15:44:00,364: 15:44:00 | Finished running 10 view models, 15 incremental models in 686.08s.
2017-12-21 15:44:00,364: 
2017-12-21 15:44:00,364: Completed successfully
2017-12-21 15:44:00,364: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2017-12-21 15:44:00,365: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4c32e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4c32f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f89b4c19950>], 'label': 'end'}
2017-12-21 15:44:00,398: Flushing usage events
2017-12-21 15:44:10,139: Tracking: tracking
2017-12-21 15:44:10,139: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315c1e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315c1f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315c1ed0>], 'label': 'start'}
2017-12-21 15:44:10,193: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 15:44:10,226: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 15:44:10,228: Parsing core.sql
2017-12-21 15:44:10,251: Parsing etc/get_custom_schema.sql
2017-12-21 15:44:10,261: Parsing schema_tests/relationships.sql
2017-12-21 15:44:10,266: Parsing schema_tests/accepted_values.sql
2017-12-21 15:44:10,272: Parsing schema_tests/not_null.sql
2017-12-21 15:44:10,275: Parsing schema_tests/unique.sql
2017-12-21 15:44:10,278: Parsing materializations/wrapper.sql
2017-12-21 15:44:10,284: Parsing materializations/archive.sql
2017-12-21 15:44:10,343: Parsing materializations/table.sql
2017-12-21 15:44:10,378: Parsing materializations/helpers.sql
2017-12-21 15:44:10,409: Parsing materializations/bigquery.sql
2017-12-21 15:44:10,436: Parsing materializations/view.sql
2017-12-21 15:44:10,465: Parsing materializations/incremental.sql
2017-12-21 15:44:10,517: Parsing adapters/redshift.sql
2017-12-21 15:44:10,553: Parsing adapters/bigquery.sql
2017-12-21 15:44:10,562: Parsing adapters/postgres.sql
2017-12-21 15:44:10,566: Parsing adapters/common.sql
2017-12-21 15:44:10,584: Parsing model.parsely.parsely_audit
2017-12-21 15:44:10,586: Parsing model.parsely.parsely_video_content
2017-12-21 15:44:10,589: Parsing model.parsely.parsely_post_content
2017-12-21 15:44:10,592: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 15:44:10,594: Parsing model.parsely.parsely_rawdata
2017-12-21 15:44:10,597: Parsing model.parsely.calendar
2017-12-21 15:44:10,598: Parsing model.parsely.parsely_all_events
2017-12-21 15:44:10,606: Acquiring new redshift connection "parsely_all_events".
2017-12-21 15:44:10,607: Opening a new connection (0 currently allocated)
2017-12-21 15:44:10,619: Using redshift connection "parsely_all_events".
2017-12-21 15:44:10,619: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:10,644: SQL status: SELECT in 0.03 seconds
2017-12-21 15:44:10,654: Parsing model.parsely.parsely_event_ids
2017-12-21 15:44:10,658: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 15:44:10,662: Parsing model.parsely.parsely_base_events
2017-12-21 15:44:10,668: Acquiring new redshift connection "parsely_base_events".
2017-12-21 15:44:10,668: Re-using an available connection from the pool.
2017-12-21 15:44:10,669: Using redshift connection "parsely_base_events".
2017-12-21 15:44:10,669: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:10,689: SQL status: SELECT in 0.02 seconds
2017-12-21 15:44:10,691: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 15:44:10,701: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 15:44:10,709: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 15:44:10,713: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 15:44:10,716: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 15:44:10,722: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 15:44:10,733: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 15:44:10,746: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 15:44:10,755: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:44:10,755: Re-using an available connection from the pool.
2017-12-21 15:44:10,756: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:44:10,756: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:10,777: SQL status: SELECT in 0.02 seconds
2017-12-21 15:44:10,778: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 15:44:10,790: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 15:44:10,799: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:44:10,799: Re-using an available connection from the pool.
2017-12-21 15:44:10,799: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:44:10,800: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:10,820: SQL status: SELECT in 0.02 seconds
2017-12-21 15:44:10,821: Parsing model.parsely.parsely_incoming_users
2017-12-21 15:44:10,827: Parsing model.parsely.parsely_users
2017-12-21 15:44:10,836: Acquiring new redshift connection "parsely_users".
2017-12-21 15:44:10,836: Re-using an available connection from the pool.
2017-12-21 15:44:10,836: Using redshift connection "parsely_users".
2017-12-21 15:44:10,836: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:10,856: SQL status: SELECT in 0.02 seconds
2017-12-21 15:44:10,858: Parsing model.parsely.parsely_errors
2017-12-21 15:44:10,865: Parsing model.parsely.parsely_bot_traffic
2017-12-21 15:44:10,873: Parsing model.parsely.parsely_custom_events
2017-12-21 15:44:10,882: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 15:44:10,888: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 15:44:10,893: Parsing model.parsely.parsely_sessions
2017-12-21 15:44:10,903: Acquiring new redshift connection "parsely_sessions".
2017-12-21 15:44:10,903: Re-using an available connection from the pool.
2017-12-21 15:44:10,904: Using redshift connection "parsely_sessions".
2017-12-21 15:44:10,904: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:10,924: SQL status: SELECT in 0.02 seconds
2017-12-21 15:44:10,925: Parsing model.parsely.parsely_campaigns
2017-12-21 15:44:10,932: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 15:44:10,932: Re-using an available connection from the pool.
2017-12-21 15:44:10,933: Using redshift connection "parsely_campaigns".
2017-12-21 15:44:10,933: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:10,953: SQL status: SELECT in 0.02 seconds
2017-12-21 15:44:10,965: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 15:44:10,975: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 15:44:10,989: 
2017-12-21 15:44:10,994: Acquiring new redshift connection "master".
2017-12-21 15:44:10,994: Re-using an available connection from the pool.
2017-12-21 15:44:10,994: Using redshift connection "master".
2017-12-21 15:44:10,994: On master: select distinct nspname from pg_namespace
2017-12-21 15:44:10,997: SQL status: SELECT in 0.00 seconds
2017-12-21 15:44:11,002: Using redshift connection "master".
2017-12-21 15:44:11,002: On master: BEGIN
2017-12-21 15:44:11,003: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:44:11,004: On master: COMMIT
2017-12-21 15:44:11,004: Using redshift connection "master".
2017-12-21 15:44:11,004: On master: COMMIT
2017-12-21 15:44:11,006: SQL status: COMMIT in 0.00 seconds
2017-12-21 15:44:11,015: 15:44:11 | Concurrency: 1 threads (target='dev')
2017-12-21 15:44:11,016: 15:44:11 | 
2017-12-21 15:44:11,016: Using redshift connection "master".
2017-12-21 15:44:11,016: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:11,037: SQL status: SELECT in 0.02 seconds
2017-12-21 15:44:11,122: 15:44:11 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-21 15:44:11,122: Compiling model.parsely.calendar
2017-12-21 15:44:11,129: Writing injected SQL for node "model.parsely.calendar"
2017-12-21 15:44:11,130: Acquiring new redshift connection "calendar".
2017-12-21 15:44:11,130: Opening a new connection (1 currently allocated)
2017-12-21 15:44:11,143: Using redshift connection "calendar".
2017-12-21 15:44:11,144: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:11,170: SQL status: SELECT in 0.03 seconds
2017-12-21 15:44:11,173: Writing runtime SQL for node "model.parsely.calendar"
2017-12-21 15:44:11,175: Using redshift connection "calendar".
2017-12-21 15:44:11,175: On calendar: BEGIN
2017-12-21 15:44:11,176: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:44:11,176: Using redshift connection "calendar".
2017-12-21 15:44:11,177: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-21 15:44:11,234: SQL status: CREATE VIEW in 0.06 seconds
2017-12-21 15:44:11,235: On calendar: COMMIT
2017-12-21 15:44:11,235: Using redshift connection "calendar".
2017-12-21 15:44:11,235: On calendar: COMMIT
2017-12-21 15:44:11,426: SQL status: COMMIT in 0.19 seconds
2017-12-21 15:44:11,426: Using redshift connection "calendar".
2017-12-21 15:44:11,426: On calendar: BEGIN
2017-12-21 15:44:11,428: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:44:11,428: Using redshift connection "calendar".
2017-12-21 15:44:11,428: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-21 15:44:11,474: SQL status: DROP VIEW in 0.05 seconds
2017-12-21 15:44:11,475: On calendar: COMMIT
2017-12-21 15:44:11,475: Using redshift connection "calendar".
2017-12-21 15:44:11,475: On calendar: COMMIT
2017-12-21 15:44:11,896: SQL status: COMMIT in 0.42 seconds
2017-12-21 15:44:11,896: Using redshift connection "calendar".
2017-12-21 15:44:11,896: On calendar: BEGIN
2017-12-21 15:44:11,898: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:44:11,898: Using redshift connection "calendar".
2017-12-21 15:44:11,899: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-21 15:44:12,000: SQL status: ALTER TABLE in 0.10 seconds
2017-12-21 15:44:12,000: On calendar: COMMIT
2017-12-21 15:44:12,000: Using redshift connection "calendar".
2017-12-21 15:44:12,000: On calendar: COMMIT
2017-12-21 15:44:12,627: SQL status: COMMIT in 0.63 seconds
2017-12-21 15:44:12,627: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1314afc10>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:44:12,667: 15:44:12 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.51s]
2017-12-21 15:44:12,668: 15:44:12 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-21 15:44:12,668: Compiling model.parsely.parsely_rawdata
2017-12-21 15:44:12,678: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-21 15:44:12,680: Acquiring new redshift connection "parsely_rawdata".
2017-12-21 15:44:12,680: Re-using an available connection from the pool.
2017-12-21 15:44:12,680: Using redshift connection "parsely_rawdata".
2017-12-21 15:44:12,680: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:12,700: SQL status: SELECT in 0.02 seconds
2017-12-21 15:44:12,701: Using redshift connection "parsely_rawdata".
2017-12-21 15:44:12,701: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:44:12,711: SQL status: SELECT in 0.01 seconds
2017-12-21 15:44:12,713: Using redshift connection "parsely_rawdata".
2017-12-21 15:44:12,713: On parsely_rawdata: BEGIN
2017-12-21 15:44:12,715: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:44:12,715: Using redshift connection "parsely_rawdata".
2017-12-21 15:44:12,715: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:44:40,668: SQL status: SELECT in 27.95 seconds
2017-12-21 15:44:40,668: Using redshift connection "parsely_rawdata".
2017-12-21 15:44:40,668: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-21 15:44:40,919: SQL status: SELECT in 0.25 seconds
2017-12-21 15:44:40,920: Using redshift connection "parsely_rawdata".
2017-12-21 15:44:40,920: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:44:41,020: SQL status: SELECT in 0.10 seconds
2017-12-21 15:44:41,021: Using redshift connection "parsely_rawdata".
2017-12-21 15:44:41,021: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:44:41,129: SQL status: SELECT in 0.11 seconds
2017-12-21 15:44:41,134: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-21 15:44:41,135: Using redshift connection "parsely_rawdata".
2017-12-21 15:44:41,136: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-21 15:45:09,138: SQL status: INSERT 0 1013299 in 28.00 seconds
2017-12-21 15:45:09,138: On parsely_rawdata: COMMIT
2017-12-21 15:45:09,139: Using redshift connection "parsely_rawdata".
2017-12-21 15:45:09,139: On parsely_rawdata: COMMIT
2017-12-21 15:45:11,063: SQL status: COMMIT in 1.92 seconds
2017-12-21 15:45:11,064: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315bb290>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:45:11,120: 15:45:11 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1013299 in 58.40s]
2017-12-21 15:45:11,120: 15:45:11 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-21 15:45:11,121: Compiling model.parsely.parsely_all_events
2017-12-21 15:45:11,137: Acquiring new redshift connection "parsely_all_events".
2017-12-21 15:45:11,137: Re-using an available connection from the pool.
2017-12-21 15:45:11,137: Using redshift connection "parsely_all_events".
2017-12-21 15:45:11,138: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:45:11,151: SQL status: SELECT in 0.01 seconds
2017-12-21 15:45:11,167: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-21 15:45:11,169: Using redshift connection "parsely_all_events".
2017-12-21 15:45:11,169: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:45:11,181: SQL status: SELECT in 0.01 seconds
2017-12-21 15:45:11,182: Using redshift connection "parsely_all_events".
2017-12-21 15:45:11,182: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:45:11,195: SQL status: SELECT in 0.01 seconds
2017-12-21 15:45:11,198: Using redshift connection "parsely_all_events".
2017-12-21 15:45:11,198: On parsely_all_events: BEGIN
2017-12-21 15:45:11,200: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:45:11,200: Using redshift connection "parsely_all_events".
2017-12-21 15:45:11,201: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:47:12,125: SQL status: SELECT in 120.92 seconds
2017-12-21 15:47:12,125: Using redshift connection "parsely_all_events".
2017-12-21 15:47:12,125: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2017-12-21 15:47:12,353: SQL status: SELECT in 0.23 seconds
2017-12-21 15:47:12,353: Using redshift connection "parsely_all_events".
2017-12-21 15:47:12,354: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:47:12,463: SQL status: SELECT in 0.11 seconds
2017-12-21 15:47:12,464: Using redshift connection "parsely_all_events".
2017-12-21 15:47:12,464: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:47:12,571: SQL status: SELECT in 0.11 seconds
2017-12-21 15:47:12,578: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-21 15:47:12,579: Using redshift connection "parsely_all_events".
2017-12-21 15:47:12,580: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2017-12-21 15:47:29,065: SQL status: INSERT 0 897809 in 16.48 seconds
2017-12-21 15:47:29,065: On parsely_all_events: COMMIT
2017-12-21 15:47:29,065: Using redshift connection "parsely_all_events".
2017-12-21 15:47:29,066: On parsely_all_events: COMMIT
2017-12-21 15:47:31,680: SQL status: COMMIT in 2.61 seconds
2017-12-21 15:47:31,680: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315296d0>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:47:31,766: 15:47:31 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 897809 in 140.56s]
2017-12-21 15:47:31,767: 15:47:31 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-21 15:47:31,767: Compiling model.parsely.parsely_bot_traffic
2017-12-21 15:47:31,774: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 15:47:31,775: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-21 15:47:31,775: Re-using an available connection from the pool.
2017-12-21 15:47:31,775: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:47:31,775: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:47:31,791: SQL status: SELECT in 0.02 seconds
2017-12-21 15:47:31,792: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:47:31,792: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:47:31,807: SQL status: SELECT in 0.01 seconds
2017-12-21 15:47:31,809: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:47:31,810: On parsely_bot_traffic: BEGIN
2017-12-21 15:47:31,812: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:47:31,812: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:47:31,812: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:48:02,587: SQL status: SELECT in 30.78 seconds
2017-12-21 15:48:02,588: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:48:02,588: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2017-12-21 15:48:02,747: SQL status: SELECT in 0.16 seconds
2017-12-21 15:48:02,747: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:48:02,747: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:48:02,857: SQL status: SELECT in 0.11 seconds
2017-12-21 15:48:02,857: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:48:02,858: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:48:02,963: SQL status: SELECT in 0.11 seconds
2017-12-21 15:48:02,966: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 15:48:02,967: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:48:02,967: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2017-12-21 15:48:04,150: SQL status: INSERT 0 4 in 1.18 seconds
2017-12-21 15:48:04,150: On parsely_bot_traffic: COMMIT
2017-12-21 15:48:04,150: Using redshift connection "parsely_bot_traffic".
2017-12-21 15:48:04,150: On parsely_bot_traffic: COMMIT
2017-12-21 15:48:05,772: SQL status: COMMIT in 1.62 seconds
2017-12-21 15:48:05,773: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315bb250>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:48:05,803: 15:48:05 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 34.01s]
2017-12-21 15:48:05,803: 15:48:05 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-21 15:48:05,803: Compiling model.parsely.parsely_custom_events
2017-12-21 15:48:05,811: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-21 15:48:05,813: Acquiring new redshift connection "parsely_custom_events".
2017-12-21 15:48:05,813: Re-using an available connection from the pool.
2017-12-21 15:48:05,813: Using redshift connection "parsely_custom_events".
2017-12-21 15:48:05,813: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:48:05,828: SQL status: SELECT in 0.02 seconds
2017-12-21 15:48:05,829: Using redshift connection "parsely_custom_events".
2017-12-21 15:48:05,829: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:48:05,844: SQL status: SELECT in 0.01 seconds
2017-12-21 15:48:05,846: Using redshift connection "parsely_custom_events".
2017-12-21 15:48:05,846: On parsely_custom_events: BEGIN
2017-12-21 15:48:05,848: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:48:05,848: Using redshift connection "parsely_custom_events".
2017-12-21 15:48:05,848: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:48:36,068: SQL status: SELECT in 30.22 seconds
2017-12-21 15:48:36,069: Using redshift connection "parsely_custom_events".
2017-12-21 15:48:36,069: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2017-12-21 15:48:36,234: SQL status: SELECT in 0.16 seconds
2017-12-21 15:48:36,234: Using redshift connection "parsely_custom_events".
2017-12-21 15:48:36,234: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:48:36,342: SQL status: SELECT in 0.11 seconds
2017-12-21 15:48:36,342: Using redshift connection "parsely_custom_events".
2017-12-21 15:48:36,342: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:48:36,450: SQL status: SELECT in 0.11 seconds
2017-12-21 15:48:36,453: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-21 15:48:36,454: Using redshift connection "parsely_custom_events".
2017-12-21 15:48:36,454: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2017-12-21 15:48:36,720: SQL status: INSERT 0 0 in 0.27 seconds
2017-12-21 15:48:36,721: On parsely_custom_events: COMMIT
2017-12-21 15:48:36,721: Using redshift connection "parsely_custom_events".
2017-12-21 15:48:36,721: On parsely_custom_events: COMMIT
2017-12-21 15:48:37,745: SQL status: COMMIT in 1.02 seconds
2017-12-21 15:48:37,745: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315bb250>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:48:37,793: 15:48:37 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 31.94s]
2017-12-21 15:48:37,793: 15:48:37 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-21 15:48:37,793: Compiling model.parsely.parsely_errors
2017-12-21 15:48:37,800: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-21 15:48:37,802: Acquiring new redshift connection "parsely_errors".
2017-12-21 15:48:37,802: Re-using an available connection from the pool.
2017-12-21 15:48:37,802: Using redshift connection "parsely_errors".
2017-12-21 15:48:37,802: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:48:37,817: SQL status: SELECT in 0.01 seconds
2017-12-21 15:48:37,817: Using redshift connection "parsely_errors".
2017-12-21 15:48:37,817: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:48:37,831: SQL status: SELECT in 0.01 seconds
2017-12-21 15:48:37,833: Using redshift connection "parsely_errors".
2017-12-21 15:48:37,833: On parsely_errors: BEGIN
2017-12-21 15:48:37,835: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:48:37,835: Using redshift connection "parsely_errors".
2017-12-21 15:48:37,835: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:49:06,355: SQL status: SELECT in 28.52 seconds
2017-12-21 15:49:06,355: Using redshift connection "parsely_errors".
2017-12-21 15:49:06,355: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2017-12-21 15:49:06,513: SQL status: SELECT in 0.16 seconds
2017-12-21 15:49:06,513: Using redshift connection "parsely_errors".
2017-12-21 15:49:06,513: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:49:06,622: SQL status: SELECT in 0.11 seconds
2017-12-21 15:49:06,623: Using redshift connection "parsely_errors".
2017-12-21 15:49:06,623: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:49:06,727: SQL status: SELECT in 0.10 seconds
2017-12-21 15:49:06,731: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-21 15:49:06,731: Using redshift connection "parsely_errors".
2017-12-21 15:49:06,731: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2017-12-21 15:49:07,544: SQL status: INSERT 0 2 in 0.81 seconds
2017-12-21 15:49:07,544: On parsely_errors: COMMIT
2017-12-21 15:49:07,544: Using redshift connection "parsely_errors".
2017-12-21 15:49:07,544: On parsely_errors: COMMIT
2017-12-21 15:49:09,411: SQL status: COMMIT in 1.87 seconds
2017-12-21 15:49:09,412: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315bb250>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:49:09,439: 15:49:09 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 31.62s]
2017-12-21 15:49:09,440: 15:49:09 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-21 15:49:09,440: Compiling model.parsely.parsely_base_events
2017-12-21 15:49:09,444: Acquiring new redshift connection "parsely_base_events".
2017-12-21 15:49:09,444: Re-using an available connection from the pool.
2017-12-21 15:49:09,444: Using redshift connection "parsely_base_events".
2017-12-21 15:49:09,444: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:09,461: SQL status: SELECT in 0.02 seconds
2017-12-21 15:49:09,465: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-21 15:49:09,466: Using redshift connection "parsely_base_events".
2017-12-21 15:49:09,466: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:09,479: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:09,481: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-21 15:49:09,482: Using redshift connection "parsely_base_events".
2017-12-21 15:49:09,482: On parsely_base_events: BEGIN
2017-12-21 15:49:09,483: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:49:09,484: Using redshift connection "parsely_base_events".
2017-12-21 15:49:09,484: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-21 15:49:10,146: SQL status: CREATE VIEW in 0.66 seconds
2017-12-21 15:49:10,146: On parsely_base_events: COMMIT
2017-12-21 15:49:10,146: Using redshift connection "parsely_base_events".
2017-12-21 15:49:10,146: On parsely_base_events: COMMIT
2017-12-21 15:49:10,757: SQL status: COMMIT in 0.61 seconds
2017-12-21 15:49:10,757: Using redshift connection "parsely_base_events".
2017-12-21 15:49:10,757: On parsely_base_events: BEGIN
2017-12-21 15:49:10,759: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:49:10,759: Using redshift connection "parsely_base_events".
2017-12-21 15:49:10,759: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2017-12-21 15:49:11,859: SQL status: DROP VIEW in 1.10 seconds
2017-12-21 15:49:11,859: On parsely_base_events: COMMIT
2017-12-21 15:49:11,859: Using redshift connection "parsely_base_events".
2017-12-21 15:49:11,859: On parsely_base_events: COMMIT
2017-12-21 15:49:12,327: SQL status: COMMIT in 0.47 seconds
2017-12-21 15:49:12,327: Using redshift connection "parsely_base_events".
2017-12-21 15:49:12,327: On parsely_base_events: BEGIN
2017-12-21 15:49:12,329: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:49:12,329: Using redshift connection "parsely_base_events".
2017-12-21 15:49:12,330: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-21 15:49:12,334: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:49:12,334: On parsely_base_events: COMMIT
2017-12-21 15:49:12,334: Using redshift connection "parsely_base_events".
2017-12-21 15:49:12,334: On parsely_base_events: COMMIT
2017-12-21 15:49:12,769: SQL status: COMMIT in 0.43 seconds
2017-12-21 15:49:12,769: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131519890>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:49:12,798: 15:49:12 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 3.33s]
2017-12-21 15:49:12,799: 15:49:12 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2017-12-21 15:49:12,799: Compiling model.parsely.parsely_event_ids
2017-12-21 15:49:12,804: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-21 15:49:12,806: Acquiring new redshift connection "parsely_event_ids".
2017-12-21 15:49:12,806: Re-using an available connection from the pool.
2017-12-21 15:49:12,806: Using redshift connection "parsely_event_ids".
2017-12-21 15:49:12,806: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:12,820: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:12,821: Using redshift connection "parsely_event_ids".
2017-12-21 15:49:12,821: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:12,834: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:12,835: Using redshift connection "parsely_event_ids".
2017-12-21 15:49:12,835: On parsely_event_ids: BEGIN
2017-12-21 15:49:12,837: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:49:12,837: Using redshift connection "parsely_event_ids".
2017-12-21 15:49:12,837: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:49:13,773: SQL status: SELECT in 0.94 seconds
2017-12-21 15:49:13,774: Using redshift connection "parsely_event_ids".
2017-12-21 15:49:13,774: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2017-12-21 15:49:13,947: SQL status: SELECT in 0.17 seconds
2017-12-21 15:49:13,948: Using redshift connection "parsely_event_ids".
2017-12-21 15:49:13,948: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:49:14,049: SQL status: SELECT in 0.10 seconds
2017-12-21 15:49:14,049: Using redshift connection "parsely_event_ids".
2017-12-21 15:49:14,049: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:49:14,146: SQL status: SELECT in 0.10 seconds
2017-12-21 15:49:14,147: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-21 15:49:14,148: Using redshift connection "parsely_event_ids".
2017-12-21 15:49:14,148: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2017-12-21 15:49:15,133: SQL status: INSERT 0 897805 in 0.99 seconds
2017-12-21 15:49:15,134: On parsely_event_ids: COMMIT
2017-12-21 15:49:15,134: Using redshift connection "parsely_event_ids".
2017-12-21 15:49:15,134: On parsely_event_ids: COMMIT
2017-12-21 15:49:15,602: SQL status: COMMIT in 0.47 seconds
2017-12-21 15:49:15,602: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131519890>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:49:15,630: 15:49:15 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 897805 in 2.80s]
2017-12-21 15:49:15,631: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-21 15:49:15,636: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-21 15:49:15,637: 15:49:15 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-21 15:49:15,637: Compiling model.parsely.parsely_post_content
2017-12-21 15:49:15,643: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-21 15:49:15,644: Acquiring new redshift connection "parsely_post_content".
2017-12-21 15:49:15,644: Re-using an available connection from the pool.
2017-12-21 15:49:15,644: Using redshift connection "parsely_post_content".
2017-12-21 15:49:15,644: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:15,659: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:15,659: Using redshift connection "parsely_post_content".
2017-12-21 15:49:15,659: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:15,673: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:15,674: Using redshift connection "parsely_post_content".
2017-12-21 15:49:15,674: On parsely_post_content: BEGIN
2017-12-21 15:49:15,676: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:49:15,676: Using redshift connection "parsely_post_content".
2017-12-21 15:49:15,676: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:49:21,517: SQL status: SELECT in 5.84 seconds
2017-12-21 15:49:21,517: Using redshift connection "parsely_post_content".
2017-12-21 15:49:21,517: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2017-12-21 15:49:21,670: SQL status: SELECT in 0.15 seconds
2017-12-21 15:49:21,670: Using redshift connection "parsely_post_content".
2017-12-21 15:49:21,670: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:49:21,772: SQL status: SELECT in 0.10 seconds
2017-12-21 15:49:21,773: Using redshift connection "parsely_post_content".
2017-12-21 15:49:21,773: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:49:21,877: SQL status: SELECT in 0.10 seconds
2017-12-21 15:49:21,878: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-21 15:49:21,879: Using redshift connection "parsely_post_content".
2017-12-21 15:49:21,879: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2017-12-21 15:49:22,314: SQL status: INSERT 0 880 in 0.44 seconds
2017-12-21 15:49:22,315: On parsely_post_content: COMMIT
2017-12-21 15:49:22,315: Using redshift connection "parsely_post_content".
2017-12-21 15:49:22,315: On parsely_post_content: COMMIT
2017-12-21 15:49:22,832: SQL status: COMMIT in 0.52 seconds
2017-12-21 15:49:22,832: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131519bd0>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:49:22,860: 15:49:22 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 880 in 7.19s]
2017-12-21 15:49:22,860: 15:49:22 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2017-12-21 15:49:22,861: Compiling model.parsely.parsely_video_content
2017-12-21 15:49:22,866: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-21 15:49:22,867: Acquiring new redshift connection "parsely_video_content".
2017-12-21 15:49:22,867: Re-using an available connection from the pool.
2017-12-21 15:49:22,868: Using redshift connection "parsely_video_content".
2017-12-21 15:49:22,868: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:22,881: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:22,882: Using redshift connection "parsely_video_content".
2017-12-21 15:49:22,882: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:22,896: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:22,897: Using redshift connection "parsely_video_content".
2017-12-21 15:49:22,897: On parsely_video_content: BEGIN
2017-12-21 15:49:22,899: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:49:22,899: Using redshift connection "parsely_video_content".
2017-12-21 15:49:22,899: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:49:28,098: SQL status: SELECT in 5.20 seconds
2017-12-21 15:49:28,098: Using redshift connection "parsely_video_content".
2017-12-21 15:49:28,099: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2017-12-21 15:49:28,632: SQL status: SELECT in 0.53 seconds
2017-12-21 15:49:28,632: Using redshift connection "parsely_video_content".
2017-12-21 15:49:28,632: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:49:28,731: SQL status: SELECT in 0.10 seconds
2017-12-21 15:49:28,731: Using redshift connection "parsely_video_content".
2017-12-21 15:49:28,731: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:49:28,835: SQL status: SELECT in 0.10 seconds
2017-12-21 15:49:28,836: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-21 15:49:28,837: Using redshift connection "parsely_video_content".
2017-12-21 15:49:28,837: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2017-12-21 15:49:29,559: SQL status: INSERT 0 468 in 0.72 seconds
2017-12-21 15:49:29,560: On parsely_video_content: COMMIT
2017-12-21 15:49:29,560: Using redshift connection "parsely_video_content".
2017-12-21 15:49:29,560: On parsely_video_content: COMMIT
2017-12-21 15:49:30,214: SQL status: COMMIT in 0.65 seconds
2017-12-21 15:49:30,214: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1314dac10>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:49:30,238: 15:49:30 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 468 in 7.35s]
2017-12-21 15:49:30,239: 15:49:30 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-21 15:49:30,239: Compiling model.parsely.parsely_entry_exit_urls
2017-12-21 15:49:30,244: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 15:49:30,245: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-21 15:49:30,246: Re-using an available connection from the pool.
2017-12-21 15:49:30,246: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:49:30,246: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:30,260: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:30,262: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 15:49:30,263: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:49:30,263: On parsely_entry_exit_urls: BEGIN
2017-12-21 15:49:30,265: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:49:30,265: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:49:30,265: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-21 15:49:30,343: SQL status: CREATE VIEW in 0.08 seconds
2017-12-21 15:49:30,344: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:49:30,344: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2017-12-21 15:49:30,346: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:49:30,347: On parsely_entry_exit_urls: COMMIT
2017-12-21 15:49:30,347: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 15:49:30,347: On parsely_entry_exit_urls: COMMIT
2017-12-21 15:49:30,623: SQL status: COMMIT in 0.28 seconds
2017-12-21 15:49:30,623: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131519850>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:49:30,652: 15:49:30 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.38s]
2017-12-21 15:49:30,652: 15:49:30 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-21 15:49:30,652: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 15:49:30,662: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 15:49:30,664: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 15:49:30,664: Re-using an available connection from the pool.
2017-12-21 15:49:30,664: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:49:30,664: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:30,679: SQL status: SELECT in 0.02 seconds
2017-12-21 15:49:30,683: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 15:49:30,684: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:49:30,684: On parsely_incoming_videoviews: BEGIN
2017-12-21 15:49:30,686: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:49:30,686: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:49:30,686: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 15:49:30,761: SQL status: CREATE VIEW in 0.07 seconds
2017-12-21 15:49:30,761: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:49:30,761: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 15:49:30,766: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 15:49:30,766: On parsely_incoming_videoviews: COMMIT
2017-12-21 15:49:30,766: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 15:49:30,766: On parsely_incoming_videoviews: COMMIT
2017-12-21 15:49:30,932: SQL status: COMMIT in 0.17 seconds
2017-12-21 15:49:30,932: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131519850>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:49:30,958: 15:49:30 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.28s]
2017-12-21 15:49:30,959: 15:49:30 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 15:49:30,959: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 15:49:30,964: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:49:30,964: Re-using an available connection from the pool.
2017-12-21 15:49:30,964: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:49:30,964: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:30,978: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:30,981: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 15:49:30,983: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:49:30,983: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:30,997: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:30,997: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:49:30,997: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:49:31,012: SQL status: SELECT in 0.01 seconds
2017-12-21 15:49:31,014: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:49:31,014: On parsely_videoviews_sessionized: BEGIN
2017-12-21 15:49:31,016: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:49:31,016: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:49:31,016: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:50:09,167: SQL status: SELECT in 38.15 seconds
2017-12-21 15:50:09,167: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:50:09,167: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2017-12-21 15:50:09,647: SQL status: SELECT in 0.48 seconds
2017-12-21 15:50:09,648: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:50:09,648: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:50:09,764: SQL status: SELECT in 0.12 seconds
2017-12-21 15:50:09,765: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:50:09,765: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:50:09,880: SQL status: SELECT in 0.12 seconds
2017-12-21 15:50:09,884: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 15:50:09,885: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:50:09,885: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 15:50:10,997: SQL status: INSERT 0 142 in 1.11 seconds
2017-12-21 15:50:10,997: On parsely_videoviews_sessionized: COMMIT
2017-12-21 15:50:10,997: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:50:10,997: On parsely_videoviews_sessionized: COMMIT
2017-12-21 15:50:12,268: SQL status: COMMIT in 1.27 seconds
2017-12-21 15:50:12,269: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131519810>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:50:12,309: 15:50:12 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 142 in 41.31s]
2017-12-21 15:50:12,309: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-21 15:50:12,330: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-21 15:50:12,331: 15:50:12 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-21 15:50:12,331: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 15:50:12,343: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 15:50:12,344: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:50:12,344: Re-using an available connection from the pool.
2017-12-21 15:50:12,344: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:50:12,344: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:50:12,358: SQL status: SELECT in 0.01 seconds
2017-12-21 15:50:12,359: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 15:50:12,360: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:50:12,360: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-21 15:50:12,362: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:50:12,362: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:50:12,362: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-21 15:50:12,890: SQL status: CREATE VIEW in 0.53 seconds
2017-12-21 15:50:12,890: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:50:12,890: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-21 15:50:12,893: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:50:12,893: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 15:50:12,894: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 15:50:12,894: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 15:50:13,618: SQL status: COMMIT in 0.72 seconds
2017-12-21 15:50:13,619: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315bb250>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:50:13,647: 15:50:13 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.29s]
2017-12-21 15:50:13,648: 15:50:13 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-21 15:50:13,652: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 15:50:13,685: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 15:50:13,686: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:50:13,687: Re-using an available connection from the pool.
2017-12-21 15:50:13,687: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:50:13,687: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:50:13,703: SQL status: SELECT in 0.02 seconds
2017-12-21 15:50:13,706: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 15:50:13,706: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:50:13,706: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-21 15:50:13,708: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:50:13,708: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:50:13,708: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-21 15:50:14,283: SQL status: CREATE VIEW in 0.57 seconds
2017-12-21 15:50:14,283: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:50:14,283: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-21 15:50:14,287: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:50:14,287: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 15:50:14,287: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 15:50:14,287: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 15:50:14,485: SQL status: COMMIT in 0.20 seconds
2017-12-21 15:50:14,485: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131510e10>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:50:14,514: 15:50:14 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.83s]
2017-12-21 15:50:14,514: 15:50:14 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2017-12-21 15:50:14,514: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 15:50:14,524: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 15:50:14,526: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 15:50:14,526: Re-using an available connection from the pool.
2017-12-21 15:50:14,526: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:50:14,526: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:50:14,540: SQL status: SELECT in 0.01 seconds
2017-12-21 15:50:14,544: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 15:50:14,545: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:50:14,545: On parsely_incoming_pageviews: BEGIN
2017-12-21 15:50:14,547: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:50:14,547: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:50:14,547: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 15:50:14,630: SQL status: CREATE VIEW in 0.08 seconds
2017-12-21 15:50:14,631: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:50:14,631: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2017-12-21 15:50:14,635: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:50:14,635: On parsely_incoming_pageviews: COMMIT
2017-12-21 15:50:14,635: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 15:50:14,636: On parsely_incoming_pageviews: COMMIT
2017-12-21 15:50:14,827: SQL status: COMMIT in 0.19 seconds
2017-12-21 15:50:14,828: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131510e10>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:50:14,876: 15:50:14 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.31s]
2017-12-21 15:50:14,877: 15:50:14 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2017-12-21 15:50:14,877: Compiling model.parsely.parsely_pageviews_sessionized
2017-12-21 15:50:14,882: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:50:14,882: Re-using an available connection from the pool.
2017-12-21 15:50:14,882: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:50:14,882: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:50:14,896: SQL status: SELECT in 0.01 seconds
2017-12-21 15:50:14,900: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 15:50:14,902: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:50:14,902: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:50:14,915: SQL status: SELECT in 0.01 seconds
2017-12-21 15:50:14,915: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:50:14,915: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:50:14,929: SQL status: SELECT in 0.01 seconds
2017-12-21 15:50:14,931: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:50:14,931: On parsely_pageviews_sessionized: BEGIN
2017-12-21 15:50:14,933: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:50:14,933: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:50:14,933: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:53:31,265: SQL status: SELECT in 196.33 seconds
2017-12-21 15:53:31,266: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:53:31,266: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2017-12-21 15:53:31,421: SQL status: SELECT in 0.15 seconds
2017-12-21 15:53:31,421: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:53:31,421: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:53:31,529: SQL status: SELECT in 0.11 seconds
2017-12-21 15:53:31,531: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:53:31,531: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:53:31,639: SQL status: SELECT in 0.11 seconds
2017-12-21 15:53:31,643: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 15:53:31,644: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:53:31,644: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 15:53:34,465: SQL status: INSERT 0 106981 in 2.82 seconds
2017-12-21 15:53:34,465: On parsely_pageviews_sessionized: COMMIT
2017-12-21 15:53:34,465: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:53:34,465: On parsely_pageviews_sessionized: COMMIT
2017-12-21 15:53:35,768: SQL status: COMMIT in 1.30 seconds
2017-12-21 15:53:35,769: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1314af310>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:53:35,825: 15:53:35 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 106981 in 200.89s]
2017-12-21 15:53:35,825: 15:53:35 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-21 15:53:35,826: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-21 15:53:35,870: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 15:53:35,871: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:53:35,871: Re-using an available connection from the pool.
2017-12-21 15:53:35,871: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:53:35,871: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:53:35,891: SQL status: SELECT in 0.02 seconds
2017-12-21 15:53:35,894: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 15:53:35,894: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:53:35,895: On parsely_videoview_engagedtime: BEGIN
2017-12-21 15:53:35,896: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:53:35,897: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:53:35,897: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-21 15:53:36,607: SQL status: CREATE VIEW in 0.71 seconds
2017-12-21 15:53:36,608: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:53:36,608: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-21 15:53:36,612: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:53:36,612: On parsely_videoview_engagedtime: COMMIT
2017-12-21 15:53:36,612: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 15:53:36,612: On parsely_videoview_engagedtime: COMMIT
2017-12-21 15:53:37,282: SQL status: COMMIT in 0.67 seconds
2017-12-21 15:53:37,283: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1314af310>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:53:37,309: 15:53:37 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.46s]
2017-12-21 15:53:37,309: 15:53:37 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-21 15:53:37,309: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-21 15:53:37,318: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 15:53:37,319: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:53:37,319: Re-using an available connection from the pool.
2017-12-21 15:53:37,319: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:53:37,319: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:53:37,339: SQL status: SELECT in 0.02 seconds
2017-12-21 15:53:37,340: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:53:37,340: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:53:37,357: SQL status: SELECT in 0.02 seconds
2017-12-21 15:53:37,359: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:53:37,360: On parsely_videoview_behavior_workflow: BEGIN
2017-12-21 15:53:37,361: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:53:37,361: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:53:37,362: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:55:10,814: SQL status: SELECT in 93.45 seconds
2017-12-21 15:55:10,814: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:55:10,815: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 15:55:11,001: SQL status: SELECT in 0.19 seconds
2017-12-21 15:55:11,002: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:55:11,002: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:55:11,112: SQL status: SELECT in 0.11 seconds
2017-12-21 15:55:11,112: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:55:11,113: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:55:11,221: SQL status: SELECT in 0.11 seconds
2017-12-21 15:55:11,224: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 15:55:11,225: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:55:11,225: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 15:55:12,252: SQL status: INSERT 0 141 in 1.03 seconds
2017-12-21 15:55:12,252: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 15:55:12,252: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 15:55:12,252: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 15:55:13,438: SQL status: COMMIT in 1.19 seconds
2017-12-21 15:55:13,438: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131510e10>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:55:13,502: 15:55:13 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 141 in 96.13s]
2017-12-21 15:55:13,503: 15:55:13 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2017-12-21 15:55:13,503: Compiling model.parsely.parsely_campaigns
2017-12-21 15:55:13,507: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 15:55:13,507: Re-using an available connection from the pool.
2017-12-21 15:55:13,507: Using redshift connection "parsely_campaigns".
2017-12-21 15:55:13,507: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:55:13,528: SQL status: SELECT in 0.02 seconds
2017-12-21 15:55:13,531: Writing injected SQL for node "model.parsely.parsely_campaigns"
2017-12-21 15:55:13,532: Using redshift connection "parsely_campaigns".
2017-12-21 15:55:13,532: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:55:13,552: SQL status: SELECT in 0.02 seconds
2017-12-21 15:55:13,553: Using redshift connection "parsely_campaigns".
2017-12-21 15:55:13,553: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:55:13,572: SQL status: SELECT in 0.02 seconds
2017-12-21 15:55:13,573: Using redshift connection "parsely_campaigns".
2017-12-21 15:55:13,573: On parsely_campaigns: BEGIN
2017-12-21 15:55:13,575: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:55:13,575: Using redshift connection "parsely_campaigns".
2017-12-21 15:55:13,575: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:55:14,738: SQL status: SELECT in 1.16 seconds
2017-12-21 15:55:14,739: Using redshift connection "parsely_campaigns".
2017-12-21 15:55:14,739: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2017-12-21 15:55:14,910: SQL status: SELECT in 0.17 seconds
2017-12-21 15:55:14,910: Using redshift connection "parsely_campaigns".
2017-12-21 15:55:14,910: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:55:15,018: SQL status: SELECT in 0.11 seconds
2017-12-21 15:55:15,018: Using redshift connection "parsely_campaigns".
2017-12-21 15:55:15,018: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:55:15,124: SQL status: SELECT in 0.11 seconds
2017-12-21 15:55:15,126: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2017-12-21 15:55:15,127: Using redshift connection "parsely_campaigns".
2017-12-21 15:55:15,127: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2017-12-21 15:55:15,266: SQL status: INSERT 0 382 in 0.14 seconds
2017-12-21 15:55:15,267: On parsely_campaigns: COMMIT
2017-12-21 15:55:15,267: Using redshift connection "parsely_campaigns".
2017-12-21 15:55:15,267: On parsely_campaigns: COMMIT
2017-12-21 15:55:15,906: SQL status: COMMIT in 0.64 seconds
2017-12-21 15:55:15,906: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131510e10>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:55:15,932: 15:55:15 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 382 in 2.40s]
2017-12-21 15:55:15,933: Compiling model.parsely.parsely_incoming_users
2017-12-21 15:55:15,940: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 15:55:15,941: 15:55:15 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2017-12-21 15:55:15,941: Compiling model.parsely.parsely_users
2017-12-21 15:55:15,946: Acquiring new redshift connection "parsely_users".
2017-12-21 15:55:15,947: Re-using an available connection from the pool.
2017-12-21 15:55:15,947: Using redshift connection "parsely_users".
2017-12-21 15:55:15,947: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:55:15,968: SQL status: SELECT in 0.02 seconds
2017-12-21 15:55:16,008: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 15:55:16,010: Using redshift connection "parsely_users".
2017-12-21 15:55:16,010: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:55:16,030: SQL status: SELECT in 0.02 seconds
2017-12-21 15:55:16,031: Using redshift connection "parsely_users".
2017-12-21 15:55:16,031: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:55:16,050: SQL status: SELECT in 0.02 seconds
2017-12-21 15:55:16,052: Using redshift connection "parsely_users".
2017-12-21 15:55:16,052: On parsely_users: BEGIN
2017-12-21 15:55:16,054: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:55:16,054: Using redshift connection "parsely_users".
2017-12-21 15:55:16,054: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3,4
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3,4
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      visitor_ip,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3,4
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id, visitor_ip)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3,4


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    visitor_ip,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:55:18,313: SQL status: SELECT in 2.26 seconds
2017-12-21 15:55:18,314: Using redshift connection "parsely_users".
2017-12-21 15:55:18,314: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2017-12-21 15:55:18,528: SQL status: SELECT in 0.21 seconds
2017-12-21 15:55:18,529: Using redshift connection "parsely_users".
2017-12-21 15:55:18,529: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:55:18,639: SQL status: SELECT in 0.11 seconds
2017-12-21 15:55:18,640: Using redshift connection "parsely_users".
2017-12-21 15:55:18,640: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:55:18,755: SQL status: SELECT in 0.12 seconds
2017-12-21 15:55:18,757: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 15:55:18,758: Using redshift connection "parsely_users".
2017-12-21 15:55:18,758: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2017-12-21 15:55:19,075: SQL status: INSERT 0 59290 in 0.32 seconds
2017-12-21 15:55:19,075: On parsely_users: COMMIT
2017-12-21 15:55:19,076: Using redshift connection "parsely_users".
2017-12-21 15:55:19,076: On parsely_users: COMMIT
2017-12-21 15:55:20,196: SQL status: COMMIT in 1.12 seconds
2017-12-21 15:55:20,196: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1314a18d0>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:55:20,225: 15:55:20 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 59290 in 4.26s]
2017-12-21 15:55:20,225: 15:55:20 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2017-12-21 15:55:20,226: Compiling model.parsely.parsely_pageview_engagedtime
2017-12-21 15:55:20,257: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 15:55:20,258: Acquiring new redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:55:20,258: Re-using an available connection from the pool.
2017-12-21 15:55:20,258: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:55:20,258: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:55:20,279: SQL status: SELECT in 0.02 seconds
2017-12-21 15:55:20,281: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 15:55:20,282: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:55:20,282: On parsely_pageview_engagedtime: BEGIN
2017-12-21 15:55:20,284: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:55:20,284: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:55:20,284: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2017-12-21 15:55:22,974: SQL status: CREATE VIEW in 2.69 seconds
2017-12-21 15:55:22,975: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:55:22,975: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2017-12-21 15:55:22,979: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:55:22,979: On parsely_pageview_engagedtime: COMMIT
2017-12-21 15:55:22,979: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 15:55:22,979: On parsely_pageview_engagedtime: COMMIT
2017-12-21 15:55:23,170: SQL status: COMMIT in 0.19 seconds
2017-12-21 15:55:23,170: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa13156b410>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:55:23,196: 15:55:23 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 2.94s]
2017-12-21 15:55:23,196: 15:55:23 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2017-12-21 15:55:23,196: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 15:55:23,203: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 15:55:23,204: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 15:55:23,204: Re-using an available connection from the pool.
2017-12-21 15:55:23,204: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:55:23,205: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:55:23,226: SQL status: SELECT in 0.02 seconds
2017-12-21 15:55:23,228: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 15:55:23,229: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:55:23,229: On parsely_incoming_sessions: BEGIN
2017-12-21 15:55:23,231: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:55:23,231: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:55:23,231: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 15:55:23,304: SQL status: CREATE VIEW in 0.07 seconds
2017-12-21 15:55:23,304: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:55:23,304: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 15:55:23,308: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 15:55:23,308: On parsely_incoming_sessions: COMMIT
2017-12-21 15:55:23,309: Using redshift connection "parsely_incoming_sessions".
2017-12-21 15:55:23,309: On parsely_incoming_sessions: COMMIT
2017-12-21 15:55:23,537: SQL status: COMMIT in 0.23 seconds
2017-12-21 15:55:23,538: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131576e90>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:55:23,567: 15:55:23 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.34s]
2017-12-21 15:55:23,568: 15:55:23 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2017-12-21 15:55:23,568: Compiling model.parsely.parsely_pageview_behavior_workflow
2017-12-21 15:55:23,577: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 15:55:23,578: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:55:23,578: Re-using an available connection from the pool.
2017-12-21 15:55:23,578: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:55:23,578: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:55:23,600: SQL status: SELECT in 0.02 seconds
2017-12-21 15:55:23,600: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:55:23,600: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:55:23,621: SQL status: SELECT in 0.02 seconds
2017-12-21 15:55:23,622: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:55:23,622: On parsely_pageview_behavior_workflow: BEGIN
2017-12-21 15:55:23,624: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:55:23,624: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:55:23,625: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:56:40,298: SQL status: SELECT in 76.67 seconds
2017-12-21 15:56:40,298: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:56:40,299: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 15:56:40,438: SQL status: SELECT in 0.14 seconds
2017-12-21 15:56:40,438: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:56:40,438: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:56:40,547: SQL status: SELECT in 0.11 seconds
2017-12-21 15:56:40,548: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:56:40,548: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:56:40,656: SQL status: SELECT in 0.11 seconds
2017-12-21 15:56:40,659: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 15:56:40,660: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:56:40,660: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 15:56:43,893: SQL status: INSERT 0 107018 in 3.23 seconds
2017-12-21 15:56:43,893: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 15:56:43,893: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 15:56:43,893: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 15:56:45,516: SQL status: COMMIT in 1.62 seconds
2017-12-21 15:56:45,517: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131519810>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:56:45,610: 15:56:45 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 107018 in 81.95s]
2017-12-21 15:56:45,611: 15:56:45 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2017-12-21 15:56:45,611: Compiling model.parsely.parsely_sessions
2017-12-21 15:56:45,617: Acquiring new redshift connection "parsely_sessions".
2017-12-21 15:56:45,617: Re-using an available connection from the pool.
2017-12-21 15:56:45,617: Using redshift connection "parsely_sessions".
2017-12-21 15:56:45,617: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:56:45,638: SQL status: SELECT in 0.02 seconds
2017-12-21 15:56:45,641: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 15:56:45,643: Using redshift connection "parsely_sessions".
2017-12-21 15:56:45,643: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:56:45,661: SQL status: SELECT in 0.02 seconds
2017-12-21 15:56:45,662: Using redshift connection "parsely_sessions".
2017-12-21 15:56:45,662: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:56:45,681: SQL status: SELECT in 0.02 seconds
2017-12-21 15:56:45,684: Using redshift connection "parsely_sessions".
2017-12-21 15:56:45,685: On parsely_sessions: BEGIN
2017-12-21 15:56:45,686: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:56:45,687: Using redshift connection "parsely_sessions".
2017-12-21 15:56:45,687: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:57:06,201: SQL status: SELECT in 20.51 seconds
2017-12-21 15:57:06,201: Using redshift connection "parsely_sessions".
2017-12-21 15:57:06,201: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2017-12-21 15:57:06,346: SQL status: SELECT in 0.14 seconds
2017-12-21 15:57:06,346: Using redshift connection "parsely_sessions".
2017-12-21 15:57:06,346: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:57:06,458: SQL status: SELECT in 0.11 seconds
2017-12-21 15:57:06,459: Using redshift connection "parsely_sessions".
2017-12-21 15:57:06,459: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:57:06,570: SQL status: SELECT in 0.11 seconds
2017-12-21 15:57:06,572: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 15:57:06,573: Using redshift connection "parsely_sessions".
2017-12-21 15:57:06,573: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2017-12-21 15:57:08,559: SQL status: INSERT 0 86890 in 1.99 seconds
2017-12-21 15:57:08,559: On parsely_sessions: COMMIT
2017-12-21 15:57:08,559: Using redshift connection "parsely_sessions".
2017-12-21 15:57:08,559: On parsely_sessions: COMMIT
2017-12-21 15:57:09,514: SQL status: COMMIT in 0.96 seconds
2017-12-21 15:57:09,515: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa131529410>], 'label': 'a0a0a42e-386e-455e-a590-d03e1f467729'}
2017-12-21 15:57:09,542: 15:57:09 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 86890 in 23.90s]
2017-12-21 15:57:09,644: Using redshift connection "master".
2017-12-21 15:57:09,644: On master: BEGIN
2017-12-21 15:57:09,646: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:57:09,646: On master: COMMIT
2017-12-21 15:57:09,646: Using redshift connection "master".
2017-12-21 15:57:09,646: On master: COMMIT
2017-12-21 15:57:09,648: SQL status: COMMIT in 0.00 seconds
2017-12-21 15:57:09,648: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 15:57:09,653: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 15:57:09,654: Using redshift connection "master".
2017-12-21 15:57:09,654: On master:  select 1 
2017-12-21 15:57:09,656: SQL status: SELECT in 0.00 seconds
2017-12-21 15:57:09,656: 15:57:09 | 
2017-12-21 15:57:09,656: 15:57:09 | Finished running 10 view models, 15 incremental models in 778.64s.
2017-12-21 15:57:09,657: 
2017-12-21 15:57:09,657: Completed successfully
2017-12-21 15:57:09,657: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2017-12-21 15:57:09,658: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315c1e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315c1f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fa1315a8950>], 'label': 'end'}
2017-12-21 15:57:09,688: Flushing usage events
2017-12-21 15:57:16,328: Tracking: tracking
2017-12-21 15:57:16,328: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01ff5e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01ff5f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01ff5ed0>], 'label': 'start'}
2017-12-21 15:57:16,364: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 15:57:16,380: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 15:57:16,381: Parsing core.sql
2017-12-21 15:57:16,392: Parsing etc/get_custom_schema.sql
2017-12-21 15:57:16,397: Parsing schema_tests/relationships.sql
2017-12-21 15:57:16,400: Parsing schema_tests/accepted_values.sql
2017-12-21 15:57:16,403: Parsing schema_tests/not_null.sql
2017-12-21 15:57:16,404: Parsing schema_tests/unique.sql
2017-12-21 15:57:16,406: Parsing materializations/wrapper.sql
2017-12-21 15:57:16,409: Parsing materializations/archive.sql
2017-12-21 15:57:16,436: Parsing materializations/table.sql
2017-12-21 15:57:16,453: Parsing materializations/helpers.sql
2017-12-21 15:57:16,468: Parsing materializations/bigquery.sql
2017-12-21 15:57:16,480: Parsing materializations/view.sql
2017-12-21 15:57:16,494: Parsing materializations/incremental.sql
2017-12-21 15:57:16,518: Parsing adapters/redshift.sql
2017-12-21 15:57:16,534: Parsing adapters/bigquery.sql
2017-12-21 15:57:16,539: Parsing adapters/postgres.sql
2017-12-21 15:57:16,541: Parsing adapters/common.sql
2017-12-21 15:57:16,559: Parsing model.parsely.parsely_audit
2017-12-21 15:57:16,560: Parsing model.parsely.parsely_video_content
2017-12-21 15:57:16,563: Parsing model.parsely.parsely_post_content
2017-12-21 15:57:16,566: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 15:57:16,569: Parsing model.parsely.parsely_rawdata
2017-12-21 15:57:16,572: Parsing model.parsely.calendar
2017-12-21 15:57:16,573: Parsing model.parsely.parsely_all_events
2017-12-21 15:57:16,581: Acquiring new redshift connection "parsely_all_events".
2017-12-21 15:57:16,581: Opening a new connection (0 currently allocated)
2017-12-21 15:57:16,593: Using redshift connection "parsely_all_events".
2017-12-21 15:57:16,593: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:16,619: SQL status: SELECT in 0.03 seconds
2017-12-21 15:57:16,624: Parsing model.parsely.parsely_event_ids
2017-12-21 15:57:16,626: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 15:57:16,629: Parsing model.parsely.parsely_base_events
2017-12-21 15:57:16,632: Acquiring new redshift connection "parsely_base_events".
2017-12-21 15:57:16,632: Re-using an available connection from the pool.
2017-12-21 15:57:16,632: Using redshift connection "parsely_base_events".
2017-12-21 15:57:16,632: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:16,652: SQL status: SELECT in 0.02 seconds
2017-12-21 15:57:16,653: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 15:57:16,659: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 15:57:16,663: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 15:57:16,665: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 15:57:16,667: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 15:57:16,670: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 15:57:16,675: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 15:57:16,682: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 15:57:16,687: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:57:16,687: Re-using an available connection from the pool.
2017-12-21 15:57:16,687: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 15:57:16,687: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:16,706: SQL status: SELECT in 0.02 seconds
2017-12-21 15:57:16,707: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 15:57:16,713: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 15:57:16,718: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:57:16,718: Re-using an available connection from the pool.
2017-12-21 15:57:16,718: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 15:57:16,718: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:16,736: SQL status: SELECT in 0.02 seconds
2017-12-21 15:57:16,737: Parsing model.parsely.parsely_incoming_users
2017-12-21 15:57:16,740: Parsing model.parsely.parsely_users
2017-12-21 15:57:16,745: Acquiring new redshift connection "parsely_users".
2017-12-21 15:57:16,745: Re-using an available connection from the pool.
2017-12-21 15:57:16,745: Using redshift connection "parsely_users".
2017-12-21 15:57:16,745: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:16,762: SQL status: SELECT in 0.02 seconds
2017-12-21 15:57:16,763: Parsing model.parsely.parsely_errors
2017-12-21 15:57:16,767: Parsing model.parsely.parsely_bot_traffic
2017-12-21 15:57:16,771: Parsing model.parsely.parsely_custom_events
2017-12-21 15:57:16,776: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 15:57:16,779: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 15:57:16,782: Parsing model.parsely.parsely_sessions
2017-12-21 15:57:16,787: Acquiring new redshift connection "parsely_sessions".
2017-12-21 15:57:16,787: Re-using an available connection from the pool.
2017-12-21 15:57:16,787: Using redshift connection "parsely_sessions".
2017-12-21 15:57:16,787: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:16,806: SQL status: SELECT in 0.02 seconds
2017-12-21 15:57:16,807: Parsing model.parsely.parsely_campaigns
2017-12-21 15:57:16,810: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 15:57:16,810: Re-using an available connection from the pool.
2017-12-21 15:57:16,810: Using redshift connection "parsely_campaigns".
2017-12-21 15:57:16,811: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:16,828: SQL status: SELECT in 0.02 seconds
2017-12-21 15:57:16,834: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 15:57:16,839: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 15:57:16,846: 
2017-12-21 15:57:16,849: Acquiring new redshift connection "master".
2017-12-21 15:57:16,849: Re-using an available connection from the pool.
2017-12-21 15:57:16,849: Using redshift connection "master".
2017-12-21 15:57:16,849: On master: select distinct nspname from pg_namespace
2017-12-21 15:57:16,851: SQL status: SELECT in 0.00 seconds
2017-12-21 15:57:16,854: Using redshift connection "master".
2017-12-21 15:57:16,854: On master: BEGIN
2017-12-21 15:57:16,855: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:57:16,855: On master: COMMIT
2017-12-21 15:57:16,855: Using redshift connection "master".
2017-12-21 15:57:16,855: On master: COMMIT
2017-12-21 15:57:16,857: SQL status: COMMIT in 0.00 seconds
2017-12-21 15:57:16,862: 15:57:16 | Concurrency: 1 threads (target='dev')
2017-12-21 15:57:16,862: 15:57:16 | 
2017-12-21 15:57:16,862: Using redshift connection "master".
2017-12-21 15:57:16,863: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:16,881: SQL status: SELECT in 0.02 seconds
2017-12-21 15:57:16,952: 15:57:16 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-21 15:57:16,953: Compiling model.parsely.calendar
2017-12-21 15:57:16,957: Writing injected SQL for node "model.parsely.calendar"
2017-12-21 15:57:16,958: Acquiring new redshift connection "calendar".
2017-12-21 15:57:16,958: Opening a new connection (1 currently allocated)
2017-12-21 15:57:16,969: Using redshift connection "calendar".
2017-12-21 15:57:16,969: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:16,993: SQL status: SELECT in 0.02 seconds
2017-12-21 15:57:16,995: Writing runtime SQL for node "model.parsely.calendar"
2017-12-21 15:57:16,996: Using redshift connection "calendar".
2017-12-21 15:57:16,996: On calendar: BEGIN
2017-12-21 15:57:16,997: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:57:16,998: Using redshift connection "calendar".
2017-12-21 15:57:16,998: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-21 15:57:17,480: SQL status: CREATE VIEW in 0.48 seconds
2017-12-21 15:57:17,480: On calendar: COMMIT
2017-12-21 15:57:17,480: Using redshift connection "calendar".
2017-12-21 15:57:17,480: On calendar: COMMIT
2017-12-21 15:57:17,903: SQL status: COMMIT in 0.42 seconds
2017-12-21 15:57:17,904: Using redshift connection "calendar".
2017-12-21 15:57:17,904: On calendar: BEGIN
2017-12-21 15:57:17,906: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:57:17,906: Using redshift connection "calendar".
2017-12-21 15:57:17,906: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-21 15:57:18,211: SQL status: DROP VIEW in 0.31 seconds
2017-12-21 15:57:18,212: On calendar: COMMIT
2017-12-21 15:57:18,212: Using redshift connection "calendar".
2017-12-21 15:57:18,212: On calendar: COMMIT
2017-12-21 15:57:18,670: SQL status: COMMIT in 0.46 seconds
2017-12-21 15:57:18,671: Using redshift connection "calendar".
2017-12-21 15:57:18,671: On calendar: BEGIN
2017-12-21 15:57:18,673: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:57:18,673: Using redshift connection "calendar".
2017-12-21 15:57:18,673: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-21 15:57:18,850: SQL status: ALTER TABLE in 0.18 seconds
2017-12-21 15:57:18,850: On calendar: COMMIT
2017-12-21 15:57:18,850: Using redshift connection "calendar".
2017-12-21 15:57:18,851: On calendar: COMMIT
2017-12-21 15:57:19,220: SQL status: COMMIT in 0.37 seconds
2017-12-21 15:57:19,221: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01ee3c10>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 15:57:19,251: 15:57:19 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 2.27s]
2017-12-21 15:57:19,252: 15:57:19 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-21 15:57:19,252: Compiling model.parsely.parsely_rawdata
2017-12-21 15:57:19,258: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-21 15:57:19,259: Acquiring new redshift connection "parsely_rawdata".
2017-12-21 15:57:19,259: Re-using an available connection from the pool.
2017-12-21 15:57:19,259: Using redshift connection "parsely_rawdata".
2017-12-21 15:57:19,260: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:19,279: SQL status: SELECT in 0.02 seconds
2017-12-21 15:57:19,280: Using redshift connection "parsely_rawdata".
2017-12-21 15:57:19,280: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:57:19,289: SQL status: SELECT in 0.01 seconds
2017-12-21 15:57:19,290: Using redshift connection "parsely_rawdata".
2017-12-21 15:57:19,290: On parsely_rawdata: BEGIN
2017-12-21 15:57:19,292: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:57:19,292: Using redshift connection "parsely_rawdata".
2017-12-21 15:57:19,292: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 15:57:45,784: SQL status: SELECT in 26.49 seconds
2017-12-21 15:57:45,785: Using redshift connection "parsely_rawdata".
2017-12-21 15:57:45,785: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-21 15:57:46,098: SQL status: SELECT in 0.31 seconds
2017-12-21 15:57:46,099: Using redshift connection "parsely_rawdata".
2017-12-21 15:57:46,099: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:57:46,198: SQL status: SELECT in 0.10 seconds
2017-12-21 15:57:46,199: Using redshift connection "parsely_rawdata".
2017-12-21 15:57:46,199: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 15:57:46,298: SQL status: SELECT in 0.10 seconds
2017-12-21 15:57:46,301: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-21 15:57:46,301: Using redshift connection "parsely_rawdata".
2017-12-21 15:57:46,301: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-21 15:58:15,820: SQL status: INSERT 0 1015763 in 29.52 seconds
2017-12-21 15:58:15,820: On parsely_rawdata: COMMIT
2017-12-21 15:58:15,820: Using redshift connection "parsely_rawdata".
2017-12-21 15:58:15,820: On parsely_rawdata: COMMIT
2017-12-21 15:58:17,540: SQL status: COMMIT in 1.72 seconds
2017-12-21 15:58:17,540: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fdc990>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 15:58:17,611: 15:58:17 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1015763 in 58.29s]
2017-12-21 15:58:17,611: 15:58:17 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-21 15:58:17,612: Compiling model.parsely.parsely_all_events
2017-12-21 15:58:17,620: Acquiring new redshift connection "parsely_all_events".
2017-12-21 15:58:17,620: Re-using an available connection from the pool.
2017-12-21 15:58:17,620: Using redshift connection "parsely_all_events".
2017-12-21 15:58:17,620: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:58:17,634: SQL status: SELECT in 0.01 seconds
2017-12-21 15:58:17,642: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-21 15:58:17,643: Using redshift connection "parsely_all_events".
2017-12-21 15:58:17,644: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:58:17,657: SQL status: SELECT in 0.01 seconds
2017-12-21 15:58:17,657: Using redshift connection "parsely_all_events".
2017-12-21 15:58:17,657: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 15:58:17,670: SQL status: SELECT in 0.01 seconds
2017-12-21 15:58:17,672: Using redshift connection "parsely_all_events".
2017-12-21 15:58:17,672: On parsely_all_events: BEGIN
2017-12-21 15:58:17,674: SQL status: BEGIN in 0.00 seconds
2017-12-21 15:58:17,674: Using redshift connection "parsely_all_events".
2017-12-21 15:58:17,674: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:00:15,243: SQL status: SELECT in 117.57 seconds
2017-12-21 16:00:15,244: Using redshift connection "parsely_all_events".
2017-12-21 16:00:15,244: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2017-12-21 16:00:15,483: SQL status: SELECT in 0.24 seconds
2017-12-21 16:00:15,483: Using redshift connection "parsely_all_events".
2017-12-21 16:00:15,484: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:00:15,588: SQL status: SELECT in 0.10 seconds
2017-12-21 16:00:15,590: Using redshift connection "parsely_all_events".
2017-12-21 16:00:15,590: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:00:15,695: SQL status: SELECT in 0.10 seconds
2017-12-21 16:00:15,701: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-21 16:00:15,702: Using redshift connection "parsely_all_events".
2017-12-21 16:00:15,703: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2017-12-21 16:00:32,349: SQL status: INSERT 0 900273 in 16.65 seconds
2017-12-21 16:00:32,350: On parsely_all_events: COMMIT
2017-12-21 16:00:32,350: Using redshift connection "parsely_all_events".
2017-12-21 16:00:32,350: On parsely_all_events: COMMIT
2017-12-21 16:00:34,359: SQL status: COMMIT in 2.01 seconds
2017-12-21 16:00:34,360: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fef290>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:00:34,445: 16:00:34 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 900273 in 136.75s]
2017-12-21 16:00:34,447: 16:00:34 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-21 16:00:34,448: Compiling model.parsely.parsely_bot_traffic
2017-12-21 16:00:34,473: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 16:00:34,475: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-21 16:00:34,475: Re-using an available connection from the pool.
2017-12-21 16:00:34,475: Using redshift connection "parsely_bot_traffic".
2017-12-21 16:00:34,475: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:00:34,490: SQL status: SELECT in 0.01 seconds
2017-12-21 16:00:34,491: Using redshift connection "parsely_bot_traffic".
2017-12-21 16:00:34,491: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:00:34,505: SQL status: SELECT in 0.01 seconds
2017-12-21 16:00:34,507: Using redshift connection "parsely_bot_traffic".
2017-12-21 16:00:34,508: On parsely_bot_traffic: BEGIN
2017-12-21 16:00:34,509: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:00:34,510: Using redshift connection "parsely_bot_traffic".
2017-12-21 16:00:34,510: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:01:08,488: SQL status: SELECT in 33.98 seconds
2017-12-21 16:01:08,489: Using redshift connection "parsely_bot_traffic".
2017-12-21 16:01:08,489: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2017-12-21 16:01:08,646: SQL status: SELECT in 0.16 seconds
2017-12-21 16:01:08,647: Using redshift connection "parsely_bot_traffic".
2017-12-21 16:01:08,647: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:01:08,757: SQL status: SELECT in 0.11 seconds
2017-12-21 16:01:08,758: Using redshift connection "parsely_bot_traffic".
2017-12-21 16:01:08,759: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:01:08,870: SQL status: SELECT in 0.11 seconds
2017-12-21 16:01:08,876: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 16:01:08,878: Using redshift connection "parsely_bot_traffic".
2017-12-21 16:01:08,878: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2017-12-21 16:01:10,107: SQL status: INSERT 0 4 in 1.23 seconds
2017-12-21 16:01:10,108: On parsely_bot_traffic: COMMIT
2017-12-21 16:01:10,108: Using redshift connection "parsely_bot_traffic".
2017-12-21 16:01:10,108: On parsely_bot_traffic: COMMIT
2017-12-21 16:01:11,180: SQL status: COMMIT in 1.07 seconds
2017-12-21 16:01:11,181: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fdc990>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:01:11,241: 16:01:11 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 36.73s]
2017-12-21 16:01:11,241: 16:01:11 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-21 16:01:11,241: Compiling model.parsely.parsely_custom_events
2017-12-21 16:01:11,270: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-21 16:01:11,272: Acquiring new redshift connection "parsely_custom_events".
2017-12-21 16:01:11,273: Re-using an available connection from the pool.
2017-12-21 16:01:11,273: Using redshift connection "parsely_custom_events".
2017-12-21 16:01:11,273: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:01:11,288: SQL status: SELECT in 0.01 seconds
2017-12-21 16:01:11,288: Using redshift connection "parsely_custom_events".
2017-12-21 16:01:11,289: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:01:11,302: SQL status: SELECT in 0.01 seconds
2017-12-21 16:01:11,306: Using redshift connection "parsely_custom_events".
2017-12-21 16:01:11,308: On parsely_custom_events: BEGIN
2017-12-21 16:01:11,310: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:01:11,310: Using redshift connection "parsely_custom_events".
2017-12-21 16:01:11,310: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:01:46,601: SQL status: SELECT in 35.29 seconds
2017-12-21 16:01:46,601: Using redshift connection "parsely_custom_events".
2017-12-21 16:01:46,601: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2017-12-21 16:01:46,755: SQL status: SELECT in 0.15 seconds
2017-12-21 16:01:46,756: Using redshift connection "parsely_custom_events".
2017-12-21 16:01:46,756: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:01:46,868: SQL status: SELECT in 0.11 seconds
2017-12-21 16:01:46,869: Using redshift connection "parsely_custom_events".
2017-12-21 16:01:46,869: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:01:46,973: SQL status: SELECT in 0.10 seconds
2017-12-21 16:01:46,979: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-21 16:01:46,980: Using redshift connection "parsely_custom_events".
2017-12-21 16:01:46,981: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2017-12-21 16:01:47,248: SQL status: INSERT 0 0 in 0.27 seconds
2017-12-21 16:01:47,249: On parsely_custom_events: COMMIT
2017-12-21 16:01:47,249: Using redshift connection "parsely_custom_events".
2017-12-21 16:01:47,249: On parsely_custom_events: COMMIT
2017-12-21 16:01:47,599: SQL status: COMMIT in 0.35 seconds
2017-12-21 16:01:47,600: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01faa5d0>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:01:47,682: 16:01:47 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 36.36s]
2017-12-21 16:01:47,683: 16:01:47 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-21 16:01:47,688: Compiling model.parsely.parsely_errors
2017-12-21 16:01:47,700: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-21 16:01:47,702: Acquiring new redshift connection "parsely_errors".
2017-12-21 16:01:47,702: Re-using an available connection from the pool.
2017-12-21 16:01:47,702: Using redshift connection "parsely_errors".
2017-12-21 16:01:47,703: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:01:47,718: SQL status: SELECT in 0.02 seconds
2017-12-21 16:01:47,719: Using redshift connection "parsely_errors".
2017-12-21 16:01:47,719: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:01:47,733: SQL status: SELECT in 0.01 seconds
2017-12-21 16:01:47,736: Using redshift connection "parsely_errors".
2017-12-21 16:01:47,736: On parsely_errors: BEGIN
2017-12-21 16:01:47,738: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:01:47,738: Using redshift connection "parsely_errors".
2017-12-21 16:01:47,738: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:02:22,154: SQL status: SELECT in 34.42 seconds
2017-12-21 16:02:22,155: Using redshift connection "parsely_errors".
2017-12-21 16:02:22,155: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2017-12-21 16:02:22,331: SQL status: SELECT in 0.18 seconds
2017-12-21 16:02:22,333: Using redshift connection "parsely_errors".
2017-12-21 16:02:22,333: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:02:22,448: SQL status: SELECT in 0.12 seconds
2017-12-21 16:02:22,450: Using redshift connection "parsely_errors".
2017-12-21 16:02:22,450: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:02:22,564: SQL status: SELECT in 0.11 seconds
2017-12-21 16:02:22,572: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-21 16:02:22,580: Using redshift connection "parsely_errors".
2017-12-21 16:02:22,580: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2017-12-21 16:02:23,242: SQL status: INSERT 0 2 in 0.66 seconds
2017-12-21 16:02:23,243: On parsely_errors: COMMIT
2017-12-21 16:02:23,243: Using redshift connection "parsely_errors".
2017-12-21 16:02:23,243: On parsely_errors: COMMIT
2017-12-21 16:02:23,841: SQL status: COMMIT in 0.60 seconds
2017-12-21 16:02:23,842: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01faa5d0>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:02:23,890: 16:02:23 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 36.15s]
2017-12-21 16:02:23,896: 16:02:23 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-21 16:02:23,896: Compiling model.parsely.parsely_base_events
2017-12-21 16:02:23,903: Acquiring new redshift connection "parsely_base_events".
2017-12-21 16:02:23,903: Re-using an available connection from the pool.
2017-12-21 16:02:23,903: Using redshift connection "parsely_base_events".
2017-12-21 16:02:23,903: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:23,924: SQL status: SELECT in 0.02 seconds
2017-12-21 16:02:23,931: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-21 16:02:23,938: Using redshift connection "parsely_base_events".
2017-12-21 16:02:23,938: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:23,953: SQL status: SELECT in 0.01 seconds
2017-12-21 16:02:23,955: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-21 16:02:23,956: Using redshift connection "parsely_base_events".
2017-12-21 16:02:23,956: On parsely_base_events: BEGIN
2017-12-21 16:02:23,958: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:02:23,958: Using redshift connection "parsely_base_events".
2017-12-21 16:02:23,959: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-21 16:02:25,548: SQL status: CREATE VIEW in 1.59 seconds
2017-12-21 16:02:25,549: On parsely_base_events: COMMIT
2017-12-21 16:02:25,549: Using redshift connection "parsely_base_events".
2017-12-21 16:02:25,549: On parsely_base_events: COMMIT
2017-12-21 16:02:26,241: SQL status: COMMIT in 0.69 seconds
2017-12-21 16:02:26,242: Using redshift connection "parsely_base_events".
2017-12-21 16:02:26,242: On parsely_base_events: BEGIN
2017-12-21 16:02:26,244: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:02:26,244: Using redshift connection "parsely_base_events".
2017-12-21 16:02:26,244: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2017-12-21 16:02:28,448: SQL status: DROP VIEW in 2.20 seconds
2017-12-21 16:02:28,449: On parsely_base_events: COMMIT
2017-12-21 16:02:28,449: Using redshift connection "parsely_base_events".
2017-12-21 16:02:28,449: On parsely_base_events: COMMIT
2017-12-21 16:02:28,648: SQL status: COMMIT in 0.20 seconds
2017-12-21 16:02:28,648: Using redshift connection "parsely_base_events".
2017-12-21 16:02:28,649: On parsely_base_events: BEGIN
2017-12-21 16:02:28,651: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:02:28,651: Using redshift connection "parsely_base_events".
2017-12-21 16:02:28,651: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-21 16:02:28,656: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 16:02:28,656: On parsely_base_events: COMMIT
2017-12-21 16:02:28,657: Using redshift connection "parsely_base_events".
2017-12-21 16:02:28,657: On parsely_base_events: COMMIT
2017-12-21 16:02:28,849: SQL status: COMMIT in 0.19 seconds
2017-12-21 16:02:28,849: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fef290>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:02:28,896: 16:02:28 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 4.95s]
2017-12-21 16:02:28,896: 16:02:28 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2017-12-21 16:02:28,904: Compiling model.parsely.parsely_event_ids
2017-12-21 16:02:28,912: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-21 16:02:28,915: Acquiring new redshift connection "parsely_event_ids".
2017-12-21 16:02:28,915: Re-using an available connection from the pool.
2017-12-21 16:02:28,915: Using redshift connection "parsely_event_ids".
2017-12-21 16:02:28,915: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:28,931: SQL status: SELECT in 0.02 seconds
2017-12-21 16:02:28,932: Using redshift connection "parsely_event_ids".
2017-12-21 16:02:28,932: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:28,947: SQL status: SELECT in 0.02 seconds
2017-12-21 16:02:28,949: Using redshift connection "parsely_event_ids".
2017-12-21 16:02:28,949: On parsely_event_ids: BEGIN
2017-12-21 16:02:28,951: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:02:28,951: Using redshift connection "parsely_event_ids".
2017-12-21 16:02:28,951: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:02:29,983: SQL status: SELECT in 1.03 seconds
2017-12-21 16:02:29,983: Using redshift connection "parsely_event_ids".
2017-12-21 16:02:29,983: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2017-12-21 16:02:30,130: SQL status: SELECT in 0.15 seconds
2017-12-21 16:02:30,130: Using redshift connection "parsely_event_ids".
2017-12-21 16:02:30,131: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:02:30,238: SQL status: SELECT in 0.11 seconds
2017-12-21 16:02:30,239: Using redshift connection "parsely_event_ids".
2017-12-21 16:02:30,239: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:02:30,352: SQL status: SELECT in 0.11 seconds
2017-12-21 16:02:30,353: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-21 16:02:30,354: Using redshift connection "parsely_event_ids".
2017-12-21 16:02:30,355: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2017-12-21 16:02:31,428: SQL status: INSERT 0 900269 in 1.07 seconds
2017-12-21 16:02:31,429: On parsely_event_ids: COMMIT
2017-12-21 16:02:31,429: Using redshift connection "parsely_event_ids".
2017-12-21 16:02:31,429: On parsely_event_ids: COMMIT
2017-12-21 16:02:32,048: SQL status: COMMIT in 0.62 seconds
2017-12-21 16:02:32,049: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01f05c90>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:02:32,097: 16:02:32 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 900269 in 3.14s]
2017-12-21 16:02:32,104: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-21 16:02:32,125: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-21 16:02:32,126: 16:02:32 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-21 16:02:32,126: Compiling model.parsely.parsely_post_content
2017-12-21 16:02:32,144: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-21 16:02:32,145: Acquiring new redshift connection "parsely_post_content".
2017-12-21 16:02:32,145: Re-using an available connection from the pool.
2017-12-21 16:02:32,146: Using redshift connection "parsely_post_content".
2017-12-21 16:02:32,146: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:32,161: SQL status: SELECT in 0.01 seconds
2017-12-21 16:02:32,161: Using redshift connection "parsely_post_content".
2017-12-21 16:02:32,161: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:32,175: SQL status: SELECT in 0.01 seconds
2017-12-21 16:02:32,177: Using redshift connection "parsely_post_content".
2017-12-21 16:02:32,177: On parsely_post_content: BEGIN
2017-12-21 16:02:32,179: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:02:32,179: Using redshift connection "parsely_post_content".
2017-12-21 16:02:32,179: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:02:39,885: SQL status: SELECT in 7.71 seconds
2017-12-21 16:02:39,886: Using redshift connection "parsely_post_content".
2017-12-21 16:02:39,886: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2017-12-21 16:02:40,231: SQL status: SELECT in 0.34 seconds
2017-12-21 16:02:40,231: Using redshift connection "parsely_post_content".
2017-12-21 16:02:40,231: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:02:40,345: SQL status: SELECT in 0.11 seconds
2017-12-21 16:02:40,346: Using redshift connection "parsely_post_content".
2017-12-21 16:02:40,346: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:02:40,450: SQL status: SELECT in 0.10 seconds
2017-12-21 16:02:40,453: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-21 16:02:40,454: Using redshift connection "parsely_post_content".
2017-12-21 16:02:40,454: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2017-12-21 16:02:40,844: SQL status: INSERT 0 881 in 0.39 seconds
2017-12-21 16:02:40,844: On parsely_post_content: COMMIT
2017-12-21 16:02:40,845: Using redshift connection "parsely_post_content".
2017-12-21 16:02:40,845: On parsely_post_content: COMMIT
2017-12-21 16:02:41,285: SQL status: COMMIT in 0.44 seconds
2017-12-21 16:02:41,286: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01ed5090>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:02:41,337: 16:02:41 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 881 in 9.16s]
2017-12-21 16:02:41,337: 16:02:41 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2017-12-21 16:02:41,341: Compiling model.parsely.parsely_video_content
2017-12-21 16:02:41,361: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-21 16:02:41,363: Acquiring new redshift connection "parsely_video_content".
2017-12-21 16:02:41,363: Re-using an available connection from the pool.
2017-12-21 16:02:41,363: Using redshift connection "parsely_video_content".
2017-12-21 16:02:41,363: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:41,378: SQL status: SELECT in 0.01 seconds
2017-12-21 16:02:41,379: Using redshift connection "parsely_video_content".
2017-12-21 16:02:41,379: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:41,393: SQL status: SELECT in 0.01 seconds
2017-12-21 16:02:41,394: Using redshift connection "parsely_video_content".
2017-12-21 16:02:41,395: On parsely_video_content: BEGIN
2017-12-21 16:02:41,396: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:02:41,397: Using redshift connection "parsely_video_content".
2017-12-21 16:02:41,397: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:02:47,969: SQL status: SELECT in 6.57 seconds
2017-12-21 16:02:47,970: Using redshift connection "parsely_video_content".
2017-12-21 16:02:47,970: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2017-12-21 16:02:48,550: SQL status: SELECT in 0.58 seconds
2017-12-21 16:02:48,551: Using redshift connection "parsely_video_content".
2017-12-21 16:02:48,551: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:02:48,663: SQL status: SELECT in 0.11 seconds
2017-12-21 16:02:48,663: Using redshift connection "parsely_video_content".
2017-12-21 16:02:48,663: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:02:48,769: SQL status: SELECT in 0.11 seconds
2017-12-21 16:02:48,771: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-21 16:02:48,772: Using redshift connection "parsely_video_content".
2017-12-21 16:02:48,772: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2017-12-21 16:02:49,132: SQL status: INSERT 0 468 in 0.36 seconds
2017-12-21 16:02:49,133: On parsely_video_content: COMMIT
2017-12-21 16:02:49,133: Using redshift connection "parsely_video_content".
2017-12-21 16:02:49,133: On parsely_video_content: COMMIT
2017-12-21 16:02:49,656: SQL status: COMMIT in 0.52 seconds
2017-12-21 16:02:49,657: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01f4d850>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:02:49,721: 16:02:49 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 468 in 8.32s]
2017-12-21 16:02:49,721: 16:02:49 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-21 16:02:49,728: Compiling model.parsely.parsely_entry_exit_urls
2017-12-21 16:02:49,745: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 16:02:49,746: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-21 16:02:49,746: Re-using an available connection from the pool.
2017-12-21 16:02:49,746: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 16:02:49,747: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:49,762: SQL status: SELECT in 0.02 seconds
2017-12-21 16:02:49,765: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 16:02:49,766: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 16:02:49,767: On parsely_entry_exit_urls: BEGIN
2017-12-21 16:02:49,772: SQL status: BEGIN in 0.01 seconds
2017-12-21 16:02:49,772: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 16:02:49,772: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-21 16:02:50,770: SQL status: CREATE VIEW in 1.00 seconds
2017-12-21 16:02:50,771: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 16:02:50,771: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2017-12-21 16:02:50,773: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 16:02:50,774: On parsely_entry_exit_urls: COMMIT
2017-12-21 16:02:50,774: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 16:02:50,774: On parsely_entry_exit_urls: COMMIT
2017-12-21 16:02:51,181: SQL status: COMMIT in 0.41 seconds
2017-12-21 16:02:51,182: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01f4d850>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:02:51,232: 16:02:51 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 1.45s]
2017-12-21 16:02:51,232: 16:02:51 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-21 16:02:51,240: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 16:02:51,257: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 16:02:51,259: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 16:02:51,259: Re-using an available connection from the pool.
2017-12-21 16:02:51,259: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 16:02:51,259: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:51,275: SQL status: SELECT in 0.02 seconds
2017-12-21 16:02:51,288: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 16:02:51,290: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 16:02:51,290: On parsely_incoming_videoviews: BEGIN
2017-12-21 16:02:51,292: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:02:51,292: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 16:02:51,292: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 16:02:51,524: SQL status: CREATE VIEW in 0.23 seconds
2017-12-21 16:02:51,525: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 16:02:51,525: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 16:02:51,529: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 16:02:51,530: On parsely_incoming_videoviews: COMMIT
2017-12-21 16:02:51,530: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 16:02:51,530: On parsely_incoming_videoviews: COMMIT
2017-12-21 16:02:51,909: SQL status: COMMIT in 0.38 seconds
2017-12-21 16:02:51,909: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01f4d850>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:02:51,961: 16:02:51 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.67s]
2017-12-21 16:02:51,963: 16:02:51 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 16:02:51,963: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 16:02:51,983: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:02:51,984: Re-using an available connection from the pool.
2017-12-21 16:02:51,984: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:02:51,984: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:51,999: SQL status: SELECT in 0.02 seconds
2017-12-21 16:02:52,013: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 16:02:52,015: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:02:52,015: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:52,030: SQL status: SELECT in 0.01 seconds
2017-12-21 16:02:52,031: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:02:52,031: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:02:52,046: SQL status: SELECT in 0.01 seconds
2017-12-21 16:02:52,049: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:02:52,049: On parsely_videoviews_sessionized: BEGIN
2017-12-21 16:02:52,056: SQL status: BEGIN in 0.01 seconds
2017-12-21 16:02:52,056: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:02:52,056: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:03:35,019: SQL status: SELECT in 42.96 seconds
2017-12-21 16:03:35,019: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:03:35,019: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2017-12-21 16:03:35,153: SQL status: SELECT in 0.13 seconds
2017-12-21 16:03:35,155: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:03:35,155: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:03:35,252: SQL status: SELECT in 0.10 seconds
2017-12-21 16:03:35,254: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:03:35,254: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:03:35,351: SQL status: SELECT in 0.10 seconds
2017-12-21 16:03:35,373: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 16:03:35,374: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:03:35,374: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 16:03:36,453: SQL status: INSERT 0 142 in 1.08 seconds
2017-12-21 16:03:36,454: On parsely_videoviews_sessionized: COMMIT
2017-12-21 16:03:36,454: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 16:03:36,454: On parsely_videoviews_sessionized: COMMIT
2017-12-21 16:03:37,684: SQL status: COMMIT in 1.23 seconds
2017-12-21 16:03:37,685: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01faa790>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:03:37,733: 16:03:37 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 142 in 45.72s]
2017-12-21 16:03:37,734: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-21 16:03:37,807: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-21 16:03:37,820: 16:03:37 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-21 16:03:37,820: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 16:03:37,865: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 16:03:37,866: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 16:03:37,866: Re-using an available connection from the pool.
2017-12-21 16:03:37,867: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 16:03:37,867: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:03:37,878: SQL status: SELECT in 0.01 seconds
2017-12-21 16:03:37,881: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 16:03:37,882: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 16:03:37,882: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-21 16:03:37,884: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:03:37,884: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 16:03:37,884: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-21 16:03:38,196: SQL status: CREATE VIEW in 0.31 seconds
2017-12-21 16:03:38,197: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 16:03:38,197: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-21 16:03:38,200: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 16:03:38,201: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 16:03:38,201: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 16:03:38,201: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 16:03:38,568: SQL status: COMMIT in 0.37 seconds
2017-12-21 16:03:38,568: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01ee3650>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:03:38,617: 16:03:38 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.75s]
2017-12-21 16:03:38,617: 16:03:38 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-21 16:03:38,618: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 16:03:38,737: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 16:03:38,739: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 16:03:38,739: Re-using an available connection from the pool.
2017-12-21 16:03:38,739: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 16:03:38,740: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:03:38,753: SQL status: SELECT in 0.01 seconds
2017-12-21 16:03:38,758: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 16:03:38,759: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 16:03:38,759: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-21 16:03:38,764: SQL status: BEGIN in 0.01 seconds
2017-12-21 16:03:38,764: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 16:03:38,764: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-21 16:03:38,908: SQL status: CREATE VIEW in 0.14 seconds
2017-12-21 16:03:38,909: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 16:03:38,909: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-21 16:03:38,914: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 16:03:38,915: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 16:03:38,915: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 16:03:38,915: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 16:03:39,328: SQL status: COMMIT in 0.41 seconds
2017-12-21 16:03:39,328: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fdc990>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:03:39,378: 16:03:39 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.71s]
2017-12-21 16:03:39,378: 16:03:39 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2017-12-21 16:03:39,384: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 16:03:39,427: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 16:03:39,430: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 16:03:39,430: Re-using an available connection from the pool.
2017-12-21 16:03:39,430: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 16:03:39,430: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:03:39,443: SQL status: SELECT in 0.01 seconds
2017-12-21 16:03:39,453: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 16:03:39,454: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 16:03:39,455: On parsely_incoming_pageviews: BEGIN
2017-12-21 16:03:39,464: SQL status: BEGIN in 0.01 seconds
2017-12-21 16:03:39,464: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 16:03:39,464: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 16:03:40,638: SQL status: CREATE VIEW in 1.17 seconds
2017-12-21 16:03:40,638: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 16:03:40,639: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2017-12-21 16:03:40,643: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 16:03:40,643: On parsely_incoming_pageviews: COMMIT
2017-12-21 16:03:40,644: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 16:03:40,644: On parsely_incoming_pageviews: COMMIT
2017-12-21 16:03:40,843: SQL status: COMMIT in 0.20 seconds
2017-12-21 16:03:40,844: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fdc990>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:03:40,895: 16:03:40 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.46s]
2017-12-21 16:03:40,896: 16:03:40 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2017-12-21 16:03:40,896: Compiling model.parsely.parsely_pageviews_sessionized
2017-12-21 16:03:40,905: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:03:40,905: Re-using an available connection from the pool.
2017-12-21 16:03:40,905: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:03:40,906: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:03:40,919: SQL status: SELECT in 0.01 seconds
2017-12-21 16:03:40,925: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 16:03:40,927: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:03:40,927: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:03:40,940: SQL status: SELECT in 0.01 seconds
2017-12-21 16:03:40,940: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:03:40,941: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:03:40,953: SQL status: SELECT in 0.01 seconds
2017-12-21 16:03:40,956: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:03:40,956: On parsely_pageviews_sessionized: BEGIN
2017-12-21 16:03:40,958: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:03:40,958: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:03:40,958: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:06:26,674: SQL status: SELECT in 165.72 seconds
2017-12-21 16:06:26,674: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:06:26,674: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2017-12-21 16:06:26,830: SQL status: SELECT in 0.16 seconds
2017-12-21 16:06:26,831: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:06:26,831: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:06:26,943: SQL status: SELECT in 0.11 seconds
2017-12-21 16:06:26,945: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:06:26,945: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:06:27,057: SQL status: SELECT in 0.11 seconds
2017-12-21 16:06:27,063: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 16:06:27,072: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:06:27,072: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 16:06:29,983: SQL status: INSERT 0 107291 in 2.91 seconds
2017-12-21 16:06:29,984: On parsely_pageviews_sessionized: COMMIT
2017-12-21 16:06:29,984: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 16:06:29,984: On parsely_pageviews_sessionized: COMMIT
2017-12-21 16:06:31,511: SQL status: COMMIT in 1.53 seconds
2017-12-21 16:06:31,512: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01faa6d0>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:06:31,618: 16:06:31 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 107291 in 170.62s]
2017-12-21 16:06:31,624: 16:06:31 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-21 16:06:31,625: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-21 16:06:31,829: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 16:06:31,832: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-21 16:06:31,832: Re-using an available connection from the pool.
2017-12-21 16:06:31,840: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 16:06:31,840: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:06:31,864: SQL status: SELECT in 0.02 seconds
2017-12-21 16:06:31,869: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 16:06:31,870: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 16:06:31,870: On parsely_videoview_engagedtime: BEGIN
2017-12-21 16:06:31,876: SQL status: BEGIN in 0.01 seconds
2017-12-21 16:06:31,876: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 16:06:31,876: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-21 16:06:32,629: SQL status: CREATE VIEW in 0.75 seconds
2017-12-21 16:06:32,630: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 16:06:32,630: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-21 16:06:32,634: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 16:06:32,635: On parsely_videoview_engagedtime: COMMIT
2017-12-21 16:06:32,635: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 16:06:32,635: On parsely_videoview_engagedtime: COMMIT
2017-12-21 16:06:32,919: SQL status: COMMIT in 0.28 seconds
2017-12-21 16:06:32,920: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01faa6d0>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:06:32,973: 16:06:32 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.30s]
2017-12-21 16:06:32,980: 16:06:32 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-21 16:06:32,980: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-21 16:06:33,006: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 16:06:33,008: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 16:06:33,023: Re-using an available connection from the pool.
2017-12-21 16:06:33,024: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 16:06:33,024: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:06:33,044: SQL status: SELECT in 0.02 seconds
2017-12-21 16:06:33,045: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 16:06:33,045: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:06:33,065: SQL status: SELECT in 0.02 seconds
2017-12-21 16:06:33,068: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 16:06:33,068: On parsely_videoview_behavior_workflow: BEGIN
2017-12-21 16:06:33,076: SQL status: BEGIN in 0.01 seconds
2017-12-21 16:06:33,076: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 16:06:33,076: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:08:23,867: SQL status: SELECT in 110.79 seconds
2017-12-21 16:08:23,868: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 16:08:23,868: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 16:08:24,055: SQL status: SELECT in 0.19 seconds
2017-12-21 16:08:24,055: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 16:08:24,056: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:08:24,167: SQL status: SELECT in 0.11 seconds
2017-12-21 16:08:24,169: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 16:08:24,169: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:08:24,289: SQL status: SELECT in 0.12 seconds
2017-12-21 16:08:24,296: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 16:08:24,305: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 16:08:24,305: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 16:08:25,349: SQL status: INSERT 0 141 in 1.04 seconds
2017-12-21 16:08:25,350: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 16:08:25,350: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 16:08:25,350: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 16:08:26,611: SQL status: COMMIT in 1.26 seconds
2017-12-21 16:08:26,611: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fdc990>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:08:26,662: 16:08:26 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 141 in 113.63s]
2017-12-21 16:08:26,663: 16:08:26 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2017-12-21 16:08:26,663: Compiling model.parsely.parsely_campaigns
2017-12-21 16:08:26,672: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 16:08:26,673: Re-using an available connection from the pool.
2017-12-21 16:08:26,673: Using redshift connection "parsely_campaigns".
2017-12-21 16:08:26,673: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:08:26,695: SQL status: SELECT in 0.02 seconds
2017-12-21 16:08:26,709: Writing injected SQL for node "model.parsely.parsely_campaigns"
2017-12-21 16:08:26,711: Using redshift connection "parsely_campaigns".
2017-12-21 16:08:26,711: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:08:26,732: SQL status: SELECT in 0.02 seconds
2017-12-21 16:08:26,733: Using redshift connection "parsely_campaigns".
2017-12-21 16:08:26,733: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:08:26,754: SQL status: SELECT in 0.02 seconds
2017-12-21 16:08:26,756: Using redshift connection "parsely_campaigns".
2017-12-21 16:08:26,756: On parsely_campaigns: BEGIN
2017-12-21 16:08:26,758: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:08:26,758: Using redshift connection "parsely_campaigns".
2017-12-21 16:08:26,758: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:08:28,189: SQL status: SELECT in 1.43 seconds
2017-12-21 16:08:28,189: Using redshift connection "parsely_campaigns".
2017-12-21 16:08:28,190: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2017-12-21 16:08:28,508: SQL status: SELECT in 0.32 seconds
2017-12-21 16:08:28,508: Using redshift connection "parsely_campaigns".
2017-12-21 16:08:28,509: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:08:28,616: SQL status: SELECT in 0.11 seconds
2017-12-21 16:08:28,616: Using redshift connection "parsely_campaigns".
2017-12-21 16:08:28,616: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:08:28,725: SQL status: SELECT in 0.11 seconds
2017-12-21 16:08:28,727: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2017-12-21 16:08:28,729: Using redshift connection "parsely_campaigns".
2017-12-21 16:08:28,729: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2017-12-21 16:08:28,874: SQL status: INSERT 0 382 in 0.14 seconds
2017-12-21 16:08:28,874: On parsely_campaigns: COMMIT
2017-12-21 16:08:28,874: Using redshift connection "parsely_campaigns".
2017-12-21 16:08:28,875: On parsely_campaigns: COMMIT
2017-12-21 16:08:29,327: SQL status: COMMIT in 0.45 seconds
2017-12-21 16:08:29,328: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fdce90>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:08:29,390: 16:08:29 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 382 in 2.66s]
2017-12-21 16:08:29,390: Compiling model.parsely.parsely_incoming_users
2017-12-21 16:08:29,410: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 16:08:29,416: 16:08:29 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2017-12-21 16:08:29,416: Compiling model.parsely.parsely_users
2017-12-21 16:08:29,426: Acquiring new redshift connection "parsely_users".
2017-12-21 16:08:29,426: Re-using an available connection from the pool.
2017-12-21 16:08:29,426: Using redshift connection "parsely_users".
2017-12-21 16:08:29,426: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:08:29,448: SQL status: SELECT in 0.02 seconds
2017-12-21 16:08:29,542: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 16:08:29,556: Using redshift connection "parsely_users".
2017-12-21 16:08:29,556: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:08:29,578: SQL status: SELECT in 0.02 seconds
2017-12-21 16:08:29,579: Using redshift connection "parsely_users".
2017-12-21 16:08:29,579: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:08:29,600: SQL status: SELECT in 0.02 seconds
2017-12-21 16:08:29,604: Using redshift connection "parsely_users".
2017-12-21 16:08:29,604: On parsely_users: BEGIN
2017-12-21 16:08:29,607: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:08:29,607: Using redshift connection "parsely_users".
2017-12-21 16:08:29,607: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3,4
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3,4
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      visitor_ip,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3,4
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id, visitor_ip)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3,4


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    visitor_ip,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:08:32,296: SQL status: SELECT in 2.69 seconds
2017-12-21 16:08:32,297: Using redshift connection "parsely_users".
2017-12-21 16:08:32,297: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2017-12-21 16:08:32,508: SQL status: SELECT in 0.21 seconds
2017-12-21 16:08:32,509: Using redshift connection "parsely_users".
2017-12-21 16:08:32,509: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:08:32,617: SQL status: SELECT in 0.11 seconds
2017-12-21 16:08:32,617: Using redshift connection "parsely_users".
2017-12-21 16:08:32,618: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:08:32,724: SQL status: SELECT in 0.11 seconds
2017-12-21 16:08:32,727: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 16:08:32,728: Using redshift connection "parsely_users".
2017-12-21 16:08:32,728: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2017-12-21 16:08:33,027: SQL status: INSERT 0 59430 in 0.30 seconds
2017-12-21 16:08:33,028: On parsely_users: COMMIT
2017-12-21 16:08:33,028: Using redshift connection "parsely_users".
2017-12-21 16:08:33,028: On parsely_users: COMMIT
2017-12-21 16:08:33,858: SQL status: COMMIT in 0.83 seconds
2017-12-21 16:08:33,859: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01f05450>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:08:33,915: 16:08:33 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 59430 in 4.44s]
2017-12-21 16:08:33,916: 16:08:33 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2017-12-21 16:08:33,916: Compiling model.parsely.parsely_pageview_engagedtime
2017-12-21 16:08:34,028: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 16:08:34,031: Acquiring new redshift connection "parsely_pageview_engagedtime".
2017-12-21 16:08:34,031: Re-using an available connection from the pool.
2017-12-21 16:08:34,031: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 16:08:34,031: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:08:34,052: SQL status: SELECT in 0.02 seconds
2017-12-21 16:08:34,056: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 16:08:34,057: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 16:08:34,057: On parsely_pageview_engagedtime: BEGIN
2017-12-21 16:08:34,068: SQL status: BEGIN in 0.01 seconds
2017-12-21 16:08:34,068: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 16:08:34,068: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2017-12-21 16:08:34,415: SQL status: CREATE VIEW in 0.35 seconds
2017-12-21 16:08:34,416: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 16:08:34,416: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2017-12-21 16:08:34,421: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 16:08:34,421: On parsely_pageview_engagedtime: COMMIT
2017-12-21 16:08:34,421: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 16:08:34,421: On parsely_pageview_engagedtime: COMMIT
2017-12-21 16:08:34,584: SQL status: COMMIT in 0.16 seconds
2017-12-21 16:08:34,585: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01faa710>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:08:34,620: 16:08:34 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.67s]
2017-12-21 16:08:34,620: 16:08:34 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2017-12-21 16:08:34,621: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 16:08:34,632: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 16:08:34,634: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 16:08:34,634: Re-using an available connection from the pool.
2017-12-21 16:08:34,634: Using redshift connection "parsely_incoming_sessions".
2017-12-21 16:08:34,634: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:08:34,656: SQL status: SELECT in 0.02 seconds
2017-12-21 16:08:34,660: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 16:08:34,661: Using redshift connection "parsely_incoming_sessions".
2017-12-21 16:08:34,661: On parsely_incoming_sessions: BEGIN
2017-12-21 16:08:34,663: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:08:34,663: Using redshift connection "parsely_incoming_sessions".
2017-12-21 16:08:34,663: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 16:08:34,726: SQL status: CREATE VIEW in 0.06 seconds
2017-12-21 16:08:34,727: Using redshift connection "parsely_incoming_sessions".
2017-12-21 16:08:34,727: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 16:08:34,732: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 16:08:34,732: On parsely_incoming_sessions: COMMIT
2017-12-21 16:08:34,732: Using redshift connection "parsely_incoming_sessions".
2017-12-21 16:08:34,732: On parsely_incoming_sessions: COMMIT
2017-12-21 16:08:34,920: SQL status: COMMIT in 0.19 seconds
2017-12-21 16:08:34,921: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fdce90>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:08:34,975: 16:08:34 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.30s]
2017-12-21 16:08:34,975: 16:08:34 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2017-12-21 16:08:34,984: Compiling model.parsely.parsely_pageview_behavior_workflow
2017-12-21 16:08:35,019: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 16:08:35,033: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 16:08:35,033: Re-using an available connection from the pool.
2017-12-21 16:08:35,033: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 16:08:35,033: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:08:35,055: SQL status: SELECT in 0.02 seconds
2017-12-21 16:08:35,056: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 16:08:35,056: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:08:35,077: SQL status: SELECT in 0.02 seconds
2017-12-21 16:08:35,080: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 16:08:35,080: On parsely_pageview_behavior_workflow: BEGIN
2017-12-21 16:08:35,082: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:08:35,082: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 16:08:35,083: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:10:01,233: SQL status: SELECT in 86.15 seconds
2017-12-21 16:10:01,233: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 16:10:01,234: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 16:10:01,394: SQL status: SELECT in 0.16 seconds
2017-12-21 16:10:01,395: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 16:10:01,396: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:10:01,516: SQL status: SELECT in 0.12 seconds
2017-12-21 16:10:01,517: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 16:10:01,517: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:10:01,635: SQL status: SELECT in 0.12 seconds
2017-12-21 16:10:01,641: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 16:10:01,643: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 16:10:01,643: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 16:10:04,870: SQL status: INSERT 0 107331 in 3.23 seconds
2017-12-21 16:10:04,870: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 16:10:04,870: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 16:10:04,871: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 16:10:06,384: SQL status: COMMIT in 1.51 seconds
2017-12-21 16:10:06,385: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fdce90>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:10:06,437: 16:10:06 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 107331 in 91.40s]
2017-12-21 16:10:06,444: 16:10:06 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2017-12-21 16:10:06,444: Compiling model.parsely.parsely_sessions
2017-12-21 16:10:06,474: Acquiring new redshift connection "parsely_sessions".
2017-12-21 16:10:06,474: Re-using an available connection from the pool.
2017-12-21 16:10:06,474: Using redshift connection "parsely_sessions".
2017-12-21 16:10:06,474: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:10:06,496: SQL status: SELECT in 0.02 seconds
2017-12-21 16:10:06,502: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 16:10:06,504: Using redshift connection "parsely_sessions".
2017-12-21 16:10:06,504: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:10:06,525: SQL status: SELECT in 0.02 seconds
2017-12-21 16:10:06,527: Using redshift connection "parsely_sessions".
2017-12-21 16:10:06,527: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 16:10:06,548: SQL status: SELECT in 0.02 seconds
2017-12-21 16:10:06,553: Using redshift connection "parsely_sessions".
2017-12-21 16:10:06,553: On parsely_sessions: BEGIN
2017-12-21 16:10:06,555: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:10:06,555: Using redshift connection "parsely_sessions".
2017-12-21 16:10:06,555: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 16:10:28,701: SQL status: SELECT in 22.15 seconds
2017-12-21 16:10:28,702: Using redshift connection "parsely_sessions".
2017-12-21 16:10:28,702: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2017-12-21 16:10:28,855: SQL status: SELECT in 0.15 seconds
2017-12-21 16:10:28,856: Using redshift connection "parsely_sessions".
2017-12-21 16:10:28,856: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:10:28,974: SQL status: SELECT in 0.12 seconds
2017-12-21 16:10:28,975: Using redshift connection "parsely_sessions".
2017-12-21 16:10:28,976: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 16:10:29,099: SQL status: SELECT in 0.12 seconds
2017-12-21 16:10:29,104: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 16:10:29,105: Using redshift connection "parsely_sessions".
2017-12-21 16:10:29,105: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2017-12-21 16:10:30,648: SQL status: INSERT 0 87122 in 1.54 seconds
2017-12-21 16:10:30,649: On parsely_sessions: COMMIT
2017-12-21 16:10:30,649: Using redshift connection "parsely_sessions".
2017-12-21 16:10:30,649: On parsely_sessions: COMMIT
2017-12-21 16:10:31,988: SQL status: COMMIT in 1.34 seconds
2017-12-21 16:10:31,988: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01faa710>], 'label': '5e398173-dede-49c6-ac26-3868dc27c7e4'}
2017-12-21 16:10:32,028: 16:10:32 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 87122 in 25.54s]
2017-12-21 16:10:32,053: Using redshift connection "master".
2017-12-21 16:10:32,053: On master: BEGIN
2017-12-21 16:10:32,055: SQL status: BEGIN in 0.00 seconds
2017-12-21 16:10:32,056: On master: COMMIT
2017-12-21 16:10:32,056: Using redshift connection "master".
2017-12-21 16:10:32,056: On master: COMMIT
2017-12-21 16:10:32,058: SQL status: COMMIT in 0.00 seconds
2017-12-21 16:10:32,058: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 16:10:32,079: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 16:10:32,080: Using redshift connection "master".
2017-12-21 16:10:32,080: On master:  select 1 
2017-12-21 16:10:32,088: SQL status: SELECT in 0.01 seconds
2017-12-21 16:10:32,088: 16:10:32 | 
2017-12-21 16:10:32,089: 16:10:32 | Finished running 10 view models, 15 incremental models in 795.19s.
2017-12-21 16:10:32,089: 
2017-12-21 16:10:32,090: Completed successfully
2017-12-21 16:10:32,090: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2017-12-21 16:10:32,091: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01ff5e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01ff5f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f8c01fdc950>], 'label': 'end'}
2017-12-21 16:10:32,149: Flushing usage events
2017-12-21 17:21:16,984: Tracking: tracking
2017-12-21 17:21:16,984: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05d97250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05d974d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05d97310>], 'label': 'start'}
2017-12-21 17:21:17,040: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 17:21:17,056: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 17:21:17,057: Parsing core.sql
2017-12-21 17:21:17,068: Parsing etc/get_custom_schema.sql
2017-12-21 17:21:17,073: Parsing schema_tests/relationships.sql
2017-12-21 17:21:17,075: Parsing schema_tests/accepted_values.sql
2017-12-21 17:21:17,078: Parsing schema_tests/not_null.sql
2017-12-21 17:21:17,080: Parsing schema_tests/unique.sql
2017-12-21 17:21:17,082: Parsing materializations/wrapper.sql
2017-12-21 17:21:17,085: Parsing materializations/archive.sql
2017-12-21 17:21:17,112: Parsing materializations/table.sql
2017-12-21 17:21:17,129: Parsing materializations/helpers.sql
2017-12-21 17:21:17,144: Parsing materializations/bigquery.sql
2017-12-21 17:21:17,157: Parsing materializations/view.sql
2017-12-21 17:21:17,170: Parsing materializations/incremental.sql
2017-12-21 17:21:17,194: Parsing adapters/redshift.sql
2017-12-21 17:21:17,211: Parsing adapters/bigquery.sql
2017-12-21 17:21:17,216: Parsing adapters/postgres.sql
2017-12-21 17:21:17,218: Parsing adapters/common.sql
2017-12-21 17:21:17,237: Parsing model.parsely.parsely_audit
2017-12-21 17:21:17,238: Parsing model.parsely.parsely_video_content
2017-12-21 17:21:17,241: Parsing model.parsely.parsely_post_content
2017-12-21 17:21:17,244: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 17:21:17,246: Parsing model.parsely.parsely_rawdata
2017-12-21 17:21:17,249: Parsing model.parsely.calendar
2017-12-21 17:21:17,250: Parsing model.parsely.parsely_all_events
2017-12-21 17:21:17,259: Acquiring new redshift connection "parsely_all_events".
2017-12-21 17:21:17,259: Opening a new connection (0 currently allocated)
2017-12-21 17:21:17,299: Using redshift connection "parsely_all_events".
2017-12-21 17:21:17,299: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:17,325: SQL status: SELECT in 0.03 seconds
2017-12-21 17:21:17,330: Parsing model.parsely.parsely_event_ids
2017-12-21 17:21:17,333: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 17:21:17,335: Parsing model.parsely.parsely_base_events
2017-12-21 17:21:17,338: Acquiring new redshift connection "parsely_base_events".
2017-12-21 17:21:17,339: Re-using an available connection from the pool.
2017-12-21 17:21:17,339: Using redshift connection "parsely_base_events".
2017-12-21 17:21:17,339: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:17,359: SQL status: SELECT in 0.02 seconds
2017-12-21 17:21:17,360: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 17:21:17,366: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 17:21:17,370: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 17:21:17,372: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 17:21:17,374: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 17:21:17,377: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 17:21:17,382: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 17:21:17,389: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 17:21:17,394: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:21:17,394: Re-using an available connection from the pool.
2017-12-21 17:21:17,394: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:21:17,394: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:17,415: SQL status: SELECT in 0.02 seconds
2017-12-21 17:21:17,416: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 17:21:17,422: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 17:21:17,427: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:21:17,427: Re-using an available connection from the pool.
2017-12-21 17:21:17,427: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:21:17,427: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:17,448: SQL status: SELECT in 0.02 seconds
2017-12-21 17:21:17,449: Parsing model.parsely.parsely_incoming_users
2017-12-21 17:21:17,452: Parsing model.parsely.parsely_users
2017-12-21 17:21:17,456: Acquiring new redshift connection "parsely_users".
2017-12-21 17:21:17,457: Re-using an available connection from the pool.
2017-12-21 17:21:17,457: Using redshift connection "parsely_users".
2017-12-21 17:21:17,457: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:17,477: SQL status: SELECT in 0.02 seconds
2017-12-21 17:21:17,478: Parsing model.parsely.parsely_errors
2017-12-21 17:21:17,482: Parsing model.parsely.parsely_bot_traffic
2017-12-21 17:21:17,486: Parsing model.parsely.parsely_custom_events
2017-12-21 17:21:17,491: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 17:21:17,494: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 17:21:17,497: Parsing model.parsely.parsely_sessions
2017-12-21 17:21:17,502: Acquiring new redshift connection "parsely_sessions".
2017-12-21 17:21:17,502: Re-using an available connection from the pool.
2017-12-21 17:21:17,503: Using redshift connection "parsely_sessions".
2017-12-21 17:21:17,503: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:17,523: SQL status: SELECT in 0.02 seconds
2017-12-21 17:21:17,523: Parsing model.parsely.parsely_campaigns
2017-12-21 17:21:17,527: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 17:21:17,527: Re-using an available connection from the pool.
2017-12-21 17:21:17,527: Using redshift connection "parsely_campaigns".
2017-12-21 17:21:17,527: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:17,547: SQL status: SELECT in 0.02 seconds
2017-12-21 17:21:17,552: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 17:21:17,558: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 17:21:17,565: 
2017-12-21 17:21:17,567: Acquiring new redshift connection "master".
2017-12-21 17:21:17,568: Re-using an available connection from the pool.
2017-12-21 17:21:17,568: Using redshift connection "master".
2017-12-21 17:21:17,568: On master: select distinct nspname from pg_namespace
2017-12-21 17:21:17,570: SQL status: SELECT in 0.00 seconds
2017-12-21 17:21:17,572: Using redshift connection "master".
2017-12-21 17:21:17,573: On master: BEGIN
2017-12-21 17:21:17,574: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:21:17,574: On master: COMMIT
2017-12-21 17:21:17,574: Using redshift connection "master".
2017-12-21 17:21:17,574: On master: COMMIT
2017-12-21 17:21:17,576: SQL status: COMMIT in 0.00 seconds
2017-12-21 17:21:17,581: 17:21:17 | Concurrency: 1 threads (target='dev')
2017-12-21 17:21:17,581: 17:21:17 | 
2017-12-21 17:21:17,581: Using redshift connection "master".
2017-12-21 17:21:17,581: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:17,602: SQL status: SELECT in 0.02 seconds
2017-12-21 17:21:17,674: 17:21:17 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-21 17:21:17,674: Compiling model.parsely.calendar
2017-12-21 17:21:17,679: Writing injected SQL for node "model.parsely.calendar"
2017-12-21 17:21:17,680: Acquiring new redshift connection "calendar".
2017-12-21 17:21:17,680: Opening a new connection (1 currently allocated)
2017-12-21 17:21:17,691: Using redshift connection "calendar".
2017-12-21 17:21:17,691: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:17,717: SQL status: SELECT in 0.03 seconds
2017-12-21 17:21:17,719: Writing runtime SQL for node "model.parsely.calendar"
2017-12-21 17:21:17,720: Using redshift connection "calendar".
2017-12-21 17:21:17,720: On calendar: BEGIN
2017-12-21 17:21:17,721: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:21:17,721: Using redshift connection "calendar".
2017-12-21 17:21:17,721: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-21 17:21:17,854: SQL status: CREATE VIEW in 0.13 seconds
2017-12-21 17:21:17,855: On calendar: COMMIT
2017-12-21 17:21:17,855: Using redshift connection "calendar".
2017-12-21 17:21:17,855: On calendar: COMMIT
2017-12-21 17:21:18,156: SQL status: COMMIT in 0.30 seconds
2017-12-21 17:21:18,156: Using redshift connection "calendar".
2017-12-21 17:21:18,156: On calendar: BEGIN
2017-12-21 17:21:18,158: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:21:18,159: Using redshift connection "calendar".
2017-12-21 17:21:18,159: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-21 17:21:18,165: SQL status: DROP VIEW in 0.01 seconds
2017-12-21 17:21:18,165: On calendar: COMMIT
2017-12-21 17:21:18,165: Using redshift connection "calendar".
2017-12-21 17:21:18,165: On calendar: COMMIT
2017-12-21 17:21:18,453: SQL status: COMMIT in 0.29 seconds
2017-12-21 17:21:18,454: Using redshift connection "calendar".
2017-12-21 17:21:18,454: On calendar: BEGIN
2017-12-21 17:21:18,456: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:21:18,456: Using redshift connection "calendar".
2017-12-21 17:21:18,456: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-21 17:21:18,460: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 17:21:18,460: On calendar: COMMIT
2017-12-21 17:21:18,460: Using redshift connection "calendar".
2017-12-21 17:21:18,461: On calendar: COMMIT
2017-12-21 17:21:18,824: SQL status: COMMIT in 0.36 seconds
2017-12-21 17:21:18,824: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05c90350>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:21:18,851: 17:21:18 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.15s]
2017-12-21 17:21:18,851: 17:21:18 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-21 17:21:18,851: Compiling model.parsely.parsely_rawdata
2017-12-21 17:21:18,857: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-21 17:21:18,858: Acquiring new redshift connection "parsely_rawdata".
2017-12-21 17:21:18,858: Re-using an available connection from the pool.
2017-12-21 17:21:18,858: Using redshift connection "parsely_rawdata".
2017-12-21 17:21:18,858: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:18,879: SQL status: SELECT in 0.02 seconds
2017-12-21 17:21:18,879: Using redshift connection "parsely_rawdata".
2017-12-21 17:21:18,879: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:21:18,899: SQL status: SELECT in 0.02 seconds
2017-12-21 17:21:18,900: Using redshift connection "parsely_rawdata".
2017-12-21 17:21:18,900: On parsely_rawdata: BEGIN
2017-12-21 17:21:18,902: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:21:18,902: Using redshift connection "parsely_rawdata".
2017-12-21 17:21:18,902: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:21:46,374: SQL status: SELECT in 27.47 seconds
2017-12-21 17:21:46,374: Using redshift connection "parsely_rawdata".
2017-12-21 17:21:46,375: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-21 17:21:46,550: SQL status: SELECT in 0.18 seconds
2017-12-21 17:21:46,551: Using redshift connection "parsely_rawdata".
2017-12-21 17:21:46,551: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:21:46,663: SQL status: SELECT in 0.11 seconds
2017-12-21 17:21:46,663: Using redshift connection "parsely_rawdata".
2017-12-21 17:21:46,663: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:21:46,779: SQL status: SELECT in 0.12 seconds
2017-12-21 17:21:46,782: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-21 17:21:46,783: Using redshift connection "parsely_rawdata".
2017-12-21 17:21:46,783: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-21 17:22:17,191: SQL status: INSERT 0 1015763 in 30.41 seconds
2017-12-21 17:22:17,191: On parsely_rawdata: COMMIT
2017-12-21 17:22:17,191: Using redshift connection "parsely_rawdata".
2017-12-21 17:22:17,192: On parsely_rawdata: COMMIT
2017-12-21 17:22:19,507: SQL status: COMMIT in 2.31 seconds
2017-12-21 17:22:19,507: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05d4c850>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:22:19,542: 17:22:19 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1015763 in 60.66s]
2017-12-21 17:22:19,543: 17:22:19 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-21 17:22:19,543: Compiling model.parsely.parsely_all_events
2017-12-21 17:22:19,551: Acquiring new redshift connection "parsely_all_events".
2017-12-21 17:22:19,551: Re-using an available connection from the pool.
2017-12-21 17:22:19,551: Using redshift connection "parsely_all_events".
2017-12-21 17:22:19,551: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:22:19,574: SQL status: SELECT in 0.02 seconds
2017-12-21 17:22:19,582: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-21 17:22:19,583: Using redshift connection "parsely_all_events".
2017-12-21 17:22:19,583: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:22:19,603: SQL status: SELECT in 0.02 seconds
2017-12-21 17:22:19,604: Using redshift connection "parsely_all_events".
2017-12-21 17:22:19,604: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:22:19,624: SQL status: SELECT in 0.02 seconds
2017-12-21 17:22:19,626: Using redshift connection "parsely_all_events".
2017-12-21 17:22:19,626: On parsely_all_events: BEGIN
2017-12-21 17:22:19,628: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:22:19,628: Using redshift connection "parsely_all_events".
2017-12-21 17:22:19,628: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_ip,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:24:58,490: SQL status: SELECT in 158.86 seconds
2017-12-21 17:24:58,491: Using redshift connection "parsely_all_events".
2017-12-21 17:24:58,491: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2017-12-21 17:24:58,661: SQL status: SELECT in 0.17 seconds
2017-12-21 17:24:58,662: Using redshift connection "parsely_all_events".
2017-12-21 17:24:58,662: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:24:58,775: SQL status: SELECT in 0.11 seconds
2017-12-21 17:24:58,776: Using redshift connection "parsely_all_events".
2017-12-21 17:24:58,776: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:24:58,889: SQL status: SELECT in 0.11 seconds
2017-12-21 17:24:58,895: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-21 17:24:58,896: Using redshift connection "parsely_all_events".
2017-12-21 17:24:58,896: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2017-12-21 17:25:34,627: SQL status: INSERT 0 900273 in 35.73 seconds
2017-12-21 17:25:34,627: On parsely_all_events: COMMIT
2017-12-21 17:25:34,627: Using redshift connection "parsely_all_events".
2017-12-21 17:25:34,627: On parsely_all_events: COMMIT
2017-12-21 17:25:37,588: SQL status: COMMIT in 2.96 seconds
2017-12-21 17:25:37,589: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cfff10>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:25:37,626: 17:25:37 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 900273 in 198.05s]
2017-12-21 17:25:37,627: 17:25:37 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-21 17:25:37,627: Compiling model.parsely.parsely_bot_traffic
2017-12-21 17:25:37,634: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 17:25:37,635: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-21 17:25:37,635: Re-using an available connection from the pool.
2017-12-21 17:25:37,635: Using redshift connection "parsely_bot_traffic".
2017-12-21 17:25:37,635: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:25:37,657: SQL status: SELECT in 0.02 seconds
2017-12-21 17:25:37,658: Using redshift connection "parsely_bot_traffic".
2017-12-21 17:25:37,658: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:25:37,678: SQL status: SELECT in 0.02 seconds
2017-12-21 17:25:37,680: Using redshift connection "parsely_bot_traffic".
2017-12-21 17:25:37,680: On parsely_bot_traffic: BEGIN
2017-12-21 17:25:37,682: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:25:37,682: Using redshift connection "parsely_bot_traffic".
2017-12-21 17:25:37,682: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:26:08,829: SQL status: SELECT in 31.15 seconds
2017-12-21 17:26:08,830: Using redshift connection "parsely_bot_traffic".
2017-12-21 17:26:08,830: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2017-12-21 17:26:09,063: SQL status: SELECT in 0.23 seconds
2017-12-21 17:26:09,064: Using redshift connection "parsely_bot_traffic".
2017-12-21 17:26:09,064: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:26:09,184: SQL status: SELECT in 0.12 seconds
2017-12-21 17:26:09,185: Using redshift connection "parsely_bot_traffic".
2017-12-21 17:26:09,185: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:26:09,302: SQL status: SELECT in 0.12 seconds
2017-12-21 17:26:09,305: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 17:26:09,305: Using redshift connection "parsely_bot_traffic".
2017-12-21 17:26:09,305: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2017-12-21 17:26:29,704: SQL status: INSERT 0 4 in 20.40 seconds
2017-12-21 17:26:29,704: On parsely_bot_traffic: COMMIT
2017-12-21 17:26:29,705: Using redshift connection "parsely_bot_traffic".
2017-12-21 17:26:29,705: On parsely_bot_traffic: COMMIT
2017-12-21 17:26:31,501: SQL status: COMMIT in 1.80 seconds
2017-12-21 17:26:31,502: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05d4cf10>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:26:31,530: 17:26:31 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 53.87s]
2017-12-21 17:26:31,531: 17:26:31 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-21 17:26:31,531: Compiling model.parsely.parsely_custom_events
2017-12-21 17:26:31,539: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-21 17:26:31,540: Acquiring new redshift connection "parsely_custom_events".
2017-12-21 17:26:31,540: Re-using an available connection from the pool.
2017-12-21 17:26:31,541: Using redshift connection "parsely_custom_events".
2017-12-21 17:26:31,541: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:26:31,562: SQL status: SELECT in 0.02 seconds
2017-12-21 17:26:31,562: Using redshift connection "parsely_custom_events".
2017-12-21 17:26:31,562: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:26:31,582: SQL status: SELECT in 0.02 seconds
2017-12-21 17:26:31,584: Using redshift connection "parsely_custom_events".
2017-12-21 17:26:31,584: On parsely_custom_events: BEGIN
2017-12-21 17:26:31,586: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:26:31,586: Using redshift connection "parsely_custom_events".
2017-12-21 17:26:31,586: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:26:54,956: SQL status: SELECT in 23.37 seconds
2017-12-21 17:26:54,956: Using redshift connection "parsely_custom_events".
2017-12-21 17:26:54,956: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2017-12-21 17:26:55,267: SQL status: SELECT in 0.31 seconds
2017-12-21 17:26:55,267: Using redshift connection "parsely_custom_events".
2017-12-21 17:26:55,267: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:26:55,395: SQL status: SELECT in 0.13 seconds
2017-12-21 17:26:55,395: Using redshift connection "parsely_custom_events".
2017-12-21 17:26:55,395: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:26:55,522: SQL status: SELECT in 0.13 seconds
2017-12-21 17:26:55,526: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-21 17:26:55,527: Using redshift connection "parsely_custom_events".
2017-12-21 17:26:55,527: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2017-12-21 17:27:19,065: SQL status: INSERT 0 0 in 23.54 seconds
2017-12-21 17:27:19,066: On parsely_custom_events: COMMIT
2017-12-21 17:27:19,066: Using redshift connection "parsely_custom_events".
2017-12-21 17:27:19,066: On parsely_custom_events: COMMIT
2017-12-21 17:27:19,566: SQL status: COMMIT in 0.50 seconds
2017-12-21 17:27:19,566: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cffa90>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:27:19,611: 17:27:19 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 48.04s]
2017-12-21 17:27:19,611: 17:27:19 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-21 17:27:19,611: Compiling model.parsely.parsely_errors
2017-12-21 17:27:19,618: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-21 17:27:19,620: Acquiring new redshift connection "parsely_errors".
2017-12-21 17:27:19,620: Re-using an available connection from the pool.
2017-12-21 17:27:19,620: Using redshift connection "parsely_errors".
2017-12-21 17:27:19,620: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:27:19,641: SQL status: SELECT in 0.02 seconds
2017-12-21 17:27:19,641: Using redshift connection "parsely_errors".
2017-12-21 17:27:19,641: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:27:19,661: SQL status: SELECT in 0.02 seconds
2017-12-21 17:27:19,663: Using redshift connection "parsely_errors".
2017-12-21 17:27:19,663: On parsely_errors: BEGIN
2017-12-21 17:27:19,665: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:27:19,665: Using redshift connection "parsely_errors".
2017-12-21 17:27:19,665: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:27:47,870: SQL status: SELECT in 28.21 seconds
2017-12-21 17:27:47,871: Using redshift connection "parsely_errors".
2017-12-21 17:27:47,871: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2017-12-21 17:27:48,042: SQL status: SELECT in 0.17 seconds
2017-12-21 17:27:48,043: Using redshift connection "parsely_errors".
2017-12-21 17:27:48,043: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:27:48,154: SQL status: SELECT in 0.11 seconds
2017-12-21 17:27:48,155: Using redshift connection "parsely_errors".
2017-12-21 17:27:48,156: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:27:48,267: SQL status: SELECT in 0.11 seconds
2017-12-21 17:27:48,270: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-21 17:27:48,271: Using redshift connection "parsely_errors".
2017-12-21 17:27:48,271: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2017-12-21 17:27:48,519: SQL status: INSERT 0 2 in 0.25 seconds
2017-12-21 17:27:48,519: On parsely_errors: COMMIT
2017-12-21 17:27:48,519: Using redshift connection "parsely_errors".
2017-12-21 17:27:48,519: On parsely_errors: COMMIT
2017-12-21 17:27:49,657: SQL status: COMMIT in 1.14 seconds
2017-12-21 17:27:49,657: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05c761d0>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:27:49,682: 17:27:49 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 30.05s]
2017-12-21 17:27:49,682: 17:27:49 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-21 17:27:49,682: Compiling model.parsely.parsely_base_events
2017-12-21 17:27:49,686: Acquiring new redshift connection "parsely_base_events".
2017-12-21 17:27:49,686: Re-using an available connection from the pool.
2017-12-21 17:27:49,686: Using redshift connection "parsely_base_events".
2017-12-21 17:27:49,686: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:27:49,707: SQL status: SELECT in 0.02 seconds
2017-12-21 17:27:49,711: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-21 17:27:49,712: Using redshift connection "parsely_base_events".
2017-12-21 17:27:49,712: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:27:49,731: SQL status: SELECT in 0.02 seconds
2017-12-21 17:27:49,733: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-21 17:27:49,733: Using redshift connection "parsely_base_events".
2017-12-21 17:27:49,734: On parsely_base_events: BEGIN
2017-12-21 17:27:49,735: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:27:49,735: Using redshift connection "parsely_base_events".
2017-12-21 17:27:49,736: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-21 17:27:50,503: SQL status: CREATE VIEW in 0.77 seconds
2017-12-21 17:27:50,503: On parsely_base_events: COMMIT
2017-12-21 17:27:50,503: Using redshift connection "parsely_base_events".
2017-12-21 17:27:50,504: On parsely_base_events: COMMIT
2017-12-21 17:27:51,124: SQL status: COMMIT in 0.62 seconds
2017-12-21 17:27:51,124: Using redshift connection "parsely_base_events".
2017-12-21 17:27:51,124: On parsely_base_events: BEGIN
2017-12-21 17:27:51,127: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:27:51,127: Using redshift connection "parsely_base_events".
2017-12-21 17:27:51,127: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2017-12-21 17:27:51,949: SQL status: DROP VIEW in 0.82 seconds
2017-12-21 17:27:51,949: On parsely_base_events: COMMIT
2017-12-21 17:27:51,949: Using redshift connection "parsely_base_events".
2017-12-21 17:27:51,949: On parsely_base_events: COMMIT
2017-12-21 17:27:52,232: SQL status: COMMIT in 0.28 seconds
2017-12-21 17:27:52,232: Using redshift connection "parsely_base_events".
2017-12-21 17:27:52,232: On parsely_base_events: BEGIN
2017-12-21 17:27:52,235: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:27:52,235: Using redshift connection "parsely_base_events".
2017-12-21 17:27:52,235: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-21 17:27:52,331: SQL status: ALTER TABLE in 0.10 seconds
2017-12-21 17:27:52,332: On parsely_base_events: COMMIT
2017-12-21 17:27:52,332: Using redshift connection "parsely_base_events".
2017-12-21 17:27:52,332: On parsely_base_events: COMMIT
2017-12-21 17:27:52,808: SQL status: COMMIT in 0.48 seconds
2017-12-21 17:27:52,809: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05d4c850>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:27:52,836: 17:27:52 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 3.13s]
2017-12-21 17:27:52,836: 17:27:52 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2017-12-21 17:27:52,837: Compiling model.parsely.parsely_event_ids
2017-12-21 17:27:52,842: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-21 17:27:52,844: Acquiring new redshift connection "parsely_event_ids".
2017-12-21 17:27:52,844: Re-using an available connection from the pool.
2017-12-21 17:27:52,844: Using redshift connection "parsely_event_ids".
2017-12-21 17:27:52,844: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:27:52,868: SQL status: SELECT in 0.02 seconds
2017-12-21 17:27:52,869: Using redshift connection "parsely_event_ids".
2017-12-21 17:27:52,869: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:27:52,886: SQL status: SELECT in 0.02 seconds
2017-12-21 17:27:52,887: Using redshift connection "parsely_event_ids".
2017-12-21 17:27:52,887: On parsely_event_ids: BEGIN
2017-12-21 17:27:52,889: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:27:52,889: Using redshift connection "parsely_event_ids".
2017-12-21 17:27:52,889: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:27:53,544: SQL status: SELECT in 0.65 seconds
2017-12-21 17:27:53,544: Using redshift connection "parsely_event_ids".
2017-12-21 17:27:53,545: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2017-12-21 17:27:53,707: SQL status: SELECT in 0.16 seconds
2017-12-21 17:27:53,707: Using redshift connection "parsely_event_ids".
2017-12-21 17:27:53,709: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:27:53,816: SQL status: SELECT in 0.11 seconds
2017-12-21 17:27:53,816: Using redshift connection "parsely_event_ids".
2017-12-21 17:27:53,816: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:27:53,923: SQL status: SELECT in 0.11 seconds
2017-12-21 17:27:53,924: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-21 17:27:53,925: Using redshift connection "parsely_event_ids".
2017-12-21 17:27:53,925: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2017-12-21 17:27:54,373: SQL status: INSERT 0 900269 in 0.45 seconds
2017-12-21 17:27:54,374: On parsely_event_ids: COMMIT
2017-12-21 17:27:54,374: Using redshift connection "parsely_event_ids".
2017-12-21 17:27:54,374: On parsely_event_ids: COMMIT
2017-12-21 17:27:54,751: SQL status: COMMIT in 0.38 seconds
2017-12-21 17:27:54,751: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05c9ded0>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:27:54,776: 17:27:54 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 900269 in 1.91s]
2017-12-21 17:27:54,777: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-21 17:27:54,782: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-21 17:27:54,783: 17:27:54 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-21 17:27:54,783: Compiling model.parsely.parsely_post_content
2017-12-21 17:27:54,789: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-21 17:27:54,790: Acquiring new redshift connection "parsely_post_content".
2017-12-21 17:27:54,790: Re-using an available connection from the pool.
2017-12-21 17:27:54,790: Using redshift connection "parsely_post_content".
2017-12-21 17:27:54,790: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:27:54,811: SQL status: SELECT in 0.02 seconds
2017-12-21 17:27:54,811: Using redshift connection "parsely_post_content".
2017-12-21 17:27:54,811: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:27:54,828: SQL status: SELECT in 0.02 seconds
2017-12-21 17:27:54,829: Using redshift connection "parsely_post_content".
2017-12-21 17:27:54,830: On parsely_post_content: BEGIN
2017-12-21 17:27:54,831: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:27:54,831: Using redshift connection "parsely_post_content".
2017-12-21 17:27:54,831: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:27:58,592: SQL status: SELECT in 3.76 seconds
2017-12-21 17:27:58,592: Using redshift connection "parsely_post_content".
2017-12-21 17:27:58,592: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2017-12-21 17:27:58,772: SQL status: SELECT in 0.18 seconds
2017-12-21 17:27:58,773: Using redshift connection "parsely_post_content".
2017-12-21 17:27:58,774: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:27:58,881: SQL status: SELECT in 0.11 seconds
2017-12-21 17:27:58,882: Using redshift connection "parsely_post_content".
2017-12-21 17:27:58,882: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:27:58,989: SQL status: SELECT in 0.11 seconds
2017-12-21 17:27:58,990: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-21 17:27:58,991: Using redshift connection "parsely_post_content".
2017-12-21 17:27:58,991: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2017-12-21 17:28:01,910: SQL status: INSERT 0 881 in 2.92 seconds
2017-12-21 17:28:01,910: On parsely_post_content: COMMIT
2017-12-21 17:28:01,910: Using redshift connection "parsely_post_content".
2017-12-21 17:28:01,910: On parsely_post_content: COMMIT
2017-12-21 17:28:02,406: SQL status: COMMIT in 0.50 seconds
2017-12-21 17:28:02,406: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05c76250>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:28:02,437: 17:28:02 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 881 in 7.62s]
2017-12-21 17:28:02,437: 17:28:02 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2017-12-21 17:28:02,438: Compiling model.parsely.parsely_video_content
2017-12-21 17:28:02,443: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-21 17:28:02,444: Acquiring new redshift connection "parsely_video_content".
2017-12-21 17:28:02,445: Re-using an available connection from the pool.
2017-12-21 17:28:02,445: Using redshift connection "parsely_video_content".
2017-12-21 17:28:02,445: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:02,465: SQL status: SELECT in 0.02 seconds
2017-12-21 17:28:02,466: Using redshift connection "parsely_video_content".
2017-12-21 17:28:02,466: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:02,484: SQL status: SELECT in 0.02 seconds
2017-12-21 17:28:02,485: Using redshift connection "parsely_video_content".
2017-12-21 17:28:02,485: On parsely_video_content: BEGIN
2017-12-21 17:28:02,487: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:28:02,487: Using redshift connection "parsely_video_content".
2017-12-21 17:28:02,487: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:28:05,977: SQL status: SELECT in 3.49 seconds
2017-12-21 17:28:05,978: Using redshift connection "parsely_video_content".
2017-12-21 17:28:05,978: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2017-12-21 17:28:06,149: SQL status: SELECT in 0.17 seconds
2017-12-21 17:28:06,150: Using redshift connection "parsely_video_content".
2017-12-21 17:28:06,150: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:28:06,257: SQL status: SELECT in 0.11 seconds
2017-12-21 17:28:06,257: Using redshift connection "parsely_video_content".
2017-12-21 17:28:06,257: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:28:06,366: SQL status: SELECT in 0.11 seconds
2017-12-21 17:28:06,367: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-21 17:28:06,368: Using redshift connection "parsely_video_content".
2017-12-21 17:28:06,368: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2017-12-21 17:28:09,215: SQL status: INSERT 0 468 in 2.85 seconds
2017-12-21 17:28:09,216: On parsely_video_content: COMMIT
2017-12-21 17:28:09,216: Using redshift connection "parsely_video_content".
2017-12-21 17:28:09,216: On parsely_video_content: COMMIT
2017-12-21 17:28:09,836: SQL status: COMMIT in 0.62 seconds
2017-12-21 17:28:09,836: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cf1910>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:28:09,863: 17:28:09 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 468 in 7.40s]
2017-12-21 17:28:09,864: 17:28:09 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-21 17:28:09,864: Compiling model.parsely.parsely_entry_exit_urls
2017-12-21 17:28:09,869: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 17:28:09,870: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-21 17:28:09,871: Re-using an available connection from the pool.
2017-12-21 17:28:09,871: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 17:28:09,871: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:09,892: SQL status: SELECT in 0.02 seconds
2017-12-21 17:28:09,894: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 17:28:09,895: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 17:28:09,895: On parsely_entry_exit_urls: BEGIN
2017-12-21 17:28:09,897: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:28:09,897: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 17:28:09,897: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-21 17:28:10,304: SQL status: CREATE VIEW in 0.41 seconds
2017-12-21 17:28:10,304: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 17:28:10,304: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2017-12-21 17:28:10,308: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 17:28:10,308: On parsely_entry_exit_urls: COMMIT
2017-12-21 17:28:10,308: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 17:28:10,308: On parsely_entry_exit_urls: COMMIT
2017-12-21 17:28:12,257: SQL status: COMMIT in 1.95 seconds
2017-12-21 17:28:12,258: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cf1910>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:28:12,287: 17:28:12 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 2.39s]
2017-12-21 17:28:12,287: 17:28:12 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-21 17:28:12,287: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 17:28:12,297: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 17:28:12,299: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 17:28:12,299: Re-using an available connection from the pool.
2017-12-21 17:28:12,299: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 17:28:12,299: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:12,320: SQL status: SELECT in 0.02 seconds
2017-12-21 17:28:12,323: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 17:28:12,324: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 17:28:12,324: On parsely_incoming_videoviews: BEGIN
2017-12-21 17:28:12,326: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:28:12,326: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 17:28:12,326: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 17:28:13,069: SQL status: CREATE VIEW in 0.74 seconds
2017-12-21 17:28:13,070: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 17:28:13,070: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 17:28:13,074: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 17:28:13,074: On parsely_incoming_videoviews: COMMIT
2017-12-21 17:28:13,074: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 17:28:13,074: On parsely_incoming_videoviews: COMMIT
2017-12-21 17:28:13,227: SQL status: COMMIT in 0.15 seconds
2017-12-21 17:28:13,227: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cf1910>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:28:13,256: 17:28:13 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.94s]
2017-12-21 17:28:13,257: 17:28:13 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 17:28:13,257: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 17:28:13,262: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:13,262: Re-using an available connection from the pool.
2017-12-21 17:28:13,262: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:13,262: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:13,283: SQL status: SELECT in 0.02 seconds
2017-12-21 17:28:13,287: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 17:28:13,288: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:13,288: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:13,309: SQL status: SELECT in 0.02 seconds
2017-12-21 17:28:13,309: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:13,310: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:13,330: SQL status: SELECT in 0.02 seconds
2017-12-21 17:28:13,331: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:13,332: On parsely_videoviews_sessionized: BEGIN
2017-12-21 17:28:13,333: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:28:13,334: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:13,334: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:28:33,743: SQL status: SELECT in 20.41 seconds
2017-12-21 17:28:33,743: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:33,743: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2017-12-21 17:28:33,890: SQL status: SELECT in 0.15 seconds
2017-12-21 17:28:33,891: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:33,891: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:28:33,991: SQL status: SELECT in 0.10 seconds
2017-12-21 17:28:33,992: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:33,992: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:28:34,092: SQL status: SELECT in 0.10 seconds
2017-12-21 17:28:34,095: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 17:28:34,096: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:34,096: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 17:28:50,175: SQL status: INSERT 0 142 in 16.08 seconds
2017-12-21 17:28:50,175: On parsely_videoviews_sessionized: COMMIT
2017-12-21 17:28:50,175: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 17:28:50,175: On parsely_videoviews_sessionized: COMMIT
2017-12-21 17:28:51,897: SQL status: COMMIT in 1.72 seconds
2017-12-21 17:28:51,897: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05d4cc50>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:28:51,999: 17:28:51 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 142 in 38.64s]
2017-12-21 17:28:52,001: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-21 17:28:52,023: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-21 17:28:52,024: 17:28:52 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-21 17:28:52,025: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 17:28:52,037: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 17:28:52,038: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 17:28:52,038: Re-using an available connection from the pool.
2017-12-21 17:28:52,038: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 17:28:52,038: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:52,053: SQL status: SELECT in 0.02 seconds
2017-12-21 17:28:52,055: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 17:28:52,056: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 17:28:52,056: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-21 17:28:52,058: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:28:52,058: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 17:28:52,058: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-21 17:28:52,881: SQL status: CREATE VIEW in 0.82 seconds
2017-12-21 17:28:52,882: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 17:28:52,882: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-21 17:28:52,886: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 17:28:52,886: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 17:28:52,886: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 17:28:52,886: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 17:28:53,506: SQL status: COMMIT in 0.62 seconds
2017-12-21 17:28:53,506: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05c9de50>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:28:53,535: 17:28:53 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.48s]
2017-12-21 17:28:53,536: 17:28:53 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-21 17:28:53,536: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 17:28:53,564: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 17:28:53,565: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 17:28:53,565: Re-using an available connection from the pool.
2017-12-21 17:28:53,565: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 17:28:53,565: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:53,578: SQL status: SELECT in 0.01 seconds
2017-12-21 17:28:53,581: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 17:28:53,582: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 17:28:53,582: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-21 17:28:53,584: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:28:53,584: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 17:28:53,584: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-21 17:28:54,251: SQL status: CREATE VIEW in 0.67 seconds
2017-12-21 17:28:54,251: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 17:28:54,252: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-21 17:28:54,257: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 17:28:54,257: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 17:28:54,257: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 17:28:54,257: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 17:28:54,476: SQL status: COMMIT in 0.22 seconds
2017-12-21 17:28:54,476: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cff110>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:28:54,502: 17:28:54 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.94s]
2017-12-21 17:28:54,503: 17:28:54 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2017-12-21 17:28:54,503: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 17:28:54,513: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 17:28:54,514: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 17:28:54,514: Re-using an available connection from the pool.
2017-12-21 17:28:54,514: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 17:28:54,515: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:54,529: SQL status: SELECT in 0.01 seconds
2017-12-21 17:28:54,533: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 17:28:54,534: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 17:28:54,534: On parsely_incoming_pageviews: BEGIN
2017-12-21 17:28:54,536: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:28:54,536: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 17:28:54,536: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 17:28:54,616: SQL status: CREATE VIEW in 0.08 seconds
2017-12-21 17:28:54,617: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 17:28:54,617: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2017-12-21 17:28:54,621: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 17:28:54,622: On parsely_incoming_pageviews: COMMIT
2017-12-21 17:28:54,622: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 17:28:54,622: On parsely_incoming_pageviews: COMMIT
2017-12-21 17:28:54,776: SQL status: COMMIT in 0.15 seconds
2017-12-21 17:28:54,777: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cf1890>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:28:54,804: 17:28:54 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.27s]
2017-12-21 17:28:54,805: 17:28:54 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2017-12-21 17:28:54,805: Compiling model.parsely.parsely_pageviews_sessionized
2017-12-21 17:28:54,810: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:28:54,810: Re-using an available connection from the pool.
2017-12-21 17:28:54,810: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:28:54,810: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:54,826: SQL status: SELECT in 0.02 seconds
2017-12-21 17:28:54,830: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 17:28:54,831: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:28:54,831: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:54,847: SQL status: SELECT in 0.02 seconds
2017-12-21 17:28:54,848: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:28:54,848: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:28:54,862: SQL status: SELECT in 0.01 seconds
2017-12-21 17:28:54,864: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:28:54,864: On parsely_pageviews_sessionized: BEGIN
2017-12-21 17:28:54,866: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:28:54,866: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:28:54,866: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:30:22,090: SQL status: SELECT in 87.22 seconds
2017-12-21 17:30:22,091: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:30:22,091: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2017-12-21 17:30:22,303: SQL status: SELECT in 0.21 seconds
2017-12-21 17:30:22,304: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:30:22,304: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:30:22,412: SQL status: SELECT in 0.11 seconds
2017-12-21 17:30:22,413: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:30:22,413: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:30:22,521: SQL status: SELECT in 0.11 seconds
2017-12-21 17:30:22,527: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 17:30:22,528: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:30:22,528: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 17:30:43,539: SQL status: INSERT 0 107291 in 21.01 seconds
2017-12-21 17:30:43,539: On parsely_pageviews_sessionized: COMMIT
2017-12-21 17:30:43,540: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 17:30:43,540: On parsely_pageviews_sessionized: COMMIT
2017-12-21 17:30:45,237: SQL status: COMMIT in 1.70 seconds
2017-12-21 17:30:45,238: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05c90210>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:30:45,324: 17:30:45 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 107291 in 110.43s]
2017-12-21 17:30:45,325: 17:30:45 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-21 17:30:45,332: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-21 17:30:45,521: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 17:30:45,523: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-21 17:30:45,523: Re-using an available connection from the pool.
2017-12-21 17:30:45,524: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 17:30:45,524: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:30:45,549: SQL status: SELECT in 0.02 seconds
2017-12-21 17:30:45,553: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 17:30:45,554: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 17:30:45,554: On parsely_videoview_engagedtime: BEGIN
2017-12-21 17:30:45,556: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:30:45,556: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 17:30:45,556: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-21 17:30:45,646: SQL status: CREATE VIEW in 0.09 seconds
2017-12-21 17:30:45,647: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 17:30:45,647: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-21 17:30:45,651: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 17:30:45,651: On parsely_videoview_engagedtime: COMMIT
2017-12-21 17:30:45,651: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 17:30:45,651: On parsely_videoview_engagedtime: COMMIT
2017-12-21 17:30:45,846: SQL status: COMMIT in 0.19 seconds
2017-12-21 17:30:45,847: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05c90210>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:30:45,898: 17:30:45 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.51s]
2017-12-21 17:30:45,900: 17:30:45 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-21 17:30:45,900: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-21 17:30:45,942: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 17:30:45,944: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 17:30:45,948: Re-using an available connection from the pool.
2017-12-21 17:30:45,948: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 17:30:45,948: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:30:45,969: SQL status: SELECT in 0.02 seconds
2017-12-21 17:30:45,970: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 17:30:45,970: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:30:45,990: SQL status: SELECT in 0.02 seconds
2017-12-21 17:30:45,994: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 17:30:45,994: On parsely_videoview_behavior_workflow: BEGIN
2017-12-21 17:30:45,996: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:30:45,996: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 17:30:45,996: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:31:34,410: SQL status: SELECT in 48.41 seconds
2017-12-21 17:31:34,411: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 17:31:34,411: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 17:31:34,899: SQL status: SELECT in 0.49 seconds
2017-12-21 17:31:34,900: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 17:31:34,900: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:31:35,010: SQL status: SELECT in 0.11 seconds
2017-12-21 17:31:35,011: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 17:31:35,011: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:31:35,120: SQL status: SELECT in 0.11 seconds
2017-12-21 17:31:35,132: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 17:31:35,133: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 17:31:35,133: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 17:31:35,378: SQL status: INSERT 0 141 in 0.24 seconds
2017-12-21 17:31:35,379: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 17:31:35,379: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 17:31:35,379: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 17:31:37,151: SQL status: COMMIT in 1.77 seconds
2017-12-21 17:31:37,152: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cf1890>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:31:37,204: 17:31:37 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 141 in 51.25s]
2017-12-21 17:31:37,204: 17:31:37 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2017-12-21 17:31:37,205: Compiling model.parsely.parsely_campaigns
2017-12-21 17:31:37,211: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 17:31:37,211: Re-using an available connection from the pool.
2017-12-21 17:31:37,212: Using redshift connection "parsely_campaigns".
2017-12-21 17:31:37,212: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:31:37,233: SQL status: SELECT in 0.02 seconds
2017-12-21 17:31:37,239: Writing injected SQL for node "model.parsely.parsely_campaigns"
2017-12-21 17:31:37,244: Using redshift connection "parsely_campaigns".
2017-12-21 17:31:37,244: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:31:37,264: SQL status: SELECT in 0.02 seconds
2017-12-21 17:31:37,265: Using redshift connection "parsely_campaigns".
2017-12-21 17:31:37,265: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:31:37,284: SQL status: SELECT in 0.02 seconds
2017-12-21 17:31:37,286: Using redshift connection "parsely_campaigns".
2017-12-21 17:31:37,286: On parsely_campaigns: BEGIN
2017-12-21 17:31:37,288: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:31:37,288: Using redshift connection "parsely_campaigns".
2017-12-21 17:31:37,288: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:31:39,814: SQL status: SELECT in 2.53 seconds
2017-12-21 17:31:39,814: Using redshift connection "parsely_campaigns".
2017-12-21 17:31:39,815: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2017-12-21 17:31:39,972: SQL status: SELECT in 0.16 seconds
2017-12-21 17:31:39,972: Using redshift connection "parsely_campaigns".
2017-12-21 17:31:39,972: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:31:40,090: SQL status: SELECT in 0.12 seconds
2017-12-21 17:31:40,090: Using redshift connection "parsely_campaigns".
2017-12-21 17:31:40,090: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:31:40,199: SQL status: SELECT in 0.11 seconds
2017-12-21 17:31:40,201: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2017-12-21 17:31:40,202: Using redshift connection "parsely_campaigns".
2017-12-21 17:31:40,202: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2017-12-21 17:31:40,348: SQL status: INSERT 0 382 in 0.15 seconds
2017-12-21 17:31:40,349: On parsely_campaigns: COMMIT
2017-12-21 17:31:40,349: Using redshift connection "parsely_campaigns".
2017-12-21 17:31:40,349: On parsely_campaigns: COMMIT
2017-12-21 17:31:40,710: SQL status: COMMIT in 0.36 seconds
2017-12-21 17:31:40,711: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05c90bd0>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:31:40,763: 17:31:40 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 382 in 3.51s]
2017-12-21 17:31:40,763: Compiling model.parsely.parsely_incoming_users
2017-12-21 17:31:40,790: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 17:31:40,797: 17:31:40 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2017-12-21 17:31:40,797: Compiling model.parsely.parsely_users
2017-12-21 17:31:40,809: Acquiring new redshift connection "parsely_users".
2017-12-21 17:31:40,809: Re-using an available connection from the pool.
2017-12-21 17:31:40,809: Using redshift connection "parsely_users".
2017-12-21 17:31:40,809: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:31:40,831: SQL status: SELECT in 0.02 seconds
2017-12-21 17:31:40,976: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 17:31:40,978: Using redshift connection "parsely_users".
2017-12-21 17:31:40,979: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:31:41,000: SQL status: SELECT in 0.02 seconds
2017-12-21 17:31:41,000: Using redshift connection "parsely_users".
2017-12-21 17:31:41,000: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:31:41,020: SQL status: SELECT in 0.02 seconds
2017-12-21 17:31:41,023: Using redshift connection "parsely_users".
2017-12-21 17:31:41,024: On parsely_users: BEGIN
2017-12-21 17:31:41,026: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:31:41,026: Using redshift connection "parsely_users".
2017-12-21 17:31:41,026: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3,4
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      visitor_ip,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3,4
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      visitor_ip,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3,4
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id, visitor_ip)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        visitor_ip,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3,4


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    visitor_ip,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:31:42,640: SQL status: SELECT in 1.61 seconds
2017-12-21 17:31:42,640: Using redshift connection "parsely_users".
2017-12-21 17:31:42,640: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2017-12-21 17:31:42,831: SQL status: SELECT in 0.19 seconds
2017-12-21 17:31:42,831: Using redshift connection "parsely_users".
2017-12-21 17:31:42,831: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:31:42,937: SQL status: SELECT in 0.11 seconds
2017-12-21 17:31:42,938: Using redshift connection "parsely_users".
2017-12-21 17:31:42,938: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:31:43,045: SQL status: SELECT in 0.11 seconds
2017-12-21 17:31:43,047: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 17:31:43,048: Using redshift connection "parsely_users".
2017-12-21 17:31:43,048: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_ip", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2017-12-21 17:31:43,281: SQL status: INSERT 0 59375 in 0.23 seconds
2017-12-21 17:31:43,281: On parsely_users: COMMIT
2017-12-21 17:31:43,281: Using redshift connection "parsely_users".
2017-12-21 17:31:43,282: On parsely_users: COMMIT
2017-12-21 17:31:44,009: SQL status: COMMIT in 0.73 seconds
2017-12-21 17:31:44,010: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cffed0>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:31:44,061: 17:31:44 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 59375 in 3.21s]
2017-12-21 17:31:44,068: 17:31:44 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2017-12-21 17:31:44,068: Compiling model.parsely.parsely_pageview_engagedtime
2017-12-21 17:31:44,215: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 17:31:44,217: Acquiring new redshift connection "parsely_pageview_engagedtime".
2017-12-21 17:31:44,218: Re-using an available connection from the pool.
2017-12-21 17:31:44,218: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 17:31:44,218: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:31:44,240: SQL status: SELECT in 0.02 seconds
2017-12-21 17:31:44,243: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 17:31:44,244: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 17:31:44,245: On parsely_pageview_engagedtime: BEGIN
2017-12-21 17:31:44,252: SQL status: BEGIN in 0.01 seconds
2017-12-21 17:31:44,252: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 17:31:44,252: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2017-12-21 17:31:44,528: SQL status: CREATE VIEW in 0.28 seconds
2017-12-21 17:31:44,529: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 17:31:44,529: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2017-12-21 17:31:44,533: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 17:31:44,533: On parsely_pageview_engagedtime: COMMIT
2017-12-21 17:31:44,533: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 17:31:44,533: On parsely_pageview_engagedtime: COMMIT
2017-12-21 17:31:44,734: SQL status: COMMIT in 0.20 seconds
2017-12-21 17:31:44,735: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cffd50>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:31:44,784: 17:31:44 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.67s]
2017-12-21 17:31:44,792: 17:31:44 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2017-12-21 17:31:44,792: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 17:31:44,804: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 17:31:44,824: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 17:31:44,824: Re-using an available connection from the pool.
2017-12-21 17:31:44,825: Using redshift connection "parsely_incoming_sessions".
2017-12-21 17:31:44,825: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:31:44,846: SQL status: SELECT in 0.02 seconds
2017-12-21 17:31:44,850: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 17:31:44,851: Using redshift connection "parsely_incoming_sessions".
2017-12-21 17:31:44,851: On parsely_incoming_sessions: BEGIN
2017-12-21 17:31:44,856: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:31:44,856: Using redshift connection "parsely_incoming_sessions".
2017-12-21 17:31:44,856: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 17:31:44,921: SQL status: CREATE VIEW in 0.06 seconds
2017-12-21 17:31:44,921: Using redshift connection "parsely_incoming_sessions".
2017-12-21 17:31:44,922: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 17:31:44,925: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 17:31:44,925: On parsely_incoming_sessions: COMMIT
2017-12-21 17:31:44,925: Using redshift connection "parsely_incoming_sessions".
2017-12-21 17:31:44,925: On parsely_incoming_sessions: COMMIT
2017-12-21 17:31:45,368: SQL status: COMMIT in 0.44 seconds
2017-12-21 17:31:45,368: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05c764d0>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:31:45,420: 17:31:45 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.58s]
2017-12-21 17:31:45,420: 17:31:45 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2017-12-21 17:31:45,421: Compiling model.parsely.parsely_pageview_behavior_workflow
2017-12-21 17:31:45,453: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 17:31:45,455: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 17:31:45,455: Re-using an available connection from the pool.
2017-12-21 17:31:45,456: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 17:31:45,456: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:31:45,477: SQL status: SELECT in 0.02 seconds
2017-12-21 17:31:45,478: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 17:31:45,478: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:31:45,497: SQL status: SELECT in 0.02 seconds
2017-12-21 17:31:45,500: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 17:31:45,500: On parsely_pageview_behavior_workflow: BEGIN
2017-12-21 17:31:45,508: SQL status: BEGIN in 0.01 seconds
2017-12-21 17:31:45,508: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 17:31:45,508: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:32:35,564: SQL status: SELECT in 50.06 seconds
2017-12-21 17:32:35,565: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 17:32:35,565: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 17:32:35,834: SQL status: SELECT in 0.27 seconds
2017-12-21 17:32:35,835: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 17:32:35,835: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:32:35,948: SQL status: SELECT in 0.11 seconds
2017-12-21 17:32:35,949: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 17:32:35,950: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:32:36,065: SQL status: SELECT in 0.12 seconds
2017-12-21 17:32:36,071: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 17:32:36,088: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 17:32:36,088: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 17:32:38,538: SQL status: INSERT 0 107331 in 2.45 seconds
2017-12-21 17:32:38,539: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 17:32:38,539: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 17:32:38,539: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 17:32:39,813: SQL status: COMMIT in 1.27 seconds
2017-12-21 17:32:39,813: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cf1890>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:32:39,891: 17:32:39 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 107331 in 54.39s]
2017-12-21 17:32:39,893: 17:32:39 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2017-12-21 17:32:39,894: Compiling model.parsely.parsely_sessions
2017-12-21 17:32:39,925: Acquiring new redshift connection "parsely_sessions".
2017-12-21 17:32:39,925: Re-using an available connection from the pool.
2017-12-21 17:32:39,925: Using redshift connection "parsely_sessions".
2017-12-21 17:32:39,925: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:32:39,948: SQL status: SELECT in 0.02 seconds
2017-12-21 17:32:39,953: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 17:32:39,955: Using redshift connection "parsely_sessions".
2017-12-21 17:32:39,955: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:32:39,977: SQL status: SELECT in 0.02 seconds
2017-12-21 17:32:39,978: Using redshift connection "parsely_sessions".
2017-12-21 17:32:39,978: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 17:32:39,999: SQL status: SELECT in 0.02 seconds
2017-12-21 17:32:40,004: Using redshift connection "parsely_sessions".
2017-12-21 17:32:40,004: On parsely_sessions: BEGIN
2017-12-21 17:32:40,007: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:32:40,007: Using redshift connection "parsely_sessions".
2017-12-21 17:32:40,007: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 17:36:53,956: SQL status: SELECT in 253.95 seconds
2017-12-21 17:36:53,956: Using redshift connection "parsely_sessions".
2017-12-21 17:36:53,958: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2017-12-21 17:36:54,437: SQL status: SELECT in 0.48 seconds
2017-12-21 17:36:54,438: Using redshift connection "parsely_sessions".
2017-12-21 17:36:54,438: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:36:54,718: SQL status: SELECT in 0.28 seconds
2017-12-21 17:36:54,720: Using redshift connection "parsely_sessions".
2017-12-21 17:36:54,720: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 17:36:55,065: SQL status: SELECT in 0.34 seconds
2017-12-21 17:36:55,070: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 17:36:55,071: Using redshift connection "parsely_sessions".
2017-12-21 17:36:55,071: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2017-12-21 17:37:19,522: SQL status: INSERT 0 87122 in 24.45 seconds
2017-12-21 17:37:19,523: On parsely_sessions: COMMIT
2017-12-21 17:37:19,523: Using redshift connection "parsely_sessions".
2017-12-21 17:37:19,523: On parsely_sessions: COMMIT
2017-12-21 17:37:21,445: SQL status: COMMIT in 1.92 seconds
2017-12-21 17:37:21,446: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05cf1f90>], 'label': '7e28d018-010e-4660-9ff6-7a1a6260727c'}
2017-12-21 17:37:21,508: 17:37:21 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 87122 in 281.55s]
2017-12-21 17:37:21,602: Using redshift connection "master".
2017-12-21 17:37:21,602: On master: BEGIN
2017-12-21 17:37:21,604: SQL status: BEGIN in 0.00 seconds
2017-12-21 17:37:21,605: On master: COMMIT
2017-12-21 17:37:21,605: Using redshift connection "master".
2017-12-21 17:37:21,605: On master: COMMIT
2017-12-21 17:37:21,607: SQL status: COMMIT in 0.00 seconds
2017-12-21 17:37:21,607: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 17:37:21,640: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 17:37:21,641: Using redshift connection "master".
2017-12-21 17:37:21,641: On master:  select 1 
2017-12-21 17:37:21,643: SQL status: SELECT in 0.00 seconds
2017-12-21 17:37:21,644: 17:37:21 | 
2017-12-21 17:37:21,644: 17:37:21 | Finished running 10 view models, 15 incremental models in 964.02s.
2017-12-21 17:37:21,644: 
2017-12-21 17:37:21,645: Completed successfully
2017-12-21 17:37:21,645: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2017-12-21 17:37:21,645: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05d97250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05d974d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f3a05d7e990>], 'label': 'end'}
2017-12-21 17:37:21,725: Flushing usage events
2017-12-21 18:08:30,494: Tracking: tracking
2017-12-21 18:08:30,494: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f52c7af9250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f52c7af94d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f52c7af9310>], 'label': 'start'}
2017-12-21 18:08:30,582: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 18:08:30,623: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 18:08:30,625: Parsing core.sql
2017-12-21 18:08:30,648: Parsing etc/get_custom_schema.sql
2017-12-21 18:08:30,659: Parsing schema_tests/relationships.sql
2017-12-21 18:08:30,664: Parsing schema_tests/accepted_values.sql
2017-12-21 18:08:30,669: Parsing schema_tests/not_null.sql
2017-12-21 18:08:30,672: Parsing schema_tests/unique.sql
2017-12-21 18:08:30,676: Parsing materializations/wrapper.sql
2017-12-21 18:08:30,683: Parsing materializations/archive.sql
2017-12-21 18:08:30,740: Parsing materializations/table.sql
2017-12-21 18:08:30,775: Parsing materializations/helpers.sql
2017-12-21 18:08:30,826: Parsing materializations/bigquery.sql
2017-12-21 18:08:30,863: Parsing materializations/view.sql
2017-12-21 18:08:30,903: Parsing materializations/incremental.sql
2017-12-21 18:08:30,978: Parsing adapters/redshift.sql
2017-12-21 18:08:31,027: Parsing adapters/bigquery.sql
2017-12-21 18:08:31,035: Parsing adapters/postgres.sql
2017-12-21 18:08:31,040: Parsing adapters/common.sql
2017-12-21 18:08:31,072: Parsing model.parsely.parsely_audit
2017-12-21 18:08:31,074: Parsing model.parsely.parsely_video_content
2017-12-21 18:08:31,077: Parsing model.parsely.parsely_post_content
2017-12-21 18:08:31,080: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 18:08:31,082: Parsing model.parsely.parsely_rawdata
2017-12-21 18:08:31,085: Parsing model.parsely.calendar
2017-12-21 18:08:31,087: Parsing model.parsely.parsely_all_events
2017-12-21 18:08:31,102: Acquiring new redshift connection "parsely_all_events".
2017-12-21 18:08:31,103: Opening a new connection (0 currently allocated)
2017-12-21 18:08:31,150: Using redshift connection "parsely_all_events".
2017-12-21 18:08:31,150: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,177: SQL status: SELECT in 0.03 seconds
2017-12-21 18:08:31,192: Parsing model.parsely.parsely_event_ids
2017-12-21 18:08:31,196: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 18:08:31,201: Parsing model.parsely.parsely_base_events
2017-12-21 18:08:31,212: Acquiring new redshift connection "parsely_base_events".
2017-12-21 18:08:31,212: Re-using an available connection from the pool.
2017-12-21 18:08:31,213: Using redshift connection "parsely_base_events".
2017-12-21 18:08:31,213: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,234: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:31,235: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 18:08:31,250: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 18:08:31,262: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 18:08:31,266: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 18:08:31,278: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 18:08:31,283: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 18:08:31,306: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 18:08:31,322: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 18:08:31,340: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:08:31,340: Re-using an available connection from the pool.
2017-12-21 18:08:31,340: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:08:31,340: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,362: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:31,364: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 18:08:31,385: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 18:08:31,402: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:08:31,402: Re-using an available connection from the pool.
2017-12-21 18:08:31,402: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:08:31,402: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,423: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:31,425: Parsing model.parsely.parsely_incoming_users
2017-12-21 18:08:31,430: Parsing model.parsely.parsely_users
2017-12-21 18:08:31,451: Acquiring new redshift connection "parsely_users".
2017-12-21 18:08:31,451: Re-using an available connection from the pool.
2017-12-21 18:08:31,452: Using redshift connection "parsely_users".
2017-12-21 18:08:31,452: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,473: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:31,475: Parsing model.parsely.parsely_errors
2017-12-21 18:08:31,490: Parsing model.parsely.parsely_bot_traffic
2017-12-21 18:08:31,501: Parsing model.parsely.parsely_custom_events
2017-12-21 18:08:31,518: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 18:08:31,533: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 18:08:31,538: Parsing model.parsely.parsely_sessions
2017-12-21 18:08:31,561: Acquiring new redshift connection "parsely_sessions".
2017-12-21 18:08:31,561: Re-using an available connection from the pool.
2017-12-21 18:08:31,561: Using redshift connection "parsely_sessions".
2017-12-21 18:08:31,561: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,583: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:31,584: Parsing model.parsely.parsely_campaigns
2017-12-21 18:08:31,591: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 18:08:31,591: Re-using an available connection from the pool.
2017-12-21 18:08:31,591: Using redshift connection "parsely_campaigns".
2017-12-21 18:08:31,592: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,613: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:31,625: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 18:08:31,635: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 18:08:31,642: 
2017-12-21 18:08:31,647: Acquiring new redshift connection "master".
2017-12-21 18:08:31,647: Re-using an available connection from the pool.
2017-12-21 18:08:31,647: Using redshift connection "master".
2017-12-21 18:08:31,647: On master: select distinct nspname from pg_namespace
2017-12-21 18:08:31,649: SQL status: SELECT in 0.00 seconds
2017-12-21 18:08:31,654: Using redshift connection "master".
2017-12-21 18:08:31,654: On master: BEGIN
2017-12-21 18:08:31,656: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:08:31,656: On master: COMMIT
2017-12-21 18:08:31,656: Using redshift connection "master".
2017-12-21 18:08:31,656: On master: COMMIT
2017-12-21 18:08:31,658: SQL status: COMMIT in 0.00 seconds
2017-12-21 18:08:31,667: 18:08:31 | Concurrency: 1 threads (target='dev')
2017-12-21 18:08:31,667: 18:08:31 | 
2017-12-21 18:08:31,668: Using redshift connection "master".
2017-12-21 18:08:31,668: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,690: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:31,711: Compiling model.parsely.parsely_incoming_users
2017-12-21 18:08:31,720: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 18:08:31,721: 18:08:31 | 1 of 3 START incremental model blog_dbt_dev.parsely_users............ [RUN]
2017-12-21 18:08:31,722: Compiling model.parsely.parsely_users
2017-12-21 18:08:31,731: Acquiring new redshift connection "parsely_users".
2017-12-21 18:08:31,731: Opening a new connection (1 currently allocated)
2017-12-21 18:08:31,749: Using redshift connection "parsely_users".
2017-12-21 18:08:31,750: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,776: SQL status: SELECT in 0.03 seconds
2017-12-21 18:08:31,937: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 18:08:31,941: Using redshift connection "parsely_users".
2017-12-21 18:08:31,941: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,962: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:31,963: Using redshift connection "parsely_users".
2017-12-21 18:08:31,963: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:31,984: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:31,989: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 18:08:31,990: Using redshift connection "parsely_users".
2017-12-21 18:08:31,991: On parsely_users: BEGIN
2017-12-21 18:08:31,996: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:08:31,996: Using redshift connection "parsely_users".
2017-12-21 18:08:31,996: On parsely_users: 
    
  

  create  table "blog_dbt_dev"."parsely_users"
  
  
  as (
    -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



-- initial run, don't merge
merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        date(min(last_timestamp)) as date_first_seen,
        date(max(last_timestamp)) as date_last_seen,
        -- metrics to aggregate
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from incoming_users
    group by 1,2,3
)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
  );
2017-12-21 18:08:50,264: SQL status: SELECT in 18.27 seconds
2017-12-21 18:08:50,264: On parsely_users: COMMIT
2017-12-21 18:08:50,265: Using redshift connection "parsely_users".
2017-12-21 18:08:50,265: On parsely_users: COMMIT
2017-12-21 18:08:50,641: SQL status: COMMIT in 0.38 seconds
2017-12-21 18:08:50,642: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f52c7a610d0>], 'label': '67ccee8d-fac2-4947-a886-3f95d9666cc5'}
2017-12-21 18:08:50,679: 18:08:50 | 1 of 3 OK created incremental model blog_dbt_dev.parsely_users....... [SELECT in 18.92s]
2017-12-21 18:08:50,684: 18:08:50 | 2 of 3 START view model blog_dbt_dev.parsely_incoming_sessions....... [RUN]
2017-12-21 18:08:50,684: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 18:08:50,708: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 18:08:50,710: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 18:08:50,710: Re-using an available connection from the pool.
2017-12-21 18:08:50,710: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:08:50,710: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:50,734: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:50,738: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 18:08:50,739: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:08:50,739: On parsely_incoming_sessions: BEGIN
2017-12-21 18:08:50,748: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:08:50,748: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:08:50,748: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 18:08:50,831: SQL status: CREATE VIEW in 0.08 seconds
2017-12-21 18:08:50,832: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:08:50,832: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 18:08:50,837: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:08:50,837: On parsely_incoming_sessions: COMMIT
2017-12-21 18:08:50,837: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:08:50,837: On parsely_incoming_sessions: COMMIT
2017-12-21 18:08:51,033: SQL status: COMMIT in 0.20 seconds
2017-12-21 18:08:51,034: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f52c7aaef50>], 'label': '67ccee8d-fac2-4947-a886-3f95d9666cc5'}
2017-12-21 18:08:51,089: 18:08:51 | 2 of 3 OK created view model blog_dbt_dev.parsely_incoming_sessions.. [CREATE VIEW in 0.35s]
2017-12-21 18:08:51,096: 18:08:51 | 3 of 3 START incremental model blog_dbt_dev.parsely_sessions......... [RUN]
2017-12-21 18:08:51,096: Compiling model.parsely.parsely_sessions
2017-12-21 18:08:51,107: Acquiring new redshift connection "parsely_sessions".
2017-12-21 18:08:51,107: Re-using an available connection from the pool.
2017-12-21 18:08:51,107: Using redshift connection "parsely_sessions".
2017-12-21 18:08:51,107: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:51,130: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:51,135: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 18:08:51,145: Using redshift connection "parsely_sessions".
2017-12-21 18:08:51,145: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:51,167: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:51,168: Using redshift connection "parsely_sessions".
2017-12-21 18:08:51,168: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:08:51,188: SQL status: SELECT in 0.02 seconds
2017-12-21 18:08:51,193: Using redshift connection "parsely_sessions".
2017-12-21 18:08:51,193: On parsely_sessions: BEGIN
2017-12-21 18:08:51,195: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:08:51,195: Using redshift connection "parsely_sessions".
2017-12-21 18:08:51,195: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:11:52,346: SQL status: SELECT in 181.15 seconds
2017-12-21 18:11:52,347: Using redshift connection "parsely_sessions".
2017-12-21 18:11:52,347: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2017-12-21 18:11:52,610: SQL status: SELECT in 0.26 seconds
2017-12-21 18:11:52,611: Using redshift connection "parsely_sessions".
2017-12-21 18:11:52,611: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:11:52,730: SQL status: SELECT in 0.12 seconds
2017-12-21 18:11:52,732: Using redshift connection "parsely_sessions".
2017-12-21 18:11:52,732: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:11:52,841: SQL status: SELECT in 0.11 seconds
2017-12-21 18:11:52,847: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 18:11:52,848: Using redshift connection "parsely_sessions".
2017-12-21 18:11:52,848: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2017-12-21 18:11:54,425: SQL status: INSERT 0 87122 in 1.57 seconds
2017-12-21 18:11:54,426: On parsely_sessions: COMMIT
2017-12-21 18:11:54,426: Using redshift connection "parsely_sessions".
2017-12-21 18:11:54,426: On parsely_sessions: COMMIT
2017-12-21 18:11:55,658: SQL status: COMMIT in 1.23 seconds
2017-12-21 18:11:55,659: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f52c7a4a510>], 'label': '67ccee8d-fac2-4947-a886-3f95d9666cc5'}
2017-12-21 18:11:55,720: 18:11:55 | 3 of 3 OK created incremental model blog_dbt_dev.parsely_sessions.... [INSERT 0 87122 in 184.56s]
2017-12-21 18:11:55,762: 
2017-12-21 18:11:55,772: Exited because of keyboard interrupt.
2017-12-21 18:11:55,772: 
Done. PASS=2 ERROR=0 SKIP=0 TOTAL=2
2017-12-21 18:11:55,773: Connection 'master' was left open.
2017-12-21 18:11:55,773: ctrl-c
2017-12-21 18:12:37,931: Tracking: tracking
2017-12-21 18:12:37,931: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5b21250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5b214d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5b21310>], 'label': 'start'}
2017-12-21 18:12:37,995: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 18:12:38,072: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 18:12:38,074: Parsing core.sql
2017-12-21 18:12:38,129: Parsing etc/get_custom_schema.sql
2017-12-21 18:12:38,147: Parsing schema_tests/relationships.sql
2017-12-21 18:12:38,164: Parsing schema_tests/accepted_values.sql
2017-12-21 18:12:38,178: Parsing schema_tests/not_null.sql
2017-12-21 18:12:38,181: Parsing schema_tests/unique.sql
2017-12-21 18:12:38,192: Parsing materializations/wrapper.sql
2017-12-21 18:12:38,198: Parsing materializations/archive.sql
2017-12-21 18:12:38,323: Parsing materializations/table.sql
2017-12-21 18:12:38,399: Parsing materializations/helpers.sql
2017-12-21 18:12:38,459: Parsing materializations/bigquery.sql
2017-12-21 18:12:38,517: Parsing materializations/view.sql
2017-12-21 18:12:38,599: Parsing materializations/incremental.sql
2017-12-21 18:12:38,715: Parsing adapters/redshift.sql
2017-12-21 18:12:38,739: Parsing adapters/bigquery.sql
2017-12-21 18:12:38,743: Parsing adapters/postgres.sql
2017-12-21 18:12:38,746: Parsing adapters/common.sql
2017-12-21 18:12:38,764: Parsing model.parsely.parsely_audit
2017-12-21 18:12:38,765: Parsing model.parsely.parsely_video_content
2017-12-21 18:12:38,768: Parsing model.parsely.parsely_post_content
2017-12-21 18:12:38,771: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 18:12:38,774: Parsing model.parsely.parsely_rawdata
2017-12-21 18:12:38,777: Parsing model.parsely.calendar
2017-12-21 18:12:38,780: Parsing model.parsely.parsely_all_events
2017-12-21 18:12:38,795: Acquiring new redshift connection "parsely_all_events".
2017-12-21 18:12:38,795: Opening a new connection (0 currently allocated)
2017-12-21 18:12:38,870: Using redshift connection "parsely_all_events".
2017-12-21 18:12:38,870: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:38,896: SQL status: SELECT in 0.03 seconds
2017-12-21 18:12:38,916: Parsing model.parsely.parsely_event_ids
2017-12-21 18:12:38,932: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 18:12:38,937: Parsing model.parsely.parsely_base_events
2017-12-21 18:12:38,952: Acquiring new redshift connection "parsely_base_events".
2017-12-21 18:12:38,952: Re-using an available connection from the pool.
2017-12-21 18:12:38,952: Using redshift connection "parsely_base_events".
2017-12-21 18:12:38,952: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:38,976: SQL status: SELECT in 0.02 seconds
2017-12-21 18:12:38,977: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 18:12:38,987: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 18:12:39,010: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 18:12:39,022: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 18:12:39,025: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 18:12:39,031: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 18:12:39,048: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 18:12:39,080: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 18:12:39,101: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:12:39,101: Re-using an available connection from the pool.
2017-12-21 18:12:39,101: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:12:39,101: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:39,125: SQL status: SELECT in 0.02 seconds
2017-12-21 18:12:39,126: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 18:12:39,146: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 18:12:39,163: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:12:39,163: Re-using an available connection from the pool.
2017-12-21 18:12:39,163: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:12:39,163: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:39,187: SQL status: SELECT in 0.02 seconds
2017-12-21 18:12:39,189: Parsing model.parsely.parsely_incoming_users
2017-12-21 18:12:39,194: Parsing model.parsely.parsely_users
2017-12-21 18:12:39,213: Acquiring new redshift connection "parsely_users".
2017-12-21 18:12:39,213: Re-using an available connection from the pool.
2017-12-21 18:12:39,213: Using redshift connection "parsely_users".
2017-12-21 18:12:39,213: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:39,234: SQL status: SELECT in 0.02 seconds
2017-12-21 18:12:39,236: Parsing model.parsely.parsely_errors
2017-12-21 18:12:39,243: Parsing model.parsely.parsely_bot_traffic
2017-12-21 18:12:39,258: Parsing model.parsely.parsely_custom_events
2017-12-21 18:12:39,275: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 18:12:39,289: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 18:12:39,305: Parsing model.parsely.parsely_sessions
2017-12-21 18:12:39,326: Acquiring new redshift connection "parsely_sessions".
2017-12-21 18:12:39,326: Re-using an available connection from the pool.
2017-12-21 18:12:39,327: Using redshift connection "parsely_sessions".
2017-12-21 18:12:39,327: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:39,351: SQL status: SELECT in 0.02 seconds
2017-12-21 18:12:39,352: Parsing model.parsely.parsely_campaigns
2017-12-21 18:12:39,359: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 18:12:39,359: Re-using an available connection from the pool.
2017-12-21 18:12:39,359: Using redshift connection "parsely_campaigns".
2017-12-21 18:12:39,359: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:39,383: SQL status: SELECT in 0.02 seconds
2017-12-21 18:12:39,395: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 18:12:39,424: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 18:12:39,445: 
2017-12-21 18:12:39,450: Acquiring new redshift connection "master".
2017-12-21 18:12:39,450: Re-using an available connection from the pool.
2017-12-21 18:12:39,450: Using redshift connection "master".
2017-12-21 18:12:39,450: On master: select distinct nspname from pg_namespace
2017-12-21 18:12:39,453: SQL status: SELECT in 0.00 seconds
2017-12-21 18:12:39,458: Using redshift connection "master".
2017-12-21 18:12:39,458: On master: BEGIN
2017-12-21 18:12:39,459: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:12:39,459: On master: COMMIT
2017-12-21 18:12:39,460: Using redshift connection "master".
2017-12-21 18:12:39,460: On master: COMMIT
2017-12-21 18:12:39,461: SQL status: COMMIT in 0.00 seconds
2017-12-21 18:12:39,471: 18:12:39 | Concurrency: 1 threads (target='dev')
2017-12-21 18:12:39,471: 18:12:39 | 
2017-12-21 18:12:39,472: Using redshift connection "master".
2017-12-21 18:12:39,472: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:39,495: SQL status: SELECT in 0.02 seconds
2017-12-21 18:12:39,671: 18:12:39 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-21 18:12:39,671: Compiling model.parsely.calendar
2017-12-21 18:12:39,678: Writing injected SQL for node "model.parsely.calendar"
2017-12-21 18:12:39,680: Acquiring new redshift connection "calendar".
2017-12-21 18:12:39,680: Opening a new connection (1 currently allocated)
2017-12-21 18:12:39,698: Using redshift connection "calendar".
2017-12-21 18:12:39,698: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:39,726: SQL status: SELECT in 0.03 seconds
2017-12-21 18:12:39,730: Writing runtime SQL for node "model.parsely.calendar"
2017-12-21 18:12:39,731: Using redshift connection "calendar".
2017-12-21 18:12:39,731: On calendar: BEGIN
2017-12-21 18:12:39,740: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:12:39,740: Using redshift connection "calendar".
2017-12-21 18:12:39,740: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-21 18:12:39,858: SQL status: CREATE VIEW in 0.12 seconds
2017-12-21 18:12:39,859: On calendar: COMMIT
2017-12-21 18:12:39,859: Using redshift connection "calendar".
2017-12-21 18:12:39,860: On calendar: COMMIT
2017-12-21 18:12:40,271: SQL status: COMMIT in 0.41 seconds
2017-12-21 18:12:40,272: Using redshift connection "calendar".
2017-12-21 18:12:40,272: On calendar: BEGIN
2017-12-21 18:12:40,274: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:12:40,274: Using redshift connection "calendar".
2017-12-21 18:12:40,274: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-21 18:12:40,716: SQL status: DROP VIEW in 0.44 seconds
2017-12-21 18:12:40,716: On calendar: COMMIT
2017-12-21 18:12:40,716: Using redshift connection "calendar".
2017-12-21 18:12:40,716: On calendar: COMMIT
2017-12-21 18:12:41,171: SQL status: COMMIT in 0.45 seconds
2017-12-21 18:12:41,171: Using redshift connection "calendar".
2017-12-21 18:12:41,172: On calendar: BEGIN
2017-12-21 18:12:41,174: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:12:41,174: Using redshift connection "calendar".
2017-12-21 18:12:41,174: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-21 18:12:41,193: SQL status: ALTER TABLE in 0.02 seconds
2017-12-21 18:12:41,193: On calendar: COMMIT
2017-12-21 18:12:41,193: Using redshift connection "calendar".
2017-12-21 18:12:41,193: On calendar: COMMIT
2017-12-21 18:12:41,396: SQL status: COMMIT in 0.20 seconds
2017-12-21 18:12:41,397: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a1a350>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:12:41,473: 18:12:41 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.73s]
2017-12-21 18:12:41,474: 18:12:41 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-21 18:12:41,474: Compiling model.parsely.parsely_rawdata
2017-12-21 18:12:41,501: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-21 18:12:41,503: Acquiring new redshift connection "parsely_rawdata".
2017-12-21 18:12:41,503: Re-using an available connection from the pool.
2017-12-21 18:12:41,503: Using redshift connection "parsely_rawdata".
2017-12-21 18:12:41,504: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:41,526: SQL status: SELECT in 0.02 seconds
2017-12-21 18:12:41,526: Using redshift connection "parsely_rawdata".
2017-12-21 18:12:41,527: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:12:41,538: SQL status: SELECT in 0.01 seconds
2017-12-21 18:12:41,540: Using redshift connection "parsely_rawdata".
2017-12-21 18:12:41,540: On parsely_rawdata: BEGIN
2017-12-21 18:12:41,542: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:12:41,542: Using redshift connection "parsely_rawdata".
2017-12-21 18:12:41,542: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:13:09,456: SQL status: SELECT in 27.91 seconds
2017-12-21 18:13:09,457: Using redshift connection "parsely_rawdata".
2017-12-21 18:13:09,457: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-21 18:13:09,696: SQL status: SELECT in 0.24 seconds
2017-12-21 18:13:09,698: Using redshift connection "parsely_rawdata".
2017-12-21 18:13:09,698: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:13:09,811: SQL status: SELECT in 0.11 seconds
2017-12-21 18:13:09,812: Using redshift connection "parsely_rawdata".
2017-12-21 18:13:09,813: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:13:09,929: SQL status: SELECT in 0.12 seconds
2017-12-21 18:13:09,934: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-21 18:13:09,936: Using redshift connection "parsely_rawdata".
2017-12-21 18:13:09,936: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-21 18:13:39,929: SQL status: INSERT 0 1015763 in 29.99 seconds
2017-12-21 18:13:39,929: On parsely_rawdata: COMMIT
2017-12-21 18:13:39,929: Using redshift connection "parsely_rawdata".
2017-12-21 18:13:39,930: On parsely_rawdata: COMMIT
2017-12-21 18:13:41,923: SQL status: COMMIT in 1.99 seconds
2017-12-21 18:13:41,923: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5ad6e50>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:13:42,027: 18:13:42 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1015763 in 60.45s]
2017-12-21 18:13:42,036: 18:13:42 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-21 18:13:42,036: Compiling model.parsely.parsely_all_events
2017-12-21 18:13:42,064: Acquiring new redshift connection "parsely_all_events".
2017-12-21 18:13:42,076: Re-using an available connection from the pool.
2017-12-21 18:13:42,076: Using redshift connection "parsely_all_events".
2017-12-21 18:13:42,076: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:13:42,091: SQL status: SELECT in 0.01 seconds
2017-12-21 18:13:42,110: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-21 18:13:42,111: Using redshift connection "parsely_all_events".
2017-12-21 18:13:42,111: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:13:42,125: SQL status: SELECT in 0.01 seconds
2017-12-21 18:13:42,126: Using redshift connection "parsely_all_events".
2017-12-21 18:13:42,126: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:13:42,141: SQL status: SELECT in 0.01 seconds
2017-12-21 18:13:42,144: Using redshift connection "parsely_all_events".
2017-12-21 18:13:42,145: On parsely_all_events: BEGIN
2017-12-21 18:13:42,147: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:13:42,147: Using redshift connection "parsely_all_events".
2017-12-21 18:13:42,147: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:16:28,630: SQL status: SELECT in 166.48 seconds
2017-12-21 18:16:28,630: Using redshift connection "parsely_all_events".
2017-12-21 18:16:28,630: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2017-12-21 18:16:28,809: SQL status: SELECT in 0.18 seconds
2017-12-21 18:16:28,809: Using redshift connection "parsely_all_events".
2017-12-21 18:16:28,812: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:16:28,917: SQL status: SELECT in 0.11 seconds
2017-12-21 18:16:28,918: Using redshift connection "parsely_all_events".
2017-12-21 18:16:28,919: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:16:29,027: SQL status: SELECT in 0.11 seconds
2017-12-21 18:16:29,033: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-21 18:16:29,034: Using redshift connection "parsely_all_events".
2017-12-21 18:16:29,034: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2017-12-21 18:16:48,118: SQL status: INSERT 0 900273 in 19.08 seconds
2017-12-21 18:16:48,119: On parsely_all_events: COMMIT
2017-12-21 18:16:48,119: Using redshift connection "parsely_all_events".
2017-12-21 18:16:48,119: On parsely_all_events: COMMIT
2017-12-21 18:16:50,893: SQL status: COMMIT in 2.77 seconds
2017-12-21 18:16:50,893: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a89dd0>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:16:50,989: 18:16:50 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 900273 in 188.86s]
2017-12-21 18:16:50,990: 18:16:50 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-21 18:16:50,990: Compiling model.parsely.parsely_bot_traffic
2017-12-21 18:16:51,002: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 18:16:51,004: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-21 18:16:51,004: Re-using an available connection from the pool.
2017-12-21 18:16:51,005: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:16:51,005: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:16:51,020: SQL status: SELECT in 0.02 seconds
2017-12-21 18:16:51,021: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:16:51,021: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:16:51,036: SQL status: SELECT in 0.01 seconds
2017-12-21 18:16:51,040: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:16:51,040: On parsely_bot_traffic: BEGIN
2017-12-21 18:16:51,042: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:16:51,042: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:16:51,043: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:16:56,363: SQL status: SELECT in 5.32 seconds
2017-12-21 18:16:56,364: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:16:56,366: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2017-12-21 18:16:56,556: SQL status: SELECT in 0.19 seconds
2017-12-21 18:16:56,557: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:16:56,557: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:16:56,665: SQL status: SELECT in 0.11 seconds
2017-12-21 18:16:56,667: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:16:56,667: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:16:56,771: SQL status: SELECT in 0.10 seconds
2017-12-21 18:16:56,777: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 18:16:56,778: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:16:56,779: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2017-12-21 18:16:57,029: SQL status: INSERT 0 4 in 0.25 seconds
2017-12-21 18:16:57,029: On parsely_bot_traffic: COMMIT
2017-12-21 18:16:57,030: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:16:57,030: On parsely_bot_traffic: COMMIT
2017-12-21 18:16:58,739: SQL status: COMMIT in 1.71 seconds
2017-12-21 18:16:58,740: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5b1a310>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:16:58,779: 18:16:58 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 7.75s]
2017-12-21 18:16:58,780: 18:16:58 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-21 18:16:58,780: Compiling model.parsely.parsely_custom_events
2017-12-21 18:16:58,808: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-21 18:16:58,814: Acquiring new redshift connection "parsely_custom_events".
2017-12-21 18:16:58,814: Re-using an available connection from the pool.
2017-12-21 18:16:58,814: Using redshift connection "parsely_custom_events".
2017-12-21 18:16:58,814: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:16:58,829: SQL status: SELECT in 0.01 seconds
2017-12-21 18:16:58,829: Using redshift connection "parsely_custom_events".
2017-12-21 18:16:58,830: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:16:58,844: SQL status: SELECT in 0.01 seconds
2017-12-21 18:16:58,847: Using redshift connection "parsely_custom_events".
2017-12-21 18:16:58,847: On parsely_custom_events: BEGIN
2017-12-21 18:16:58,849: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:16:58,849: Using redshift connection "parsely_custom_events".
2017-12-21 18:16:58,850: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:17:06,324: SQL status: SELECT in 7.47 seconds
2017-12-21 18:17:06,325: Using redshift connection "parsely_custom_events".
2017-12-21 18:17:06,325: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2017-12-21 18:17:06,427: SQL status: SELECT in 0.10 seconds
2017-12-21 18:17:06,428: Using redshift connection "parsely_custom_events".
2017-12-21 18:17:06,428: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:06,534: SQL status: SELECT in 0.11 seconds
2017-12-21 18:17:06,535: Using redshift connection "parsely_custom_events".
2017-12-21 18:17:06,536: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:06,638: SQL status: SELECT in 0.10 seconds
2017-12-21 18:17:06,645: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-21 18:17:06,646: Using redshift connection "parsely_custom_events".
2017-12-21 18:17:06,646: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2017-12-21 18:17:06,898: SQL status: INSERT 0 0 in 0.25 seconds
2017-12-21 18:17:06,898: On parsely_custom_events: COMMIT
2017-12-21 18:17:06,898: Using redshift connection "parsely_custom_events".
2017-12-21 18:17:06,898: On parsely_custom_events: COMMIT
2017-12-21 18:17:07,227: SQL status: COMMIT in 0.33 seconds
2017-12-21 18:17:07,227: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a7b890>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:07,256: 18:17:07 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 8.45s]
2017-12-21 18:17:07,256: 18:17:07 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-21 18:17:07,257: Compiling model.parsely.parsely_errors
2017-12-21 18:17:07,264: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-21 18:17:07,265: Acquiring new redshift connection "parsely_errors".
2017-12-21 18:17:07,265: Re-using an available connection from the pool.
2017-12-21 18:17:07,265: Using redshift connection "parsely_errors".
2017-12-21 18:17:07,265: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:07,282: SQL status: SELECT in 0.02 seconds
2017-12-21 18:17:07,283: Using redshift connection "parsely_errors".
2017-12-21 18:17:07,283: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:07,296: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:07,298: Using redshift connection "parsely_errors".
2017-12-21 18:17:07,298: On parsely_errors: BEGIN
2017-12-21 18:17:07,300: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:07,300: Using redshift connection "parsely_errors".
2017-12-21 18:17:07,301: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:17:12,655: SQL status: SELECT in 5.35 seconds
2017-12-21 18:17:12,655: Using redshift connection "parsely_errors".
2017-12-21 18:17:12,656: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2017-12-21 18:17:12,862: SQL status: SELECT in 0.21 seconds
2017-12-21 18:17:12,862: Using redshift connection "parsely_errors".
2017-12-21 18:17:12,862: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:12,971: SQL status: SELECT in 0.11 seconds
2017-12-21 18:17:12,973: Using redshift connection "parsely_errors".
2017-12-21 18:17:12,973: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:13,078: SQL status: SELECT in 0.10 seconds
2017-12-21 18:17:13,084: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-21 18:17:13,085: Using redshift connection "parsely_errors".
2017-12-21 18:17:13,086: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2017-12-21 18:17:13,335: SQL status: INSERT 0 2 in 0.25 seconds
2017-12-21 18:17:13,335: On parsely_errors: COMMIT
2017-12-21 18:17:13,335: Using redshift connection "parsely_errors".
2017-12-21 18:17:13,336: On parsely_errors: COMMIT
2017-12-21 18:17:14,190: SQL status: COMMIT in 0.85 seconds
2017-12-21 18:17:14,191: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a899d0>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:14,224: 18:17:14 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 6.93s]
2017-12-21 18:17:14,225: 18:17:14 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-21 18:17:14,225: Compiling model.parsely.parsely_base_events
2017-12-21 18:17:14,229: Acquiring new redshift connection "parsely_base_events".
2017-12-21 18:17:14,229: Re-using an available connection from the pool.
2017-12-21 18:17:14,229: Using redshift connection "parsely_base_events".
2017-12-21 18:17:14,229: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:14,244: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:14,248: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-21 18:17:14,250: Using redshift connection "parsely_base_events".
2017-12-21 18:17:14,251: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:14,265: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:14,267: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-21 18:17:14,268: Using redshift connection "parsely_base_events".
2017-12-21 18:17:14,268: On parsely_base_events: BEGIN
2017-12-21 18:17:14,270: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:14,271: Using redshift connection "parsely_base_events".
2017-12-21 18:17:14,271: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-21 18:17:16,139: SQL status: CREATE VIEW in 1.87 seconds
2017-12-21 18:17:16,140: On parsely_base_events: COMMIT
2017-12-21 18:17:16,140: Using redshift connection "parsely_base_events".
2017-12-21 18:17:16,140: On parsely_base_events: COMMIT
2017-12-21 18:17:16,473: SQL status: COMMIT in 0.33 seconds
2017-12-21 18:17:16,473: Using redshift connection "parsely_base_events".
2017-12-21 18:17:16,473: On parsely_base_events: BEGIN
2017-12-21 18:17:16,475: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:16,475: Using redshift connection "parsely_base_events".
2017-12-21 18:17:16,476: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2017-12-21 18:17:16,647: SQL status: DROP VIEW in 0.17 seconds
2017-12-21 18:17:16,647: On parsely_base_events: COMMIT
2017-12-21 18:17:16,647: Using redshift connection "parsely_base_events".
2017-12-21 18:17:16,647: On parsely_base_events: COMMIT
2017-12-21 18:17:16,824: SQL status: COMMIT in 0.18 seconds
2017-12-21 18:17:16,824: Using redshift connection "parsely_base_events".
2017-12-21 18:17:16,824: On parsely_base_events: BEGIN
2017-12-21 18:17:16,826: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:16,826: Using redshift connection "parsely_base_events".
2017-12-21 18:17:16,826: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-21 18:17:16,831: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:17:16,831: On parsely_base_events: COMMIT
2017-12-21 18:17:16,832: Using redshift connection "parsely_base_events".
2017-12-21 18:17:16,832: On parsely_base_events: COMMIT
2017-12-21 18:17:17,134: SQL status: COMMIT in 0.30 seconds
2017-12-21 18:17:17,135: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a7b890>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:17,170: 18:17:17 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 2.91s]
2017-12-21 18:17:17,171: 18:17:17 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2017-12-21 18:17:17,171: Compiling model.parsely.parsely_event_ids
2017-12-21 18:17:17,180: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-21 18:17:17,183: Acquiring new redshift connection "parsely_event_ids".
2017-12-21 18:17:17,183: Re-using an available connection from the pool.
2017-12-21 18:17:17,183: Using redshift connection "parsely_event_ids".
2017-12-21 18:17:17,183: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:17,196: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:17,197: Using redshift connection "parsely_event_ids".
2017-12-21 18:17:17,197: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:17,210: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:17,211: Using redshift connection "parsely_event_ids".
2017-12-21 18:17:17,211: On parsely_event_ids: BEGIN
2017-12-21 18:17:17,213: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:17,213: Using redshift connection "parsely_event_ids".
2017-12-21 18:17:17,213: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:17:18,358: SQL status: SELECT in 1.14 seconds
2017-12-21 18:17:18,359: Using redshift connection "parsely_event_ids".
2017-12-21 18:17:18,359: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2017-12-21 18:17:18,513: SQL status: SELECT in 0.15 seconds
2017-12-21 18:17:18,513: Using redshift connection "parsely_event_ids".
2017-12-21 18:17:18,513: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:18,616: SQL status: SELECT in 0.10 seconds
2017-12-21 18:17:18,616: Using redshift connection "parsely_event_ids".
2017-12-21 18:17:18,616: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:18,715: SQL status: SELECT in 0.10 seconds
2017-12-21 18:17:18,716: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-21 18:17:18,717: Using redshift connection "parsely_event_ids".
2017-12-21 18:17:18,717: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2017-12-21 18:17:19,164: SQL status: INSERT 0 900269 in 0.45 seconds
2017-12-21 18:17:19,164: On parsely_event_ids: COMMIT
2017-12-21 18:17:19,165: Using redshift connection "parsely_event_ids".
2017-12-21 18:17:19,165: On parsely_event_ids: COMMIT
2017-12-21 18:17:19,932: SQL status: COMMIT in 0.77 seconds
2017-12-21 18:17:19,932: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a27750>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:19,959: 18:17:19 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 900269 in 2.76s]
2017-12-21 18:17:19,960: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-21 18:17:19,969: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-21 18:17:19,970: 18:17:19 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-21 18:17:19,970: Compiling model.parsely.parsely_post_content
2017-12-21 18:17:19,980: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-21 18:17:19,981: Acquiring new redshift connection "parsely_post_content".
2017-12-21 18:17:19,981: Re-using an available connection from the pool.
2017-12-21 18:17:19,981: Using redshift connection "parsely_post_content".
2017-12-21 18:17:19,981: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:19,996: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:19,997: Using redshift connection "parsely_post_content".
2017-12-21 18:17:19,997: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:20,011: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:20,013: Using redshift connection "parsely_post_content".
2017-12-21 18:17:20,014: On parsely_post_content: BEGIN
2017-12-21 18:17:20,015: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:20,016: Using redshift connection "parsely_post_content".
2017-12-21 18:17:20,016: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:17:22,014: SQL status: SELECT in 2.00 seconds
2017-12-21 18:17:22,015: Using redshift connection "parsely_post_content".
2017-12-21 18:17:22,015: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2017-12-21 18:17:22,146: SQL status: SELECT in 0.13 seconds
2017-12-21 18:17:22,147: Using redshift connection "parsely_post_content".
2017-12-21 18:17:22,147: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:22,249: SQL status: SELECT in 0.10 seconds
2017-12-21 18:17:22,250: Using redshift connection "parsely_post_content".
2017-12-21 18:17:22,250: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:22,348: SQL status: SELECT in 0.10 seconds
2017-12-21 18:17:22,350: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-21 18:17:22,351: Using redshift connection "parsely_post_content".
2017-12-21 18:17:22,351: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2017-12-21 18:17:22,533: SQL status: INSERT 0 881 in 0.18 seconds
2017-12-21 18:17:22,534: On parsely_post_content: COMMIT
2017-12-21 18:17:22,534: Using redshift connection "parsely_post_content".
2017-12-21 18:17:22,534: On parsely_post_content: COMMIT
2017-12-21 18:17:23,549: SQL status: COMMIT in 1.01 seconds
2017-12-21 18:17:23,550: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a00fd0>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:23,588: 18:17:23 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 881 in 3.58s]
2017-12-21 18:17:23,588: 18:17:23 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2017-12-21 18:17:23,589: Compiling model.parsely.parsely_video_content
2017-12-21 18:17:23,599: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-21 18:17:23,601: Acquiring new redshift connection "parsely_video_content".
2017-12-21 18:17:23,601: Re-using an available connection from the pool.
2017-12-21 18:17:23,601: Using redshift connection "parsely_video_content".
2017-12-21 18:17:23,602: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:23,616: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:23,617: Using redshift connection "parsely_video_content".
2017-12-21 18:17:23,617: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:23,630: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:23,632: Using redshift connection "parsely_video_content".
2017-12-21 18:17:23,632: On parsely_video_content: BEGIN
2017-12-21 18:17:23,634: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:23,634: Using redshift connection "parsely_video_content".
2017-12-21 18:17:23,634: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:17:25,926: SQL status: SELECT in 2.29 seconds
2017-12-21 18:17:25,926: Using redshift connection "parsely_video_content".
2017-12-21 18:17:25,927: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2017-12-21 18:17:26,679: SQL status: SELECT in 0.75 seconds
2017-12-21 18:17:26,679: Using redshift connection "parsely_video_content".
2017-12-21 18:17:26,679: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:26,781: SQL status: SELECT in 0.10 seconds
2017-12-21 18:17:26,782: Using redshift connection "parsely_video_content".
2017-12-21 18:17:26,782: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:26,882: SQL status: SELECT in 0.10 seconds
2017-12-21 18:17:26,884: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-21 18:17:26,885: Using redshift connection "parsely_video_content".
2017-12-21 18:17:26,885: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2017-12-21 18:17:27,060: SQL status: INSERT 0 468 in 0.17 seconds
2017-12-21 18:17:27,061: On parsely_video_content: COMMIT
2017-12-21 18:17:27,061: Using redshift connection "parsely_video_content".
2017-12-21 18:17:27,061: On parsely_video_content: COMMIT
2017-12-21 18:17:27,647: SQL status: COMMIT in 0.59 seconds
2017-12-21 18:17:27,648: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a7b710>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:27,684: 18:17:27 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 468 in 4.06s]
2017-12-21 18:17:27,684: 18:17:27 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-21 18:17:27,685: Compiling model.parsely.parsely_entry_exit_urls
2017-12-21 18:17:27,695: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 18:17:27,696: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-21 18:17:27,697: Re-using an available connection from the pool.
2017-12-21 18:17:27,697: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 18:17:27,697: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:27,711: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:27,714: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 18:17:27,715: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 18:17:27,715: On parsely_entry_exit_urls: BEGIN
2017-12-21 18:17:27,717: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:27,717: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 18:17:27,718: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-21 18:17:28,089: SQL status: CREATE VIEW in 0.37 seconds
2017-12-21 18:17:28,089: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 18:17:28,090: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2017-12-21 18:17:28,092: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:17:28,093: On parsely_entry_exit_urls: COMMIT
2017-12-21 18:17:28,093: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 18:17:28,093: On parsely_entry_exit_urls: COMMIT
2017-12-21 18:17:28,748: SQL status: COMMIT in 0.65 seconds
2017-12-21 18:17:28,748: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a27210>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:28,787: 18:17:28 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 1.06s]
2017-12-21 18:17:28,788: 18:17:28 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-21 18:17:28,788: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 18:17:28,806: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 18:17:28,808: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 18:17:28,808: Re-using an available connection from the pool.
2017-12-21 18:17:28,808: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 18:17:28,808: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:28,822: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:28,828: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 18:17:28,829: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 18:17:28,829: On parsely_incoming_videoviews: BEGIN
2017-12-21 18:17:28,831: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:28,832: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 18:17:28,832: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 18:17:31,476: SQL status: CREATE VIEW in 2.64 seconds
2017-12-21 18:17:31,477: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 18:17:31,477: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 18:17:31,481: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:17:31,481: On parsely_incoming_videoviews: COMMIT
2017-12-21 18:17:31,481: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 18:17:31,481: On parsely_incoming_videoviews: COMMIT
2017-12-21 18:17:32,372: SQL status: COMMIT in 0.89 seconds
2017-12-21 18:17:32,373: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a27210>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:32,410: 18:17:32 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 3.58s]
2017-12-21 18:17:32,411: 18:17:32 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 18:17:32,411: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 18:17:32,420: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:32,420: Re-using an available connection from the pool.
2017-12-21 18:17:32,420: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:32,421: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:32,435: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:32,441: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 18:17:32,443: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:32,443: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:32,457: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:32,458: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:32,458: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:32,472: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:32,475: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:32,475: On parsely_videoviews_sessionized: BEGIN
2017-12-21 18:17:32,477: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:32,477: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:32,477: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:17:42,046: SQL status: SELECT in 9.57 seconds
2017-12-21 18:17:42,046: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:42,047: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2017-12-21 18:17:42,224: SQL status: SELECT in 0.18 seconds
2017-12-21 18:17:42,225: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:42,225: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:42,327: SQL status: SELECT in 0.10 seconds
2017-12-21 18:17:42,329: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:42,329: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:17:42,439: SQL status: SELECT in 0.11 seconds
2017-12-21 18:17:42,445: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 18:17:42,446: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:42,446: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 18:17:42,705: SQL status: INSERT 0 142 in 0.26 seconds
2017-12-21 18:17:42,705: On parsely_videoviews_sessionized: COMMIT
2017-12-21 18:17:42,705: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:17:42,705: On parsely_videoviews_sessionized: COMMIT
2017-12-21 18:17:46,116: SQL status: COMMIT in 3.41 seconds
2017-12-21 18:17:46,116: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5ad6c90>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:46,145: 18:17:46 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 142 in 13.70s]
2017-12-21 18:17:46,145: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-21 18:17:46,168: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-21 18:17:46,169: 18:17:46 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-21 18:17:46,169: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 18:17:46,182: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 18:17:46,183: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:17:46,183: Re-using an available connection from the pool.
2017-12-21 18:17:46,183: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:17:46,183: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:46,202: SQL status: SELECT in 0.02 seconds
2017-12-21 18:17:46,203: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 18:17:46,204: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:17:46,204: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-21 18:17:46,206: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:46,206: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:17:46,206: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-21 18:17:47,109: SQL status: CREATE VIEW in 0.90 seconds
2017-12-21 18:17:47,110: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:17:47,110: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-21 18:17:47,113: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:17:47,113: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 18:17:47,113: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:17:47,114: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 18:17:47,481: SQL status: COMMIT in 0.37 seconds
2017-12-21 18:17:47,482: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a1a050>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:47,505: 18:17:47 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.31s]
2017-12-21 18:17:47,506: 18:17:47 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-21 18:17:47,506: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 18:17:47,533: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 18:17:47,534: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:17:47,535: Re-using an available connection from the pool.
2017-12-21 18:17:47,535: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:17:47,535: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:47,549: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:47,552: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 18:17:47,553: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:17:47,553: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-21 18:17:47,555: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:47,555: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:17:47,555: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-21 18:17:48,881: SQL status: CREATE VIEW in 1.33 seconds
2017-12-21 18:17:48,881: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:17:48,881: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-21 18:17:48,886: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 18:17:48,886: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 18:17:48,887: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:17:48,887: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 18:17:50,299: SQL status: COMMIT in 1.41 seconds
2017-12-21 18:17:50,300: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a89fd0>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:50,333: 18:17:50 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 2.79s]
2017-12-21 18:17:50,334: 18:17:50 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2017-12-21 18:17:50,334: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 18:17:50,344: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 18:17:50,345: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 18:17:50,346: Re-using an available connection from the pool.
2017-12-21 18:17:50,346: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 18:17:50,346: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:50,360: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:50,364: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 18:17:50,365: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 18:17:50,365: On parsely_incoming_pageviews: BEGIN
2017-12-21 18:17:50,367: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:50,367: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 18:17:50,367: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 18:17:50,450: SQL status: CREATE VIEW in 0.08 seconds
2017-12-21 18:17:50,451: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 18:17:50,451: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2017-12-21 18:17:50,456: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:17:50,456: On parsely_incoming_pageviews: COMMIT
2017-12-21 18:17:50,456: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 18:17:50,456: On parsely_incoming_pageviews: COMMIT
2017-12-21 18:17:50,826: SQL status: COMMIT in 0.37 seconds
2017-12-21 18:17:50,827: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a89f10>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:17:50,856: 18:17:50 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.49s]
2017-12-21 18:17:50,857: 18:17:50 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2017-12-21 18:17:50,857: Compiling model.parsely.parsely_pageviews_sessionized
2017-12-21 18:17:50,862: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:17:50,862: Re-using an available connection from the pool.
2017-12-21 18:17:50,862: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:17:50,862: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:50,877: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:50,881: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 18:17:50,882: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:17:50,882: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:50,897: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:50,897: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:17:50,897: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:17:50,911: SQL status: SELECT in 0.01 seconds
2017-12-21 18:17:50,913: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:17:50,913: On parsely_pageviews_sessionized: BEGIN
2017-12-21 18:17:50,915: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:17:50,916: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:17:50,916: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:19:03,967: SQL status: SELECT in 73.05 seconds
2017-12-21 18:19:03,967: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:19:03,967: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2017-12-21 18:19:04,147: SQL status: SELECT in 0.18 seconds
2017-12-21 18:19:04,148: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:19:04,148: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:19:04,261: SQL status: SELECT in 0.11 seconds
2017-12-21 18:19:04,262: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:19:04,262: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:19:04,385: SQL status: SELECT in 0.12 seconds
2017-12-21 18:19:04,388: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 18:19:04,389: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:19:04,389: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2017-12-21 18:19:06,641: SQL status: INSERT 0 107291 in 2.25 seconds
2017-12-21 18:19:06,641: On parsely_pageviews_sessionized: COMMIT
2017-12-21 18:19:06,642: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:19:06,642: On parsely_pageviews_sessionized: COMMIT
2017-12-21 18:19:08,356: SQL status: COMMIT in 1.71 seconds
2017-12-21 18:19:08,357: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a1af50>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:19:08,397: 18:19:08 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 107291 in 77.50s]
2017-12-21 18:19:08,397: 18:19:08 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-21 18:19:08,397: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-21 18:19:08,438: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 18:19:08,439: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:19:08,439: Re-using an available connection from the pool.
2017-12-21 18:19:08,439: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:19:08,439: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:19:08,461: SQL status: SELECT in 0.02 seconds
2017-12-21 18:19:08,464: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 18:19:08,465: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:19:08,465: On parsely_videoview_engagedtime: BEGIN
2017-12-21 18:19:08,467: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:19:08,467: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:19:08,467: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-21 18:19:08,565: SQL status: CREATE VIEW in 0.10 seconds
2017-12-21 18:19:08,565: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:19:08,565: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-21 18:19:08,569: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:19:08,569: On parsely_videoview_engagedtime: COMMIT
2017-12-21 18:19:08,570: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:19:08,570: On parsely_videoview_engagedtime: COMMIT
2017-12-21 18:19:08,757: SQL status: COMMIT in 0.19 seconds
2017-12-21 18:19:08,757: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a1af50>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:19:08,787: 18:19:08 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.36s]
2017-12-21 18:19:08,788: 18:19:08 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-21 18:19:08,788: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-21 18:19:08,796: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 18:19:08,797: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:19:08,797: Re-using an available connection from the pool.
2017-12-21 18:19:08,797: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:19:08,798: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:19:08,820: SQL status: SELECT in 0.02 seconds
2017-12-21 18:19:08,820: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:19:08,820: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:19:08,841: SQL status: SELECT in 0.02 seconds
2017-12-21 18:19:08,843: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:19:08,844: On parsely_videoview_behavior_workflow: BEGIN
2017-12-21 18:19:08,845: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:19:08,845: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:19:08,846: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:19:35,073: SQL status: SELECT in 26.23 seconds
2017-12-21 18:19:35,073: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:19:35,073: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 18:19:35,335: SQL status: SELECT in 0.26 seconds
2017-12-21 18:19:35,336: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:19:35,336: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:19:35,450: SQL status: SELECT in 0.11 seconds
2017-12-21 18:19:35,451: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:19:35,451: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:19:35,564: SQL status: SELECT in 0.11 seconds
2017-12-21 18:19:35,567: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 18:19:35,568: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:19:35,568: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 18:19:35,808: SQL status: INSERT 0 141 in 0.24 seconds
2017-12-21 18:19:35,808: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 18:19:35,808: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:19:35,808: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 18:19:36,875: SQL status: COMMIT in 1.07 seconds
2017-12-21 18:19:36,876: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5ad6c90>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:19:36,902: 18:19:36 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 141 in 28.09s]
2017-12-21 18:19:36,903: 18:19:36 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2017-12-21 18:19:36,903: Compiling model.parsely.parsely_campaigns
2017-12-21 18:19:36,907: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 18:19:36,907: Re-using an available connection from the pool.
2017-12-21 18:19:36,907: Using redshift connection "parsely_campaigns".
2017-12-21 18:19:36,907: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:19:36,929: SQL status: SELECT in 0.02 seconds
2017-12-21 18:19:36,932: Writing injected SQL for node "model.parsely.parsely_campaigns"
2017-12-21 18:19:36,933: Using redshift connection "parsely_campaigns".
2017-12-21 18:19:36,933: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:19:36,954: SQL status: SELECT in 0.02 seconds
2017-12-21 18:19:36,955: Using redshift connection "parsely_campaigns".
2017-12-21 18:19:36,955: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:19:36,977: SQL status: SELECT in 0.02 seconds
2017-12-21 18:19:36,978: Using redshift connection "parsely_campaigns".
2017-12-21 18:19:36,978: On parsely_campaigns: BEGIN
2017-12-21 18:19:36,980: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:19:36,980: Using redshift connection "parsely_campaigns".
2017-12-21 18:19:36,980: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:19:37,650: SQL status: SELECT in 0.67 seconds
2017-12-21 18:19:37,651: Using redshift connection "parsely_campaigns".
2017-12-21 18:19:37,651: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2017-12-21 18:19:38,086: SQL status: SELECT in 0.44 seconds
2017-12-21 18:19:38,087: Using redshift connection "parsely_campaigns".
2017-12-21 18:19:38,087: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:19:38,196: SQL status: SELECT in 0.11 seconds
2017-12-21 18:19:38,196: Using redshift connection "parsely_campaigns".
2017-12-21 18:19:38,196: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:19:38,304: SQL status: SELECT in 0.11 seconds
2017-12-21 18:19:38,306: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2017-12-21 18:19:38,306: Using redshift connection "parsely_campaigns".
2017-12-21 18:19:38,307: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2017-12-21 18:19:38,437: SQL status: INSERT 0 382 in 0.13 seconds
2017-12-21 18:19:38,437: On parsely_campaigns: COMMIT
2017-12-21 18:19:38,438: Using redshift connection "parsely_campaigns".
2017-12-21 18:19:38,438: On parsely_campaigns: COMMIT
2017-12-21 18:19:39,027: SQL status: COMMIT in 0.59 seconds
2017-12-21 18:19:39,027: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5b08ed0>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:19:39,060: 18:19:39 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 382 in 2.12s]
2017-12-21 18:19:39,060: Compiling model.parsely.parsely_incoming_users
2017-12-21 18:19:39,065: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 18:19:39,066: 18:19:39 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2017-12-21 18:19:39,067: Compiling model.parsely.parsely_users
2017-12-21 18:19:39,072: Acquiring new redshift connection "parsely_users".
2017-12-21 18:19:39,072: Re-using an available connection from the pool.
2017-12-21 18:19:39,072: Using redshift connection "parsely_users".
2017-12-21 18:19:39,072: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:19:39,094: SQL status: SELECT in 0.02 seconds
2017-12-21 18:19:39,133: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 18:19:39,134: Using redshift connection "parsely_users".
2017-12-21 18:19:39,134: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:19:39,156: SQL status: SELECT in 0.02 seconds
2017-12-21 18:19:39,157: Using redshift connection "parsely_users".
2017-12-21 18:19:39,157: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:19:39,179: SQL status: SELECT in 0.02 seconds
2017-12-21 18:19:39,181: Using redshift connection "parsely_users".
2017-12-21 18:19:39,181: On parsely_users: BEGIN
2017-12-21 18:19:39,183: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:19:39,183: Using redshift connection "parsely_users".
2017-12-21 18:19:39,183: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:20:03,740: SQL status: SELECT in 24.56 seconds
2017-12-21 18:20:03,740: Using redshift connection "parsely_users".
2017-12-21 18:20:03,740: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2017-12-21 18:20:03,884: SQL status: SELECT in 0.14 seconds
2017-12-21 18:20:03,884: Using redshift connection "parsely_users".
2017-12-21 18:20:03,884: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:20:03,995: SQL status: SELECT in 0.11 seconds
2017-12-21 18:20:03,995: Using redshift connection "parsely_users".
2017-12-21 18:20:03,995: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:20:04,105: SQL status: SELECT in 0.11 seconds
2017-12-21 18:20:04,107: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 18:20:04,108: Using redshift connection "parsely_users".
2017-12-21 18:20:04,108: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2017-12-21 18:20:10,525: SQL status: INSERT 0 111948 in 6.42 seconds
2017-12-21 18:20:10,525: On parsely_users: COMMIT
2017-12-21 18:20:10,525: Using redshift connection "parsely_users".
2017-12-21 18:20:10,525: On parsely_users: COMMIT
2017-12-21 18:20:11,562: SQL status: COMMIT in 1.04 seconds
2017-12-21 18:20:11,562: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a00710>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:20:11,642: 18:20:11 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 111948 in 32.50s]
2017-12-21 18:20:11,642: 18:20:11 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2017-12-21 18:20:11,642: Compiling model.parsely.parsely_pageview_engagedtime
2017-12-21 18:20:11,674: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 18:20:11,675: Acquiring new redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:20:11,675: Re-using an available connection from the pool.
2017-12-21 18:20:11,675: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:20:11,675: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:20:11,698: SQL status: SELECT in 0.02 seconds
2017-12-21 18:20:11,700: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 18:20:11,700: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:20:11,701: On parsely_pageview_engagedtime: BEGIN
2017-12-21 18:20:11,702: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:20:11,703: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:20:11,703: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2017-12-21 18:20:11,800: SQL status: CREATE VIEW in 0.10 seconds
2017-12-21 18:20:11,801: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:20:11,801: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2017-12-21 18:20:11,805: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:20:11,805: On parsely_pageview_engagedtime: COMMIT
2017-12-21 18:20:11,805: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:20:11,805: On parsely_pageview_engagedtime: COMMIT
2017-12-21 18:20:12,101: SQL status: COMMIT in 0.30 seconds
2017-12-21 18:20:12,101: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a72450>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:20:12,127: 18:20:12 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.46s]
2017-12-21 18:20:12,127: 18:20:12 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2017-12-21 18:20:12,127: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 18:20:12,134: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 18:20:12,135: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 18:20:12,135: Re-using an available connection from the pool.
2017-12-21 18:20:12,135: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:20:12,135: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:20:12,157: SQL status: SELECT in 0.02 seconds
2017-12-21 18:20:12,159: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 18:20:12,160: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:20:12,160: On parsely_incoming_sessions: BEGIN
2017-12-21 18:20:12,162: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:20:12,162: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:20:12,162: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 18:20:12,455: SQL status: CREATE VIEW in 0.29 seconds
2017-12-21 18:20:12,456: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:20:12,456: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 18:20:12,459: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:20:12,459: On parsely_incoming_sessions: COMMIT
2017-12-21 18:20:12,459: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:20:12,459: On parsely_incoming_sessions: COMMIT
2017-12-21 18:20:13,035: SQL status: COMMIT in 0.58 seconds
2017-12-21 18:20:13,035: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5b08ed0>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:20:13,062: 18:20:13 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.91s]
2017-12-21 18:20:13,062: 18:20:13 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2017-12-21 18:20:13,063: Compiling model.parsely.parsely_pageview_behavior_workflow
2017-12-21 18:20:13,073: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 18:20:13,074: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:20:13,074: Re-using an available connection from the pool.
2017-12-21 18:20:13,074: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:20:13,074: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:20:13,097: SQL status: SELECT in 0.02 seconds
2017-12-21 18:20:13,097: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:20:13,097: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:20:13,119: SQL status: SELECT in 0.02 seconds
2017-12-21 18:20:13,121: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:20:13,121: On parsely_pageview_behavior_workflow: BEGIN
2017-12-21 18:20:13,123: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:20:13,123: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:20:13,123: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:20:42,887: SQL status: SELECT in 29.76 seconds
2017-12-21 18:20:42,887: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:20:42,888: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2017-12-21 18:20:43,047: SQL status: SELECT in 0.16 seconds
2017-12-21 18:20:43,048: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:20:43,048: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:20:43,162: SQL status: SELECT in 0.11 seconds
2017-12-21 18:20:43,163: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:20:43,163: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:20:43,277: SQL status: SELECT in 0.11 seconds
2017-12-21 18:20:43,280: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 18:20:43,281: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:20:43,281: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2017-12-21 18:20:45,660: SQL status: INSERT 0 107331 in 2.38 seconds
2017-12-21 18:20:45,660: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 18:20:45,660: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:20:45,660: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 18:20:47,246: SQL status: COMMIT in 1.59 seconds
2017-12-21 18:20:47,247: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a00210>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:20:47,272: 18:20:47 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 107331 in 34.18s]
2017-12-21 18:20:47,273: 18:20:47 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2017-12-21 18:20:47,273: Compiling model.parsely.parsely_sessions
2017-12-21 18:20:47,278: Acquiring new redshift connection "parsely_sessions".
2017-12-21 18:20:47,279: Re-using an available connection from the pool.
2017-12-21 18:20:47,279: Using redshift connection "parsely_sessions".
2017-12-21 18:20:47,279: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:20:47,304: SQL status: SELECT in 0.02 seconds
2017-12-21 18:20:47,307: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 18:20:47,308: Using redshift connection "parsely_sessions".
2017-12-21 18:20:47,308: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:20:47,330: SQL status: SELECT in 0.02 seconds
2017-12-21 18:20:47,331: Using redshift connection "parsely_sessions".
2017-12-21 18:20:47,331: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:20:47,351: SQL status: SELECT in 0.02 seconds
2017-12-21 18:20:47,354: Using redshift connection "parsely_sessions".
2017-12-21 18:20:47,355: On parsely_sessions: BEGIN
2017-12-21 18:20:47,356: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:20:47,357: Using redshift connection "parsely_sessions".
2017-12-21 18:20:47,357: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:23:39,251: SQL status: SELECT in 171.89 seconds
2017-12-21 18:23:39,251: Using redshift connection "parsely_sessions".
2017-12-21 18:23:39,251: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2017-12-21 18:23:39,411: SQL status: SELECT in 0.16 seconds
2017-12-21 18:23:39,411: Using redshift connection "parsely_sessions".
2017-12-21 18:23:39,412: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:23:39,525: SQL status: SELECT in 0.11 seconds
2017-12-21 18:23:39,525: Using redshift connection "parsely_sessions".
2017-12-21 18:23:39,526: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:23:39,638: SQL status: SELECT in 0.11 seconds
2017-12-21 18:23:39,641: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 18:23:39,642: Using redshift connection "parsely_sessions".
2017-12-21 18:23:39,642: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2017-12-21 18:23:41,155: SQL status: INSERT 0 87122 in 1.51 seconds
2017-12-21 18:23:41,156: On parsely_sessions: COMMIT
2017-12-21 18:23:41,156: Using redshift connection "parsely_sessions".
2017-12-21 18:23:41,156: On parsely_sessions: COMMIT
2017-12-21 18:23:42,415: SQL status: COMMIT in 1.26 seconds
2017-12-21 18:23:42,416: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5a00750>], 'label': '6e20723a-1c42-49eb-a61a-2821807806d4'}
2017-12-21 18:23:42,464: 18:23:42 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 87122 in 175.14s]
2017-12-21 18:23:42,480: Using redshift connection "master".
2017-12-21 18:23:42,480: On master: BEGIN
2017-12-21 18:23:42,483: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:23:42,483: On master: COMMIT
2017-12-21 18:23:42,483: Using redshift connection "master".
2017-12-21 18:23:42,483: On master: COMMIT
2017-12-21 18:23:42,485: SQL status: COMMIT in 0.00 seconds
2017-12-21 18:23:42,485: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 18:23:42,490: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 18:23:42,490: Using redshift connection "master".
2017-12-21 18:23:42,490: On master:  select 1 
2017-12-21 18:23:42,492: SQL status: SELECT in 0.00 seconds
2017-12-21 18:23:42,492: 18:23:42 | 
2017-12-21 18:23:42,492: 18:23:42 | Finished running 10 view models, 15 incremental models in 663.02s.
2017-12-21 18:23:42,493: 
2017-12-21 18:23:42,493: Completed successfully
2017-12-21 18:23:42,493: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2017-12-21 18:23:42,494: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5b21250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5b214d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f94c5b08990>], 'label': 'end'}
2017-12-21 18:23:42,522: Flushing usage events
2017-12-21 18:33:01,732: Tracking: tracking
2017-12-21 18:33:01,732: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7cd250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7cd4d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7cd310>], 'label': 'start'}
2017-12-21 18:33:01,813: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2017-12-21 18:33:01,864: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2017-12-21 18:33:01,866: Parsing core.sql
2017-12-21 18:33:01,900: Parsing etc/get_custom_schema.sql
2017-12-21 18:33:01,917: Parsing schema_tests/relationships.sql
2017-12-21 18:33:01,925: Parsing schema_tests/accepted_values.sql
2017-12-21 18:33:01,931: Parsing schema_tests/not_null.sql
2017-12-21 18:33:01,944: Parsing schema_tests/unique.sql
2017-12-21 18:33:01,947: Parsing materializations/wrapper.sql
2017-12-21 18:33:01,976: Parsing materializations/archive.sql
2017-12-21 18:33:02,104: Parsing materializations/table.sql
2017-12-21 18:33:02,173: Parsing materializations/helpers.sql
2017-12-21 18:33:02,202: Parsing materializations/bigquery.sql
2017-12-21 18:33:02,227: Parsing materializations/view.sql
2017-12-21 18:33:02,255: Parsing materializations/incremental.sql
2017-12-21 18:33:02,309: Parsing adapters/redshift.sql
2017-12-21 18:33:02,342: Parsing adapters/bigquery.sql
2017-12-21 18:33:02,350: Parsing adapters/postgres.sql
2017-12-21 18:33:02,355: Parsing adapters/common.sql
2017-12-21 18:33:02,395: Parsing model.parsely.parsely_audit
2017-12-21 18:33:02,397: Parsing model.parsely.parsely_video_content
2017-12-21 18:33:02,402: Parsing model.parsely.parsely_post_content
2017-12-21 18:33:02,407: Parsing model.parsely.parsely_parent_videostart_keys
2017-12-21 18:33:02,412: Parsing model.parsely.parsely_rawdata
2017-12-21 18:33:02,417: Parsing model.parsely.calendar
2017-12-21 18:33:02,419: Parsing model.parsely.parsely_all_events
2017-12-21 18:33:02,434: Acquiring new redshift connection "parsely_all_events".
2017-12-21 18:33:02,434: Opening a new connection (0 currently allocated)
2017-12-21 18:33:02,482: Using redshift connection "parsely_all_events".
2017-12-21 18:33:02,482: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:02,509: SQL status: SELECT in 0.03 seconds
2017-12-21 18:33:02,526: Parsing model.parsely.parsely_event_ids
2017-12-21 18:33:02,530: Parsing model.parsely.parsely_parent_pageview_keys
2017-12-21 18:33:02,539: Parsing model.parsely.parsely_base_events
2017-12-21 18:33:02,556: Acquiring new redshift connection "parsely_base_events".
2017-12-21 18:33:02,556: Re-using an available connection from the pool.
2017-12-21 18:33:02,556: Using redshift connection "parsely_base_events".
2017-12-21 18:33:02,556: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:02,577: SQL status: SELECT in 0.02 seconds
2017-12-21 18:33:02,579: Parsing model.parsely.parsely_pageview_behavior_workflow
2017-12-21 18:33:02,596: Parsing model.parsely.parsely_pageview_engagedtime
2017-12-21 18:33:02,604: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 18:33:02,615: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 18:33:02,618: Parsing model.parsely.parsely_videoview_engagedtime
2017-12-21 18:33:02,631: Parsing model.parsely.parsely_videoview_behavior_workflow
2017-12-21 18:33:02,654: Parsing model.parsely.parsely_incoming_pageviews
2017-12-21 18:33:02,674: Parsing model.parsely.parsely_pageviews_sessionized
2017-12-21 18:33:02,692: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:33:02,692: Re-using an available connection from the pool.
2017-12-21 18:33:02,692: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:33:02,692: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:02,713: SQL status: SELECT in 0.02 seconds
2017-12-21 18:33:02,714: Parsing model.parsely.parsely_incoming_videoviews
2017-12-21 18:33:02,737: Parsing model.parsely.parsely_videoviews_sessionized
2017-12-21 18:33:02,748: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:33:02,749: Re-using an available connection from the pool.
2017-12-21 18:33:02,749: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:33:02,749: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:02,770: SQL status: SELECT in 0.02 seconds
2017-12-21 18:33:02,771: Parsing model.parsely.parsely_incoming_users
2017-12-21 18:33:02,775: Parsing model.parsely.parsely_users
2017-12-21 18:33:02,784: Acquiring new redshift connection "parsely_users".
2017-12-21 18:33:02,785: Re-using an available connection from the pool.
2017-12-21 18:33:02,785: Using redshift connection "parsely_users".
2017-12-21 18:33:02,785: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:02,806: SQL status: SELECT in 0.02 seconds
2017-12-21 18:33:02,808: Parsing model.parsely.parsely_errors
2017-12-21 18:33:02,815: Parsing model.parsely.parsely_bot_traffic
2017-12-21 18:33:02,833: Parsing model.parsely.parsely_custom_events
2017-12-21 18:33:02,854: Parsing model.parsely.parsely_incoming_sessions
2017-12-21 18:33:02,860: Parsing model.parsely.parsely_entry_exit_urls
2017-12-21 18:33:02,873: Parsing model.parsely.parsely_sessions
2017-12-21 18:33:02,890: Acquiring new redshift connection "parsely_sessions".
2017-12-21 18:33:02,890: Re-using an available connection from the pool.
2017-12-21 18:33:02,890: Using redshift connection "parsely_sessions".
2017-12-21 18:33:02,890: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:02,911: SQL status: SELECT in 0.02 seconds
2017-12-21 18:33:02,912: Parsing model.parsely.parsely_campaigns
2017-12-21 18:33:02,918: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 18:33:02,919: Re-using an available connection from the pool.
2017-12-21 18:33:02,919: Using redshift connection "parsely_campaigns".
2017-12-21 18:33:02,919: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:02,940: SQL status: SELECT in 0.02 seconds
2017-12-21 18:33:02,956: Parsing operation.parsely.parsely-on-run-end-0
2017-12-21 18:33:02,973: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2017-12-21 18:33:03,013: 
2017-12-21 18:33:03,025: Acquiring new redshift connection "master".
2017-12-21 18:33:03,025: Re-using an available connection from the pool.
2017-12-21 18:33:03,025: Using redshift connection "master".
2017-12-21 18:33:03,025: On master: select distinct nspname from pg_namespace
2017-12-21 18:33:03,028: SQL status: SELECT in 0.00 seconds
2017-12-21 18:33:03,036: Using redshift connection "master".
2017-12-21 18:33:03,036: On master: BEGIN
2017-12-21 18:33:03,043: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:33:03,044: On master: COMMIT
2017-12-21 18:33:03,044: Using redshift connection "master".
2017-12-21 18:33:03,044: On master: COMMIT
2017-12-21 18:33:03,046: SQL status: COMMIT in 0.00 seconds
2017-12-21 18:33:03,063: 18:33:03 | Concurrency: 1 threads (target='dev')
2017-12-21 18:33:03,068: 18:33:03 | 
2017-12-21 18:33:03,068: Using redshift connection "master".
2017-12-21 18:33:03,069: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:03,090: SQL status: SELECT in 0.02 seconds
2017-12-21 18:33:03,339: 18:33:03 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2017-12-21 18:33:03,339: Compiling model.parsely.calendar
2017-12-21 18:33:03,358: Writing injected SQL for node "model.parsely.calendar"
2017-12-21 18:33:03,359: Acquiring new redshift connection "calendar".
2017-12-21 18:33:03,360: Opening a new connection (1 currently allocated)
2017-12-21 18:33:03,390: Using redshift connection "calendar".
2017-12-21 18:33:03,390: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:03,416: SQL status: SELECT in 0.03 seconds
2017-12-21 18:33:03,419: Writing runtime SQL for node "model.parsely.calendar"
2017-12-21 18:33:03,431: Using redshift connection "calendar".
2017-12-21 18:33:03,431: On calendar: BEGIN
2017-12-21 18:33:03,433: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:33:03,433: Using redshift connection "calendar".
2017-12-21 18:33:03,433: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2017-12-21 18:33:03,462: SQL status: CREATE VIEW in 0.03 seconds
2017-12-21 18:33:03,462: On calendar: COMMIT
2017-12-21 18:33:03,463: Using redshift connection "calendar".
2017-12-21 18:33:03,463: On calendar: COMMIT
2017-12-21 18:33:03,854: SQL status: COMMIT in 0.39 seconds
2017-12-21 18:33:03,854: Using redshift connection "calendar".
2017-12-21 18:33:03,854: On calendar: BEGIN
2017-12-21 18:33:03,856: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:33:03,856: Using redshift connection "calendar".
2017-12-21 18:33:03,857: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2017-12-21 18:33:04,085: SQL status: DROP VIEW in 0.23 seconds
2017-12-21 18:33:04,085: On calendar: COMMIT
2017-12-21 18:33:04,085: Using redshift connection "calendar".
2017-12-21 18:33:04,085: On calendar: COMMIT
2017-12-21 18:33:04,659: SQL status: COMMIT in 0.57 seconds
2017-12-21 18:33:04,659: Using redshift connection "calendar".
2017-12-21 18:33:04,659: On calendar: BEGIN
2017-12-21 18:33:04,662: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:33:04,662: Using redshift connection "calendar".
2017-12-21 18:33:04,662: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2017-12-21 18:33:04,667: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:33:04,667: On calendar: COMMIT
2017-12-21 18:33:04,667: Using redshift connection "calendar".
2017-12-21 18:33:04,667: On calendar: COMMIT
2017-12-21 18:33:04,857: SQL status: COMMIT in 0.19 seconds
2017-12-21 18:33:04,858: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd6c0190>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:33:04,905: 18:33:04 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.52s]
2017-12-21 18:33:04,905: 18:33:04 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2017-12-21 18:33:04,905: Compiling model.parsely.parsely_rawdata
2017-12-21 18:33:04,918: Writing injected SQL for node "model.parsely.parsely_rawdata"
2017-12-21 18:33:04,919: Acquiring new redshift connection "parsely_rawdata".
2017-12-21 18:33:04,919: Re-using an available connection from the pool.
2017-12-21 18:33:04,919: Using redshift connection "parsely_rawdata".
2017-12-21 18:33:04,920: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:04,940: SQL status: SELECT in 0.02 seconds
2017-12-21 18:33:04,941: Using redshift connection "parsely_rawdata".
2017-12-21 18:33:04,941: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:33:04,951: SQL status: SELECT in 0.01 seconds
2017-12-21 18:33:04,952: Using redshift connection "parsely_rawdata".
2017-12-21 18:33:04,952: On parsely_rawdata: BEGIN
2017-12-21 18:33:04,954: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:33:04,954: Using redshift connection "parsely_rawdata".
2017-12-21 18:33:04,955: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2017-12-21 18:33:30,936: SQL status: SELECT in 25.98 seconds
2017-12-21 18:33:30,936: Using redshift connection "parsely_rawdata".
2017-12-21 18:33:30,936: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2017-12-21 18:33:31,086: SQL status: SELECT in 0.15 seconds
2017-12-21 18:33:31,087: Using redshift connection "parsely_rawdata".
2017-12-21 18:33:31,088: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:33:31,189: SQL status: SELECT in 0.10 seconds
2017-12-21 18:33:31,190: Using redshift connection "parsely_rawdata".
2017-12-21 18:33:31,190: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2017-12-21 18:33:31,289: SQL status: SELECT in 0.10 seconds
2017-12-21 18:33:31,295: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2017-12-21 18:33:31,545: Using redshift connection "parsely_rawdata".
2017-12-21 18:33:31,545: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2017-12-21 18:34:01,318: SQL status: INSERT 0 1015763 in 29.77 seconds
2017-12-21 18:34:01,319: On parsely_rawdata: COMMIT
2017-12-21 18:34:01,319: Using redshift connection "parsely_rawdata".
2017-12-21 18:34:01,319: On parsely_rawdata: COMMIT
2017-12-21 18:34:03,208: SQL status: COMMIT in 1.89 seconds
2017-12-21 18:34:03,209: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd782e90>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:34:03,295: 18:34:03 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1015763 in 58.30s]
2017-12-21 18:34:03,296: 18:34:03 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2017-12-21 18:34:03,296: Compiling model.parsely.parsely_all_events
2017-12-21 18:34:03,319: Acquiring new redshift connection "parsely_all_events".
2017-12-21 18:34:03,319: Re-using an available connection from the pool.
2017-12-21 18:34:03,319: Using redshift connection "parsely_all_events".
2017-12-21 18:34:03,319: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:34:03,334: SQL status: SELECT in 0.01 seconds
2017-12-21 18:34:03,361: Writing injected SQL for node "model.parsely.parsely_all_events"
2017-12-21 18:34:03,363: Using redshift connection "parsely_all_events".
2017-12-21 18:34:03,363: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:34:03,377: SQL status: SELECT in 0.01 seconds
2017-12-21 18:34:03,378: Using redshift connection "parsely_all_events".
2017-12-21 18:34:03,378: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:34:03,393: SQL status: SELECT in 0.01 seconds
2017-12-21 18:34:03,397: Writing runtime SQL for node "model.parsely.parsely_all_events"
2017-12-21 18:34:03,398: Using redshift connection "parsely_all_events".
2017-12-21 18:34:03,398: On parsely_all_events: BEGIN
2017-12-21 18:34:03,408: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:34:03,408: Using redshift connection "parsely_all_events".
2017-12-21 18:34:03,408: On parsely_all_events: 
    
  

  create  table "blog_dbt_dev"."parsely_all_events"
  
  
  as (
    

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
  );
2017-12-21 18:36:48,756: SQL status: SELECT in 165.35 seconds
2017-12-21 18:36:48,757: On parsely_all_events: COMMIT
2017-12-21 18:36:48,757: Using redshift connection "parsely_all_events".
2017-12-21 18:36:48,757: On parsely_all_events: COMMIT
2017-12-21 18:36:52,217: SQL status: COMMIT in 3.46 seconds
2017-12-21 18:36:52,218: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd735cd0>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:36:52,271: 18:36:52 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [SELECT in 168.92s]
2017-12-21 18:36:52,272: 18:36:52 | 4 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2017-12-21 18:36:52,272: Compiling model.parsely.parsely_base_events
2017-12-21 18:36:52,291: Acquiring new redshift connection "parsely_base_events".
2017-12-21 18:36:52,291: Re-using an available connection from the pool.
2017-12-21 18:36:52,291: Using redshift connection "parsely_base_events".
2017-12-21 18:36:52,291: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:36:52,313: SQL status: SELECT in 0.02 seconds
2017-12-21 18:36:52,320: Writing injected SQL for node "model.parsely.parsely_base_events"
2017-12-21 18:36:52,337: Using redshift connection "parsely_base_events".
2017-12-21 18:36:52,337: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:36:52,354: SQL status: SELECT in 0.02 seconds
2017-12-21 18:36:52,357: Writing runtime SQL for node "model.parsely.parsely_base_events"
2017-12-21 18:36:52,358: Using redshift connection "parsely_base_events".
2017-12-21 18:36:52,358: On parsely_base_events: BEGIN
2017-12-21 18:36:52,360: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:36:52,360: Using redshift connection "parsely_base_events".
2017-12-21 18:36:52,360: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
     --running for the first time
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2017-12-21 18:36:52,828: SQL status: CREATE VIEW in 0.47 seconds
2017-12-21 18:36:52,829: Using redshift connection "parsely_base_events".
2017-12-21 18:36:52,829: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2017-12-21 18:36:52,832: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:36:52,832: On parsely_base_events: COMMIT
2017-12-21 18:36:52,832: Using redshift connection "parsely_base_events".
2017-12-21 18:36:52,832: On parsely_base_events: COMMIT
2017-12-21 18:36:53,284: SQL status: COMMIT in 0.45 seconds
2017-12-21 18:36:53,285: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7c6690>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:36:53,331: 18:36:53 | 4 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 1.01s]
2017-12-21 18:36:53,331: 18:36:53 | 5 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2017-12-21 18:36:53,331: Compiling model.parsely.parsely_bot_traffic
2017-12-21 18:36:53,343: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 18:36:53,345: Acquiring new redshift connection "parsely_bot_traffic".
2017-12-21 18:36:53,345: Re-using an available connection from the pool.
2017-12-21 18:36:53,345: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:36:53,346: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:36:53,359: SQL status: SELECT in 0.01 seconds
2017-12-21 18:36:53,360: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:36:53,360: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:36:53,373: SQL status: SELECT in 0.01 seconds
2017-12-21 18:36:53,376: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2017-12-21 18:36:53,377: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:36:53,378: On parsely_bot_traffic: BEGIN
2017-12-21 18:36:53,380: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:36:53,380: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:36:53,380: On parsely_bot_traffic: 
    
  

  create  table "blog_dbt_dev"."parsely_bot_traffic"
  
  
  as (
    --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
  );
2017-12-21 18:36:58,196: SQL status: SELECT in 4.82 seconds
2017-12-21 18:36:58,197: On parsely_bot_traffic: COMMIT
2017-12-21 18:36:58,197: Using redshift connection "parsely_bot_traffic".
2017-12-21 18:36:58,197: On parsely_bot_traffic: COMMIT
2017-12-21 18:36:59,873: SQL status: COMMIT in 1.68 seconds
2017-12-21 18:36:59,874: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7c6690>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:36:59,926: 18:36:59 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [SELECT in 6.54s]
2017-12-21 18:36:59,928: 18:36:59 | 6 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2017-12-21 18:36:59,929: Compiling model.parsely.parsely_custom_events
2017-12-21 18:36:59,959: Writing injected SQL for node "model.parsely.parsely_custom_events"
2017-12-21 18:36:59,967: Acquiring new redshift connection "parsely_custom_events".
2017-12-21 18:36:59,967: Re-using an available connection from the pool.
2017-12-21 18:36:59,967: Using redshift connection "parsely_custom_events".
2017-12-21 18:36:59,967: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:36:59,981: SQL status: SELECT in 0.01 seconds
2017-12-21 18:36:59,982: Using redshift connection "parsely_custom_events".
2017-12-21 18:36:59,982: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:36:59,994: SQL status: SELECT in 0.01 seconds
2017-12-21 18:36:59,998: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2017-12-21 18:36:59,999: Using redshift connection "parsely_custom_events".
2017-12-21 18:36:59,999: On parsely_custom_events: BEGIN
2017-12-21 18:37:00,008: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:37:00,008: Using redshift connection "parsely_custom_events".
2017-12-21 18:37:00,008: On parsely_custom_events: 
    
  

  create  table "blog_dbt_dev"."parsely_custom_events"
  
  
  as (
    -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
  );
2017-12-21 18:37:05,302: SQL status: SELECT in 5.29 seconds
2017-12-21 18:37:05,303: On parsely_custom_events: COMMIT
2017-12-21 18:37:05,303: Using redshift connection "parsely_custom_events".
2017-12-21 18:37:05,303: On parsely_custom_events: COMMIT
2017-12-21 18:37:05,920: SQL status: COMMIT in 0.62 seconds
2017-12-21 18:37:05,921: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7c6690>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:05,964: 18:37:05 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [SELECT in 5.99s]
2017-12-21 18:37:05,965: 18:37:05 | 7 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2017-12-21 18:37:05,965: Compiling model.parsely.parsely_errors
2017-12-21 18:37:06,005: Writing injected SQL for node "model.parsely.parsely_errors"
2017-12-21 18:37:06,007: Acquiring new redshift connection "parsely_errors".
2017-12-21 18:37:06,007: Re-using an available connection from the pool.
2017-12-21 18:37:06,008: Using redshift connection "parsely_errors".
2017-12-21 18:37:06,008: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:06,021: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:06,022: Using redshift connection "parsely_errors".
2017-12-21 18:37:06,022: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:06,035: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:06,039: Writing runtime SQL for node "model.parsely.parsely_errors"
2017-12-21 18:37:06,045: Using redshift connection "parsely_errors".
2017-12-21 18:37:06,045: On parsely_errors: BEGIN
2017-12-21 18:37:06,047: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:37:06,047: Using redshift connection "parsely_errors".
2017-12-21 18:37:06,047: On parsely_errors: 
    
  

  create  table "blog_dbt_dev"."parsely_errors"
  
  
  as (
    -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
  );
2017-12-21 18:37:11,347: SQL status: SELECT in 5.30 seconds
2017-12-21 18:37:11,348: On parsely_errors: COMMIT
2017-12-21 18:37:11,348: Using redshift connection "parsely_errors".
2017-12-21 18:37:11,348: On parsely_errors: COMMIT
2017-12-21 18:37:12,417: SQL status: COMMIT in 1.07 seconds
2017-12-21 18:37:12,418: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7c6690>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:12,463: 18:37:12 | 7 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [SELECT in 6.45s]
2017-12-21 18:37:12,464: Compiling model.parsely.parsely_parent_pageview_keys
2017-12-21 18:37:12,472: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2017-12-21 18:37:12,481: 18:37:12 | 8 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2017-12-21 18:37:12,481: Compiling model.parsely.parsely_post_content
2017-12-21 18:37:12,497: Writing injected SQL for node "model.parsely.parsely_post_content"
2017-12-21 18:37:12,499: Acquiring new redshift connection "parsely_post_content".
2017-12-21 18:37:12,508: Re-using an available connection from the pool.
2017-12-21 18:37:12,508: Using redshift connection "parsely_post_content".
2017-12-21 18:37:12,508: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:12,524: SQL status: SELECT in 0.02 seconds
2017-12-21 18:37:12,525: Using redshift connection "parsely_post_content".
2017-12-21 18:37:12,525: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:12,537: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:12,540: Writing runtime SQL for node "model.parsely.parsely_post_content"
2017-12-21 18:37:12,541: Using redshift connection "parsely_post_content".
2017-12-21 18:37:12,541: On parsely_post_content: BEGIN
2017-12-21 18:37:12,543: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:37:12,543: Using redshift connection "parsely_post_content".
2017-12-21 18:37:12,543: On parsely_post_content: 
    
  

  create  table "blog_dbt_dev"."parsely_post_content"
  
  
  as (
    -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
  );
2017-12-21 18:37:14,099: SQL status: SELECT in 1.56 seconds
2017-12-21 18:37:14,100: On parsely_post_content: COMMIT
2017-12-21 18:37:14,100: Using redshift connection "parsely_post_content".
2017-12-21 18:37:14,100: On parsely_post_content: COMMIT
2017-12-21 18:37:14,659: SQL status: COMMIT in 0.56 seconds
2017-12-21 18:37:14,659: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7c6250>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:14,716: 18:37:14 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [SELECT in 2.18s]
2017-12-21 18:37:14,717: 18:37:14 | 9 of 25 START incremental model blog_dbt_dev.parsely_video_content... [RUN]
2017-12-21 18:37:14,724: Compiling model.parsely.parsely_video_content
2017-12-21 18:37:14,742: Writing injected SQL for node "model.parsely.parsely_video_content"
2017-12-21 18:37:14,744: Acquiring new redshift connection "parsely_video_content".
2017-12-21 18:37:14,744: Re-using an available connection from the pool.
2017-12-21 18:37:14,744: Using redshift connection "parsely_video_content".
2017-12-21 18:37:14,744: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:14,758: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:14,758: Using redshift connection "parsely_video_content".
2017-12-21 18:37:14,758: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:14,771: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:14,774: Writing runtime SQL for node "model.parsely.parsely_video_content"
2017-12-21 18:37:14,775: Using redshift connection "parsely_video_content".
2017-12-21 18:37:14,775: On parsely_video_content: BEGIN
2017-12-21 18:37:14,777: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:37:14,777: Using redshift connection "parsely_video_content".
2017-12-21 18:37:14,778: On parsely_video_content: 
    
  

  create  table "blog_dbt_dev"."parsely_video_content"
  
  
  as (
    -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
  );
2017-12-21 18:37:16,365: SQL status: SELECT in 1.59 seconds
2017-12-21 18:37:16,366: On parsely_video_content: COMMIT
2017-12-21 18:37:16,366: Using redshift connection "parsely_video_content".
2017-12-21 18:37:16,366: On parsely_video_content: COMMIT
2017-12-21 18:37:16,967: SQL status: COMMIT in 0.60 seconds
2017-12-21 18:37:16,967: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd6d9810>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:17,066: 18:37:17 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [SELECT in 2.24s]
2017-12-21 18:37:17,067: 18:37:17 | 10 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2017-12-21 18:37:17,067: Compiling model.parsely.parsely_entry_exit_urls
2017-12-21 18:37:17,097: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 18:37:17,107: Acquiring new redshift connection "parsely_entry_exit_urls".
2017-12-21 18:37:17,107: Re-using an available connection from the pool.
2017-12-21 18:37:17,108: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 18:37:17,108: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:17,122: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:17,126: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2017-12-21 18:37:17,129: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 18:37:17,129: On parsely_entry_exit_urls: BEGIN
2017-12-21 18:37:17,131: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:37:17,132: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 18:37:17,132: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2017-12-21 18:37:17,192: SQL status: CREATE VIEW in 0.06 seconds
2017-12-21 18:37:17,193: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 18:37:17,193: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2017-12-21 18:37:17,196: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:37:17,196: On parsely_entry_exit_urls: COMMIT
2017-12-21 18:37:17,196: Using redshift connection "parsely_entry_exit_urls".
2017-12-21 18:37:17,196: On parsely_entry_exit_urls: COMMIT
2017-12-21 18:37:17,577: SQL status: COMMIT in 0.38 seconds
2017-12-21 18:37:17,578: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd6af750>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:17,632: 18:37:17 | 10 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.51s]
2017-12-21 18:37:17,632: 18:37:17 | 11 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2017-12-21 18:37:17,632: Compiling model.parsely.parsely_incoming_videoviews
2017-12-21 18:37:17,670: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 18:37:17,673: Acquiring new redshift connection "parsely_incoming_videoviews".
2017-12-21 18:37:17,674: Re-using an available connection from the pool.
2017-12-21 18:37:17,674: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 18:37:17,674: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:17,689: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:17,695: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2017-12-21 18:37:17,704: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 18:37:17,704: On parsely_incoming_videoviews: BEGIN
2017-12-21 18:37:17,706: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:37:17,706: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 18:37:17,707: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2017-12-21 18:37:18,004: SQL status: CREATE VIEW in 0.30 seconds
2017-12-21 18:37:18,005: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 18:37:18,005: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2017-12-21 18:37:18,010: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:37:18,010: On parsely_incoming_videoviews: COMMIT
2017-12-21 18:37:18,010: Using redshift connection "parsely_incoming_videoviews".
2017-12-21 18:37:18,010: On parsely_incoming_videoviews: COMMIT
2017-12-21 18:37:18,411: SQL status: COMMIT in 0.40 seconds
2017-12-21 18:37:18,412: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd782850>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:18,467: 18:37:18 | 11 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.78s]
2017-12-21 18:37:18,467: 18:37:18 | 12 of 25 START incremental model blog_dbt_dev.parsely_event_ids...... [RUN]
2017-12-21 18:37:18,468: Compiling model.parsely.parsely_event_ids
2017-12-21 18:37:18,487: Writing injected SQL for node "model.parsely.parsely_event_ids"
2017-12-21 18:37:18,501: Acquiring new redshift connection "parsely_event_ids".
2017-12-21 18:37:18,501: Re-using an available connection from the pool.
2017-12-21 18:37:18,501: Using redshift connection "parsely_event_ids".
2017-12-21 18:37:18,501: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:18,515: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:18,515: Using redshift connection "parsely_event_ids".
2017-12-21 18:37:18,516: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:18,528: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:18,531: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2017-12-21 18:37:18,532: Using redshift connection "parsely_event_ids".
2017-12-21 18:37:18,532: On parsely_event_ids: BEGIN
2017-12-21 18:37:18,538: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:37:18,538: Using redshift connection "parsely_event_ids".
2017-12-21 18:37:18,538: On parsely_event_ids: 
    
  

  create  table "blog_dbt_dev"."parsely_event_ids"
  
  
  as (
    

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
  );
2017-12-21 18:37:19,150: SQL status: SELECT in 0.61 seconds
2017-12-21 18:37:19,151: On parsely_event_ids: COMMIT
2017-12-21 18:37:19,151: Using redshift connection "parsely_event_ids".
2017-12-21 18:37:19,151: On parsely_event_ids: COMMIT
2017-12-21 18:37:19,620: SQL status: COMMIT in 0.47 seconds
2017-12-21 18:37:19,621: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd6af3d0>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:19,681: 18:37:19 | 12 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids. [SELECT in 1.15s]
2017-12-21 18:37:19,682: 18:37:19 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2017-12-21 18:37:19,682: Compiling model.parsely.parsely_videoviews_sessionized
2017-12-21 18:37:19,700: Acquiring new redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:37:19,700: Re-using an available connection from the pool.
2017-12-21 18:37:19,700: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:37:19,700: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:19,714: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:19,719: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 18:37:19,729: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:37:19,729: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:19,742: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:19,743: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:37:19,743: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:19,756: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:19,759: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2017-12-21 18:37:19,760: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:37:19,760: On parsely_videoviews_sessionized: BEGIN
2017-12-21 18:37:19,768: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:37:19,768: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:37:19,768: On parsely_videoviews_sessionized: 
    
  

  create  table "blog_dbt_dev"."parsely_videoviews_sessionized"
  
  
  as (
    

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




-- initial run, don't merge
merged as (

    select
      *
    from incoming_videoviews
)



select
  *
from merged
  );
2017-12-21 18:37:27,717: SQL status: SELECT in 7.95 seconds
2017-12-21 18:37:27,718: On parsely_videoviews_sessionized: COMMIT
2017-12-21 18:37:27,718: Using redshift connection "parsely_videoviews_sessionized".
2017-12-21 18:37:27,718: On parsely_videoviews_sessionized: COMMIT
2017-12-21 18:37:29,718: SQL status: COMMIT in 2.00 seconds
2017-12-21 18:37:29,718: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7c6290>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:29,765: 18:37:29 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [SELECT in 10.04s]
2017-12-21 18:37:29,765: Compiling model.parsely.parsely_parent_videostart_keys
2017-12-21 18:37:29,845: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2017-12-21 18:37:29,847: 18:37:29 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2017-12-21 18:37:29,847: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2017-12-21 18:37:29,897: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 18:37:29,899: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:37:29,899: Re-using an available connection from the pool.
2017-12-21 18:37:29,899: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:37:29,899: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:29,913: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:29,916: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2017-12-21 18:37:29,917: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:37:29,917: On parsely_pageview_hanging_engagedtime: BEGIN
2017-12-21 18:37:29,919: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:37:29,920: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:37:29,920: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2017-12-21 18:37:29,987: SQL status: CREATE VIEW in 0.07 seconds
2017-12-21 18:37:29,988: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:37:29,988: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2017-12-21 18:37:29,991: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:37:29,992: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 18:37:29,992: Using redshift connection "parsely_pageview_hanging_engagedtime".
2017-12-21 18:37:29,992: On parsely_pageview_hanging_engagedtime: COMMIT
2017-12-21 18:37:30,174: SQL status: COMMIT in 0.18 seconds
2017-12-21 18:37:30,175: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd6d9610>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:30,227: 18:37:30 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.33s]
2017-12-21 18:37:30,230: 18:37:30 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2017-12-21 18:37:30,230: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2017-12-21 18:37:30,367: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 18:37:30,381: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:37:30,381: Re-using an available connection from the pool.
2017-12-21 18:37:30,382: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:37:30,382: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:30,395: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:30,400: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2017-12-21 18:37:30,401: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:37:30,401: On parsely_videoview_hanging_engagedtime: BEGIN
2017-12-21 18:37:30,408: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:37:30,408: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:37:30,408: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2017-12-21 18:37:30,537: SQL status: CREATE VIEW in 0.13 seconds
2017-12-21 18:37:30,538: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:37:30,538: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2017-12-21 18:37:30,542: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:37:30,542: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 18:37:30,542: Using redshift connection "parsely_videoview_hanging_engagedtime".
2017-12-21 18:37:30,542: On parsely_videoview_hanging_engagedtime: COMMIT
2017-12-21 18:37:30,699: SQL status: COMMIT in 0.16 seconds
2017-12-21 18:37:30,700: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd71e510>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:30,738: 18:37:30 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.47s]
2017-12-21 18:37:30,738: 18:37:30 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2017-12-21 18:37:30,738: Compiling model.parsely.parsely_incoming_pageviews
2017-12-21 18:37:30,753: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 18:37:30,756: Acquiring new redshift connection "parsely_incoming_pageviews".
2017-12-21 18:37:30,756: Re-using an available connection from the pool.
2017-12-21 18:37:30,756: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 18:37:30,756: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:30,770: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:30,786: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2017-12-21 18:37:30,788: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 18:37:30,788: On parsely_incoming_pageviews: BEGIN
2017-12-21 18:37:30,796: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:37:30,796: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 18:37:30,796: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2017-12-21 18:37:31,405: SQL status: CREATE VIEW in 0.61 seconds
2017-12-21 18:37:31,406: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 18:37:31,406: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2017-12-21 18:37:31,411: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:37:31,411: On parsely_incoming_pageviews: COMMIT
2017-12-21 18:37:31,411: Using redshift connection "parsely_incoming_pageviews".
2017-12-21 18:37:31,411: On parsely_incoming_pageviews: COMMIT
2017-12-21 18:37:32,058: SQL status: COMMIT in 0.65 seconds
2017-12-21 18:37:32,059: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd71ed90>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:37:32,094: 18:37:32 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.32s]
2017-12-21 18:37:32,094: 18:37:32 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2017-12-21 18:37:32,095: Compiling model.parsely.parsely_pageviews_sessionized
2017-12-21 18:37:32,104: Acquiring new redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:37:32,104: Re-using an available connection from the pool.
2017-12-21 18:37:32,104: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:37:32,104: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:32,120: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:32,126: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 18:37:32,127: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:37:32,127: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:32,142: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:32,142: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:37:32,143: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:37:32,157: SQL status: SELECT in 0.01 seconds
2017-12-21 18:37:32,159: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2017-12-21 18:37:32,160: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:37:32,160: On parsely_pageviews_sessionized: BEGIN
2017-12-21 18:37:32,162: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:37:32,162: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:37:32,162: On parsely_pageviews_sessionized: 
    
  

  create  table "blog_dbt_dev"."parsely_pageviews_sessionized"
  
  
  as (
    

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




-- initial run, don't merge
merged as (

    select
      *
    from incoming_pageviews
)



select
  *
from merged
  );
2017-12-21 18:37:59,084: SQL status: SELECT in 26.92 seconds
2017-12-21 18:37:59,084: On parsely_pageviews_sessionized: COMMIT
2017-12-21 18:37:59,085: Using redshift connection "parsely_pageviews_sessionized".
2017-12-21 18:37:59,085: On parsely_pageviews_sessionized: COMMIT
2017-12-21 18:38:00,878: SQL status: COMMIT in 1.79 seconds
2017-12-21 18:38:00,879: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7c6290>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:38:00,925: 18:38:00 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [SELECT in 28.78s]
2017-12-21 18:38:00,926: 18:38:00 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2017-12-21 18:38:00,926: Compiling model.parsely.parsely_videoview_engagedtime
2017-12-21 18:38:01,023: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 18:38:01,026: Acquiring new redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:38:01,026: Re-using an available connection from the pool.
2017-12-21 18:38:01,026: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:38:01,026: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:01,040: SQL status: SELECT in 0.01 seconds
2017-12-21 18:38:01,045: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2017-12-21 18:38:01,046: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:38:01,046: On parsely_videoview_engagedtime: BEGIN
2017-12-21 18:38:01,048: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:38:01,048: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:38:01,048: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2017-12-21 18:38:01,178: SQL status: CREATE VIEW in 0.13 seconds
2017-12-21 18:38:01,179: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:38:01,179: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2017-12-21 18:38:01,184: SQL status: ALTER TABLE in 0.01 seconds
2017-12-21 18:38:01,184: On parsely_videoview_engagedtime: COMMIT
2017-12-21 18:38:01,185: Using redshift connection "parsely_videoview_engagedtime".
2017-12-21 18:38:01,185: On parsely_videoview_engagedtime: COMMIT
2017-12-21 18:38:01,412: SQL status: COMMIT in 0.23 seconds
2017-12-21 18:38:01,413: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7c6250>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:38:01,463: 18:38:01 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.49s]
2017-12-21 18:38:01,464: 18:38:01 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2017-12-21 18:38:01,464: Compiling model.parsely.parsely_videoview_behavior_workflow
2017-12-21 18:38:01,491: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 18:38:01,492: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:38:01,493: Re-using an available connection from the pool.
2017-12-21 18:38:01,493: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:38:01,493: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:01,508: SQL status: SELECT in 0.01 seconds
2017-12-21 18:38:01,509: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:38:01,509: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:01,523: SQL status: SELECT in 0.01 seconds
2017-12-21 18:38:01,527: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2017-12-21 18:38:01,528: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:38:01,528: On parsely_videoview_behavior_workflow: BEGIN
2017-12-21 18:38:01,530: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:38:01,530: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:38:01,530: On parsely_videoview_behavior_workflow: 
    
  

  create  table "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  
  
  as (
    -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
  );
2017-12-21 18:38:34,460: SQL status: SELECT in 32.93 seconds
2017-12-21 18:38:34,461: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 18:38:34,461: Using redshift connection "parsely_videoview_behavior_workflow".
2017-12-21 18:38:34,461: On parsely_videoview_behavior_workflow: COMMIT
2017-12-21 18:38:35,660: SQL status: COMMIT in 1.20 seconds
2017-12-21 18:38:35,661: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd6af510>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:38:35,702: 18:38:35 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [SELECT in 34.20s]
2017-12-21 18:38:35,703: 18:38:35 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2017-12-21 18:38:35,703: Compiling model.parsely.parsely_campaigns
2017-12-21 18:38:35,711: Acquiring new redshift connection "parsely_campaigns".
2017-12-21 18:38:35,711: Re-using an available connection from the pool.
2017-12-21 18:38:35,711: Using redshift connection "parsely_campaigns".
2017-12-21 18:38:35,712: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:35,731: SQL status: SELECT in 0.02 seconds
2017-12-21 18:38:35,737: Writing injected SQL for node "model.parsely.parsely_campaigns"
2017-12-21 18:38:35,739: Using redshift connection "parsely_campaigns".
2017-12-21 18:38:35,739: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:35,754: SQL status: SELECT in 0.02 seconds
2017-12-21 18:38:35,755: Using redshift connection "parsely_campaigns".
2017-12-21 18:38:35,755: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:35,770: SQL status: SELECT in 0.02 seconds
2017-12-21 18:38:35,773: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2017-12-21 18:38:35,774: Using redshift connection "parsely_campaigns".
2017-12-21 18:38:35,774: On parsely_campaigns: BEGIN
2017-12-21 18:38:35,776: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:38:35,777: Using redshift connection "parsely_campaigns".
2017-12-21 18:38:35,777: On parsely_campaigns: 
    
  

  create  table "blog_dbt_dev"."parsely_campaigns"
  
  
  as (
    -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



-- initial run, don't merge
merged as (

    select
      *
    from incoming_campaigns
),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
  );
2017-12-21 18:38:36,112: SQL status: SELECT in 0.33 seconds
2017-12-21 18:38:36,112: On parsely_campaigns: COMMIT
2017-12-21 18:38:36,113: Using redshift connection "parsely_campaigns".
2017-12-21 18:38:36,113: On parsely_campaigns: COMMIT
2017-12-21 18:38:36,894: SQL status: COMMIT in 0.78 seconds
2017-12-21 18:38:36,895: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd6afc10>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:38:36,937: 18:38:36 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [SELECT in 1.19s]
2017-12-21 18:38:36,937: Compiling model.parsely.parsely_incoming_users
2017-12-21 18:38:36,944: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2017-12-21 18:38:36,945: 18:38:36 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2017-12-21 18:38:36,945: Compiling model.parsely.parsely_users
2017-12-21 18:38:36,950: Acquiring new redshift connection "parsely_users".
2017-12-21 18:38:36,951: Re-using an available connection from the pool.
2017-12-21 18:38:36,951: Using redshift connection "parsely_users".
2017-12-21 18:38:36,951: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:36,968: SQL status: SELECT in 0.02 seconds
2017-12-21 18:38:37,009: Writing injected SQL for node "model.parsely.parsely_users"
2017-12-21 18:38:37,011: Using redshift connection "parsely_users".
2017-12-21 18:38:37,011: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:37,027: SQL status: SELECT in 0.02 seconds
2017-12-21 18:38:37,027: Using redshift connection "parsely_users".
2017-12-21 18:38:37,028: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:37,043: SQL status: SELECT in 0.02 seconds
2017-12-21 18:38:37,047: Writing runtime SQL for node "model.parsely.parsely_users"
2017-12-21 18:38:37,048: Using redshift connection "parsely_users".
2017-12-21 18:38:37,048: On parsely_users: BEGIN
2017-12-21 18:38:37,050: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:38:37,050: Using redshift connection "parsely_users".
2017-12-21 18:38:37,050: On parsely_users: 
    
  

  create  table "blog_dbt_dev"."parsely_users"
  
  
  as (
    -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



-- initial run, don't merge
merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        date(min(last_timestamp)) as date_first_seen,
        date(max(last_timestamp)) as date_last_seen,
        -- metrics to aggregate
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from incoming_users
    group by 1,2,3
)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
  );
2017-12-21 18:38:41,230: SQL status: SELECT in 4.18 seconds
2017-12-21 18:38:41,231: On parsely_users: COMMIT
2017-12-21 18:38:41,231: Using redshift connection "parsely_users".
2017-12-21 18:38:41,231: On parsely_users: COMMIT
2017-12-21 18:38:41,667: SQL status: COMMIT in 0.44 seconds
2017-12-21 18:38:41,668: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7c6290>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:38:41,701: 18:38:41 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [SELECT in 4.72s]
2017-12-21 18:38:41,702: 18:38:41 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2017-12-21 18:38:41,702: Compiling model.parsely.parsely_pageview_engagedtime
2017-12-21 18:38:41,763: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 18:38:41,764: Acquiring new redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:38:41,764: Re-using an available connection from the pool.
2017-12-21 18:38:41,765: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:38:41,765: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:41,783: SQL status: SELECT in 0.02 seconds
2017-12-21 18:38:41,787: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2017-12-21 18:38:41,788: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:38:41,788: On parsely_pageview_engagedtime: BEGIN
2017-12-21 18:38:41,796: SQL status: BEGIN in 0.01 seconds
2017-12-21 18:38:41,796: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:38:41,796: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2017-12-21 18:38:42,615: SQL status: CREATE VIEW in 0.82 seconds
2017-12-21 18:38:42,616: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:38:42,616: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2017-12-21 18:38:42,620: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:38:42,620: On parsely_pageview_engagedtime: COMMIT
2017-12-21 18:38:42,620: Using redshift connection "parsely_pageview_engagedtime".
2017-12-21 18:38:42,620: On parsely_pageview_engagedtime: COMMIT
2017-12-21 18:38:42,825: SQL status: COMMIT in 0.21 seconds
2017-12-21 18:38:42,826: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90d8192450>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:38:42,862: 18:38:42 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 1.12s]
2017-12-21 18:38:42,863: 18:38:42 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2017-12-21 18:38:42,863: Compiling model.parsely.parsely_incoming_sessions
2017-12-21 18:38:42,875: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 18:38:42,877: Acquiring new redshift connection "parsely_incoming_sessions".
2017-12-21 18:38:42,877: Re-using an available connection from the pool.
2017-12-21 18:38:42,877: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:38:42,877: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:42,895: SQL status: SELECT in 0.02 seconds
2017-12-21 18:38:42,899: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2017-12-21 18:38:42,900: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:38:42,900: On parsely_incoming_sessions: BEGIN
2017-12-21 18:38:42,902: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:38:42,902: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:38:42,902: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2017-12-21 18:38:42,976: SQL status: CREATE VIEW in 0.07 seconds
2017-12-21 18:38:42,977: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:38:42,977: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2017-12-21 18:38:42,981: SQL status: ALTER TABLE in 0.00 seconds
2017-12-21 18:38:42,981: On parsely_incoming_sessions: COMMIT
2017-12-21 18:38:42,981: Using redshift connection "parsely_incoming_sessions".
2017-12-21 18:38:42,981: On parsely_incoming_sessions: COMMIT
2017-12-21 18:38:43,143: SQL status: COMMIT in 0.16 seconds
2017-12-21 18:38:43,143: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd782e90>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:38:43,195: 18:38:43 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.28s]
2017-12-21 18:38:43,196: 18:38:43 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2017-12-21 18:38:43,196: Compiling model.parsely.parsely_pageview_behavior_workflow
2017-12-21 18:38:43,212: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 18:38:43,214: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:38:43,214: Re-using an available connection from the pool.
2017-12-21 18:38:43,214: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:38:43,214: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:43,232: SQL status: SELECT in 0.02 seconds
2017-12-21 18:38:43,232: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:38:43,232: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:38:43,248: SQL status: SELECT in 0.02 seconds
2017-12-21 18:38:43,252: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2017-12-21 18:38:43,253: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:38:43,253: On parsely_pageview_behavior_workflow: BEGIN
2017-12-21 18:38:43,256: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:38:43,256: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:38:43,256: On parsely_pageview_behavior_workflow: 
    
  

  create  table "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  
  
  as (
    -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
  );
2017-12-21 18:39:34,447: SQL status: SELECT in 51.19 seconds
2017-12-21 18:39:34,447: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 18:39:34,448: Using redshift connection "parsely_pageview_behavior_workflow".
2017-12-21 18:39:34,448: On parsely_pageview_behavior_workflow: COMMIT
2017-12-21 18:39:35,757: SQL status: COMMIT in 1.31 seconds
2017-12-21 18:39:35,758: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd6d9e50>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:39:35,854: 18:39:35 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [SELECT in 52.56s]
2017-12-21 18:39:35,856: 18:39:35 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2017-12-21 18:39:35,856: Compiling model.parsely.parsely_sessions
2017-12-21 18:39:35,884: Acquiring new redshift connection "parsely_sessions".
2017-12-21 18:39:35,892: Re-using an available connection from the pool.
2017-12-21 18:39:35,892: Using redshift connection "parsely_sessions".
2017-12-21 18:39:35,892: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:39:35,913: SQL status: SELECT in 0.02 seconds
2017-12-21 18:39:35,919: Writing injected SQL for node "model.parsely.parsely_sessions"
2017-12-21 18:39:35,921: Using redshift connection "parsely_sessions".
2017-12-21 18:39:35,921: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:39:35,940: SQL status: SELECT in 0.02 seconds
2017-12-21 18:39:35,940: Using redshift connection "parsely_sessions".
2017-12-21 18:39:35,940: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2017-12-21 18:39:35,959: SQL status: SELECT in 0.02 seconds
2017-12-21 18:39:35,962: Writing runtime SQL for node "model.parsely.parsely_sessions"
2017-12-21 18:39:35,963: Using redshift connection "parsely_sessions".
2017-12-21 18:39:35,963: On parsely_sessions: BEGIN
2017-12-21 18:39:35,965: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:39:35,966: Using redshift connection "parsely_sessions".
2017-12-21 18:39:35,969: On parsely_sessions: 
    
  

  create  table "blog_dbt_dev"."parsely_sessions"
  
  
  as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




-- initial run, don't merge
merged as (

    select
      *
    from incoming_sessions
)



select
    * --and derviced fields
from merged
  );
2017-12-21 18:39:44,602: SQL status: SELECT in 8.63 seconds
2017-12-21 18:39:44,603: On parsely_sessions: COMMIT
2017-12-21 18:39:44,603: Using redshift connection "parsely_sessions".
2017-12-21 18:39:44,603: On parsely_sessions: COMMIT
2017-12-21 18:39:45,977: SQL status: COMMIT in 1.37 seconds
2017-12-21 18:39:45,978: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7273d0>], 'label': 'c59c6ee5-de44-4a77-a0d9-26e2acb09596'}
2017-12-21 18:39:46,028: 18:39:46 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [SELECT in 10.12s]
2017-12-21 18:39:46,115: Using redshift connection "master".
2017-12-21 18:39:46,115: On master: BEGIN
2017-12-21 18:39:46,118: SQL status: BEGIN in 0.00 seconds
2017-12-21 18:39:46,118: On master: COMMIT
2017-12-21 18:39:46,118: Using redshift connection "master".
2017-12-21 18:39:46,118: On master: COMMIT
2017-12-21 18:39:46,120: SQL status: COMMIT in 0.00 seconds
2017-12-21 18:39:46,120: Compiling operation.parsely.parsely-on-run-end-0
2017-12-21 18:39:46,125: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2017-12-21 18:39:46,126: Using redshift connection "master".
2017-12-21 18:39:46,126: On master:  select 1 
2017-12-21 18:39:46,128: SQL status: SELECT in 0.00 seconds
2017-12-21 18:39:46,128: 18:39:46 | 
2017-12-21 18:39:46,128: 18:39:46 | Finished running 10 view models, 15 incremental models in 403.06s.
2017-12-21 18:39:46,129: 
2017-12-21 18:39:46,129: Completed successfully
2017-12-21 18:39:46,129: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2017-12-21 18:39:46,130: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7cd250>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7cd4d0>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f90cd7b4990>], 'label': 'end'}
2017-12-21 18:39:46,164: Flushing usage events
