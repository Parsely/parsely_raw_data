2018-01-08 17:11:27,842: Tracking: tracking
2018-01-08 17:11:27,854: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f210e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f210f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f210ed0>], 'label': 'start'}
2018-01-08 17:11:28,016: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-08 17:11:28,047: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-08 17:11:28,049: Parsing core.sql
2018-01-08 17:11:28,084: Parsing etc/get_custom_schema.sql
2018-01-08 17:11:28,098: Parsing schema_tests/relationships.sql
2018-01-08 17:11:28,108: Parsing schema_tests/accepted_values.sql
2018-01-08 17:11:28,113: Parsing schema_tests/not_null.sql
2018-01-08 17:11:28,124: Parsing schema_tests/unique.sql
2018-01-08 17:11:28,127: Parsing materializations/wrapper.sql
2018-01-08 17:11:28,140: Parsing materializations/archive.sql
2018-01-08 17:11:28,195: Parsing materializations/table.sql
2018-01-08 17:11:28,228: Parsing materializations/helpers.sql
2018-01-08 17:11:28,257: Parsing materializations/bigquery.sql
2018-01-08 17:11:28,282: Parsing materializations/view.sql
2018-01-08 17:11:28,309: Parsing materializations/incremental.sql
2018-01-08 17:11:28,360: Parsing adapters/redshift.sql
2018-01-08 17:11:28,395: Parsing adapters/bigquery.sql
2018-01-08 17:11:28,403: Parsing adapters/postgres.sql
2018-01-08 17:11:28,409: Parsing adapters/common.sql
2018-01-08 17:11:28,446: Parsing model.parsely.parsely_audit
2018-01-08 17:11:28,448: Parsing model.parsely.parsely_video_content
2018-01-08 17:11:28,461: Parsing model.parsely.parsely_post_content
2018-01-08 17:11:28,466: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-08 17:11:28,475: Parsing model.parsely.parsely_rawdata
2018-01-08 17:11:28,480: Parsing model.parsely.calendar
2018-01-08 17:11:28,482: Parsing model.parsely.parsely_all_events
2018-01-08 17:11:28,508: Acquiring new redshift connection "parsely_all_events".
2018-01-08 17:11:28,508: Opening a new connection (0 currently allocated)
2018-01-08 17:11:28,523: Using redshift connection "parsely_all_events".
2018-01-08 17:11:28,523: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:28,551: SQL status: SELECT in 0.03 seconds
2018-01-08 17:11:28,568: Parsing model.parsely.parsely_event_ids
2018-01-08 17:11:28,572: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-08 17:11:28,584: Parsing model.parsely.parsely_base_events
2018-01-08 17:11:28,595: Acquiring new redshift connection "parsely_base_events".
2018-01-08 17:11:28,595: Re-using an available connection from the pool.
2018-01-08 17:11:28,595: Using redshift connection "parsely_base_events".
2018-01-08 17:11:28,595: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:28,619: SQL status: SELECT in 0.02 seconds
2018-01-08 17:11:28,620: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-08 17:11:28,638: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-08 17:11:28,647: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-08 17:11:28,651: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-08 17:11:28,661: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-08 17:11:28,666: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-08 17:11:28,697: Parsing model.parsely.parsely_incoming_pageviews
2018-01-08 17:11:28,718: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-08 17:11:28,739: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:11:28,740: Re-using an available connection from the pool.
2018-01-08 17:11:28,740: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:11:28,740: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:28,764: SQL status: SELECT in 0.02 seconds
2018-01-08 17:11:28,766: Parsing model.parsely.parsely_incoming_videoviews
2018-01-08 17:11:28,785: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-08 17:11:28,795: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:11:28,795: Re-using an available connection from the pool.
2018-01-08 17:11:28,795: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:11:28,795: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:28,819: SQL status: SELECT in 0.02 seconds
2018-01-08 17:11:28,821: Parsing model.parsely.parsely_incoming_users
2018-01-08 17:11:28,826: Parsing model.parsely.parsely_users
2018-01-08 17:11:28,843: Acquiring new redshift connection "parsely_users".
2018-01-08 17:11:28,847: Re-using an available connection from the pool.
2018-01-08 17:11:28,847: Using redshift connection "parsely_users".
2018-01-08 17:11:28,847: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:28,871: SQL status: SELECT in 0.02 seconds
2018-01-08 17:11:28,872: Parsing model.parsely.parsely_errors
2018-01-08 17:11:28,887: Parsing model.parsely.parsely_bot_traffic
2018-01-08 17:11:28,894: Parsing model.parsely.parsely_custom_events
2018-01-08 17:11:28,911: Parsing model.parsely.parsely_incoming_sessions
2018-01-08 17:11:28,917: Parsing model.parsely.parsely_entry_exit_urls
2018-01-08 17:11:28,922: Parsing model.parsely.parsely_sessions
2018-01-08 17:11:28,932: Acquiring new redshift connection "parsely_sessions".
2018-01-08 17:11:28,933: Re-using an available connection from the pool.
2018-01-08 17:11:28,933: Using redshift connection "parsely_sessions".
2018-01-08 17:11:28,933: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:28,954: SQL status: SELECT in 0.02 seconds
2018-01-08 17:11:28,955: Parsing model.parsely.parsely_campaigns
2018-01-08 17:11:28,962: Acquiring new redshift connection "parsely_campaigns".
2018-01-08 17:11:28,962: Re-using an available connection from the pool.
2018-01-08 17:11:28,962: Using redshift connection "parsely_campaigns".
2018-01-08 17:11:28,962: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:28,983: SQL status: SELECT in 0.02 seconds
2018-01-08 17:11:28,997: Parsing operation.parsely.parsely-on-run-end-0
2018-01-08 17:11:29,015: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-08 17:11:29,037: 
2018-01-08 17:11:29,048: Acquiring new redshift connection "master".
2018-01-08 17:11:29,048: Re-using an available connection from the pool.
2018-01-08 17:11:29,048: Using redshift connection "master".
2018-01-08 17:11:29,048: On master: select distinct nspname from pg_namespace
2018-01-08 17:11:29,053: SQL status: SELECT in 0.01 seconds
2018-01-08 17:11:29,058: Using redshift connection "master".
2018-01-08 17:11:29,058: On master: BEGIN
2018-01-08 17:11:29,067: SQL status: BEGIN in 0.01 seconds
2018-01-08 17:11:29,067: On master: COMMIT
2018-01-08 17:11:29,067: Using redshift connection "master".
2018-01-08 17:11:29,067: On master: COMMIT
2018-01-08 17:11:29,069: SQL status: COMMIT in 0.00 seconds
2018-01-08 17:11:29,079: 17:11:29 | Concurrency: 1 threads (target='dev')
2018-01-08 17:11:29,087: 17:11:29 | 
2018-01-08 17:11:29,087: Using redshift connection "master".
2018-01-08 17:11:29,087: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:29,110: SQL status: SELECT in 0.02 seconds
2018-01-08 17:11:29,321: 17:11:29 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-08 17:11:29,321: Compiling model.parsely.calendar
2018-01-08 17:11:29,338: Writing injected SQL for node "model.parsely.calendar"
2018-01-08 17:11:29,339: Acquiring new redshift connection "calendar".
2018-01-08 17:11:29,339: Opening a new connection (1 currently allocated)
2018-01-08 17:11:29,372: Using redshift connection "calendar".
2018-01-08 17:11:29,373: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:29,400: SQL status: SELECT in 0.03 seconds
2018-01-08 17:11:29,417: Writing runtime SQL for node "model.parsely.calendar"
2018-01-08 17:11:29,418: Using redshift connection "calendar".
2018-01-08 17:11:29,418: On calendar: BEGIN
2018-01-08 17:11:29,421: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:11:29,421: Using redshift connection "calendar".
2018-01-08 17:11:29,421: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-08 17:11:29,561: SQL status: CREATE VIEW in 0.14 seconds
2018-01-08 17:11:29,562: On calendar: COMMIT
2018-01-08 17:11:29,562: Using redshift connection "calendar".
2018-01-08 17:11:29,562: On calendar: COMMIT
2018-01-08 17:11:30,272: SQL status: COMMIT in 0.71 seconds
2018-01-08 17:11:30,272: Using redshift connection "calendar".
2018-01-08 17:11:30,272: On calendar: BEGIN
2018-01-08 17:11:30,275: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:11:30,275: Using redshift connection "calendar".
2018-01-08 17:11:30,275: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-08 17:11:30,636: SQL status: DROP VIEW in 0.36 seconds
2018-01-08 17:11:30,637: On calendar: COMMIT
2018-01-08 17:11:30,637: Using redshift connection "calendar".
2018-01-08 17:11:30,637: On calendar: COMMIT
2018-01-08 17:11:31,480: SQL status: COMMIT in 0.84 seconds
2018-01-08 17:11:31,480: Using redshift connection "calendar".
2018-01-08 17:11:31,481: On calendar: BEGIN
2018-01-08 17:11:31,522: SQL status: BEGIN in 0.04 seconds
2018-01-08 17:11:31,522: Using redshift connection "calendar".
2018-01-08 17:11:31,522: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-08 17:11:31,613: SQL status: ALTER TABLE in 0.09 seconds
2018-01-08 17:11:31,613: On calendar: COMMIT
2018-01-08 17:11:31,613: Using redshift connection "calendar".
2018-01-08 17:11:31,613: On calendar: COMMIT
2018-01-08 17:11:31,822: SQL status: COMMIT in 0.21 seconds
2018-01-08 17:11:31,823: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f0fe810>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:11:31,872: 17:11:31 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 2.50s]
2018-01-08 17:11:31,872: 17:11:31 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-08 17:11:31,872: Compiling model.parsely.parsely_rawdata
2018-01-08 17:11:31,890: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-08 17:11:31,909: Acquiring new redshift connection "parsely_rawdata".
2018-01-08 17:11:31,909: Re-using an available connection from the pool.
2018-01-08 17:11:31,909: Using redshift connection "parsely_rawdata".
2018-01-08 17:11:31,910: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:31,934: SQL status: SELECT in 0.02 seconds
2018-01-08 17:11:31,935: Using redshift connection "parsely_rawdata".
2018-01-08 17:11:31,935: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:11:31,959: SQL status: SELECT in 0.02 seconds
2018-01-08 17:11:31,960: Using redshift connection "parsely_rawdata".
2018-01-08 17:11:31,960: On parsely_rawdata: BEGIN
2018-01-08 17:11:31,962: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:11:31,963: Using redshift connection "parsely_rawdata".
2018-01-08 17:11:31,963: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:12:09,374: SQL status: SELECT in 37.41 seconds
2018-01-08 17:12:09,375: Using redshift connection "parsely_rawdata".
2018-01-08 17:12:09,375: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-08 17:12:09,671: SQL status: SELECT in 0.30 seconds
2018-01-08 17:12:09,673: Using redshift connection "parsely_rawdata".
2018-01-08 17:12:09,673: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:12:09,804: SQL status: SELECT in 0.13 seconds
2018-01-08 17:12:09,806: Using redshift connection "parsely_rawdata".
2018-01-08 17:12:09,806: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:12:09,939: SQL status: SELECT in 0.13 seconds
2018-01-08 17:12:09,945: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-08 17:12:09,946: Using redshift connection "parsely_rawdata".
2018-01-08 17:12:09,946: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-08 17:12:44,017: SQL status: INSERT 0 1056755 in 34.07 seconds
2018-01-08 17:12:44,018: On parsely_rawdata: COMMIT
2018-01-08 17:12:44,018: Using redshift connection "parsely_rawdata".
2018-01-08 17:12:44,018: On parsely_rawdata: COMMIT
2018-01-08 17:12:45,623: SQL status: COMMIT in 1.60 seconds
2018-01-08 17:12:45,624: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f20a150>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:12:45,706: 17:12:45 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1056755 in 73.75s]
2018-01-08 17:12:45,707: 17:12:45 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-08 17:12:45,707: Compiling model.parsely.parsely_all_events
2018-01-08 17:12:45,717: Acquiring new redshift connection "parsely_all_events".
2018-01-08 17:12:45,717: Re-using an available connection from the pool.
2018-01-08 17:12:45,718: Using redshift connection "parsely_all_events".
2018-01-08 17:12:45,718: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:12:45,739: SQL status: SELECT in 0.02 seconds
2018-01-08 17:12:45,749: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-08 17:12:45,750: Using redshift connection "parsely_all_events".
2018-01-08 17:12:45,750: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:12:45,772: SQL status: SELECT in 0.02 seconds
2018-01-08 17:12:45,772: Using redshift connection "parsely_all_events".
2018-01-08 17:12:45,772: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:12:45,793: SQL status: SELECT in 0.02 seconds
2018-01-08 17:12:45,795: Using redshift connection "parsely_all_events".
2018-01-08 17:12:45,795: On parsely_all_events: BEGIN
2018-01-08 17:12:45,797: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:12:45,797: Using redshift connection "parsely_all_events".
2018-01-08 17:12:45,797: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:14:21,674: SQL status: SELECT in 95.88 seconds
2018-01-08 17:14:21,674: Using redshift connection "parsely_all_events".
2018-01-08 17:14:21,674: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-08 17:14:21,849: SQL status: SELECT in 0.17 seconds
2018-01-08 17:14:21,850: Using redshift connection "parsely_all_events".
2018-01-08 17:14:21,850: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:14:21,985: SQL status: SELECT in 0.13 seconds
2018-01-08 17:14:21,987: Using redshift connection "parsely_all_events".
2018-01-08 17:14:21,987: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:14:22,121: SQL status: SELECT in 0.13 seconds
2018-01-08 17:14:22,128: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-08 17:14:22,129: Using redshift connection "parsely_all_events".
2018-01-08 17:14:22,129: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-08 17:14:41,068: SQL status: INSERT 0 936586 in 18.94 seconds
2018-01-08 17:14:41,068: On parsely_all_events: COMMIT
2018-01-08 17:14:41,068: Using redshift connection "parsely_all_events".
2018-01-08 17:14:41,069: On parsely_all_events: COMMIT
2018-01-08 17:14:43,929: SQL status: COMMIT in 2.86 seconds
2018-01-08 17:14:43,930: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1c5f90>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:14:44,008: 17:14:44 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 936586 in 118.22s]
2018-01-08 17:14:44,015: 17:14:44 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-08 17:14:44,015: Compiling model.parsely.parsely_bot_traffic
2018-01-08 17:14:44,036: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-08 17:14:44,038: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-08 17:14:44,038: Re-using an available connection from the pool.
2018-01-08 17:14:44,039: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:14:44,039: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:14:44,074: SQL status: SELECT in 0.02 seconds
2018-01-08 17:14:44,075: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:14:44,076: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:14:44,098: SQL status: SELECT in 0.02 seconds
2018-01-08 17:14:44,101: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:14:44,101: On parsely_bot_traffic: BEGIN
2018-01-08 17:14:44,103: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:14:44,103: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:14:44,103: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:16:03,263: SQL status: SELECT in 79.16 seconds
2018-01-08 17:16:03,263: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:16:03,263: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-08 17:16:03,565: SQL status: SELECT in 0.30 seconds
2018-01-08 17:16:03,565: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:16:03,566: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:16:03,697: SQL status: SELECT in 0.13 seconds
2018-01-08 17:16:03,698: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:16:03,698: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:16:03,834: SQL status: SELECT in 0.14 seconds
2018-01-08 17:16:03,840: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-08 17:16:03,841: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:16:03,842: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-08 17:16:04,979: SQL status: INSERT 0 4 in 1.14 seconds
2018-01-08 17:16:04,979: On parsely_bot_traffic: COMMIT
2018-01-08 17:16:04,980: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:16:04,980: On parsely_bot_traffic: COMMIT
2018-01-08 17:16:06,184: SQL status: COMMIT in 1.20 seconds
2018-01-08 17:16:06,185: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1c5050>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:16:06,245: 17:16:06 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 82.17s]
2018-01-08 17:16:06,245: 17:16:06 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-08 17:16:06,246: Compiling model.parsely.parsely_custom_events
2018-01-08 17:16:06,261: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-08 17:16:06,264: Acquiring new redshift connection "parsely_custom_events".
2018-01-08 17:16:06,265: Re-using an available connection from the pool.
2018-01-08 17:16:06,265: Using redshift connection "parsely_custom_events".
2018-01-08 17:16:06,265: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:16:06,288: SQL status: SELECT in 0.02 seconds
2018-01-08 17:16:06,289: Using redshift connection "parsely_custom_events".
2018-01-08 17:16:06,289: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:16:06,312: SQL status: SELECT in 0.02 seconds
2018-01-08 17:16:06,315: Using redshift connection "parsely_custom_events".
2018-01-08 17:16:06,315: On parsely_custom_events: BEGIN
2018-01-08 17:16:06,317: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:16:06,318: Using redshift connection "parsely_custom_events".
2018-01-08 17:16:06,318: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:17:27,123: SQL status: SELECT in 80.80 seconds
2018-01-08 17:17:27,123: Using redshift connection "parsely_custom_events".
2018-01-08 17:17:27,123: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-08 17:17:27,452: SQL status: SELECT in 0.33 seconds
2018-01-08 17:17:27,452: Using redshift connection "parsely_custom_events".
2018-01-08 17:17:27,452: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:17:27,582: SQL status: SELECT in 0.13 seconds
2018-01-08 17:17:27,584: Using redshift connection "parsely_custom_events".
2018-01-08 17:17:27,584: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:17:27,709: SQL status: SELECT in 0.13 seconds
2018-01-08 17:17:27,716: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-08 17:17:27,717: Using redshift connection "parsely_custom_events".
2018-01-08 17:17:27,718: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-08 17:17:28,007: SQL status: INSERT 0 0 in 0.29 seconds
2018-01-08 17:17:28,007: On parsely_custom_events: COMMIT
2018-01-08 17:17:28,008: Using redshift connection "parsely_custom_events".
2018-01-08 17:17:28,008: On parsely_custom_events: COMMIT
2018-01-08 17:17:28,435: SQL status: COMMIT in 0.43 seconds
2018-01-08 17:17:28,436: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1c5050>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:17:28,551: 17:17:28 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 82.19s]
2018-01-08 17:17:28,552: 17:17:28 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-08 17:17:28,552: Compiling model.parsely.parsely_errors
2018-01-08 17:17:28,565: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-08 17:17:28,567: Acquiring new redshift connection "parsely_errors".
2018-01-08 17:17:28,567: Re-using an available connection from the pool.
2018-01-08 17:17:28,568: Using redshift connection "parsely_errors".
2018-01-08 17:17:28,568: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:17:28,592: SQL status: SELECT in 0.02 seconds
2018-01-08 17:17:28,593: Using redshift connection "parsely_errors".
2018-01-08 17:17:28,593: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:17:28,615: SQL status: SELECT in 0.02 seconds
2018-01-08 17:17:28,617: Using redshift connection "parsely_errors".
2018-01-08 17:17:28,617: On parsely_errors: BEGIN
2018-01-08 17:17:28,619: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:17:28,619: Using redshift connection "parsely_errors".
2018-01-08 17:17:28,619: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:18:48,212: SQL status: SELECT in 79.59 seconds
2018-01-08 17:18:48,213: Using redshift connection "parsely_errors".
2018-01-08 17:18:48,213: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-08 17:18:48,392: SQL status: SELECT in 0.18 seconds
2018-01-08 17:18:48,393: Using redshift connection "parsely_errors".
2018-01-08 17:18:48,393: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:18:48,527: SQL status: SELECT in 0.13 seconds
2018-01-08 17:18:48,529: Using redshift connection "parsely_errors".
2018-01-08 17:18:48,529: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:18:48,662: SQL status: SELECT in 0.13 seconds
2018-01-08 17:18:48,668: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-08 17:18:48,669: Using redshift connection "parsely_errors".
2018-01-08 17:18:48,669: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-08 17:18:49,391: SQL status: INSERT 0 2 in 0.72 seconds
2018-01-08 17:18:49,391: On parsely_errors: COMMIT
2018-01-08 17:18:49,391: Using redshift connection "parsely_errors".
2018-01-08 17:18:49,392: On parsely_errors: COMMIT
2018-01-08 17:18:50,054: SQL status: COMMIT in 0.66 seconds
2018-01-08 17:18:50,054: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1c5050>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:18:50,106: 17:18:50 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 81.50s]
2018-01-08 17:18:50,106: 17:18:50 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-08 17:18:50,107: Compiling model.parsely.parsely_base_events
2018-01-08 17:18:50,114: Acquiring new redshift connection "parsely_base_events".
2018-01-08 17:18:50,114: Re-using an available connection from the pool.
2018-01-08 17:18:50,114: Using redshift connection "parsely_base_events".
2018-01-08 17:18:50,114: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:18:50,138: SQL status: SELECT in 0.02 seconds
2018-01-08 17:18:50,145: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-08 17:18:50,147: Using redshift connection "parsely_base_events".
2018-01-08 17:18:50,147: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:18:50,169: SQL status: SELECT in 0.02 seconds
2018-01-08 17:18:50,172: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-08 17:18:50,173: Using redshift connection "parsely_base_events".
2018-01-08 17:18:50,173: On parsely_base_events: BEGIN
2018-01-08 17:18:50,175: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:18:50,175: Using redshift connection "parsely_base_events".
2018-01-08 17:18:50,175: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-08 17:18:50,350: SQL status: CREATE VIEW in 0.18 seconds
2018-01-08 17:18:50,351: On parsely_base_events: COMMIT
2018-01-08 17:18:50,351: Using redshift connection "parsely_base_events".
2018-01-08 17:18:50,352: On parsely_base_events: COMMIT
2018-01-08 17:18:50,604: SQL status: COMMIT in 0.25 seconds
2018-01-08 17:18:50,604: Using redshift connection "parsely_base_events".
2018-01-08 17:18:50,605: On parsely_base_events: BEGIN
2018-01-08 17:18:50,607: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:18:50,607: Using redshift connection "parsely_base_events".
2018-01-08 17:18:50,607: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-08 17:18:51,334: SQL status: DROP VIEW in 0.73 seconds
2018-01-08 17:18:51,334: On parsely_base_events: COMMIT
2018-01-08 17:18:51,334: Using redshift connection "parsely_base_events".
2018-01-08 17:18:51,334: On parsely_base_events: COMMIT
2018-01-08 17:18:51,730: SQL status: COMMIT in 0.40 seconds
2018-01-08 17:18:51,730: Using redshift connection "parsely_base_events".
2018-01-08 17:18:51,730: On parsely_base_events: BEGIN
2018-01-08 17:18:51,733: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:18:51,733: Using redshift connection "parsely_base_events".
2018-01-08 17:18:51,733: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-08 17:18:51,868: SQL status: ALTER TABLE in 0.13 seconds
2018-01-08 17:18:51,868: On parsely_base_events: COMMIT
2018-01-08 17:18:51,868: Using redshift connection "parsely_base_events".
2018-01-08 17:18:51,868: On parsely_base_events: COMMIT
2018-01-08 17:18:53,082: SQL status: COMMIT in 1.21 seconds
2018-01-08 17:18:53,082: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1c5f90>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:18:53,113: 17:18:53 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 2.98s]
2018-01-08 17:18:53,114: 17:18:53 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-08 17:18:53,114: Compiling model.parsely.parsely_event_ids
2018-01-08 17:18:53,119: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-08 17:18:53,122: Acquiring new redshift connection "parsely_event_ids".
2018-01-08 17:18:53,122: Re-using an available connection from the pool.
2018-01-08 17:18:53,122: Using redshift connection "parsely_event_ids".
2018-01-08 17:18:53,122: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:18:53,146: SQL status: SELECT in 0.02 seconds
2018-01-08 17:18:53,146: Using redshift connection "parsely_event_ids".
2018-01-08 17:18:53,147: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:18:53,173: SQL status: SELECT in 0.03 seconds
2018-01-08 17:18:53,175: Using redshift connection "parsely_event_ids".
2018-01-08 17:18:53,175: On parsely_event_ids: BEGIN
2018-01-08 17:18:53,177: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:18:53,177: Using redshift connection "parsely_event_ids".
2018-01-08 17:18:53,178: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:18:55,463: SQL status: SELECT in 2.28 seconds
2018-01-08 17:18:55,463: Using redshift connection "parsely_event_ids".
2018-01-08 17:18:55,463: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-08 17:18:55,659: SQL status: SELECT in 0.20 seconds
2018-01-08 17:18:55,659: Using redshift connection "parsely_event_ids".
2018-01-08 17:18:55,659: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:18:55,789: SQL status: SELECT in 0.13 seconds
2018-01-08 17:18:55,790: Using redshift connection "parsely_event_ids".
2018-01-08 17:18:55,790: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:18:55,917: SQL status: SELECT in 0.13 seconds
2018-01-08 17:18:55,919: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-08 17:18:55,921: Using redshift connection "parsely_event_ids".
2018-01-08 17:18:55,921: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-08 17:18:57,785: SQL status: INSERT 0 936582 in 1.86 seconds
2018-01-08 17:18:57,785: On parsely_event_ids: COMMIT
2018-01-08 17:18:57,786: Using redshift connection "parsely_event_ids".
2018-01-08 17:18:57,786: On parsely_event_ids: COMMIT
2018-01-08 17:18:58,460: SQL status: COMMIT in 0.67 seconds
2018-01-08 17:18:58,461: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f123d50>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:18:58,497: 17:18:58 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 936582 in 5.35s]
2018-01-08 17:18:58,498: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-08 17:18:58,508: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-08 17:18:58,510: 17:18:58 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-08 17:18:58,510: Compiling model.parsely.parsely_post_content
2018-01-08 17:18:58,531: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-08 17:18:58,532: Acquiring new redshift connection "parsely_post_content".
2018-01-08 17:18:58,532: Re-using an available connection from the pool.
2018-01-08 17:18:58,532: Using redshift connection "parsely_post_content".
2018-01-08 17:18:58,532: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:18:58,557: SQL status: SELECT in 0.02 seconds
2018-01-08 17:18:58,557: Using redshift connection "parsely_post_content".
2018-01-08 17:18:58,557: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:18:58,580: SQL status: SELECT in 0.02 seconds
2018-01-08 17:18:58,582: Using redshift connection "parsely_post_content".
2018-01-08 17:18:58,582: On parsely_post_content: BEGIN
2018-01-08 17:18:58,584: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:18:58,584: Using redshift connection "parsely_post_content".
2018-01-08 17:18:58,584: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:19:15,160: SQL status: SELECT in 16.58 seconds
2018-01-08 17:19:15,161: Using redshift connection "parsely_post_content".
2018-01-08 17:19:15,161: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-08 17:19:15,522: SQL status: SELECT in 0.36 seconds
2018-01-08 17:19:15,523: Using redshift connection "parsely_post_content".
2018-01-08 17:19:15,523: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:19:15,656: SQL status: SELECT in 0.13 seconds
2018-01-08 17:19:15,657: Using redshift connection "parsely_post_content".
2018-01-08 17:19:15,658: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:19:15,788: SQL status: SELECT in 0.13 seconds
2018-01-08 17:19:15,790: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-08 17:19:15,791: Using redshift connection "parsely_post_content".
2018-01-08 17:19:15,791: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-08 17:19:16,184: SQL status: INSERT 0 894 in 0.39 seconds
2018-01-08 17:19:16,185: On parsely_post_content: COMMIT
2018-01-08 17:19:16,185: Using redshift connection "parsely_post_content".
2018-01-08 17:19:16,185: On parsely_post_content: COMMIT
2018-01-08 17:19:16,609: SQL status: COMMIT in 0.42 seconds
2018-01-08 17:19:16,610: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f15ff10>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:19:16,646: 17:19:16 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 894 in 18.10s]
2018-01-08 17:19:16,646: 17:19:16 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-08 17:19:16,647: Compiling model.parsely.parsely_video_content
2018-01-08 17:19:16,658: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-08 17:19:16,660: Acquiring new redshift connection "parsely_video_content".
2018-01-08 17:19:16,660: Re-using an available connection from the pool.
2018-01-08 17:19:16,660: Using redshift connection "parsely_video_content".
2018-01-08 17:19:16,660: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:19:16,683: SQL status: SELECT in 0.02 seconds
2018-01-08 17:19:16,684: Using redshift connection "parsely_video_content".
2018-01-08 17:19:16,685: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:19:16,709: SQL status: SELECT in 0.02 seconds
2018-01-08 17:19:16,711: Using redshift connection "parsely_video_content".
2018-01-08 17:19:16,711: On parsely_video_content: BEGIN
2018-01-08 17:19:16,713: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:19:16,713: Using redshift connection "parsely_video_content".
2018-01-08 17:19:16,713: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:19:31,623: SQL status: SELECT in 14.91 seconds
2018-01-08 17:19:31,623: Using redshift connection "parsely_video_content".
2018-01-08 17:19:31,624: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-08 17:19:31,814: SQL status: SELECT in 0.19 seconds
2018-01-08 17:19:31,814: Using redshift connection "parsely_video_content".
2018-01-08 17:19:31,814: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:19:31,939: SQL status: SELECT in 0.12 seconds
2018-01-08 17:19:31,940: Using redshift connection "parsely_video_content".
2018-01-08 17:19:31,940: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:19:32,066: SQL status: SELECT in 0.13 seconds
2018-01-08 17:19:32,067: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-08 17:19:32,068: Using redshift connection "parsely_video_content".
2018-01-08 17:19:32,069: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-08 17:19:32,482: SQL status: INSERT 0 470 in 0.41 seconds
2018-01-08 17:19:32,483: On parsely_video_content: COMMIT
2018-01-08 17:19:32,483: Using redshift connection "parsely_video_content".
2018-01-08 17:19:32,483: On parsely_video_content: COMMIT
2018-01-08 17:19:33,327: SQL status: COMMIT in 0.84 seconds
2018-01-08 17:19:33,328: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f20a2d0>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:19:33,368: 17:19:33 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 470 in 16.68s]
2018-01-08 17:19:33,369: 17:19:33 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-08 17:19:33,369: Compiling model.parsely.parsely_entry_exit_urls
2018-01-08 17:19:33,379: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-08 17:19:33,381: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-08 17:19:33,381: Re-using an available connection from the pool.
2018-01-08 17:19:33,381: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 17:19:33,382: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:19:33,405: SQL status: SELECT in 0.02 seconds
2018-01-08 17:19:33,409: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-08 17:19:33,410: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 17:19:33,410: On parsely_entry_exit_urls: BEGIN
2018-01-08 17:19:33,412: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:19:33,412: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 17:19:33,412: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-08 17:19:33,570: SQL status: CREATE VIEW in 0.16 seconds
2018-01-08 17:19:33,571: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 17:19:33,571: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-08 17:19:33,574: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:19:33,574: On parsely_entry_exit_urls: COMMIT
2018-01-08 17:19:33,574: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 17:19:33,574: On parsely_entry_exit_urls: COMMIT
2018-01-08 17:19:34,194: SQL status: COMMIT in 0.62 seconds
2018-01-08 17:19:34,195: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f20a210>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:19:34,235: 17:19:34 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.83s]
2018-01-08 17:19:34,235: 17:19:34 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-08 17:19:34,236: Compiling model.parsely.parsely_incoming_videoviews
2018-01-08 17:19:34,254: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-08 17:19:34,257: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-08 17:19:34,257: Re-using an available connection from the pool.
2018-01-08 17:19:34,257: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 17:19:34,257: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:19:34,280: SQL status: SELECT in 0.02 seconds
2018-01-08 17:19:34,286: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-08 17:19:34,288: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 17:19:34,288: On parsely_incoming_videoviews: BEGIN
2018-01-08 17:19:34,290: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:19:34,290: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 17:19:34,290: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-08 17:19:34,623: SQL status: CREATE VIEW in 0.33 seconds
2018-01-08 17:19:34,623: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 17:19:34,624: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-08 17:19:34,628: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:19:34,628: On parsely_incoming_videoviews: COMMIT
2018-01-08 17:19:34,628: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 17:19:34,628: On parsely_incoming_videoviews: COMMIT
2018-01-08 17:19:34,904: SQL status: COMMIT in 0.28 seconds
2018-01-08 17:19:34,904: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f20a210>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:19:34,934: 17:19:34 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.67s]
2018-01-08 17:19:34,935: 17:19:34 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-08 17:19:34,935: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-08 17:19:34,940: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:19:34,940: Re-using an available connection from the pool.
2018-01-08 17:19:34,940: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:19:34,940: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:19:34,967: SQL status: SELECT in 0.03 seconds
2018-01-08 17:19:34,970: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-08 17:19:34,972: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:19:34,972: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:19:34,994: SQL status: SELECT in 0.02 seconds
2018-01-08 17:19:34,996: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:19:34,996: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:19:35,018: SQL status: SELECT in 0.02 seconds
2018-01-08 17:19:35,022: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:19:35,022: On parsely_videoviews_sessionized: BEGIN
2018-01-08 17:19:35,024: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:19:35,024: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:19:35,024: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:21:14,503: SQL status: SELECT in 99.48 seconds
2018-01-08 17:21:14,503: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:21:14,503: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-08 17:21:14,783: SQL status: SELECT in 0.28 seconds
2018-01-08 17:21:14,784: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:21:14,784: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:21:14,897: SQL status: SELECT in 0.11 seconds
2018-01-08 17:21:14,898: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:21:14,898: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:21:15,009: SQL status: SELECT in 0.11 seconds
2018-01-08 17:21:15,013: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-08 17:21:15,014: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:21:15,014: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-08 17:21:16,217: SQL status: INSERT 0 145 in 1.20 seconds
2018-01-08 17:21:16,217: On parsely_videoviews_sessionized: COMMIT
2018-01-08 17:21:16,218: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:21:16,218: On parsely_videoviews_sessionized: COMMIT
2018-01-08 17:21:17,269: SQL status: COMMIT in 1.05 seconds
2018-01-08 17:21:17,270: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f15fbd0>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:21:17,315: 17:21:17 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 145 in 102.33s]
2018-01-08 17:21:17,316: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-08 17:21:17,337: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-08 17:21:17,338: 17:21:17 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-08 17:21:17,338: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-08 17:21:17,351: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-08 17:21:17,352: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:21:17,352: Re-using an available connection from the pool.
2018-01-08 17:21:17,352: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:21:17,353: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:21:17,364: SQL status: SELECT in 0.01 seconds
2018-01-08 17:21:17,366: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-08 17:21:17,367: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:21:17,367: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-08 17:21:17,369: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:21:17,369: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:21:17,369: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-08 17:21:18,909: SQL status: CREATE VIEW in 1.54 seconds
2018-01-08 17:21:18,909: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:21:18,909: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-08 17:21:18,913: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:21:18,913: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-08 17:21:18,913: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:21:18,913: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-08 17:21:20,268: SQL status: COMMIT in 1.36 seconds
2018-01-08 17:21:20,269: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f168110>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:21:20,300: 17:21:20 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 2.93s]
2018-01-08 17:21:20,301: 17:21:20 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-08 17:21:20,301: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-08 17:21:20,329: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-08 17:21:20,331: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:21:20,331: Re-using an available connection from the pool.
2018-01-08 17:21:20,331: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:21:20,331: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:21:20,341: SQL status: SELECT in 0.01 seconds
2018-01-08 17:21:20,344: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-08 17:21:20,345: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:21:20,345: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-08 17:21:20,347: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:21:20,347: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:21:20,347: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-08 17:21:20,519: SQL status: CREATE VIEW in 0.17 seconds
2018-01-08 17:21:20,520: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:21:20,520: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-08 17:21:20,524: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:21:20,524: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-08 17:21:20,524: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:21:20,524: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-08 17:21:20,838: SQL status: COMMIT in 0.31 seconds
2018-01-08 17:21:20,839: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f0fef50>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:21:20,868: 17:21:20 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.54s]
2018-01-08 17:21:20,869: 17:21:20 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-08 17:21:20,869: Compiling model.parsely.parsely_incoming_pageviews
2018-01-08 17:21:20,880: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-08 17:21:20,882: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-08 17:21:20,882: Re-using an available connection from the pool.
2018-01-08 17:21:20,882: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 17:21:20,883: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:21:20,893: SQL status: SELECT in 0.01 seconds
2018-01-08 17:21:20,897: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-08 17:21:20,898: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 17:21:20,898: On parsely_incoming_pageviews: BEGIN
2018-01-08 17:21:20,900: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:21:20,900: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 17:21:20,900: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-08 17:21:21,319: SQL status: CREATE VIEW in 0.42 seconds
2018-01-08 17:21:21,319: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 17:21:21,320: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-08 17:21:21,698: SQL status: ALTER TABLE in 0.38 seconds
2018-01-08 17:21:21,698: On parsely_incoming_pageviews: COMMIT
2018-01-08 17:21:21,698: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 17:21:21,698: On parsely_incoming_pageviews: COMMIT
2018-01-08 17:21:22,054: SQL status: COMMIT in 0.36 seconds
2018-01-08 17:21:22,055: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f0fef50>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:21:22,116: 17:21:22 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.19s]
2018-01-08 17:21:22,116: 17:21:22 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-08 17:21:22,117: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-08 17:21:22,122: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:21:22,122: Re-using an available connection from the pool.
2018-01-08 17:21:22,122: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:21:22,122: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:21:22,133: SQL status: SELECT in 0.01 seconds
2018-01-08 17:21:22,137: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-08 17:21:22,138: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:21:22,138: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:21:22,149: SQL status: SELECT in 0.01 seconds
2018-01-08 17:21:22,149: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:21:22,149: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:21:22,160: SQL status: SELECT in 0.01 seconds
2018-01-08 17:21:22,162: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:21:22,162: On parsely_pageviews_sessionized: BEGIN
2018-01-08 17:21:22,164: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:21:22,164: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:21:22,164: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:26:43,144: SQL status: SELECT in 320.98 seconds
2018-01-08 17:26:43,144: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:26:43,144: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-08 17:26:43,311: SQL status: SELECT in 0.17 seconds
2018-01-08 17:26:43,311: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:26:43,311: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:26:43,435: SQL status: SELECT in 0.12 seconds
2018-01-08 17:26:43,436: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:26:43,436: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:26:43,567: SQL status: SELECT in 0.13 seconds
2018-01-08 17:26:43,570: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-08 17:26:43,571: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:26:43,571: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-08 17:26:46,856: SQL status: INSERT 0 111740 in 3.28 seconds
2018-01-08 17:26:46,856: On parsely_pageviews_sessionized: COMMIT
2018-01-08 17:26:46,856: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:26:46,856: On parsely_pageviews_sessionized: COMMIT
2018-01-08 17:26:48,241: SQL status: COMMIT in 1.38 seconds
2018-01-08 17:26:48,242: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1c5050>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:26:48,278: 17:26:48 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 111740 in 326.12s]
2018-01-08 17:26:48,278: 17:26:48 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-08 17:26:48,279: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-08 17:26:48,321: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-08 17:26:48,322: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:26:48,322: Re-using an available connection from the pool.
2018-01-08 17:26:48,322: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:26:48,322: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:26:48,347: SQL status: SELECT in 0.02 seconds
2018-01-08 17:26:48,350: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-08 17:26:48,351: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:26:48,351: On parsely_videoview_engagedtime: BEGIN
2018-01-08 17:26:48,353: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:26:48,353: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:26:48,353: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-08 17:26:50,053: SQL status: CREATE VIEW in 1.70 seconds
2018-01-08 17:26:50,053: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:26:50,053: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-08 17:26:50,057: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:26:50,058: On parsely_videoview_engagedtime: COMMIT
2018-01-08 17:26:50,058: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:26:50,058: On parsely_videoview_engagedtime: COMMIT
2018-01-08 17:26:50,374: SQL status: COMMIT in 0.32 seconds
2018-01-08 17:26:50,374: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1bdc50>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:26:50,402: 17:26:50 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 2.10s]
2018-01-08 17:26:50,403: 17:26:50 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-08 17:26:50,403: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-08 17:26:50,412: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-08 17:26:50,413: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:26:50,413: Re-using an available connection from the pool.
2018-01-08 17:26:50,414: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:26:50,414: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:26:50,436: SQL status: SELECT in 0.02 seconds
2018-01-08 17:26:50,436: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:26:50,437: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:26:50,458: SQL status: SELECT in 0.02 seconds
2018-01-08 17:26:50,460: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:26:50,460: On parsely_videoview_behavior_workflow: BEGIN
2018-01-08 17:26:50,462: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:26:50,462: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:26:50,462: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:31:21,525: SQL status: SELECT in 271.06 seconds
2018-01-08 17:31:21,525: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:31:21,525: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-08 17:31:21,698: SQL status: SELECT in 0.17 seconds
2018-01-08 17:31:21,698: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:31:21,698: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:31:21,828: SQL status: SELECT in 0.13 seconds
2018-01-08 17:31:21,829: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:31:21,833: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:31:21,953: SQL status: SELECT in 0.12 seconds
2018-01-08 17:31:21,963: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-08 17:31:21,964: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:31:21,964: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-08 17:31:23,207: SQL status: INSERT 0 144 in 1.24 seconds
2018-01-08 17:31:23,208: On parsely_videoview_behavior_workflow: COMMIT
2018-01-08 17:31:23,208: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:31:23,208: On parsely_videoview_behavior_workflow: COMMIT
2018-01-08 17:31:24,496: SQL status: COMMIT in 1.29 seconds
2018-01-08 17:31:24,496: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f15fed0>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:31:24,568: 17:31:24 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 144 in 274.09s]
2018-01-08 17:31:24,569: 17:31:24 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-08 17:31:24,569: Compiling model.parsely.parsely_campaigns
2018-01-08 17:31:24,585: Acquiring new redshift connection "parsely_campaigns".
2018-01-08 17:31:24,585: Re-using an available connection from the pool.
2018-01-08 17:31:24,585: Using redshift connection "parsely_campaigns".
2018-01-08 17:31:24,585: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:31:24,607: SQL status: SELECT in 0.02 seconds
2018-01-08 17:31:24,613: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-08 17:31:24,615: Using redshift connection "parsely_campaigns".
2018-01-08 17:31:24,615: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:31:24,640: SQL status: SELECT in 0.02 seconds
2018-01-08 17:31:24,641: Using redshift connection "parsely_campaigns".
2018-01-08 17:31:24,641: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:31:24,666: SQL status: SELECT in 0.02 seconds
2018-01-08 17:31:24,668: Using redshift connection "parsely_campaigns".
2018-01-08 17:31:24,668: On parsely_campaigns: BEGIN
2018-01-08 17:31:24,670: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:31:24,670: Using redshift connection "parsely_campaigns".
2018-01-08 17:31:24,670: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:31:25,961: SQL status: SELECT in 1.29 seconds
2018-01-08 17:31:25,961: Using redshift connection "parsely_campaigns".
2018-01-08 17:31:25,962: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-08 17:31:26,155: SQL status: SELECT in 0.19 seconds
2018-01-08 17:31:26,155: Using redshift connection "parsely_campaigns".
2018-01-08 17:31:26,155: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:31:26,274: SQL status: SELECT in 0.12 seconds
2018-01-08 17:31:26,274: Using redshift connection "parsely_campaigns".
2018-01-08 17:31:26,275: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:31:26,393: SQL status: SELECT in 0.12 seconds
2018-01-08 17:31:26,395: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-08 17:31:26,396: Using redshift connection "parsely_campaigns".
2018-01-08 17:31:26,396: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-08 17:31:26,556: SQL status: INSERT 0 392 in 0.16 seconds
2018-01-08 17:31:26,557: On parsely_campaigns: COMMIT
2018-01-08 17:31:26,557: Using redshift connection "parsely_campaigns".
2018-01-08 17:31:26,557: On parsely_campaigns: COMMIT
2018-01-08 17:31:27,137: SQL status: COMMIT in 0.58 seconds
2018-01-08 17:31:27,138: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f15fed0>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:31:27,189: 17:31:27 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 392 in 2.57s]
2018-01-08 17:31:27,189: Compiling model.parsely.parsely_incoming_users
2018-01-08 17:31:27,205: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-08 17:31:27,212: 17:31:27 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-08 17:31:27,212: Compiling model.parsely.parsely_users
2018-01-08 17:31:27,225: Acquiring new redshift connection "parsely_users".
2018-01-08 17:31:27,225: Re-using an available connection from the pool.
2018-01-08 17:31:27,226: Using redshift connection "parsely_users".
2018-01-08 17:31:27,226: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:31:27,249: SQL status: SELECT in 0.02 seconds
2018-01-08 17:31:27,355: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-08 17:31:27,358: Using redshift connection "parsely_users".
2018-01-08 17:31:27,358: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:31:27,382: SQL status: SELECT in 0.02 seconds
2018-01-08 17:31:27,383: Using redshift connection "parsely_users".
2018-01-08 17:31:27,383: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:31:27,404: SQL status: SELECT in 0.02 seconds
2018-01-08 17:31:27,408: Using redshift connection "parsely_users".
2018-01-08 17:31:27,408: On parsely_users: BEGIN
2018-01-08 17:31:27,411: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:31:27,411: Using redshift connection "parsely_users".
2018-01-08 17:31:27,411: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:31:30,227: SQL status: SELECT in 2.82 seconds
2018-01-08 17:31:30,227: Using redshift connection "parsely_users".
2018-01-08 17:31:30,227: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-08 17:31:30,419: SQL status: SELECT in 0.19 seconds
2018-01-08 17:31:30,419: Using redshift connection "parsely_users".
2018-01-08 17:31:30,419: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:31:30,549: SQL status: SELECT in 0.13 seconds
2018-01-08 17:31:30,549: Using redshift connection "parsely_users".
2018-01-08 17:31:30,549: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:31:30,677: SQL status: SELECT in 0.13 seconds
2018-01-08 17:31:30,680: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-08 17:31:30,681: Using redshift connection "parsely_users".
2018-01-08 17:31:30,681: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-08 17:31:31,021: SQL status: INSERT 0 54477 in 0.34 seconds
2018-01-08 17:31:31,022: On parsely_users: COMMIT
2018-01-08 17:31:31,022: Using redshift connection "parsely_users".
2018-01-08 17:31:31,022: On parsely_users: COMMIT
2018-01-08 17:31:31,610: SQL status: COMMIT in 0.59 seconds
2018-01-08 17:31:31,611: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f0f4090>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:31:31,726: 17:31:31 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 54477 in 4.40s]
2018-01-08 17:31:31,731: 17:31:31 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-08 17:31:31,731: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-08 17:31:31,898: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-08 17:31:31,900: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:31:31,901: Re-using an available connection from the pool.
2018-01-08 17:31:31,901: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:31:31,901: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:31:31,927: SQL status: SELECT in 0.03 seconds
2018-01-08 17:31:31,931: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-08 17:31:31,932: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:31:31,932: On parsely_pageview_engagedtime: BEGIN
2018-01-08 17:31:31,939: SQL status: BEGIN in 0.01 seconds
2018-01-08 17:31:31,939: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:31:31,939: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-08 17:31:32,252: SQL status: CREATE VIEW in 0.31 seconds
2018-01-08 17:31:32,253: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:31:32,255: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-08 17:31:32,259: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:31:32,259: On parsely_pageview_engagedtime: COMMIT
2018-01-08 17:31:32,260: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:31:32,260: On parsely_pageview_engagedtime: COMMIT
2018-01-08 17:31:32,569: SQL status: COMMIT in 0.31 seconds
2018-01-08 17:31:32,569: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1c5d10>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:31:32,628: 17:31:32 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.84s]
2018-01-08 17:31:32,629: 17:31:32 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-08 17:31:32,629: Compiling model.parsely.parsely_incoming_sessions
2018-01-08 17:31:32,649: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-08 17:31:32,651: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-08 17:31:32,667: Re-using an available connection from the pool.
2018-01-08 17:31:32,667: Using redshift connection "parsely_incoming_sessions".
2018-01-08 17:31:32,667: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:31:32,691: SQL status: SELECT in 0.02 seconds
2018-01-08 17:31:32,695: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-08 17:31:32,696: Using redshift connection "parsely_incoming_sessions".
2018-01-08 17:31:32,696: On parsely_incoming_sessions: BEGIN
2018-01-08 17:31:32,703: SQL status: BEGIN in 0.01 seconds
2018-01-08 17:31:32,703: Using redshift connection "parsely_incoming_sessions".
2018-01-08 17:31:32,703: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-08 17:31:32,976: SQL status: CREATE VIEW in 0.27 seconds
2018-01-08 17:31:32,977: Using redshift connection "parsely_incoming_sessions".
2018-01-08 17:31:32,977: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-08 17:31:32,982: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:31:32,982: On parsely_incoming_sessions: COMMIT
2018-01-08 17:31:32,982: Using redshift connection "parsely_incoming_sessions".
2018-01-08 17:31:32,982: On parsely_incoming_sessions: COMMIT
2018-01-08 17:31:33,294: SQL status: COMMIT in 0.31 seconds
2018-01-08 17:31:33,295: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1bd990>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:31:33,348: 17:31:33 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.67s]
2018-01-08 17:31:33,348: 17:31:33 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-08 17:31:33,349: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-08 17:31:33,379: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-08 17:31:33,381: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:31:33,381: Re-using an available connection from the pool.
2018-01-08 17:31:33,381: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:31:33,382: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:31:33,405: SQL status: SELECT in 0.02 seconds
2018-01-08 17:31:33,406: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:31:33,406: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:31:33,425: SQL status: SELECT in 0.02 seconds
2018-01-08 17:31:33,428: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:31:33,428: On parsely_pageview_behavior_workflow: BEGIN
2018-01-08 17:31:33,430: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:31:33,431: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:31:33,431: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:34:39,771: SQL status: SELECT in 186.34 seconds
2018-01-08 17:34:39,772: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:34:39,772: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-08 17:34:40,014: SQL status: SELECT in 0.24 seconds
2018-01-08 17:34:40,015: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:34:40,015: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:34:40,148: SQL status: SELECT in 0.13 seconds
2018-01-08 17:34:40,149: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:34:40,150: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:34:40,280: SQL status: SELECT in 0.13 seconds
2018-01-08 17:34:40,286: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-08 17:34:40,296: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:34:40,296: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-08 17:34:43,777: SQL status: INSERT 0 111708 in 3.48 seconds
2018-01-08 17:34:43,777: On parsely_pageview_behavior_workflow: COMMIT
2018-01-08 17:34:43,777: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:34:43,778: On parsely_pageview_behavior_workflow: COMMIT
2018-01-08 17:34:45,458: SQL status: COMMIT in 1.68 seconds
2018-01-08 17:34:45,458: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f0f44d0>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:34:45,564: 17:34:45 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 111708 in 192.11s]
2018-01-08 17:34:45,565: 17:34:45 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-08 17:34:45,565: Compiling model.parsely.parsely_sessions
2018-01-08 17:34:45,587: Acquiring new redshift connection "parsely_sessions".
2018-01-08 17:34:45,587: Re-using an available connection from the pool.
2018-01-08 17:34:45,587: Using redshift connection "parsely_sessions".
2018-01-08 17:34:45,587: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:34:45,615: SQL status: SELECT in 0.03 seconds
2018-01-08 17:34:45,621: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-08 17:34:45,635: Using redshift connection "parsely_sessions".
2018-01-08 17:34:45,636: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:34:45,660: SQL status: SELECT in 0.02 seconds
2018-01-08 17:34:45,661: Using redshift connection "parsely_sessions".
2018-01-08 17:34:45,662: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:34:45,685: SQL status: SELECT in 0.02 seconds
2018-01-08 17:34:45,690: Using redshift connection "parsely_sessions".
2018-01-08 17:34:45,690: On parsely_sessions: BEGIN
2018-01-08 17:34:45,699: SQL status: BEGIN in 0.01 seconds
2018-01-08 17:34:45,699: Using redshift connection "parsely_sessions".
2018-01-08 17:34:45,699: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:35:24,448: SQL status: SELECT in 38.75 seconds
2018-01-08 17:35:24,448: Using redshift connection "parsely_sessions".
2018-01-08 17:35:24,448: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-08 17:35:24,658: SQL status: SELECT in 0.21 seconds
2018-01-08 17:35:24,658: Using redshift connection "parsely_sessions".
2018-01-08 17:35:24,659: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:35:24,789: SQL status: SELECT in 0.13 seconds
2018-01-08 17:35:24,790: Using redshift connection "parsely_sessions".
2018-01-08 17:35:24,790: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:35:24,921: SQL status: SELECT in 0.13 seconds
2018-01-08 17:35:24,926: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-08 17:35:24,935: Using redshift connection "parsely_sessions".
2018-01-08 17:35:24,935: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-08 17:35:26,720: SQL status: INSERT 0 90755 in 1.78 seconds
2018-01-08 17:35:26,720: On parsely_sessions: COMMIT
2018-01-08 17:35:26,720: Using redshift connection "parsely_sessions".
2018-01-08 17:35:26,721: On parsely_sessions: COMMIT
2018-01-08 17:35:28,039: SQL status: COMMIT in 1.32 seconds
2018-01-08 17:35:28,040: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1bd690>], 'label': '70674c34-ec81-421d-aca7-3255cd5b0bc1'}
2018-01-08 17:35:28,097: 17:35:28 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 90755 in 42.48s]
2018-01-08 17:35:28,132: Using redshift connection "master".
2018-01-08 17:35:28,132: On master: BEGIN
2018-01-08 17:35:28,139: SQL status: BEGIN in 0.01 seconds
2018-01-08 17:35:28,139: On master: COMMIT
2018-01-08 17:35:28,139: Using redshift connection "master".
2018-01-08 17:35:28,139: On master: COMMIT
2018-01-08 17:35:28,141: SQL status: COMMIT in 0.00 seconds
2018-01-08 17:35:28,141: Compiling operation.parsely.parsely-on-run-end-0
2018-01-08 17:35:28,158: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-08 17:35:28,171: Using redshift connection "master".
2018-01-08 17:35:28,171: On master:  select 1 
2018-01-08 17:35:28,174: SQL status: SELECT in 0.00 seconds
2018-01-08 17:35:28,174: 17:35:28 | 
2018-01-08 17:35:28,174: 17:35:28 | Finished running 10 view models, 15 incremental models in 1439.05s.
2018-01-08 17:35:28,175: 
2018-01-08 17:35:28,175: Completed successfully
2018-01-08 17:35:28,175: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-08 17:35:28,176: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f210e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f210f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f0e6f1f7950>], 'label': 'end'}
2018-01-08 17:35:28,249: Flushing usage events
2018-01-08 17:35:38,928: Tracking: tracking
2018-01-08 17:35:38,929: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd4de10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd4df90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd4ded0>], 'label': 'start'}
2018-01-08 17:35:39,002: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-08 17:35:39,075: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-08 17:35:39,077: Parsing core.sql
2018-01-08 17:35:39,119: Parsing etc/get_custom_schema.sql
2018-01-08 17:35:39,145: Parsing schema_tests/relationships.sql
2018-01-08 17:35:39,150: Parsing schema_tests/accepted_values.sql
2018-01-08 17:35:39,164: Parsing schema_tests/not_null.sql
2018-01-08 17:35:39,166: Parsing schema_tests/unique.sql
2018-01-08 17:35:39,177: Parsing materializations/wrapper.sql
2018-01-08 17:35:39,191: Parsing materializations/archive.sql
2018-01-08 17:35:39,312: Parsing materializations/table.sql
2018-01-08 17:35:39,399: Parsing materializations/helpers.sql
2018-01-08 17:35:39,455: Parsing materializations/bigquery.sql
2018-01-08 17:35:39,521: Parsing materializations/view.sql
2018-01-08 17:35:39,568: Parsing materializations/incremental.sql
2018-01-08 17:35:39,658: Parsing adapters/redshift.sql
2018-01-08 17:35:39,703: Parsing adapters/bigquery.sql
2018-01-08 17:35:39,720: Parsing adapters/postgres.sql
2018-01-08 17:35:39,725: Parsing adapters/common.sql
2018-01-08 17:35:39,777: Parsing model.parsely.parsely_audit
2018-01-08 17:35:39,788: Parsing model.parsely.parsely_video_content
2018-01-08 17:35:39,793: Parsing model.parsely.parsely_post_content
2018-01-08 17:35:39,799: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-08 17:35:39,809: Parsing model.parsely.parsely_rawdata
2018-01-08 17:35:39,816: Parsing model.parsely.calendar
2018-01-08 17:35:39,818: Parsing model.parsely.parsely_all_events
2018-01-08 17:35:39,834: Acquiring new redshift connection "parsely_all_events".
2018-01-08 17:35:39,834: Opening a new connection (0 currently allocated)
2018-01-08 17:35:39,849: Using redshift connection "parsely_all_events".
2018-01-08 17:35:39,849: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:39,877: SQL status: SELECT in 0.03 seconds
2018-01-08 17:35:39,886: Parsing model.parsely.parsely_event_ids
2018-01-08 17:35:39,899: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-08 17:35:39,903: Parsing model.parsely.parsely_base_events
2018-01-08 17:35:39,918: Acquiring new redshift connection "parsely_base_events".
2018-01-08 17:35:39,918: Re-using an available connection from the pool.
2018-01-08 17:35:39,918: Using redshift connection "parsely_base_events".
2018-01-08 17:35:39,918: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:39,941: SQL status: SELECT in 0.02 seconds
2018-01-08 17:35:39,943: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-08 17:35:39,953: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-08 17:35:39,969: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-08 17:35:39,980: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-08 17:35:39,984: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-08 17:35:40,005: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-08 17:35:40,024: Parsing model.parsely.parsely_incoming_pageviews
2018-01-08 17:35:40,046: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-08 17:35:40,072: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:35:40,072: Re-using an available connection from the pool.
2018-01-08 17:35:40,072: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:35:40,072: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:40,096: SQL status: SELECT in 0.02 seconds
2018-01-08 17:35:40,098: Parsing model.parsely.parsely_incoming_videoviews
2018-01-08 17:35:40,116: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-08 17:35:40,130: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:35:40,130: Re-using an available connection from the pool.
2018-01-08 17:35:40,130: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:35:40,130: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:40,154: SQL status: SELECT in 0.02 seconds
2018-01-08 17:35:40,156: Parsing model.parsely.parsely_incoming_users
2018-01-08 17:35:40,160: Parsing model.parsely.parsely_users
2018-01-08 17:35:40,176: Acquiring new redshift connection "parsely_users".
2018-01-08 17:35:40,177: Re-using an available connection from the pool.
2018-01-08 17:35:40,177: Using redshift connection "parsely_users".
2018-01-08 17:35:40,177: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:40,201: SQL status: SELECT in 0.02 seconds
2018-01-08 17:35:40,203: Parsing model.parsely.parsely_errors
2018-01-08 17:35:40,209: Parsing model.parsely.parsely_bot_traffic
2018-01-08 17:35:40,223: Parsing model.parsely.parsely_custom_events
2018-01-08 17:35:40,238: Parsing model.parsely.parsely_incoming_sessions
2018-01-08 17:35:40,251: Parsing model.parsely.parsely_entry_exit_urls
2018-01-08 17:35:40,266: Parsing model.parsely.parsely_sessions
2018-01-08 17:35:40,280: Acquiring new redshift connection "parsely_sessions".
2018-01-08 17:35:40,281: Re-using an available connection from the pool.
2018-01-08 17:35:40,281: Using redshift connection "parsely_sessions".
2018-01-08 17:35:40,281: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:40,305: SQL status: SELECT in 0.02 seconds
2018-01-08 17:35:40,306: Parsing model.parsely.parsely_campaigns
2018-01-08 17:35:40,313: Acquiring new redshift connection "parsely_campaigns".
2018-01-08 17:35:40,313: Re-using an available connection from the pool.
2018-01-08 17:35:40,313: Using redshift connection "parsely_campaigns".
2018-01-08 17:35:40,314: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:40,342: SQL status: SELECT in 0.03 seconds
2018-01-08 17:35:40,361: Parsing operation.parsely.parsely-on-run-end-0
2018-01-08 17:35:40,380: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-08 17:35:40,415: 
2018-01-08 17:35:40,420: Acquiring new redshift connection "master".
2018-01-08 17:35:40,420: Re-using an available connection from the pool.
2018-01-08 17:35:40,420: Using redshift connection "master".
2018-01-08 17:35:40,420: On master: select distinct nspname from pg_namespace
2018-01-08 17:35:40,423: SQL status: SELECT in 0.00 seconds
2018-01-08 17:35:40,427: Using redshift connection "master".
2018-01-08 17:35:40,428: On master: BEGIN
2018-01-08 17:35:40,435: SQL status: BEGIN in 0.01 seconds
2018-01-08 17:35:40,435: On master: COMMIT
2018-01-08 17:35:40,435: Using redshift connection "master".
2018-01-08 17:35:40,435: On master: COMMIT
2018-01-08 17:35:40,437: SQL status: COMMIT in 0.00 seconds
2018-01-08 17:35:40,447: 17:35:40 | Concurrency: 1 threads (target='dev')
2018-01-08 17:35:40,455: 17:35:40 | 
2018-01-08 17:35:40,455: Using redshift connection "master".
2018-01-08 17:35:40,456: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:40,480: SQL status: SELECT in 0.02 seconds
2018-01-08 17:35:40,723: 17:35:40 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-08 17:35:40,723: Compiling model.parsely.calendar
2018-01-08 17:35:40,744: Writing injected SQL for node "model.parsely.calendar"
2018-01-08 17:35:40,746: Acquiring new redshift connection "calendar".
2018-01-08 17:35:40,746: Opening a new connection (1 currently allocated)
2018-01-08 17:35:40,768: Using redshift connection "calendar".
2018-01-08 17:35:40,768: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:40,797: SQL status: SELECT in 0.03 seconds
2018-01-08 17:35:40,801: Writing runtime SQL for node "model.parsely.calendar"
2018-01-08 17:35:40,802: Using redshift connection "calendar".
2018-01-08 17:35:40,802: On calendar: BEGIN
2018-01-08 17:35:40,819: SQL status: BEGIN in 0.02 seconds
2018-01-08 17:35:40,819: Using redshift connection "calendar".
2018-01-08 17:35:40,819: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-08 17:35:40,930: SQL status: CREATE VIEW in 0.11 seconds
2018-01-08 17:35:40,931: On calendar: COMMIT
2018-01-08 17:35:40,931: Using redshift connection "calendar".
2018-01-08 17:35:40,931: On calendar: COMMIT
2018-01-08 17:35:41,647: SQL status: COMMIT in 0.72 seconds
2018-01-08 17:35:41,647: Using redshift connection "calendar".
2018-01-08 17:35:41,647: On calendar: BEGIN
2018-01-08 17:35:41,649: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:35:41,649: Using redshift connection "calendar".
2018-01-08 17:35:41,650: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-08 17:35:41,699: SQL status: DROP VIEW in 0.05 seconds
2018-01-08 17:35:41,699: On calendar: COMMIT
2018-01-08 17:35:41,699: Using redshift connection "calendar".
2018-01-08 17:35:41,700: On calendar: COMMIT
2018-01-08 17:35:42,124: SQL status: COMMIT in 0.42 seconds
2018-01-08 17:35:42,124: Using redshift connection "calendar".
2018-01-08 17:35:42,124: On calendar: BEGIN
2018-01-08 17:35:42,127: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:35:42,127: Using redshift connection "calendar".
2018-01-08 17:35:42,127: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-08 17:35:42,279: SQL status: ALTER TABLE in 0.15 seconds
2018-01-08 17:35:42,279: On calendar: COMMIT
2018-01-08 17:35:42,280: Using redshift connection "calendar".
2018-01-08 17:35:42,280: On calendar: COMMIT
2018-01-08 17:35:42,533: SQL status: COMMIT in 0.25 seconds
2018-01-08 17:35:42,533: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cc3bbd0>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:35:42,600: 17:35:42 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.81s]
2018-01-08 17:35:42,600: 17:35:42 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-08 17:35:42,601: Compiling model.parsely.parsely_rawdata
2018-01-08 17:35:42,632: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-08 17:35:42,641: Acquiring new redshift connection "parsely_rawdata".
2018-01-08 17:35:42,641: Re-using an available connection from the pool.
2018-01-08 17:35:42,641: Using redshift connection "parsely_rawdata".
2018-01-08 17:35:42,641: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:42,667: SQL status: SELECT in 0.02 seconds
2018-01-08 17:35:42,667: Using redshift connection "parsely_rawdata".
2018-01-08 17:35:42,668: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:35:42,692: SQL status: SELECT in 0.02 seconds
2018-01-08 17:35:42,694: Using redshift connection "parsely_rawdata".
2018-01-08 17:35:42,694: On parsely_rawdata: BEGIN
2018-01-08 17:35:42,696: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:35:42,696: Using redshift connection "parsely_rawdata".
2018-01-08 17:35:42,697: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:36:15,701: SQL status: SELECT in 33.00 seconds
2018-01-08 17:36:15,701: Using redshift connection "parsely_rawdata".
2018-01-08 17:36:15,701: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-08 17:36:15,881: SQL status: SELECT in 0.18 seconds
2018-01-08 17:36:15,882: Using redshift connection "parsely_rawdata".
2018-01-08 17:36:15,883: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:36:16,014: SQL status: SELECT in 0.13 seconds
2018-01-08 17:36:16,015: Using redshift connection "parsely_rawdata".
2018-01-08 17:36:16,015: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:36:16,148: SQL status: SELECT in 0.13 seconds
2018-01-08 17:36:16,153: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-08 17:36:16,155: Using redshift connection "parsely_rawdata".
2018-01-08 17:36:16,155: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-08 17:36:52,020: SQL status: INSERT 0 1060743 in 35.86 seconds
2018-01-08 17:36:52,021: On parsely_rawdata: COMMIT
2018-01-08 17:36:52,021: Using redshift connection "parsely_rawdata".
2018-01-08 17:36:52,021: On parsely_rawdata: COMMIT
2018-01-08 17:36:54,301: SQL status: COMMIT in 2.28 seconds
2018-01-08 17:36:54,302: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cca5b10>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:36:54,360: 17:36:54 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1060743 in 71.70s]
2018-01-08 17:36:54,362: 17:36:54 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-08 17:36:54,362: Compiling model.parsely.parsely_all_events
2018-01-08 17:36:54,402: Acquiring new redshift connection "parsely_all_events".
2018-01-08 17:36:54,402: Re-using an available connection from the pool.
2018-01-08 17:36:54,402: Using redshift connection "parsely_all_events".
2018-01-08 17:36:54,402: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:36:54,423: SQL status: SELECT in 0.02 seconds
2018-01-08 17:36:54,445: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-08 17:36:54,460: Using redshift connection "parsely_all_events".
2018-01-08 17:36:54,460: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:36:54,481: SQL status: SELECT in 0.02 seconds
2018-01-08 17:36:54,481: Using redshift connection "parsely_all_events".
2018-01-08 17:36:54,481: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:36:54,501: SQL status: SELECT in 0.02 seconds
2018-01-08 17:36:54,504: Using redshift connection "parsely_all_events".
2018-01-08 17:36:54,504: On parsely_all_events: BEGIN
2018-01-08 17:36:54,506: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:36:54,507: Using redshift connection "parsely_all_events".
2018-01-08 17:36:54,507: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:38:37,461: SQL status: SELECT in 102.95 seconds
2018-01-08 17:38:37,462: Using redshift connection "parsely_all_events".
2018-01-08 17:38:37,462: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-08 17:38:37,853: SQL status: SELECT in 0.39 seconds
2018-01-08 17:38:37,853: Using redshift connection "parsely_all_events".
2018-01-08 17:38:37,854: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:38:37,981: SQL status: SELECT in 0.13 seconds
2018-01-08 17:38:37,983: Using redshift connection "parsely_all_events".
2018-01-08 17:38:37,983: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:38:38,112: SQL status: SELECT in 0.13 seconds
2018-01-08 17:38:38,118: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-08 17:38:38,127: Using redshift connection "parsely_all_events".
2018-01-08 17:38:38,127: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-08 17:38:57,180: SQL status: INSERT 0 940574 in 19.05 seconds
2018-01-08 17:38:57,181: On parsely_all_events: COMMIT
2018-01-08 17:38:57,181: Using redshift connection "parsely_all_events".
2018-01-08 17:38:57,181: On parsely_all_events: COMMIT
2018-01-08 17:39:00,134: SQL status: COMMIT in 2.95 seconds
2018-01-08 17:39:00,134: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189ccfa810>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:39:00,231: 17:39:00 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 940574 in 125.77s]
2018-01-08 17:39:00,239: 17:39:00 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-08 17:39:00,239: Compiling model.parsely.parsely_bot_traffic
2018-01-08 17:39:00,272: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-08 17:39:00,274: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-08 17:39:00,274: Re-using an available connection from the pool.
2018-01-08 17:39:00,275: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:39:00,275: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:39:00,298: SQL status: SELECT in 0.02 seconds
2018-01-08 17:39:00,298: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:39:00,299: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:39:00,317: SQL status: SELECT in 0.02 seconds
2018-01-08 17:39:00,320: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:39:00,320: On parsely_bot_traffic: BEGIN
2018-01-08 17:39:00,322: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:39:00,322: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:39:00,323: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:40:24,270: SQL status: SELECT in 83.95 seconds
2018-01-08 17:40:24,271: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:40:24,271: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-08 17:40:24,453: SQL status: SELECT in 0.18 seconds
2018-01-08 17:40:24,454: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:40:24,454: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:40:24,587: SQL status: SELECT in 0.13 seconds
2018-01-08 17:40:24,589: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:40:24,589: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:40:24,724: SQL status: SELECT in 0.14 seconds
2018-01-08 17:40:24,731: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-08 17:40:24,732: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:40:24,732: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-08 17:40:25,837: SQL status: INSERT 0 4 in 1.10 seconds
2018-01-08 17:40:25,838: On parsely_bot_traffic: COMMIT
2018-01-08 17:40:25,838: Using redshift connection "parsely_bot_traffic".
2018-01-08 17:40:25,838: On parsely_bot_traffic: COMMIT
2018-01-08 17:40:27,111: SQL status: COMMIT in 1.27 seconds
2018-01-08 17:40:27,111: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cc3bc90>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:40:27,185: 17:40:27 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 86.87s]
2018-01-08 17:40:27,185: 17:40:27 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-08 17:40:27,186: Compiling model.parsely.parsely_custom_events
2018-01-08 17:40:27,200: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-08 17:40:27,203: Acquiring new redshift connection "parsely_custom_events".
2018-01-08 17:40:27,203: Re-using an available connection from the pool.
2018-01-08 17:40:27,203: Using redshift connection "parsely_custom_events".
2018-01-08 17:40:27,203: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:40:27,226: SQL status: SELECT in 0.02 seconds
2018-01-08 17:40:27,226: Using redshift connection "parsely_custom_events".
2018-01-08 17:40:27,226: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:40:27,249: SQL status: SELECT in 0.02 seconds
2018-01-08 17:40:27,252: Using redshift connection "parsely_custom_events".
2018-01-08 17:40:27,252: On parsely_custom_events: BEGIN
2018-01-08 17:40:27,254: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:40:27,254: Using redshift connection "parsely_custom_events".
2018-01-08 17:40:27,255: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:41:53,105: SQL status: SELECT in 85.85 seconds
2018-01-08 17:41:53,105: Using redshift connection "parsely_custom_events".
2018-01-08 17:41:53,105: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-08 17:41:53,310: SQL status: SELECT in 0.20 seconds
2018-01-08 17:41:53,310: Using redshift connection "parsely_custom_events".
2018-01-08 17:41:53,310: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:41:53,443: SQL status: SELECT in 0.13 seconds
2018-01-08 17:41:53,445: Using redshift connection "parsely_custom_events".
2018-01-08 17:41:53,445: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:41:53,578: SQL status: SELECT in 0.13 seconds
2018-01-08 17:41:53,585: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-08 17:41:53,586: Using redshift connection "parsely_custom_events".
2018-01-08 17:41:53,586: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-08 17:41:53,882: SQL status: INSERT 0 0 in 0.30 seconds
2018-01-08 17:41:53,883: On parsely_custom_events: COMMIT
2018-01-08 17:41:53,883: Using redshift connection "parsely_custom_events".
2018-01-08 17:41:53,883: On parsely_custom_events: COMMIT
2018-01-08 17:41:54,102: SQL status: COMMIT in 0.22 seconds
2018-01-08 17:41:54,102: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cc3bc90>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:41:54,156: 17:41:54 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 86.92s]
2018-01-08 17:41:54,157: 17:41:54 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-08 17:41:54,157: Compiling model.parsely.parsely_errors
2018-01-08 17:41:54,194: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-08 17:41:54,207: Acquiring new redshift connection "parsely_errors".
2018-01-08 17:41:54,208: Re-using an available connection from the pool.
2018-01-08 17:41:54,208: Using redshift connection "parsely_errors".
2018-01-08 17:41:54,208: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:41:54,234: SQL status: SELECT in 0.03 seconds
2018-01-08 17:41:54,234: Using redshift connection "parsely_errors".
2018-01-08 17:41:54,234: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:41:54,256: SQL status: SELECT in 0.02 seconds
2018-01-08 17:41:54,258: Using redshift connection "parsely_errors".
2018-01-08 17:41:54,258: On parsely_errors: BEGIN
2018-01-08 17:41:54,260: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:41:54,261: Using redshift connection "parsely_errors".
2018-01-08 17:41:54,261: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:43:19,546: SQL status: SELECT in 85.29 seconds
2018-01-08 17:43:19,547: Using redshift connection "parsely_errors".
2018-01-08 17:43:19,547: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-08 17:43:19,873: SQL status: SELECT in 0.33 seconds
2018-01-08 17:43:19,873: Using redshift connection "parsely_errors".
2018-01-08 17:43:19,874: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:43:20,007: SQL status: SELECT in 0.13 seconds
2018-01-08 17:43:20,009: Using redshift connection "parsely_errors".
2018-01-08 17:43:20,009: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:43:20,139: SQL status: SELECT in 0.13 seconds
2018-01-08 17:43:20,145: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-08 17:43:20,146: Using redshift connection "parsely_errors".
2018-01-08 17:43:20,146: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-08 17:43:20,879: SQL status: INSERT 0 2 in 0.73 seconds
2018-01-08 17:43:20,880: On parsely_errors: COMMIT
2018-01-08 17:43:20,880: Using redshift connection "parsely_errors".
2018-01-08 17:43:20,880: On parsely_errors: COMMIT
2018-01-08 17:43:21,575: SQL status: COMMIT in 0.69 seconds
2018-01-08 17:43:21,576: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cc31bd0>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:43:21,708: 17:43:21 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 87.42s]
2018-01-08 17:43:21,719: 17:43:21 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-08 17:43:21,719: Compiling model.parsely.parsely_base_events
2018-01-08 17:43:21,726: Acquiring new redshift connection "parsely_base_events".
2018-01-08 17:43:21,726: Re-using an available connection from the pool.
2018-01-08 17:43:21,726: Using redshift connection "parsely_base_events".
2018-01-08 17:43:21,727: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:43:21,751: SQL status: SELECT in 0.02 seconds
2018-01-08 17:43:21,758: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-08 17:43:21,767: Using redshift connection "parsely_base_events".
2018-01-08 17:43:21,768: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:43:21,792: SQL status: SELECT in 0.02 seconds
2018-01-08 17:43:21,795: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-08 17:43:21,796: Using redshift connection "parsely_base_events".
2018-01-08 17:43:21,796: On parsely_base_events: BEGIN
2018-01-08 17:43:21,798: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:43:21,798: Using redshift connection "parsely_base_events".
2018-01-08 17:43:21,799: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-08 17:43:21,924: SQL status: CREATE VIEW in 0.13 seconds
2018-01-08 17:43:21,924: On parsely_base_events: COMMIT
2018-01-08 17:43:21,925: Using redshift connection "parsely_base_events".
2018-01-08 17:43:21,925: On parsely_base_events: COMMIT
2018-01-08 17:43:22,417: SQL status: COMMIT in 0.49 seconds
2018-01-08 17:43:22,417: Using redshift connection "parsely_base_events".
2018-01-08 17:43:22,417: On parsely_base_events: BEGIN
2018-01-08 17:43:22,420: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:43:22,420: Using redshift connection "parsely_base_events".
2018-01-08 17:43:22,420: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-08 17:43:22,534: SQL status: DROP VIEW in 0.11 seconds
2018-01-08 17:43:22,534: On parsely_base_events: COMMIT
2018-01-08 17:43:22,534: Using redshift connection "parsely_base_events".
2018-01-08 17:43:22,535: On parsely_base_events: COMMIT
2018-01-08 17:43:23,000: SQL status: COMMIT in 0.47 seconds
2018-01-08 17:43:23,000: Using redshift connection "parsely_base_events".
2018-01-08 17:43:23,000: On parsely_base_events: BEGIN
2018-01-08 17:43:23,003: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:43:23,003: Using redshift connection "parsely_base_events".
2018-01-08 17:43:23,003: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-08 17:43:23,088: SQL status: ALTER TABLE in 0.08 seconds
2018-01-08 17:43:23,088: On parsely_base_events: COMMIT
2018-01-08 17:43:23,088: Using redshift connection "parsely_base_events".
2018-01-08 17:43:23,088: On parsely_base_events: COMMIT
2018-01-08 17:43:23,584: SQL status: COMMIT in 0.50 seconds
2018-01-08 17:43:23,585: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cca59d0>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:43:23,649: 17:43:23 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 1.87s]
2018-01-08 17:43:23,649: 17:43:23 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-08 17:43:23,650: Compiling model.parsely.parsely_event_ids
2018-01-08 17:43:23,680: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-08 17:43:23,688: Acquiring new redshift connection "parsely_event_ids".
2018-01-08 17:43:23,688: Re-using an available connection from the pool.
2018-01-08 17:43:23,688: Using redshift connection "parsely_event_ids".
2018-01-08 17:43:23,688: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:43:23,709: SQL status: SELECT in 0.02 seconds
2018-01-08 17:43:23,710: Using redshift connection "parsely_event_ids".
2018-01-08 17:43:23,710: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:43:23,729: SQL status: SELECT in 0.02 seconds
2018-01-08 17:43:23,731: Using redshift connection "parsely_event_ids".
2018-01-08 17:43:23,731: On parsely_event_ids: BEGIN
2018-01-08 17:43:23,733: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:43:23,733: Using redshift connection "parsely_event_ids".
2018-01-08 17:43:23,733: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:43:25,819: SQL status: SELECT in 2.09 seconds
2018-01-08 17:43:25,820: Using redshift connection "parsely_event_ids".
2018-01-08 17:43:25,820: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-08 17:43:26,021: SQL status: SELECT in 0.20 seconds
2018-01-08 17:43:26,021: Using redshift connection "parsely_event_ids".
2018-01-08 17:43:26,022: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:43:26,139: SQL status: SELECT in 0.12 seconds
2018-01-08 17:43:26,139: Using redshift connection "parsely_event_ids".
2018-01-08 17:43:26,140: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:43:26,258: SQL status: SELECT in 0.12 seconds
2018-01-08 17:43:26,260: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-08 17:43:26,261: Using redshift connection "parsely_event_ids".
2018-01-08 17:43:26,261: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-08 17:43:28,098: SQL status: INSERT 0 940570 in 1.84 seconds
2018-01-08 17:43:28,099: On parsely_event_ids: COMMIT
2018-01-08 17:43:28,099: Using redshift connection "parsely_event_ids".
2018-01-08 17:43:28,099: On parsely_event_ids: COMMIT
2018-01-08 17:43:28,982: SQL status: COMMIT in 0.88 seconds
2018-01-08 17:43:28,983: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cc53dd0>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:43:29,022: 17:43:29 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 940570 in 5.33s]
2018-01-08 17:43:29,023: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-08 17:43:29,033: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-08 17:43:29,034: 17:43:29 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-08 17:43:29,034: Compiling model.parsely.parsely_post_content
2018-01-08 17:43:29,045: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-08 17:43:29,047: Acquiring new redshift connection "parsely_post_content".
2018-01-08 17:43:29,047: Re-using an available connection from the pool.
2018-01-08 17:43:29,047: Using redshift connection "parsely_post_content".
2018-01-08 17:43:29,047: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:43:29,071: SQL status: SELECT in 0.02 seconds
2018-01-08 17:43:29,071: Using redshift connection "parsely_post_content".
2018-01-08 17:43:29,071: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:43:29,090: SQL status: SELECT in 0.02 seconds
2018-01-08 17:43:29,093: Using redshift connection "parsely_post_content".
2018-01-08 17:43:29,093: On parsely_post_content: BEGIN
2018-01-08 17:43:29,095: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:43:29,095: Using redshift connection "parsely_post_content".
2018-01-08 17:43:29,095: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:43:45,829: SQL status: SELECT in 16.73 seconds
2018-01-08 17:43:45,829: Using redshift connection "parsely_post_content".
2018-01-08 17:43:45,829: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-08 17:43:45,996: SQL status: SELECT in 0.17 seconds
2018-01-08 17:43:45,997: Using redshift connection "parsely_post_content".
2018-01-08 17:43:45,997: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:43:46,117: SQL status: SELECT in 0.12 seconds
2018-01-08 17:43:46,118: Using redshift connection "parsely_post_content".
2018-01-08 17:43:46,118: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:43:46,239: SQL status: SELECT in 0.12 seconds
2018-01-08 17:43:46,242: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-08 17:43:46,243: Using redshift connection "parsely_post_content".
2018-01-08 17:43:46,243: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-08 17:43:46,788: SQL status: INSERT 0 894 in 0.55 seconds
2018-01-08 17:43:46,789: On parsely_post_content: COMMIT
2018-01-08 17:43:46,789: Using redshift connection "parsely_post_content".
2018-01-08 17:43:46,789: On parsely_post_content: COMMIT
2018-01-08 17:43:47,401: SQL status: COMMIT in 0.61 seconds
2018-01-08 17:43:47,401: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cc9ced0>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:43:47,452: 17:43:47 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 894 in 18.37s]
2018-01-08 17:43:47,452: 17:43:47 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-08 17:43:47,459: Compiling model.parsely.parsely_video_content
2018-01-08 17:43:47,482: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-08 17:43:47,484: Acquiring new redshift connection "parsely_video_content".
2018-01-08 17:43:47,484: Re-using an available connection from the pool.
2018-01-08 17:43:47,484: Using redshift connection "parsely_video_content".
2018-01-08 17:43:47,484: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:43:47,507: SQL status: SELECT in 0.02 seconds
2018-01-08 17:43:47,508: Using redshift connection "parsely_video_content".
2018-01-08 17:43:47,508: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:43:47,529: SQL status: SELECT in 0.02 seconds
2018-01-08 17:43:47,531: Using redshift connection "parsely_video_content".
2018-01-08 17:43:47,531: On parsely_video_content: BEGIN
2018-01-08 17:43:47,534: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:43:47,534: Using redshift connection "parsely_video_content".
2018-01-08 17:43:47,534: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:44:03,722: SQL status: SELECT in 16.19 seconds
2018-01-08 17:44:03,722: Using redshift connection "parsely_video_content".
2018-01-08 17:44:03,723: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-08 17:44:03,896: SQL status: SELECT in 0.17 seconds
2018-01-08 17:44:03,896: Using redshift connection "parsely_video_content".
2018-01-08 17:44:03,896: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:44:04,024: SQL status: SELECT in 0.13 seconds
2018-01-08 17:44:04,025: Using redshift connection "parsely_video_content".
2018-01-08 17:44:04,025: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:44:04,154: SQL status: SELECT in 0.13 seconds
2018-01-08 17:44:04,156: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-08 17:44:04,158: Using redshift connection "parsely_video_content".
2018-01-08 17:44:04,158: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-08 17:44:04,539: SQL status: INSERT 0 470 in 0.38 seconds
2018-01-08 17:44:04,540: On parsely_video_content: COMMIT
2018-01-08 17:44:04,540: Using redshift connection "parsely_video_content".
2018-01-08 17:44:04,540: On parsely_video_content: COMMIT
2018-01-08 17:44:05,086: SQL status: COMMIT in 0.55 seconds
2018-01-08 17:44:05,086: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cc9ced0>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:44:05,226: 17:44:05 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 470 in 17.63s]
2018-01-08 17:44:05,227: 17:44:05 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-08 17:44:05,227: Compiling model.parsely.parsely_entry_exit_urls
2018-01-08 17:44:05,247: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-08 17:44:05,249: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-08 17:44:05,249: Re-using an available connection from the pool.
2018-01-08 17:44:05,250: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 17:44:05,250: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:44:05,274: SQL status: SELECT in 0.02 seconds
2018-01-08 17:44:05,277: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-08 17:44:05,279: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 17:44:05,279: On parsely_entry_exit_urls: BEGIN
2018-01-08 17:44:05,287: SQL status: BEGIN in 0.01 seconds
2018-01-08 17:44:05,287: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 17:44:05,287: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-08 17:44:05,460: SQL status: CREATE VIEW in 0.17 seconds
2018-01-08 17:44:05,461: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 17:44:05,461: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-08 17:44:05,464: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:44:05,464: On parsely_entry_exit_urls: COMMIT
2018-01-08 17:44:05,464: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 17:44:05,465: On parsely_entry_exit_urls: COMMIT
2018-01-08 17:44:05,739: SQL status: COMMIT in 0.27 seconds
2018-01-08 17:44:05,739: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd34990>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:44:05,793: 17:44:05 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.51s]
2018-01-08 17:44:05,794: 17:44:05 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-08 17:44:05,794: Compiling model.parsely.parsely_incoming_videoviews
2018-01-08 17:44:05,832: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-08 17:44:05,843: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-08 17:44:05,843: Re-using an available connection from the pool.
2018-01-08 17:44:05,843: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 17:44:05,843: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:44:05,864: SQL status: SELECT in 0.02 seconds
2018-01-08 17:44:05,871: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-08 17:44:05,881: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 17:44:05,881: On parsely_incoming_videoviews: BEGIN
2018-01-08 17:44:05,883: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:44:05,883: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 17:44:05,883: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-08 17:44:05,990: SQL status: CREATE VIEW in 0.11 seconds
2018-01-08 17:44:05,990: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 17:44:05,990: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-08 17:44:05,995: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:44:05,995: On parsely_incoming_videoviews: COMMIT
2018-01-08 17:44:05,995: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 17:44:05,995: On parsely_incoming_videoviews: COMMIT
2018-01-08 17:44:06,350: SQL status: COMMIT in 0.35 seconds
2018-01-08 17:44:06,350: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cc9ced0>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:44:06,418: 17:44:06 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.56s]
2018-01-08 17:44:06,427: 17:44:06 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-08 17:44:06,427: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-08 17:44:06,437: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:44:06,437: Re-using an available connection from the pool.
2018-01-08 17:44:06,437: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:44:06,437: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:44:06,461: SQL status: SELECT in 0.02 seconds
2018-01-08 17:44:06,476: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-08 17:44:06,479: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:44:06,479: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:44:06,500: SQL status: SELECT in 0.02 seconds
2018-01-08 17:44:06,500: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:44:06,500: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:44:06,520: SQL status: SELECT in 0.02 seconds
2018-01-08 17:44:06,523: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:44:06,523: On parsely_videoviews_sessionized: BEGIN
2018-01-08 17:44:06,535: SQL status: BEGIN in 0.01 seconds
2018-01-08 17:44:06,535: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:44:06,535: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:46:42,884: SQL status: SELECT in 156.35 seconds
2018-01-08 17:46:42,884: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:46:42,885: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-08 17:46:43,106: SQL status: SELECT in 0.22 seconds
2018-01-08 17:46:43,107: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:46:43,108: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:46:43,231: SQL status: SELECT in 0.12 seconds
2018-01-08 17:46:43,232: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:46:43,233: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:46:43,358: SQL status: SELECT in 0.13 seconds
2018-01-08 17:46:43,365: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-08 17:46:43,366: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:46:43,366: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-08 17:46:44,963: SQL status: INSERT 0 145 in 1.60 seconds
2018-01-08 17:46:44,963: On parsely_videoviews_sessionized: COMMIT
2018-01-08 17:46:44,964: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 17:46:44,964: On parsely_videoviews_sessionized: COMMIT
2018-01-08 17:46:46,247: SQL status: COMMIT in 1.28 seconds
2018-01-08 17:46:46,247: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd47210>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:46:46,289: 17:46:46 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 145 in 159.82s]
2018-01-08 17:46:46,289: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-08 17:46:46,312: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-08 17:46:46,313: 17:46:46 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-08 17:46:46,313: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-08 17:46:46,338: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-08 17:46:46,340: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:46:46,340: Re-using an available connection from the pool.
2018-01-08 17:46:46,340: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:46:46,340: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:46:46,361: SQL status: SELECT in 0.02 seconds
2018-01-08 17:46:46,364: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-08 17:46:46,365: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:46:46,366: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-08 17:46:46,368: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:46:46,368: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:46:46,368: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-08 17:46:47,272: SQL status: CREATE VIEW in 0.90 seconds
2018-01-08 17:46:47,272: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:46:47,272: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-08 17:46:47,275: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:46:47,276: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-08 17:46:47,276: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 17:46:47,276: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-08 17:46:47,658: SQL status: COMMIT in 0.38 seconds
2018-01-08 17:46:47,658: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cc3b890>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:46:47,692: 17:46:47 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.35s]
2018-01-08 17:46:47,693: 17:46:47 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-08 17:46:47,693: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-08 17:46:47,738: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-08 17:46:47,740: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:46:47,740: Re-using an available connection from the pool.
2018-01-08 17:46:47,740: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:46:47,740: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:46:47,762: SQL status: SELECT in 0.02 seconds
2018-01-08 17:46:47,766: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-08 17:46:47,768: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:46:47,768: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-08 17:46:47,770: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:46:47,770: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:46:47,770: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-08 17:46:47,897: SQL status: CREATE VIEW in 0.13 seconds
2018-01-08 17:46:47,897: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:46:47,897: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-08 17:46:47,902: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:46:47,902: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-08 17:46:47,902: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 17:46:47,902: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-08 17:46:48,200: SQL status: COMMIT in 0.30 seconds
2018-01-08 17:46:48,201: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd34990>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:46:48,238: 17:46:48 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.51s]
2018-01-08 17:46:48,239: 17:46:48 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-08 17:46:48,239: Compiling model.parsely.parsely_incoming_pageviews
2018-01-08 17:46:48,260: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-08 17:46:48,263: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-08 17:46:48,263: Re-using an available connection from the pool.
2018-01-08 17:46:48,264: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 17:46:48,264: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:46:48,286: SQL status: SELECT in 0.02 seconds
2018-01-08 17:46:48,292: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-08 17:46:48,294: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 17:46:48,294: On parsely_incoming_pageviews: BEGIN
2018-01-08 17:46:48,296: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:46:48,296: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 17:46:48,296: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-08 17:46:50,206: SQL status: CREATE VIEW in 1.91 seconds
2018-01-08 17:46:50,207: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 17:46:50,207: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-08 17:46:50,308: SQL status: ALTER TABLE in 0.10 seconds
2018-01-08 17:46:50,308: On parsely_incoming_pageviews: COMMIT
2018-01-08 17:46:50,308: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 17:46:50,308: On parsely_incoming_pageviews: COMMIT
2018-01-08 17:46:50,508: SQL status: COMMIT in 0.20 seconds
2018-01-08 17:46:50,508: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd472d0>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:46:50,542: 17:46:50 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 2.27s]
2018-01-08 17:46:50,543: 17:46:50 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-08 17:46:50,544: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-08 17:46:50,553: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:46:50,553: Re-using an available connection from the pool.
2018-01-08 17:46:50,554: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:46:50,554: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:46:50,576: SQL status: SELECT in 0.02 seconds
2018-01-08 17:46:50,581: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-08 17:46:50,583: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:46:50,583: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:46:50,605: SQL status: SELECT in 0.02 seconds
2018-01-08 17:46:50,606: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:46:50,606: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:46:50,627: SQL status: SELECT in 0.02 seconds
2018-01-08 17:46:50,631: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:46:50,631: On parsely_pageviews_sessionized: BEGIN
2018-01-08 17:46:50,633: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:46:50,633: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:46:50,633: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:52:32,255: SQL status: SELECT in 341.62 seconds
2018-01-08 17:52:32,255: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:52:32,255: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-08 17:52:32,470: SQL status: SELECT in 0.21 seconds
2018-01-08 17:52:32,470: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:52:32,471: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:52:32,593: SQL status: SELECT in 0.12 seconds
2018-01-08 17:52:32,594: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:52:32,594: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:52:32,718: SQL status: SELECT in 0.12 seconds
2018-01-08 17:52:32,721: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-08 17:52:32,722: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:52:32,722: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-08 17:52:36,164: SQL status: INSERT 0 112224 in 3.44 seconds
2018-01-08 17:52:36,164: On parsely_pageviews_sessionized: COMMIT
2018-01-08 17:52:36,164: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 17:52:36,164: On parsely_pageviews_sessionized: COMMIT
2018-01-08 17:52:37,665: SQL status: COMMIT in 1.50 seconds
2018-01-08 17:52:37,666: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd47210>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:52:37,730: 17:52:37 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 112224 in 347.12s]
2018-01-08 17:52:37,730: 17:52:37 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-08 17:52:37,731: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-08 17:52:37,775: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-08 17:52:37,776: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:52:37,776: Re-using an available connection from the pool.
2018-01-08 17:52:37,776: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:52:37,776: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:52:37,804: SQL status: SELECT in 0.03 seconds
2018-01-08 17:52:37,806: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-08 17:52:37,808: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:52:37,808: On parsely_videoview_engagedtime: BEGIN
2018-01-08 17:52:37,810: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:52:37,810: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:52:37,810: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-08 17:52:39,414: SQL status: CREATE VIEW in 1.60 seconds
2018-01-08 17:52:39,415: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:52:39,415: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-08 17:52:39,419: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:52:39,419: On parsely_videoview_engagedtime: COMMIT
2018-01-08 17:52:39,419: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 17:52:39,419: On parsely_videoview_engagedtime: COMMIT
2018-01-08 17:52:40,173: SQL status: COMMIT in 0.75 seconds
2018-01-08 17:52:40,173: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd47210>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:52:40,202: 17:52:40 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 2.44s]
2018-01-08 17:52:40,202: 17:52:40 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-08 17:52:40,203: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-08 17:52:40,211: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-08 17:52:40,213: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:52:40,213: Re-using an available connection from the pool.
2018-01-08 17:52:40,213: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:52:40,213: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:52:40,236: SQL status: SELECT in 0.02 seconds
2018-01-08 17:52:40,236: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:52:40,236: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:52:40,258: SQL status: SELECT in 0.02 seconds
2018-01-08 17:52:40,261: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:52:40,261: On parsely_videoview_behavior_workflow: BEGIN
2018-01-08 17:52:40,263: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:52:40,263: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:52:40,263: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:57:35,123: SQL status: SELECT in 294.86 seconds
2018-01-08 17:57:35,123: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:57:35,123: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-08 17:57:35,287: SQL status: SELECT in 0.16 seconds
2018-01-08 17:57:35,287: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:57:35,287: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:57:35,419: SQL status: SELECT in 0.13 seconds
2018-01-08 17:57:35,419: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:57:35,419: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:57:35,551: SQL status: SELECT in 0.13 seconds
2018-01-08 17:57:35,555: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-08 17:57:35,556: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:57:35,556: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-08 17:57:36,680: SQL status: INSERT 0 144 in 1.12 seconds
2018-01-08 17:57:36,681: On parsely_videoview_behavior_workflow: COMMIT
2018-01-08 17:57:36,681: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 17:57:36,681: On parsely_videoview_behavior_workflow: COMMIT
2018-01-08 17:57:37,738: SQL status: COMMIT in 1.06 seconds
2018-01-08 17:57:37,739: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd34990>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:57:37,796: 17:57:37 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 144 in 297.54s]
2018-01-08 17:57:37,797: 17:57:37 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-08 17:57:37,797: Compiling model.parsely.parsely_campaigns
2018-01-08 17:57:37,801: Acquiring new redshift connection "parsely_campaigns".
2018-01-08 17:57:37,801: Re-using an available connection from the pool.
2018-01-08 17:57:37,801: Using redshift connection "parsely_campaigns".
2018-01-08 17:57:37,801: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:57:37,826: SQL status: SELECT in 0.03 seconds
2018-01-08 17:57:37,830: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-08 17:57:37,831: Using redshift connection "parsely_campaigns".
2018-01-08 17:57:37,831: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:57:37,851: SQL status: SELECT in 0.02 seconds
2018-01-08 17:57:37,852: Using redshift connection "parsely_campaigns".
2018-01-08 17:57:37,852: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:57:37,872: SQL status: SELECT in 0.02 seconds
2018-01-08 17:57:37,873: Using redshift connection "parsely_campaigns".
2018-01-08 17:57:37,873: On parsely_campaigns: BEGIN
2018-01-08 17:57:37,875: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:57:37,875: Using redshift connection "parsely_campaigns".
2018-01-08 17:57:37,875: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:57:39,157: SQL status: SELECT in 1.28 seconds
2018-01-08 17:57:39,158: Using redshift connection "parsely_campaigns".
2018-01-08 17:57:39,158: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-08 17:57:39,307: SQL status: SELECT in 0.15 seconds
2018-01-08 17:57:39,307: Using redshift connection "parsely_campaigns".
2018-01-08 17:57:39,307: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:57:39,429: SQL status: SELECT in 0.12 seconds
2018-01-08 17:57:39,430: Using redshift connection "parsely_campaigns".
2018-01-08 17:57:39,430: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:57:39,556: SQL status: SELECT in 0.13 seconds
2018-01-08 17:57:39,557: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-08 17:57:39,558: Using redshift connection "parsely_campaigns".
2018-01-08 17:57:39,558: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-08 17:57:39,722: SQL status: INSERT 0 394 in 0.16 seconds
2018-01-08 17:57:39,723: On parsely_campaigns: COMMIT
2018-01-08 17:57:39,723: Using redshift connection "parsely_campaigns".
2018-01-08 17:57:39,723: On parsely_campaigns: COMMIT
2018-01-08 17:57:40,246: SQL status: COMMIT in 0.52 seconds
2018-01-08 17:57:40,247: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd02950>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:57:40,278: 17:57:40 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 394 in 2.45s]
2018-01-08 17:57:40,278: Compiling model.parsely.parsely_incoming_users
2018-01-08 17:57:40,284: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-08 17:57:40,285: 17:57:40 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-08 17:57:40,286: Compiling model.parsely.parsely_users
2018-01-08 17:57:40,293: Acquiring new redshift connection "parsely_users".
2018-01-08 17:57:40,293: Re-using an available connection from the pool.
2018-01-08 17:57:40,293: Using redshift connection "parsely_users".
2018-01-08 17:57:40,293: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:57:40,319: SQL status: SELECT in 0.03 seconds
2018-01-08 17:57:40,359: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-08 17:57:40,362: Using redshift connection "parsely_users".
2018-01-08 17:57:40,362: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:57:40,385: SQL status: SELECT in 0.02 seconds
2018-01-08 17:57:40,385: Using redshift connection "parsely_users".
2018-01-08 17:57:40,385: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:57:40,404: SQL status: SELECT in 0.02 seconds
2018-01-08 17:57:40,406: Using redshift connection "parsely_users".
2018-01-08 17:57:40,407: On parsely_users: BEGIN
2018-01-08 17:57:40,409: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:57:40,409: Using redshift connection "parsely_users".
2018-01-08 17:57:40,409: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 17:57:43,132: SQL status: SELECT in 2.72 seconds
2018-01-08 17:57:43,133: Using redshift connection "parsely_users".
2018-01-08 17:57:43,133: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-08 17:57:43,446: SQL status: SELECT in 0.31 seconds
2018-01-08 17:57:43,446: Using redshift connection "parsely_users".
2018-01-08 17:57:43,446: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:57:43,575: SQL status: SELECT in 0.13 seconds
2018-01-08 17:57:43,576: Using redshift connection "parsely_users".
2018-01-08 17:57:43,576: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-08 17:57:43,700: SQL status: SELECT in 0.12 seconds
2018-01-08 17:57:43,701: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-08 17:57:43,702: Using redshift connection "parsely_users".
2018-01-08 17:57:43,702: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-08 17:57:44,040: SQL status: INSERT 0 54676 in 0.34 seconds
2018-01-08 17:57:44,040: On parsely_users: COMMIT
2018-01-08 17:57:44,040: Using redshift connection "parsely_users".
2018-01-08 17:57:44,040: On parsely_users: COMMIT
2018-01-08 17:57:44,578: SQL status: COMMIT in 0.54 seconds
2018-01-08 17:57:44,579: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cca5890>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:57:44,607: 17:57:44 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 54676 in 4.29s]
2018-01-08 17:57:44,608: 17:57:44 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-08 17:57:44,608: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-08 17:57:44,640: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-08 17:57:44,641: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:57:44,641: Re-using an available connection from the pool.
2018-01-08 17:57:44,641: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:57:44,641: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:57:44,666: SQL status: SELECT in 0.02 seconds
2018-01-08 17:57:44,668: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-08 17:57:44,669: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:57:44,669: On parsely_pageview_engagedtime: BEGIN
2018-01-08 17:57:44,671: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:57:44,671: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:57:44,671: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-08 17:57:45,112: SQL status: CREATE VIEW in 0.44 seconds
2018-01-08 17:57:45,112: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:57:45,112: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-08 17:57:45,134: SQL status: ALTER TABLE in 0.02 seconds
2018-01-08 17:57:45,134: On parsely_pageview_engagedtime: COMMIT
2018-01-08 17:57:45,134: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 17:57:45,135: On parsely_pageview_engagedtime: COMMIT
2018-01-08 17:57:45,353: SQL status: COMMIT in 0.22 seconds
2018-01-08 17:57:45,354: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f18a7712410>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:57:45,385: 17:57:45 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.75s]
2018-01-08 17:57:45,385: 17:57:45 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-08 17:57:45,386: Compiling model.parsely.parsely_incoming_sessions
2018-01-08 17:57:45,393: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-08 17:57:45,394: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-08 17:57:45,394: Re-using an available connection from the pool.
2018-01-08 17:57:45,394: Using redshift connection "parsely_incoming_sessions".
2018-01-08 17:57:45,394: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:57:45,419: SQL status: SELECT in 0.03 seconds
2018-01-08 17:57:45,422: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-08 17:57:45,423: Using redshift connection "parsely_incoming_sessions".
2018-01-08 17:57:45,423: On parsely_incoming_sessions: BEGIN
2018-01-08 17:57:45,425: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:57:45,425: Using redshift connection "parsely_incoming_sessions".
2018-01-08 17:57:45,425: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-08 17:57:45,495: SQL status: CREATE VIEW in 0.07 seconds
2018-01-08 17:57:45,495: Using redshift connection "parsely_incoming_sessions".
2018-01-08 17:57:45,495: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-08 17:57:45,499: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 17:57:45,499: On parsely_incoming_sessions: COMMIT
2018-01-08 17:57:45,499: Using redshift connection "parsely_incoming_sessions".
2018-01-08 17:57:45,499: On parsely_incoming_sessions: COMMIT
2018-01-08 17:57:45,762: SQL status: COMMIT in 0.26 seconds
2018-01-08 17:57:45,763: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd022d0>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 17:57:45,795: 17:57:45 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.38s]
2018-01-08 17:57:45,795: 17:57:45 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-08 17:57:45,796: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-08 17:57:45,804: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-08 17:57:45,806: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:57:45,806: Re-using an available connection from the pool.
2018-01-08 17:57:45,806: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:57:45,806: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:57:45,829: SQL status: SELECT in 0.02 seconds
2018-01-08 17:57:45,829: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:57:45,830: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 17:57:45,853: SQL status: SELECT in 0.02 seconds
2018-01-08 17:57:45,855: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:57:45,855: On parsely_pageview_behavior_workflow: BEGIN
2018-01-08 17:57:45,857: SQL status: BEGIN in 0.00 seconds
2018-01-08 17:57:45,857: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 17:57:45,857: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:01:07,768: SQL status: SELECT in 201.91 seconds
2018-01-08 18:01:07,768: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:01:07,768: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-08 18:01:08,314: SQL status: SELECT in 0.55 seconds
2018-01-08 18:01:08,315: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:01:08,315: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:01:08,442: SQL status: SELECT in 0.13 seconds
2018-01-08 18:01:08,444: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:01:08,444: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:01:08,569: SQL status: SELECT in 0.12 seconds
2018-01-08 18:01:08,583: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-08 18:01:08,585: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:01:08,585: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-08 18:01:12,002: SQL status: INSERT 0 112197 in 3.42 seconds
2018-01-08 18:01:12,004: On parsely_pageview_behavior_workflow: COMMIT
2018-01-08 18:01:12,005: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:01:12,005: On parsely_pageview_behavior_workflow: COMMIT
2018-01-08 18:01:13,499: SQL status: COMMIT in 1.49 seconds
2018-01-08 18:01:13,500: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cca5110>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 18:01:13,619: 18:01:13 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 112197 in 207.70s]
2018-01-08 18:01:13,623: 18:01:13 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-08 18:01:13,623: Compiling model.parsely.parsely_sessions
2018-01-08 18:01:13,656: Acquiring new redshift connection "parsely_sessions".
2018-01-08 18:01:13,656: Re-using an available connection from the pool.
2018-01-08 18:01:13,656: Using redshift connection "parsely_sessions".
2018-01-08 18:01:13,656: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:01:13,682: SQL status: SELECT in 0.03 seconds
2018-01-08 18:01:13,688: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-08 18:01:13,691: Using redshift connection "parsely_sessions".
2018-01-08 18:01:13,692: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:01:13,713: SQL status: SELECT in 0.02 seconds
2018-01-08 18:01:13,714: Using redshift connection "parsely_sessions".
2018-01-08 18:01:13,714: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:01:13,735: SQL status: SELECT in 0.02 seconds
2018-01-08 18:01:13,739: Using redshift connection "parsely_sessions".
2018-01-08 18:01:13,740: On parsely_sessions: BEGIN
2018-01-08 18:01:13,742: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:01:13,742: Using redshift connection "parsely_sessions".
2018-01-08 18:01:13,742: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:01:56,429: SQL status: SELECT in 42.69 seconds
2018-01-08 18:01:56,430: Using redshift connection "parsely_sessions".
2018-01-08 18:01:56,430: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-08 18:01:56,591: SQL status: SELECT in 0.16 seconds
2018-01-08 18:01:56,592: Using redshift connection "parsely_sessions".
2018-01-08 18:01:56,592: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:01:56,715: SQL status: SELECT in 0.12 seconds
2018-01-08 18:01:56,716: Using redshift connection "parsely_sessions".
2018-01-08 18:01:56,716: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:01:56,840: SQL status: SELECT in 0.12 seconds
2018-01-08 18:01:56,844: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-08 18:01:56,846: Using redshift connection "parsely_sessions".
2018-01-08 18:01:56,846: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-08 18:01:58,556: SQL status: INSERT 0 91130 in 1.71 seconds
2018-01-08 18:01:58,556: On parsely_sessions: COMMIT
2018-01-08 18:01:58,556: Using redshift connection "parsely_sessions".
2018-01-08 18:01:58,556: On parsely_sessions: COMMIT
2018-01-08 18:01:59,708: SQL status: COMMIT in 1.15 seconds
2018-01-08 18:01:59,709: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f18a7712410>], 'label': '4fd8bf3c-46da-46be-b127-f2d3cbf5ed6e'}
2018-01-08 18:01:59,752: 18:01:59 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 91130 in 46.09s]
2018-01-08 18:01:59,856: Using redshift connection "master".
2018-01-08 18:01:59,856: On master: BEGIN
2018-01-08 18:01:59,871: SQL status: BEGIN in 0.01 seconds
2018-01-08 18:01:59,871: On master: COMMIT
2018-01-08 18:01:59,871: Using redshift connection "master".
2018-01-08 18:01:59,871: On master: COMMIT
2018-01-08 18:01:59,873: SQL status: COMMIT in 0.00 seconds
2018-01-08 18:01:59,873: Compiling operation.parsely.parsely-on-run-end-0
2018-01-08 18:01:59,894: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-08 18:01:59,903: Using redshift connection "master".
2018-01-08 18:01:59,903: On master:  select 1 
2018-01-08 18:01:59,905: SQL status: SELECT in 0.00 seconds
2018-01-08 18:01:59,905: 18:01:59 | 
2018-01-08 18:01:59,906: 18:01:59 | Finished running 10 view models, 15 incremental models in 1579.41s.
2018-01-08 18:01:59,906: 
2018-01-08 18:01:59,907: Completed successfully
2018-01-08 18:01:59,907: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-08 18:01:59,908: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd4de10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd4df90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f189cd34950>], 'label': 'end'}
2018-01-08 18:01:59,971: Flushing usage events
2018-01-08 18:02:07,860: Tracking: tracking
2018-01-08 18:02:07,860: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8832e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8832f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8832ed0>], 'label': 'start'}
2018-01-08 18:02:07,925: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-08 18:02:07,989: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-08 18:02:07,991: Parsing core.sql
2018-01-08 18:02:08,015: Parsing etc/get_custom_schema.sql
2018-01-08 18:02:08,027: Parsing schema_tests/relationships.sql
2018-01-08 18:02:08,032: Parsing schema_tests/accepted_values.sql
2018-01-08 18:02:08,048: Parsing schema_tests/not_null.sql
2018-01-08 18:02:08,050: Parsing schema_tests/unique.sql
2018-01-08 18:02:08,054: Parsing materializations/wrapper.sql
2018-01-08 18:02:08,061: Parsing materializations/archive.sql
2018-01-08 18:02:08,134: Parsing materializations/table.sql
2018-01-08 18:02:08,181: Parsing materializations/helpers.sql
2018-01-08 18:02:08,217: Parsing materializations/bigquery.sql
2018-01-08 18:02:08,251: Parsing materializations/view.sql
2018-01-08 18:02:08,295: Parsing materializations/incremental.sql
2018-01-08 18:02:08,356: Parsing adapters/redshift.sql
2018-01-08 18:02:08,406: Parsing adapters/bigquery.sql
2018-01-08 18:02:08,423: Parsing adapters/postgres.sql
2018-01-08 18:02:08,436: Parsing adapters/common.sql
2018-01-08 18:02:08,477: Parsing model.parsely.parsely_audit
2018-01-08 18:02:08,479: Parsing model.parsely.parsely_video_content
2018-01-08 18:02:08,485: Parsing model.parsely.parsely_post_content
2018-01-08 18:02:08,493: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-08 18:02:08,499: Parsing model.parsely.parsely_rawdata
2018-01-08 18:02:08,505: Parsing model.parsely.calendar
2018-01-08 18:02:08,515: Parsing model.parsely.parsely_all_events
2018-01-08 18:02:08,538: Acquiring new redshift connection "parsely_all_events".
2018-01-08 18:02:08,538: Opening a new connection (0 currently allocated)
2018-01-08 18:02:08,552: Using redshift connection "parsely_all_events".
2018-01-08 18:02:08,552: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:08,578: SQL status: SELECT in 0.03 seconds
2018-01-08 18:02:08,591: Parsing model.parsely.parsely_event_ids
2018-01-08 18:02:08,595: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-08 18:02:08,607: Parsing model.parsely.parsely_base_events
2018-01-08 18:02:08,614: Acquiring new redshift connection "parsely_base_events".
2018-01-08 18:02:08,614: Re-using an available connection from the pool.
2018-01-08 18:02:08,614: Using redshift connection "parsely_base_events".
2018-01-08 18:02:08,615: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:08,636: SQL status: SELECT in 0.02 seconds
2018-01-08 18:02:08,638: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-08 18:02:08,655: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-08 18:02:08,671: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-08 18:02:08,674: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-08 18:02:08,690: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-08 18:02:08,703: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-08 18:02:08,729: Parsing model.parsely.parsely_incoming_pageviews
2018-01-08 18:02:08,745: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-08 18:02:08,770: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:02:08,770: Re-using an available connection from the pool.
2018-01-08 18:02:08,770: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:02:08,770: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:08,791: SQL status: SELECT in 0.02 seconds
2018-01-08 18:02:08,793: Parsing model.parsely.parsely_incoming_videoviews
2018-01-08 18:02:08,812: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-08 18:02:08,832: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:02:08,832: Re-using an available connection from the pool.
2018-01-08 18:02:08,832: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:02:08,832: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:08,853: SQL status: SELECT in 0.02 seconds
2018-01-08 18:02:08,855: Parsing model.parsely.parsely_incoming_users
2018-01-08 18:02:08,863: Parsing model.parsely.parsely_users
2018-01-08 18:02:08,888: Acquiring new redshift connection "parsely_users".
2018-01-08 18:02:08,888: Re-using an available connection from the pool.
2018-01-08 18:02:08,888: Using redshift connection "parsely_users".
2018-01-08 18:02:08,888: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:08,911: SQL status: SELECT in 0.02 seconds
2018-01-08 18:02:08,912: Parsing model.parsely.parsely_errors
2018-01-08 18:02:08,919: Parsing model.parsely.parsely_bot_traffic
2018-01-08 18:02:08,945: Parsing model.parsely.parsely_custom_events
2018-01-08 18:02:08,962: Parsing model.parsely.parsely_incoming_sessions
2018-01-08 18:02:08,987: Parsing model.parsely.parsely_entry_exit_urls
2018-01-08 18:02:08,992: Parsing model.parsely.parsely_sessions
2018-01-08 18:02:09,022: Acquiring new redshift connection "parsely_sessions".
2018-01-08 18:02:09,022: Re-using an available connection from the pool.
2018-01-08 18:02:09,022: Using redshift connection "parsely_sessions".
2018-01-08 18:02:09,022: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:09,043: SQL status: SELECT in 0.02 seconds
2018-01-08 18:02:09,044: Parsing model.parsely.parsely_campaigns
2018-01-08 18:02:09,050: Acquiring new redshift connection "parsely_campaigns".
2018-01-08 18:02:09,050: Re-using an available connection from the pool.
2018-01-08 18:02:09,051: Using redshift connection "parsely_campaigns".
2018-01-08 18:02:09,051: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:09,071: SQL status: SELECT in 0.02 seconds
2018-01-08 18:02:09,086: Parsing operation.parsely.parsely-on-run-end-0
2018-01-08 18:02:09,103: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-08 18:02:09,126: 
2018-01-08 18:02:09,132: Acquiring new redshift connection "master".
2018-01-08 18:02:09,132: Re-using an available connection from the pool.
2018-01-08 18:02:09,132: Using redshift connection "master".
2018-01-08 18:02:09,132: On master: select distinct nspname from pg_namespace
2018-01-08 18:02:09,135: SQL status: SELECT in 0.00 seconds
2018-01-08 18:02:09,151: Using redshift connection "master".
2018-01-08 18:02:09,151: On master: BEGIN
2018-01-08 18:02:09,153: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:02:09,153: On master: COMMIT
2018-01-08 18:02:09,153: Using redshift connection "master".
2018-01-08 18:02:09,153: On master: COMMIT
2018-01-08 18:02:09,155: SQL status: COMMIT in 0.00 seconds
2018-01-08 18:02:09,172: 18:02:09 | Concurrency: 1 threads (target='dev')
2018-01-08 18:02:09,178: 18:02:09 | 
2018-01-08 18:02:09,179: Using redshift connection "master".
2018-01-08 18:02:09,179: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:09,200: SQL status: SELECT in 0.02 seconds
2018-01-08 18:02:09,371: 18:02:09 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-08 18:02:09,372: Compiling model.parsely.calendar
2018-01-08 18:02:09,379: Writing injected SQL for node "model.parsely.calendar"
2018-01-08 18:02:09,382: Acquiring new redshift connection "calendar".
2018-01-08 18:02:09,382: Opening a new connection (1 currently allocated)
2018-01-08 18:02:09,399: Using redshift connection "calendar".
2018-01-08 18:02:09,399: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:09,425: SQL status: SELECT in 0.03 seconds
2018-01-08 18:02:09,429: Writing runtime SQL for node "model.parsely.calendar"
2018-01-08 18:02:09,430: Using redshift connection "calendar".
2018-01-08 18:02:09,430: On calendar: BEGIN
2018-01-08 18:02:09,432: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:02:09,432: Using redshift connection "calendar".
2018-01-08 18:02:09,432: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-08 18:02:10,577: SQL status: CREATE VIEW in 1.15 seconds
2018-01-08 18:02:10,578: On calendar: COMMIT
2018-01-08 18:02:10,581: Using redshift connection "calendar".
2018-01-08 18:02:10,581: On calendar: COMMIT
2018-01-08 18:02:10,958: SQL status: COMMIT in 0.38 seconds
2018-01-08 18:02:10,958: Using redshift connection "calendar".
2018-01-08 18:02:10,958: On calendar: BEGIN
2018-01-08 18:02:10,961: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:02:10,961: Using redshift connection "calendar".
2018-01-08 18:02:10,961: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-08 18:02:11,071: SQL status: DROP VIEW in 0.11 seconds
2018-01-08 18:02:11,072: On calendar: COMMIT
2018-01-08 18:02:11,072: Using redshift connection "calendar".
2018-01-08 18:02:11,072: On calendar: COMMIT
2018-01-08 18:02:11,298: SQL status: COMMIT in 0.23 seconds
2018-01-08 18:02:11,298: Using redshift connection "calendar".
2018-01-08 18:02:11,299: On calendar: BEGIN
2018-01-08 18:02:11,301: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:02:11,301: Using redshift connection "calendar".
2018-01-08 18:02:11,301: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-08 18:02:11,306: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:02:11,306: On calendar: COMMIT
2018-01-08 18:02:11,306: Using redshift connection "calendar".
2018-01-08 18:02:11,306: On calendar: COMMIT
2018-01-08 18:02:11,499: SQL status: COMMIT in 0.19 seconds
2018-01-08 18:02:11,499: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8720bd0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:02:11,552: 18:02:11 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 2.13s]
2018-01-08 18:02:11,553: 18:02:11 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-08 18:02:11,553: Compiling model.parsely.parsely_rawdata
2018-01-08 18:02:11,562: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-08 18:02:11,571: Acquiring new redshift connection "parsely_rawdata".
2018-01-08 18:02:11,572: Re-using an available connection from the pool.
2018-01-08 18:02:11,572: Using redshift connection "parsely_rawdata".
2018-01-08 18:02:11,572: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:11,594: SQL status: SELECT in 0.02 seconds
2018-01-08 18:02:11,594: Using redshift connection "parsely_rawdata".
2018-01-08 18:02:11,594: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:02:11,614: SQL status: SELECT in 0.02 seconds
2018-01-08 18:02:11,616: Using redshift connection "parsely_rawdata".
2018-01-08 18:02:11,616: On parsely_rawdata: BEGIN
2018-01-08 18:02:11,618: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:02:11,618: Using redshift connection "parsely_rawdata".
2018-01-08 18:02:11,618: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:02:42,714: SQL status: SELECT in 31.10 seconds
2018-01-08 18:02:42,715: Using redshift connection "parsely_rawdata".
2018-01-08 18:02:42,715: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-08 18:02:43,049: SQL status: SELECT in 0.33 seconds
2018-01-08 18:02:43,050: Using redshift connection "parsely_rawdata".
2018-01-08 18:02:43,050: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:02:43,173: SQL status: SELECT in 0.12 seconds
2018-01-08 18:02:43,175: Using redshift connection "parsely_rawdata".
2018-01-08 18:02:43,175: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:02:43,297: SQL status: SELECT in 0.12 seconds
2018-01-08 18:02:43,303: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-08 18:02:43,304: Using redshift connection "parsely_rawdata".
2018-01-08 18:02:43,304: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-08 18:03:17,003: SQL status: INSERT 0 1062099 in 33.70 seconds
2018-01-08 18:03:17,003: On parsely_rawdata: COMMIT
2018-01-08 18:03:17,004: Using redshift connection "parsely_rawdata".
2018-01-08 18:03:17,004: On parsely_rawdata: COMMIT
2018-01-08 18:03:19,149: SQL status: COMMIT in 2.14 seconds
2018-01-08 18:03:19,150: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c878ab10>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:03:19,207: 18:03:19 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1062099 in 67.60s]
2018-01-08 18:03:19,207: 18:03:19 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-08 18:03:19,208: Compiling model.parsely.parsely_all_events
2018-01-08 18:03:19,237: Acquiring new redshift connection "parsely_all_events".
2018-01-08 18:03:19,237: Re-using an available connection from the pool.
2018-01-08 18:03:19,237: Using redshift connection "parsely_all_events".
2018-01-08 18:03:19,237: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:03:19,261: SQL status: SELECT in 0.02 seconds
2018-01-08 18:03:19,281: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-08 18:03:19,283: Using redshift connection "parsely_all_events".
2018-01-08 18:03:19,283: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:03:19,312: SQL status: SELECT in 0.02 seconds
2018-01-08 18:03:19,313: Using redshift connection "parsely_all_events".
2018-01-08 18:03:19,313: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:03:19,333: SQL status: SELECT in 0.02 seconds
2018-01-08 18:03:19,338: Using redshift connection "parsely_all_events".
2018-01-08 18:03:19,338: On parsely_all_events: BEGIN
2018-01-08 18:03:19,340: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:03:19,340: Using redshift connection "parsely_all_events".
2018-01-08 18:03:19,341: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:05:00,693: SQL status: SELECT in 101.35 seconds
2018-01-08 18:05:00,693: Using redshift connection "parsely_all_events".
2018-01-08 18:05:00,693: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-08 18:05:00,938: SQL status: SELECT in 0.24 seconds
2018-01-08 18:05:00,939: Using redshift connection "parsely_all_events".
2018-01-08 18:05:00,939: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:05:01,064: SQL status: SELECT in 0.12 seconds
2018-01-08 18:05:01,066: Using redshift connection "parsely_all_events".
2018-01-08 18:05:01,066: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:05:01,191: SQL status: SELECT in 0.12 seconds
2018-01-08 18:05:01,197: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-08 18:05:01,199: Using redshift connection "parsely_all_events".
2018-01-08 18:05:01,203: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-08 18:05:19,293: SQL status: INSERT 0 941930 in 18.09 seconds
2018-01-08 18:05:19,294: On parsely_all_events: COMMIT
2018-01-08 18:05:19,294: Using redshift connection "parsely_all_events".
2018-01-08 18:05:19,294: On parsely_all_events: COMMIT
2018-01-08 18:05:21,465: SQL status: COMMIT in 2.17 seconds
2018-01-08 18:05:21,466: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c87df810>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:05:21,560: 18:05:21 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 941930 in 122.26s]
2018-01-08 18:05:21,561: 18:05:21 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-08 18:05:21,561: Compiling model.parsely.parsely_bot_traffic
2018-01-08 18:05:21,586: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-08 18:05:21,588: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-08 18:05:21,588: Re-using an available connection from the pool.
2018-01-08 18:05:21,588: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:05:21,588: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:05:21,610: SQL status: SELECT in 0.02 seconds
2018-01-08 18:05:21,611: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:05:21,611: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:05:21,632: SQL status: SELECT in 0.02 seconds
2018-01-08 18:05:21,635: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:05:21,635: On parsely_bot_traffic: BEGIN
2018-01-08 18:05:21,637: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:05:21,637: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:05:21,637: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:06:50,093: SQL status: SELECT in 88.46 seconds
2018-01-08 18:06:50,093: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:06:50,093: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-08 18:06:50,260: SQL status: SELECT in 0.17 seconds
2018-01-08 18:06:50,261: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:06:50,261: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:06:50,384: SQL status: SELECT in 0.12 seconds
2018-01-08 18:06:50,385: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:06:50,385: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:06:50,508: SQL status: SELECT in 0.12 seconds
2018-01-08 18:06:50,514: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-08 18:06:50,515: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:06:50,519: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-08 18:06:51,595: SQL status: INSERT 0 4 in 1.08 seconds
2018-01-08 18:06:51,596: On parsely_bot_traffic: COMMIT
2018-01-08 18:06:51,596: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:06:51,596: On parsely_bot_traffic: COMMIT
2018-01-08 18:06:52,679: SQL status: COMMIT in 1.08 seconds
2018-01-08 18:06:52,680: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8720c90>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:06:52,734: 18:06:52 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 91.12s]
2018-01-08 18:06:52,735: 18:06:52 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-08 18:06:52,735: Compiling model.parsely.parsely_custom_events
2018-01-08 18:06:52,760: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-08 18:06:52,767: Acquiring new redshift connection "parsely_custom_events".
2018-01-08 18:06:52,767: Re-using an available connection from the pool.
2018-01-08 18:06:52,767: Using redshift connection "parsely_custom_events".
2018-01-08 18:06:52,767: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:06:52,790: SQL status: SELECT in 0.02 seconds
2018-01-08 18:06:52,791: Using redshift connection "parsely_custom_events".
2018-01-08 18:06:52,791: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:06:52,813: SQL status: SELECT in 0.02 seconds
2018-01-08 18:06:52,817: Using redshift connection "parsely_custom_events".
2018-01-08 18:06:52,817: On parsely_custom_events: BEGIN
2018-01-08 18:06:52,819: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:06:52,819: Using redshift connection "parsely_custom_events".
2018-01-08 18:06:52,819: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:08:25,041: SQL status: SELECT in 92.22 seconds
2018-01-08 18:08:25,041: Using redshift connection "parsely_custom_events".
2018-01-08 18:08:25,041: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-08 18:08:25,341: SQL status: SELECT in 0.30 seconds
2018-01-08 18:08:25,342: Using redshift connection "parsely_custom_events".
2018-01-08 18:08:25,342: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:08:25,470: SQL status: SELECT in 0.13 seconds
2018-01-08 18:08:25,471: Using redshift connection "parsely_custom_events".
2018-01-08 18:08:25,471: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:08:25,610: SQL status: SELECT in 0.14 seconds
2018-01-08 18:08:25,616: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-08 18:08:25,617: Using redshift connection "parsely_custom_events".
2018-01-08 18:08:25,617: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-08 18:08:25,899: SQL status: INSERT 0 0 in 0.28 seconds
2018-01-08 18:08:25,899: On parsely_custom_events: COMMIT
2018-01-08 18:08:25,899: Using redshift connection "parsely_custom_events".
2018-01-08 18:08:25,899: On parsely_custom_events: COMMIT
2018-01-08 18:08:26,665: SQL status: COMMIT in 0.77 seconds
2018-01-08 18:08:26,666: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8720210>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:08:26,747: 18:08:26 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 93.93s]
2018-01-08 18:08:26,748: 18:08:26 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-08 18:08:26,748: Compiling model.parsely.parsely_errors
2018-01-08 18:08:26,772: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-08 18:08:26,774: Acquiring new redshift connection "parsely_errors".
2018-01-08 18:08:26,774: Re-using an available connection from the pool.
2018-01-08 18:08:26,775: Using redshift connection "parsely_errors".
2018-01-08 18:08:26,775: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:08:26,799: SQL status: SELECT in 0.02 seconds
2018-01-08 18:08:26,800: Using redshift connection "parsely_errors".
2018-01-08 18:08:26,800: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:08:26,822: SQL status: SELECT in 0.02 seconds
2018-01-08 18:08:26,825: Using redshift connection "parsely_errors".
2018-01-08 18:08:26,825: On parsely_errors: BEGIN
2018-01-08 18:08:26,827: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:08:26,827: Using redshift connection "parsely_errors".
2018-01-08 18:08:26,828: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:09:57,067: SQL status: SELECT in 90.24 seconds
2018-01-08 18:09:57,067: Using redshift connection "parsely_errors".
2018-01-08 18:09:57,067: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-08 18:09:57,229: SQL status: SELECT in 0.16 seconds
2018-01-08 18:09:57,230: Using redshift connection "parsely_errors".
2018-01-08 18:09:57,230: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:09:57,366: SQL status: SELECT in 0.14 seconds
2018-01-08 18:09:57,368: Using redshift connection "parsely_errors".
2018-01-08 18:09:57,368: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:09:57,503: SQL status: SELECT in 0.13 seconds
2018-01-08 18:09:57,509: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-08 18:09:57,510: Using redshift connection "parsely_errors".
2018-01-08 18:09:57,511: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-08 18:09:58,190: SQL status: INSERT 0 2 in 0.68 seconds
2018-01-08 18:09:58,190: On parsely_errors: COMMIT
2018-01-08 18:09:58,191: Using redshift connection "parsely_errors".
2018-01-08 18:09:58,191: On parsely_errors: COMMIT
2018-01-08 18:09:59,210: SQL status: COMMIT in 1.02 seconds
2018-01-08 18:09:59,211: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8716f10>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:09:59,314: 18:09:59 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 92.46s]
2018-01-08 18:09:59,315: 18:09:59 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-08 18:09:59,315: Compiling model.parsely.parsely_base_events
2018-01-08 18:09:59,328: Acquiring new redshift connection "parsely_base_events".
2018-01-08 18:09:59,328: Re-using an available connection from the pool.
2018-01-08 18:09:59,328: Using redshift connection "parsely_base_events".
2018-01-08 18:09:59,328: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:09:59,350: SQL status: SELECT in 0.02 seconds
2018-01-08 18:09:59,356: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-08 18:09:59,358: Using redshift connection "parsely_base_events".
2018-01-08 18:09:59,358: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:09:59,379: SQL status: SELECT in 0.02 seconds
2018-01-08 18:09:59,382: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-08 18:09:59,383: Using redshift connection "parsely_base_events".
2018-01-08 18:09:59,383: On parsely_base_events: BEGIN
2018-01-08 18:09:59,385: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:09:59,386: Using redshift connection "parsely_base_events".
2018-01-08 18:09:59,386: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-08 18:09:59,646: SQL status: CREATE VIEW in 0.26 seconds
2018-01-08 18:09:59,647: On parsely_base_events: COMMIT
2018-01-08 18:09:59,647: Using redshift connection "parsely_base_events".
2018-01-08 18:09:59,647: On parsely_base_events: COMMIT
2018-01-08 18:09:59,952: SQL status: COMMIT in 0.30 seconds
2018-01-08 18:09:59,953: Using redshift connection "parsely_base_events".
2018-01-08 18:09:59,953: On parsely_base_events: BEGIN
2018-01-08 18:09:59,955: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:09:59,955: Using redshift connection "parsely_base_events".
2018-01-08 18:09:59,955: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-08 18:10:00,407: SQL status: DROP VIEW in 0.45 seconds
2018-01-08 18:10:00,408: On parsely_base_events: COMMIT
2018-01-08 18:10:00,408: Using redshift connection "parsely_base_events".
2018-01-08 18:10:00,408: On parsely_base_events: COMMIT
2018-01-08 18:10:01,200: SQL status: COMMIT in 0.79 seconds
2018-01-08 18:10:01,201: Using redshift connection "parsely_base_events".
2018-01-08 18:10:01,201: On parsely_base_events: BEGIN
2018-01-08 18:10:01,204: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:10:01,204: Using redshift connection "parsely_base_events".
2018-01-08 18:10:01,204: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-08 18:10:01,488: SQL status: ALTER TABLE in 0.28 seconds
2018-01-08 18:10:01,489: On parsely_base_events: COMMIT
2018-01-08 18:10:01,489: Using redshift connection "parsely_base_events".
2018-01-08 18:10:01,489: On parsely_base_events: COMMIT
2018-01-08 18:10:02,128: SQL status: COMMIT in 0.64 seconds
2018-01-08 18:10:02,129: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c878aed0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:10:02,187: 18:10:02 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 2.81s]
2018-01-08 18:10:02,188: 18:10:02 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-08 18:10:02,188: Compiling model.parsely.parsely_event_ids
2018-01-08 18:10:02,197: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-08 18:10:02,216: Acquiring new redshift connection "parsely_event_ids".
2018-01-08 18:10:02,216: Re-using an available connection from the pool.
2018-01-08 18:10:02,216: Using redshift connection "parsely_event_ids".
2018-01-08 18:10:02,217: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:02,239: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:02,240: Using redshift connection "parsely_event_ids".
2018-01-08 18:10:02,240: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:02,262: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:02,263: Using redshift connection "parsely_event_ids".
2018-01-08 18:10:02,264: On parsely_event_ids: BEGIN
2018-01-08 18:10:02,266: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:10:02,266: Using redshift connection "parsely_event_ids".
2018-01-08 18:10:02,266: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:10:05,508: SQL status: SELECT in 3.24 seconds
2018-01-08 18:10:05,508: Using redshift connection "parsely_event_ids".
2018-01-08 18:10:05,508: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-08 18:10:05,662: SQL status: SELECT in 0.15 seconds
2018-01-08 18:10:05,662: Using redshift connection "parsely_event_ids".
2018-01-08 18:10:05,662: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:10:05,783: SQL status: SELECT in 0.12 seconds
2018-01-08 18:10:05,784: Using redshift connection "parsely_event_ids".
2018-01-08 18:10:05,784: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:10:05,906: SQL status: SELECT in 0.12 seconds
2018-01-08 18:10:05,908: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-08 18:10:05,909: Using redshift connection "parsely_event_ids".
2018-01-08 18:10:05,909: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-08 18:10:07,881: SQL status: INSERT 0 941926 in 1.97 seconds
2018-01-08 18:10:07,881: On parsely_event_ids: COMMIT
2018-01-08 18:10:07,882: Using redshift connection "parsely_event_ids".
2018-01-08 18:10:07,882: On parsely_event_ids: COMMIT
2018-01-08 18:10:08,385: SQL status: COMMIT in 0.50 seconds
2018-01-08 18:10:08,385: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c87447d0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:10:08,439: 18:10:08 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 941926 in 6.20s]
2018-01-08 18:10:08,440: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-08 18:10:08,460: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-08 18:10:08,470: 18:10:08 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-08 18:10:08,471: Compiling model.parsely.parsely_post_content
2018-01-08 18:10:08,490: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-08 18:10:08,491: Acquiring new redshift connection "parsely_post_content".
2018-01-08 18:10:08,492: Re-using an available connection from the pool.
2018-01-08 18:10:08,492: Using redshift connection "parsely_post_content".
2018-01-08 18:10:08,492: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:08,515: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:08,516: Using redshift connection "parsely_post_content".
2018-01-08 18:10:08,516: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:08,537: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:08,540: Using redshift connection "parsely_post_content".
2018-01-08 18:10:08,540: On parsely_post_content: BEGIN
2018-01-08 18:10:08,542: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:10:08,542: Using redshift connection "parsely_post_content".
2018-01-08 18:10:08,542: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:10:26,750: SQL status: SELECT in 18.21 seconds
2018-01-08 18:10:26,750: Using redshift connection "parsely_post_content".
2018-01-08 18:10:26,750: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-08 18:10:26,917: SQL status: SELECT in 0.17 seconds
2018-01-08 18:10:26,918: Using redshift connection "parsely_post_content".
2018-01-08 18:10:26,918: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:10:27,038: SQL status: SELECT in 0.12 seconds
2018-01-08 18:10:27,039: Using redshift connection "parsely_post_content".
2018-01-08 18:10:27,041: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:10:27,161: SQL status: SELECT in 0.12 seconds
2018-01-08 18:10:27,163: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-08 18:10:27,164: Using redshift connection "parsely_post_content".
2018-01-08 18:10:27,164: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-08 18:10:27,521: SQL status: INSERT 0 895 in 0.36 seconds
2018-01-08 18:10:27,522: On parsely_post_content: COMMIT
2018-01-08 18:10:27,522: Using redshift connection "parsely_post_content".
2018-01-08 18:10:27,522: On parsely_post_content: COMMIT
2018-01-08 18:10:27,999: SQL status: COMMIT in 0.48 seconds
2018-01-08 18:10:28,000: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8781ed0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:10:28,045: 18:10:28 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 895 in 19.53s]
2018-01-08 18:10:28,046: 18:10:28 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-08 18:10:28,046: Compiling model.parsely.parsely_video_content
2018-01-08 18:10:28,057: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-08 18:10:28,059: Acquiring new redshift connection "parsely_video_content".
2018-01-08 18:10:28,059: Re-using an available connection from the pool.
2018-01-08 18:10:28,059: Using redshift connection "parsely_video_content".
2018-01-08 18:10:28,059: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:28,081: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:28,082: Using redshift connection "parsely_video_content".
2018-01-08 18:10:28,083: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:28,102: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:28,104: Using redshift connection "parsely_video_content".
2018-01-08 18:10:28,105: On parsely_video_content: BEGIN
2018-01-08 18:10:28,107: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:10:28,107: Using redshift connection "parsely_video_content".
2018-01-08 18:10:28,107: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:10:45,483: SQL status: SELECT in 17.38 seconds
2018-01-08 18:10:45,483: Using redshift connection "parsely_video_content".
2018-01-08 18:10:45,484: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-08 18:10:45,690: SQL status: SELECT in 0.21 seconds
2018-01-08 18:10:45,691: Using redshift connection "parsely_video_content".
2018-01-08 18:10:45,691: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:10:45,811: SQL status: SELECT in 0.12 seconds
2018-01-08 18:10:45,812: Using redshift connection "parsely_video_content".
2018-01-08 18:10:45,812: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:10:45,934: SQL status: SELECT in 0.12 seconds
2018-01-08 18:10:45,936: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-08 18:10:45,937: Using redshift connection "parsely_video_content".
2018-01-08 18:10:45,937: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-08 18:10:46,281: SQL status: INSERT 0 470 in 0.34 seconds
2018-01-08 18:10:46,282: On parsely_video_content: COMMIT
2018-01-08 18:10:46,282: Using redshift connection "parsely_video_content".
2018-01-08 18:10:46,282: On parsely_video_content: COMMIT
2018-01-08 18:10:46,723: SQL status: COMMIT in 0.44 seconds
2018-01-08 18:10:46,724: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c882c2d0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:10:46,775: 18:10:46 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 470 in 18.68s]
2018-01-08 18:10:46,776: 18:10:46 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-08 18:10:46,776: Compiling model.parsely.parsely_entry_exit_urls
2018-01-08 18:10:46,798: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-08 18:10:46,799: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-08 18:10:46,800: Re-using an available connection from the pool.
2018-01-08 18:10:46,800: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 18:10:46,800: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:46,823: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:46,828: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-08 18:10:46,828: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 18:10:46,829: On parsely_entry_exit_urls: BEGIN
2018-01-08 18:10:46,831: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:10:46,831: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 18:10:46,831: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-08 18:10:46,980: SQL status: CREATE VIEW in 0.15 seconds
2018-01-08 18:10:46,981: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 18:10:46,981: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-08 18:10:46,984: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:10:46,984: On parsely_entry_exit_urls: COMMIT
2018-01-08 18:10:46,984: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 18:10:46,984: On parsely_entry_exit_urls: COMMIT
2018-01-08 18:10:47,340: SQL status: COMMIT in 0.36 seconds
2018-01-08 18:10:47,341: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c882c2d0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:10:47,395: 18:10:47 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.56s]
2018-01-08 18:10:47,395: 18:10:47 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-08 18:10:47,396: Compiling model.parsely.parsely_incoming_videoviews
2018-01-08 18:10:47,428: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-08 18:10:47,431: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-08 18:10:47,431: Re-using an available connection from the pool.
2018-01-08 18:10:47,432: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 18:10:47,432: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:47,455: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:47,460: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-08 18:10:47,462: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 18:10:47,462: On parsely_incoming_videoviews: BEGIN
2018-01-08 18:10:47,471: SQL status: BEGIN in 0.01 seconds
2018-01-08 18:10:47,471: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 18:10:47,471: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-08 18:10:48,079: SQL status: CREATE VIEW in 0.61 seconds
2018-01-08 18:10:48,080: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 18:10:48,080: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-08 18:10:48,086: SQL status: ALTER TABLE in 0.01 seconds
2018-01-08 18:10:48,086: On parsely_incoming_videoviews: COMMIT
2018-01-08 18:10:48,086: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 18:10:48,086: On parsely_incoming_videoviews: COMMIT
2018-01-08 18:10:49,165: SQL status: COMMIT in 1.08 seconds
2018-01-08 18:10:49,166: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c882c2d0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:10:49,202: 18:10:49 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.77s]
2018-01-08 18:10:49,203: 18:10:49 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-08 18:10:49,203: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-08 18:10:49,222: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:10:49,222: Re-using an available connection from the pool.
2018-01-08 18:10:49,222: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:10:49,222: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:49,245: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:49,252: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-08 18:10:49,254: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:10:49,254: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:49,276: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:49,276: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:10:49,276: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:10:49,297: SQL status: SELECT in 0.02 seconds
2018-01-08 18:10:49,300: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:10:49,300: On parsely_videoviews_sessionized: BEGIN
2018-01-08 18:10:49,302: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:10:49,302: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:10:49,303: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:12:38,091: SQL status: SELECT in 108.79 seconds
2018-01-08 18:12:38,092: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:12:38,092: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-08 18:12:38,240: SQL status: SELECT in 0.15 seconds
2018-01-08 18:12:38,241: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:12:38,241: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:12:38,354: SQL status: SELECT in 0.11 seconds
2018-01-08 18:12:38,355: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:12:38,356: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:12:38,468: SQL status: SELECT in 0.11 seconds
2018-01-08 18:12:38,472: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-08 18:12:38,473: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:12:38,473: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-08 18:12:39,774: SQL status: INSERT 0 145 in 1.30 seconds
2018-01-08 18:12:39,774: On parsely_videoviews_sessionized: COMMIT
2018-01-08 18:12:39,775: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:12:39,775: On parsely_videoviews_sessionized: COMMIT
2018-01-08 18:12:41,060: SQL status: COMMIT in 1.28 seconds
2018-01-08 18:12:41,061: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8720890>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:12:41,112: 18:12:41 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 145 in 111.86s]
2018-01-08 18:12:41,113: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-08 18:12:41,178: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-08 18:12:41,179: 18:12:41 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-08 18:12:41,179: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-08 18:12:41,206: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-08 18:12:41,207: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:12:41,208: Re-using an available connection from the pool.
2018-01-08 18:12:41,208: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:12:41,208: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:12:41,235: SQL status: SELECT in 0.03 seconds
2018-01-08 18:12:41,237: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-08 18:12:41,238: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:12:41,238: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-08 18:12:41,240: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:12:41,240: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:12:41,240: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-08 18:12:41,265: SQL status: CREATE VIEW in 0.03 seconds
2018-01-08 18:12:41,266: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:12:41,266: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-08 18:12:41,271: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:12:41,271: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-08 18:12:41,271: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:12:41,271: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-08 18:12:41,685: SQL status: COMMIT in 0.41 seconds
2018-01-08 18:12:41,686: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8744e50>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:12:41,733: 18:12:41 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 0.51s]
2018-01-08 18:12:41,734: 18:12:41 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-08 18:12:41,734: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-08 18:12:41,880: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-08 18:12:41,882: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:12:41,882: Re-using an available connection from the pool.
2018-01-08 18:12:41,883: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:12:41,883: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:12:41,913: SQL status: SELECT in 0.03 seconds
2018-01-08 18:12:41,918: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-08 18:12:41,927: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:12:41,927: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-08 18:12:41,929: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:12:41,929: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:12:41,929: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-08 18:12:41,998: SQL status: CREATE VIEW in 0.07 seconds
2018-01-08 18:12:41,999: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:12:41,999: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-08 18:12:42,004: SQL status: ALTER TABLE in 0.01 seconds
2018-01-08 18:12:42,005: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-08 18:12:42,005: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:12:42,005: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-08 18:12:42,319: SQL status: COMMIT in 0.31 seconds
2018-01-08 18:12:42,320: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8781ed0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:12:42,369: 18:12:42 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.59s]
2018-01-08 18:12:42,379: 18:12:42 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-08 18:12:42,380: Compiling model.parsely.parsely_incoming_pageviews
2018-01-08 18:12:42,426: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-08 18:12:42,429: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-08 18:12:42,430: Re-using an available connection from the pool.
2018-01-08 18:12:42,430: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 18:12:42,430: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:12:42,451: SQL status: SELECT in 0.02 seconds
2018-01-08 18:12:42,457: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-08 18:12:42,467: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 18:12:42,467: On parsely_incoming_pageviews: BEGIN
2018-01-08 18:12:42,469: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:12:42,469: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 18:12:42,469: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-08 18:12:42,600: SQL status: CREATE VIEW in 0.13 seconds
2018-01-08 18:12:42,600: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 18:12:42,601: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-08 18:12:42,606: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:12:42,606: On parsely_incoming_pageviews: COMMIT
2018-01-08 18:12:42,606: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 18:12:42,606: On parsely_incoming_pageviews: COMMIT
2018-01-08 18:12:42,828: SQL status: COMMIT in 0.22 seconds
2018-01-08 18:12:42,828: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8819990>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:12:42,884: 18:12:42 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.45s]
2018-01-08 18:12:42,884: 18:12:42 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-08 18:12:42,885: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-08 18:12:42,902: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:12:42,902: Re-using an available connection from the pool.
2018-01-08 18:12:42,902: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:12:42,903: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:12:42,925: SQL status: SELECT in 0.02 seconds
2018-01-08 18:12:42,932: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-08 18:12:42,935: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:12:42,935: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:12:42,957: SQL status: SELECT in 0.02 seconds
2018-01-08 18:12:42,958: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:12:42,958: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:12:42,979: SQL status: SELECT in 0.02 seconds
2018-01-08 18:12:42,982: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:12:42,982: On parsely_pageviews_sessionized: BEGIN
2018-01-08 18:12:42,985: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:12:42,985: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:12:42,985: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:18:37,069: SQL status: SELECT in 354.08 seconds
2018-01-08 18:18:37,070: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:18:37,070: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-08 18:18:37,366: SQL status: SELECT in 0.30 seconds
2018-01-08 18:18:37,367: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:18:37,367: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:18:37,491: SQL status: SELECT in 0.12 seconds
2018-01-08 18:18:37,493: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:18:37,493: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:18:37,613: SQL status: SELECT in 0.12 seconds
2018-01-08 18:18:37,619: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-08 18:18:37,620: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:18:37,620: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-08 18:18:40,956: SQL status: INSERT 0 112390 in 3.34 seconds
2018-01-08 18:18:40,957: On parsely_pageviews_sessionized: COMMIT
2018-01-08 18:18:40,957: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:18:40,957: On parsely_pageviews_sessionized: COMMIT
2018-01-08 18:18:42,295: SQL status: COMMIT in 1.34 seconds
2018-01-08 18:18:42,296: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c878a950>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:18:42,376: 18:18:42 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 112390 in 359.41s]
2018-01-08 18:18:42,376: 18:18:42 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-08 18:18:42,377: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-08 18:18:42,461: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-08 18:18:42,462: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:18:42,462: Re-using an available connection from the pool.
2018-01-08 18:18:42,463: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:18:42,463: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:18:42,485: SQL status: SELECT in 0.02 seconds
2018-01-08 18:18:42,488: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-08 18:18:42,489: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:18:42,489: On parsely_videoview_engagedtime: BEGIN
2018-01-08 18:18:42,491: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:18:42,491: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:18:42,491: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-08 18:18:42,928: SQL status: CREATE VIEW in 0.44 seconds
2018-01-08 18:18:42,928: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:18:42,929: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-08 18:18:42,933: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:18:42,933: On parsely_videoview_engagedtime: COMMIT
2018-01-08 18:18:42,933: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:18:42,933: On parsely_videoview_engagedtime: COMMIT
2018-01-08 18:18:43,506: SQL status: COMMIT in 0.57 seconds
2018-01-08 18:18:43,506: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c878a950>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:18:43,571: 18:18:43 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 1.13s]
2018-01-08 18:18:43,571: 18:18:43 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-08 18:18:43,572: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-08 18:18:43,588: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-08 18:18:43,590: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:18:43,590: Re-using an available connection from the pool.
2018-01-08 18:18:43,591: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:18:43,591: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:18:43,614: SQL status: SELECT in 0.02 seconds
2018-01-08 18:18:43,614: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:18:43,614: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:18:43,636: SQL status: SELECT in 0.02 seconds
2018-01-08 18:18:43,639: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:18:43,639: On parsely_videoview_behavior_workflow: BEGIN
2018-01-08 18:18:43,641: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:18:43,641: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:18:43,641: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:23:51,026: SQL status: SELECT in 307.39 seconds
2018-01-08 18:23:51,027: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:23:51,027: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-08 18:23:51,250: SQL status: SELECT in 0.22 seconds
2018-01-08 18:23:51,250: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:23:51,250: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:23:51,372: SQL status: SELECT in 0.12 seconds
2018-01-08 18:23:51,373: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:23:51,373: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:23:51,494: SQL status: SELECT in 0.12 seconds
2018-01-08 18:23:51,498: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-08 18:23:51,500: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:23:51,500: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-08 18:23:52,741: SQL status: INSERT 0 144 in 1.24 seconds
2018-01-08 18:23:52,742: On parsely_videoview_behavior_workflow: COMMIT
2018-01-08 18:23:52,742: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:23:52,742: On parsely_videoview_behavior_workflow: COMMIT
2018-01-08 18:23:53,944: SQL status: COMMIT in 1.20 seconds
2018-01-08 18:23:53,944: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8781ed0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:23:53,994: 18:23:53 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 144 in 310.37s]
2018-01-08 18:23:53,995: 18:23:53 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-08 18:23:53,995: Compiling model.parsely.parsely_campaigns
2018-01-08 18:23:53,999: Acquiring new redshift connection "parsely_campaigns".
2018-01-08 18:23:53,999: Re-using an available connection from the pool.
2018-01-08 18:23:53,999: Using redshift connection "parsely_campaigns".
2018-01-08 18:23:53,999: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:23:54,022: SQL status: SELECT in 0.02 seconds
2018-01-08 18:23:54,026: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-08 18:23:54,027: Using redshift connection "parsely_campaigns".
2018-01-08 18:23:54,028: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:23:54,049: SQL status: SELECT in 0.02 seconds
2018-01-08 18:23:54,050: Using redshift connection "parsely_campaigns".
2018-01-08 18:23:54,050: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:23:54,072: SQL status: SELECT in 0.02 seconds
2018-01-08 18:23:54,073: Using redshift connection "parsely_campaigns".
2018-01-08 18:23:54,073: On parsely_campaigns: BEGIN
2018-01-08 18:23:54,075: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:23:54,075: Using redshift connection "parsely_campaigns".
2018-01-08 18:23:54,075: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:23:55,388: SQL status: SELECT in 1.31 seconds
2018-01-08 18:23:55,388: Using redshift connection "parsely_campaigns".
2018-01-08 18:23:55,388: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-08 18:23:55,622: SQL status: SELECT in 0.23 seconds
2018-01-08 18:23:55,622: Using redshift connection "parsely_campaigns".
2018-01-08 18:23:55,622: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:23:55,741: SQL status: SELECT in 0.12 seconds
2018-01-08 18:23:55,741: Using redshift connection "parsely_campaigns".
2018-01-08 18:23:55,742: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:23:55,861: SQL status: SELECT in 0.12 seconds
2018-01-08 18:23:55,863: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-08 18:23:55,864: Using redshift connection "parsely_campaigns".
2018-01-08 18:23:55,864: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-08 18:23:56,011: SQL status: INSERT 0 394 in 0.15 seconds
2018-01-08 18:23:56,012: On parsely_campaigns: COMMIT
2018-01-08 18:23:56,012: Using redshift connection "parsely_campaigns".
2018-01-08 18:23:56,012: On parsely_campaigns: COMMIT
2018-01-08 18:23:56,310: SQL status: COMMIT in 0.30 seconds
2018-01-08 18:23:56,310: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6d31f7410>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:23:56,337: 18:23:56 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 394 in 2.32s]
2018-01-08 18:23:56,338: Compiling model.parsely.parsely_incoming_users
2018-01-08 18:23:56,349: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-08 18:23:56,350: 18:23:56 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-08 18:23:56,350: Compiling model.parsely.parsely_users
2018-01-08 18:23:56,356: Acquiring new redshift connection "parsely_users".
2018-01-08 18:23:56,356: Re-using an available connection from the pool.
2018-01-08 18:23:56,356: Using redshift connection "parsely_users".
2018-01-08 18:23:56,356: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:23:56,379: SQL status: SELECT in 0.02 seconds
2018-01-08 18:23:56,420: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-08 18:23:56,421: Using redshift connection "parsely_users".
2018-01-08 18:23:56,421: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:23:56,444: SQL status: SELECT in 0.02 seconds
2018-01-08 18:23:56,444: Using redshift connection "parsely_users".
2018-01-08 18:23:56,444: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:23:56,467: SQL status: SELECT in 0.02 seconds
2018-01-08 18:23:56,469: Using redshift connection "parsely_users".
2018-01-08 18:23:56,469: On parsely_users: BEGIN
2018-01-08 18:23:56,471: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:23:56,471: Using redshift connection "parsely_users".
2018-01-08 18:23:56,471: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:23:59,168: SQL status: SELECT in 2.70 seconds
2018-01-08 18:23:59,168: Using redshift connection "parsely_users".
2018-01-08 18:23:59,168: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-08 18:23:59,432: SQL status: SELECT in 0.26 seconds
2018-01-08 18:23:59,432: Using redshift connection "parsely_users".
2018-01-08 18:23:59,432: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:23:59,551: SQL status: SELECT in 0.12 seconds
2018-01-08 18:23:59,551: Using redshift connection "parsely_users".
2018-01-08 18:23:59,551: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:23:59,672: SQL status: SELECT in 0.12 seconds
2018-01-08 18:23:59,673: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-08 18:23:59,674: Using redshift connection "parsely_users".
2018-01-08 18:23:59,674: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-08 18:24:00,009: SQL status: INSERT 0 54738 in 0.34 seconds
2018-01-08 18:24:00,010: On parsely_users: COMMIT
2018-01-08 18:24:00,010: Using redshift connection "parsely_users".
2018-01-08 18:24:00,010: On parsely_users: COMMIT
2018-01-08 18:24:00,367: SQL status: COMMIT in 0.36 seconds
2018-01-08 18:24:00,367: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c878a110>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:24:00,399: 18:24:00 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 54738 in 4.02s]
2018-01-08 18:24:00,400: 18:24:00 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-08 18:24:00,400: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-08 18:24:00,432: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-08 18:24:00,433: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:24:00,433: Re-using an available connection from the pool.
2018-01-08 18:24:00,433: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:24:00,434: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:24:00,457: SQL status: SELECT in 0.02 seconds
2018-01-08 18:24:00,459: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-08 18:24:00,461: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:24:00,461: On parsely_pageview_engagedtime: BEGIN
2018-01-08 18:24:00,463: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:24:00,463: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:24:00,463: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-08 18:24:00,852: SQL status: CREATE VIEW in 0.39 seconds
2018-01-08 18:24:00,852: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:24:00,852: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-08 18:24:00,860: SQL status: ALTER TABLE in 0.01 seconds
2018-01-08 18:24:00,860: On parsely_pageview_engagedtime: COMMIT
2018-01-08 18:24:00,860: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:24:00,860: On parsely_pageview_engagedtime: COMMIT
2018-01-08 18:24:01,325: SQL status: COMMIT in 0.47 seconds
2018-01-08 18:24:01,326: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8781ed0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:24:01,359: 18:24:01 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 0.93s]
2018-01-08 18:24:01,360: 18:24:01 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-08 18:24:01,360: Compiling model.parsely.parsely_incoming_sessions
2018-01-08 18:24:01,367: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-08 18:24:01,369: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-08 18:24:01,369: Re-using an available connection from the pool.
2018-01-08 18:24:01,369: Using redshift connection "parsely_incoming_sessions".
2018-01-08 18:24:01,369: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:24:01,393: SQL status: SELECT in 0.02 seconds
2018-01-08 18:24:01,395: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-08 18:24:01,396: Using redshift connection "parsely_incoming_sessions".
2018-01-08 18:24:01,396: On parsely_incoming_sessions: BEGIN
2018-01-08 18:24:01,398: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:24:01,398: Using redshift connection "parsely_incoming_sessions".
2018-01-08 18:24:01,399: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-08 18:24:03,024: SQL status: CREATE VIEW in 1.63 seconds
2018-01-08 18:24:03,024: Using redshift connection "parsely_incoming_sessions".
2018-01-08 18:24:03,025: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-08 18:24:03,028: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:24:03,028: On parsely_incoming_sessions: COMMIT
2018-01-08 18:24:03,028: Using redshift connection "parsely_incoming_sessions".
2018-01-08 18:24:03,028: On parsely_incoming_sessions: COMMIT
2018-01-08 18:24:04,033: SQL status: COMMIT in 1.00 seconds
2018-01-08 18:24:04,033: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6d31f7410>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:24:04,062: 18:24:04 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 2.67s]
2018-01-08 18:24:04,062: 18:24:04 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-08 18:24:04,062: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-08 18:24:04,071: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-08 18:24:04,073: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:24:04,073: Re-using an available connection from the pool.
2018-01-08 18:24:04,073: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:24:04,073: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:24:04,095: SQL status: SELECT in 0.02 seconds
2018-01-08 18:24:04,096: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:24:04,096: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:24:04,117: SQL status: SELECT in 0.02 seconds
2018-01-08 18:24:04,119: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:24:04,119: On parsely_pageview_behavior_workflow: BEGIN
2018-01-08 18:24:04,121: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:24:04,121: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:24:04,121: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:27:30,931: SQL status: SELECT in 206.81 seconds
2018-01-08 18:27:30,931: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:27:30,931: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-08 18:27:31,178: SQL status: SELECT in 0.25 seconds
2018-01-08 18:27:31,179: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:27:31,179: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:27:31,302: SQL status: SELECT in 0.12 seconds
2018-01-08 18:27:31,303: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:27:31,303: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:27:31,425: SQL status: SELECT in 0.12 seconds
2018-01-08 18:27:31,428: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-08 18:27:31,429: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:27:31,430: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-08 18:27:35,196: SQL status: INSERT 0 112357 in 3.77 seconds
2018-01-08 18:27:35,197: On parsely_pageview_behavior_workflow: COMMIT
2018-01-08 18:27:35,197: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:27:35,197: On parsely_pageview_behavior_workflow: COMMIT
2018-01-08 18:27:36,725: SQL status: COMMIT in 1.53 seconds
2018-01-08 18:27:36,726: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c882c210>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:27:36,789: 18:27:36 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 112357 in 212.66s]
2018-01-08 18:27:36,790: 18:27:36 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-08 18:27:36,790: Compiling model.parsely.parsely_sessions
2018-01-08 18:27:36,796: Acquiring new redshift connection "parsely_sessions".
2018-01-08 18:27:36,796: Re-using an available connection from the pool.
2018-01-08 18:27:36,797: Using redshift connection "parsely_sessions".
2018-01-08 18:27:36,797: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:27:36,820: SQL status: SELECT in 0.02 seconds
2018-01-08 18:27:36,823: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-08 18:27:36,824: Using redshift connection "parsely_sessions".
2018-01-08 18:27:36,825: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:27:36,846: SQL status: SELECT in 0.02 seconds
2018-01-08 18:27:36,847: Using redshift connection "parsely_sessions".
2018-01-08 18:27:36,847: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:27:36,869: SQL status: SELECT in 0.02 seconds
2018-01-08 18:27:36,872: Using redshift connection "parsely_sessions".
2018-01-08 18:27:36,872: On parsely_sessions: BEGIN
2018-01-08 18:27:36,874: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:27:36,874: Using redshift connection "parsely_sessions".
2018-01-08 18:27:36,874: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:28:20,487: SQL status: SELECT in 43.61 seconds
2018-01-08 18:28:20,487: Using redshift connection "parsely_sessions".
2018-01-08 18:28:20,487: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-08 18:28:20,640: SQL status: SELECT in 0.15 seconds
2018-01-08 18:28:20,640: Using redshift connection "parsely_sessions".
2018-01-08 18:28:20,640: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:28:20,762: SQL status: SELECT in 0.12 seconds
2018-01-08 18:28:20,763: Using redshift connection "parsely_sessions".
2018-01-08 18:28:20,763: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:28:20,883: SQL status: SELECT in 0.12 seconds
2018-01-08 18:28:20,887: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-08 18:28:20,888: Using redshift connection "parsely_sessions".
2018-01-08 18:28:20,889: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-08 18:28:22,641: SQL status: INSERT 0 91259 in 1.75 seconds
2018-01-08 18:28:22,642: On parsely_sessions: COMMIT
2018-01-08 18:28:22,642: Using redshift connection "parsely_sessions".
2018-01-08 18:28:22,642: On parsely_sessions: COMMIT
2018-01-08 18:28:23,709: SQL status: COMMIT in 1.07 seconds
2018-01-08 18:28:23,710: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8781ed0>], 'label': '1ee08182-7abf-4fb0-ada1-5420e4a8016c'}
2018-01-08 18:28:23,752: 18:28:23 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 91259 in 46.92s]
2018-01-08 18:28:23,797: Using redshift connection "master".
2018-01-08 18:28:23,797: On master: BEGIN
2018-01-08 18:28:23,800: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:28:23,800: On master: COMMIT
2018-01-08 18:28:23,800: Using redshift connection "master".
2018-01-08 18:28:23,800: On master: COMMIT
2018-01-08 18:28:23,802: SQL status: COMMIT in 0.00 seconds
2018-01-08 18:28:23,802: Compiling operation.parsely.parsely-on-run-end-0
2018-01-08 18:28:23,817: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-08 18:28:23,818: Using redshift connection "master".
2018-01-08 18:28:23,818: On master:  select 1 
2018-01-08 18:28:23,821: SQL status: SELECT in 0.00 seconds
2018-01-08 18:28:23,821: 18:28:23 | 
2018-01-08 18:28:23,821: 18:28:23 | Finished running 10 view models, 15 incremental models in 1574.64s.
2018-01-08 18:28:23,822: 
2018-01-08 18:28:23,822: Completed successfully
2018-01-08 18:28:23,822: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-08 18:28:23,822: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8832e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8832f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7ff6c8819950>], 'label': 'end'}
2018-01-08 18:28:23,862: Flushing usage events
2018-01-08 18:28:30,353: Tracking: tracking
2018-01-08 18:28:30,354: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a15ee10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a15ef90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a15eed0>], 'label': 'start'}
2018-01-08 18:28:30,395: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-08 18:28:30,421: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-08 18:28:30,422: Parsing core.sql
2018-01-08 18:28:30,437: Parsing etc/get_custom_schema.sql
2018-01-08 18:28:30,446: Parsing schema_tests/relationships.sql
2018-01-08 18:28:30,450: Parsing schema_tests/accepted_values.sql
2018-01-08 18:28:30,455: Parsing schema_tests/not_null.sql
2018-01-08 18:28:30,457: Parsing schema_tests/unique.sql
2018-01-08 18:28:30,459: Parsing materializations/wrapper.sql
2018-01-08 18:28:30,462: Parsing materializations/archive.sql
2018-01-08 18:28:30,504: Parsing materializations/table.sql
2018-01-08 18:28:30,530: Parsing materializations/helpers.sql
2018-01-08 18:28:30,555: Parsing materializations/bigquery.sql
2018-01-08 18:28:30,573: Parsing materializations/view.sql
2018-01-08 18:28:30,594: Parsing materializations/incremental.sql
2018-01-08 18:28:30,630: Parsing adapters/redshift.sql
2018-01-08 18:28:30,658: Parsing adapters/bigquery.sql
2018-01-08 18:28:30,663: Parsing adapters/postgres.sql
2018-01-08 18:28:30,667: Parsing adapters/common.sql
2018-01-08 18:28:30,698: Parsing model.parsely.parsely_audit
2018-01-08 18:28:30,700: Parsing model.parsely.parsely_video_content
2018-01-08 18:28:30,705: Parsing model.parsely.parsely_post_content
2018-01-08 18:28:30,709: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-08 18:28:30,714: Parsing model.parsely.parsely_rawdata
2018-01-08 18:28:30,718: Parsing model.parsely.calendar
2018-01-08 18:28:30,720: Parsing model.parsely.parsely_all_events
2018-01-08 18:28:30,735: Acquiring new redshift connection "parsely_all_events".
2018-01-08 18:28:30,735: Opening a new connection (0 currently allocated)
2018-01-08 18:28:30,749: Using redshift connection "parsely_all_events".
2018-01-08 18:28:30,749: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:30,776: SQL status: SELECT in 0.03 seconds
2018-01-08 18:28:30,783: Parsing model.parsely.parsely_event_ids
2018-01-08 18:28:30,785: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-08 18:28:30,788: Parsing model.parsely.parsely_base_events
2018-01-08 18:28:30,795: Acquiring new redshift connection "parsely_base_events".
2018-01-08 18:28:30,795: Re-using an available connection from the pool.
2018-01-08 18:28:30,795: Using redshift connection "parsely_base_events".
2018-01-08 18:28:30,795: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:30,816: SQL status: SELECT in 0.02 seconds
2018-01-08 18:28:30,818: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-08 18:28:30,827: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-08 18:28:30,835: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-08 18:28:30,838: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-08 18:28:30,841: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-08 18:28:30,846: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-08 18:28:30,856: Parsing model.parsely.parsely_incoming_pageviews
2018-01-08 18:28:30,866: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-08 18:28:30,872: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:28:30,872: Re-using an available connection from the pool.
2018-01-08 18:28:30,872: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:28:30,872: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:30,892: SQL status: SELECT in 0.02 seconds
2018-01-08 18:28:30,894: Parsing model.parsely.parsely_incoming_videoviews
2018-01-08 18:28:30,906: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-08 18:28:30,914: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:28:30,915: Re-using an available connection from the pool.
2018-01-08 18:28:30,915: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:28:30,915: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:30,936: SQL status: SELECT in 0.02 seconds
2018-01-08 18:28:30,937: Parsing model.parsely.parsely_incoming_users
2018-01-08 18:28:30,942: Parsing model.parsely.parsely_users
2018-01-08 18:28:30,950: Acquiring new redshift connection "parsely_users".
2018-01-08 18:28:30,950: Re-using an available connection from the pool.
2018-01-08 18:28:30,950: Using redshift connection "parsely_users".
2018-01-08 18:28:30,951: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:30,971: SQL status: SELECT in 0.02 seconds
2018-01-08 18:28:30,972: Parsing model.parsely.parsely_errors
2018-01-08 18:28:30,979: Parsing model.parsely.parsely_bot_traffic
2018-01-08 18:28:30,986: Parsing model.parsely.parsely_custom_events
2018-01-08 18:28:30,994: Parsing model.parsely.parsely_incoming_sessions
2018-01-08 18:28:31,000: Parsing model.parsely.parsely_entry_exit_urls
2018-01-08 18:28:31,005: Parsing model.parsely.parsely_sessions
2018-01-08 18:28:31,014: Acquiring new redshift connection "parsely_sessions".
2018-01-08 18:28:31,014: Re-using an available connection from the pool.
2018-01-08 18:28:31,014: Using redshift connection "parsely_sessions".
2018-01-08 18:28:31,014: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:31,035: SQL status: SELECT in 0.02 seconds
2018-01-08 18:28:31,036: Parsing model.parsely.parsely_campaigns
2018-01-08 18:28:31,043: Acquiring new redshift connection "parsely_campaigns".
2018-01-08 18:28:31,043: Re-using an available connection from the pool.
2018-01-08 18:28:31,043: Using redshift connection "parsely_campaigns".
2018-01-08 18:28:31,043: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:31,063: SQL status: SELECT in 0.02 seconds
2018-01-08 18:28:31,073: Parsing operation.parsely.parsely-on-run-end-0
2018-01-08 18:28:31,082: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-08 18:28:31,095: 
2018-01-08 18:28:31,100: Acquiring new redshift connection "master".
2018-01-08 18:28:31,100: Re-using an available connection from the pool.
2018-01-08 18:28:31,100: Using redshift connection "master".
2018-01-08 18:28:31,100: On master: select distinct nspname from pg_namespace
2018-01-08 18:28:31,103: SQL status: SELECT in 0.00 seconds
2018-01-08 18:28:31,107: Using redshift connection "master".
2018-01-08 18:28:31,108: On master: BEGIN
2018-01-08 18:28:31,109: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:28:31,109: On master: COMMIT
2018-01-08 18:28:31,109: Using redshift connection "master".
2018-01-08 18:28:31,110: On master: COMMIT
2018-01-08 18:28:31,111: SQL status: COMMIT in 0.00 seconds
2018-01-08 18:28:31,121: 18:28:31 | Concurrency: 1 threads (target='dev')
2018-01-08 18:28:31,121: 18:28:31 | 
2018-01-08 18:28:31,121: Using redshift connection "master".
2018-01-08 18:28:31,121: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:31,142: SQL status: SELECT in 0.02 seconds
2018-01-08 18:28:31,266: 18:28:31 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-08 18:28:31,267: Compiling model.parsely.calendar
2018-01-08 18:28:31,274: Writing injected SQL for node "model.parsely.calendar"
2018-01-08 18:28:31,277: Acquiring new redshift connection "calendar".
2018-01-08 18:28:31,277: Opening a new connection (1 currently allocated)
2018-01-08 18:28:31,290: Using redshift connection "calendar".
2018-01-08 18:28:31,290: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:31,316: SQL status: SELECT in 0.03 seconds
2018-01-08 18:28:31,319: Writing runtime SQL for node "model.parsely.calendar"
2018-01-08 18:28:31,321: Using redshift connection "calendar".
2018-01-08 18:28:31,321: On calendar: BEGIN
2018-01-08 18:28:31,323: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:28:31,323: Using redshift connection "calendar".
2018-01-08 18:28:31,323: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-08 18:28:31,427: SQL status: CREATE VIEW in 0.10 seconds
2018-01-08 18:28:31,428: On calendar: COMMIT
2018-01-08 18:28:31,428: Using redshift connection "calendar".
2018-01-08 18:28:31,428: On calendar: COMMIT
2018-01-08 18:28:31,842: SQL status: COMMIT in 0.41 seconds
2018-01-08 18:28:31,843: Using redshift connection "calendar".
2018-01-08 18:28:31,843: On calendar: BEGIN
2018-01-08 18:28:31,845: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:28:31,845: Using redshift connection "calendar".
2018-01-08 18:28:31,845: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-08 18:28:32,414: SQL status: DROP VIEW in 0.57 seconds
2018-01-08 18:28:32,414: On calendar: COMMIT
2018-01-08 18:28:32,414: Using redshift connection "calendar".
2018-01-08 18:28:32,415: On calendar: COMMIT
2018-01-08 18:28:33,978: SQL status: COMMIT in 1.56 seconds
2018-01-08 18:28:33,978: Using redshift connection "calendar".
2018-01-08 18:28:33,978: On calendar: BEGIN
2018-01-08 18:28:33,980: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:28:33,980: Using redshift connection "calendar".
2018-01-08 18:28:33,980: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-08 18:28:34,054: SQL status: ALTER TABLE in 0.07 seconds
2018-01-08 18:28:34,055: On calendar: COMMIT
2018-01-08 18:28:34,055: Using redshift connection "calendar".
2018-01-08 18:28:34,055: On calendar: COMMIT
2018-01-08 18:28:34,642: SQL status: COMMIT in 0.59 seconds
2018-01-08 18:28:34,642: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a04cbd0>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:28:34,678: 18:28:34 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 3.38s]
2018-01-08 18:28:34,679: 18:28:34 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-08 18:28:34,679: Compiling model.parsely.parsely_rawdata
2018-01-08 18:28:34,688: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-08 18:28:34,690: Acquiring new redshift connection "parsely_rawdata".
2018-01-08 18:28:34,690: Re-using an available connection from the pool.
2018-01-08 18:28:34,691: Using redshift connection "parsely_rawdata".
2018-01-08 18:28:34,691: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:34,711: SQL status: SELECT in 0.02 seconds
2018-01-08 18:28:34,711: Using redshift connection "parsely_rawdata".
2018-01-08 18:28:34,711: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:28:34,721: SQL status: SELECT in 0.01 seconds
2018-01-08 18:28:34,723: Using redshift connection "parsely_rawdata".
2018-01-08 18:28:34,723: On parsely_rawdata: BEGIN
2018-01-08 18:28:34,725: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:28:34,725: Using redshift connection "parsely_rawdata".
2018-01-08 18:28:34,725: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:29:06,852: SQL status: SELECT in 32.13 seconds
2018-01-08 18:29:06,852: Using redshift connection "parsely_rawdata".
2018-01-08 18:29:06,852: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-08 18:29:07,073: SQL status: SELECT in 0.22 seconds
2018-01-08 18:29:07,074: Using redshift connection "parsely_rawdata".
2018-01-08 18:29:07,074: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:29:07,183: SQL status: SELECT in 0.11 seconds
2018-01-08 18:29:07,184: Using redshift connection "parsely_rawdata".
2018-01-08 18:29:07,184: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:29:07,296: SQL status: SELECT in 0.11 seconds
2018-01-08 18:29:07,299: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-08 18:29:07,300: Using redshift connection "parsely_rawdata".
2018-01-08 18:29:07,300: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-08 18:29:39,802: SQL status: INSERT 0 1063612 in 32.50 seconds
2018-01-08 18:29:39,802: On parsely_rawdata: COMMIT
2018-01-08 18:29:39,802: Using redshift connection "parsely_rawdata".
2018-01-08 18:29:39,802: On parsely_rawdata: COMMIT
2018-01-08 18:29:42,154: SQL status: COMMIT in 2.35 seconds
2018-01-08 18:29:42,154: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a0b6b10>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:29:42,190: 18:29:42 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1063612 in 67.48s]
2018-01-08 18:29:42,191: 18:29:42 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-08 18:29:42,191: Compiling model.parsely.parsely_all_events
2018-01-08 18:29:42,199: Acquiring new redshift connection "parsely_all_events".
2018-01-08 18:29:42,199: Re-using an available connection from the pool.
2018-01-08 18:29:42,199: Using redshift connection "parsely_all_events".
2018-01-08 18:29:42,199: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:29:42,215: SQL status: SELECT in 0.02 seconds
2018-01-08 18:29:42,225: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-08 18:29:42,226: Using redshift connection "parsely_all_events".
2018-01-08 18:29:42,226: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:29:42,241: SQL status: SELECT in 0.01 seconds
2018-01-08 18:29:42,241: Using redshift connection "parsely_all_events".
2018-01-08 18:29:42,241: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:29:42,255: SQL status: SELECT in 0.01 seconds
2018-01-08 18:29:42,257: Using redshift connection "parsely_all_events".
2018-01-08 18:29:42,257: On parsely_all_events: BEGIN
2018-01-08 18:29:42,259: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:29:42,260: Using redshift connection "parsely_all_events".
2018-01-08 18:29:42,260: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:31:30,658: SQL status: SELECT in 108.40 seconds
2018-01-08 18:31:30,658: Using redshift connection "parsely_all_events".
2018-01-08 18:31:30,659: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-08 18:31:30,809: SQL status: SELECT in 0.15 seconds
2018-01-08 18:31:30,810: Using redshift connection "parsely_all_events".
2018-01-08 18:31:30,810: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:31:30,924: SQL status: SELECT in 0.11 seconds
2018-01-08 18:31:30,925: Using redshift connection "parsely_all_events".
2018-01-08 18:31:30,926: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:31:31,039: SQL status: SELECT in 0.11 seconds
2018-01-08 18:31:31,045: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-08 18:31:31,047: Using redshift connection "parsely_all_events".
2018-01-08 18:31:31,055: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-08 18:31:49,511: SQL status: INSERT 0 943443 in 18.46 seconds
2018-01-08 18:31:49,512: On parsely_all_events: COMMIT
2018-01-08 18:31:49,512: Using redshift connection "parsely_all_events".
2018-01-08 18:31:49,512: On parsely_all_events: COMMIT
2018-01-08 18:31:51,837: SQL status: COMMIT in 2.32 seconds
2018-01-08 18:31:51,838: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a10b810>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:31:51,902: 18:31:51 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 943443 in 129.65s]
2018-01-08 18:31:51,903: 18:31:51 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-08 18:31:51,903: Compiling model.parsely.parsely_bot_traffic
2018-01-08 18:31:51,936: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-08 18:31:51,938: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-08 18:31:51,938: Re-using an available connection from the pool.
2018-01-08 18:31:51,939: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:31:51,939: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:31:51,954: SQL status: SELECT in 0.02 seconds
2018-01-08 18:31:51,955: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:31:51,956: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:31:51,970: SQL status: SELECT in 0.01 seconds
2018-01-08 18:31:51,973: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:31:51,973: On parsely_bot_traffic: BEGIN
2018-01-08 18:31:51,975: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:31:51,975: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:31:51,975: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:33:25,139: SQL status: SELECT in 93.16 seconds
2018-01-08 18:33:25,140: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:33:25,140: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-08 18:33:25,394: SQL status: SELECT in 0.25 seconds
2018-01-08 18:33:25,395: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:33:25,395: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:33:25,509: SQL status: SELECT in 0.11 seconds
2018-01-08 18:33:25,511: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:33:25,511: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:33:25,626: SQL status: SELECT in 0.12 seconds
2018-01-08 18:33:25,632: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-08 18:33:25,633: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:33:25,633: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-08 18:33:26,746: SQL status: INSERT 0 4 in 1.11 seconds
2018-01-08 18:33:26,746: On parsely_bot_traffic: COMMIT
2018-01-08 18:33:26,746: Using redshift connection "parsely_bot_traffic".
2018-01-08 18:33:26,746: On parsely_bot_traffic: COMMIT
2018-01-08 18:33:27,831: SQL status: COMMIT in 1.08 seconds
2018-01-08 18:33:27,831: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a04cc90>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:33:27,900: 18:33:27 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 95.93s]
2018-01-08 18:33:27,901: 18:33:27 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-08 18:33:27,901: Compiling model.parsely.parsely_custom_events
2018-01-08 18:33:27,934: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-08 18:33:27,945: Acquiring new redshift connection "parsely_custom_events".
2018-01-08 18:33:27,945: Re-using an available connection from the pool.
2018-01-08 18:33:27,946: Using redshift connection "parsely_custom_events".
2018-01-08 18:33:27,946: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:33:27,960: SQL status: SELECT in 0.01 seconds
2018-01-08 18:33:27,961: Using redshift connection "parsely_custom_events".
2018-01-08 18:33:27,961: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:33:27,975: SQL status: SELECT in 0.01 seconds
2018-01-08 18:33:27,978: Using redshift connection "parsely_custom_events".
2018-01-08 18:33:27,978: On parsely_custom_events: BEGIN
2018-01-08 18:33:27,980: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:33:27,980: Using redshift connection "parsely_custom_events".
2018-01-08 18:33:27,980: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:35:57,011: SQL status: SELECT in 149.03 seconds
2018-01-08 18:35:57,012: Using redshift connection "parsely_custom_events".
2018-01-08 18:35:57,012: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-08 18:35:57,164: SQL status: SELECT in 0.15 seconds
2018-01-08 18:35:57,164: Using redshift connection "parsely_custom_events".
2018-01-08 18:35:57,164: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:35:57,281: SQL status: SELECT in 0.12 seconds
2018-01-08 18:35:57,282: Using redshift connection "parsely_custom_events".
2018-01-08 18:35:57,282: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:35:57,396: SQL status: SELECT in 0.11 seconds
2018-01-08 18:35:57,402: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-08 18:35:57,409: Using redshift connection "parsely_custom_events".
2018-01-08 18:35:57,409: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-08 18:35:57,681: SQL status: INSERT 0 0 in 0.27 seconds
2018-01-08 18:35:57,682: On parsely_custom_events: COMMIT
2018-01-08 18:35:57,682: Using redshift connection "parsely_custom_events".
2018-01-08 18:35:57,682: On parsely_custom_events: COMMIT
2018-01-08 18:35:58,032: SQL status: COMMIT in 0.35 seconds
2018-01-08 18:35:58,033: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a04cc90>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:35:58,122: 18:35:58 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 150.13s]
2018-01-08 18:35:58,124: 18:35:58 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-08 18:35:58,124: Compiling model.parsely.parsely_errors
2018-01-08 18:35:58,159: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-08 18:35:58,171: Acquiring new redshift connection "parsely_errors".
2018-01-08 18:35:58,171: Re-using an available connection from the pool.
2018-01-08 18:35:58,171: Using redshift connection "parsely_errors".
2018-01-08 18:35:58,172: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:35:58,187: SQL status: SELECT in 0.02 seconds
2018-01-08 18:35:58,188: Using redshift connection "parsely_errors".
2018-01-08 18:35:58,188: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:35:58,202: SQL status: SELECT in 0.01 seconds
2018-01-08 18:35:58,205: Using redshift connection "parsely_errors".
2018-01-08 18:35:58,205: On parsely_errors: BEGIN
2018-01-08 18:35:58,207: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:35:58,207: Using redshift connection "parsely_errors".
2018-01-08 18:35:58,207: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:37:31,585: SQL status: SELECT in 93.38 seconds
2018-01-08 18:37:31,585: Using redshift connection "parsely_errors".
2018-01-08 18:37:31,586: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-08 18:37:31,767: SQL status: SELECT in 0.18 seconds
2018-01-08 18:37:31,768: Using redshift connection "parsely_errors".
2018-01-08 18:37:31,768: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:37:31,884: SQL status: SELECT in 0.12 seconds
2018-01-08 18:37:31,885: Using redshift connection "parsely_errors".
2018-01-08 18:37:31,886: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:37:32,001: SQL status: SELECT in 0.12 seconds
2018-01-08 18:37:32,007: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-08 18:37:32,008: Using redshift connection "parsely_errors".
2018-01-08 18:37:32,009: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-08 18:37:32,873: SQL status: INSERT 0 2 in 0.86 seconds
2018-01-08 18:37:32,874: On parsely_errors: COMMIT
2018-01-08 18:37:32,874: Using redshift connection "parsely_errors".
2018-01-08 18:37:32,874: On parsely_errors: COMMIT
2018-01-08 18:37:33,966: SQL status: COMMIT in 1.09 seconds
2018-01-08 18:37:33,967: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a042f10>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:37:34,028: 18:37:34 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 95.84s]
2018-01-08 18:37:34,035: 18:37:34 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-08 18:37:34,035: Compiling model.parsely.parsely_base_events
2018-01-08 18:37:34,051: Acquiring new redshift connection "parsely_base_events".
2018-01-08 18:37:34,051: Re-using an available connection from the pool.
2018-01-08 18:37:34,051: Using redshift connection "parsely_base_events".
2018-01-08 18:37:34,051: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:37:34,068: SQL status: SELECT in 0.02 seconds
2018-01-08 18:37:34,083: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-08 18:37:34,085: Using redshift connection "parsely_base_events".
2018-01-08 18:37:34,085: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:37:34,099: SQL status: SELECT in 0.01 seconds
2018-01-08 18:37:34,102: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-08 18:37:34,103: Using redshift connection "parsely_base_events".
2018-01-08 18:37:34,104: On parsely_base_events: BEGIN
2018-01-08 18:37:34,106: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:37:34,106: Using redshift connection "parsely_base_events".
2018-01-08 18:37:34,106: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-08 18:37:34,404: SQL status: CREATE VIEW in 0.30 seconds
2018-01-08 18:37:34,404: On parsely_base_events: COMMIT
2018-01-08 18:37:34,404: Using redshift connection "parsely_base_events".
2018-01-08 18:37:34,405: On parsely_base_events: COMMIT
2018-01-08 18:37:34,784: SQL status: COMMIT in 0.38 seconds
2018-01-08 18:37:34,785: Using redshift connection "parsely_base_events".
2018-01-08 18:37:34,785: On parsely_base_events: BEGIN
2018-01-08 18:37:34,787: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:37:34,787: Using redshift connection "parsely_base_events".
2018-01-08 18:37:34,787: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-08 18:37:34,891: SQL status: DROP VIEW in 0.10 seconds
2018-01-08 18:37:34,891: On parsely_base_events: COMMIT
2018-01-08 18:37:34,891: Using redshift connection "parsely_base_events".
2018-01-08 18:37:34,891: On parsely_base_events: COMMIT
2018-01-08 18:37:35,153: SQL status: COMMIT in 0.26 seconds
2018-01-08 18:37:35,154: Using redshift connection "parsely_base_events".
2018-01-08 18:37:35,154: On parsely_base_events: BEGIN
2018-01-08 18:37:35,156: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:37:35,157: Using redshift connection "parsely_base_events".
2018-01-08 18:37:35,157: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-08 18:37:35,162: SQL status: ALTER TABLE in 0.01 seconds
2018-01-08 18:37:35,162: On parsely_base_events: COMMIT
2018-01-08 18:37:35,162: Using redshift connection "parsely_base_events".
2018-01-08 18:37:35,162: On parsely_base_events: COMMIT
2018-01-08 18:37:35,371: SQL status: COMMIT in 0.21 seconds
2018-01-08 18:37:35,371: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a0b6950>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:37:35,426: 18:37:35 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 1.34s]
2018-01-08 18:37:35,427: 18:37:35 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-08 18:37:35,435: Compiling model.parsely.parsely_event_ids
2018-01-08 18:37:35,453: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-08 18:37:35,456: Acquiring new redshift connection "parsely_event_ids".
2018-01-08 18:37:35,456: Re-using an available connection from the pool.
2018-01-08 18:37:35,456: Using redshift connection "parsely_event_ids".
2018-01-08 18:37:35,456: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:37:35,471: SQL status: SELECT in 0.01 seconds
2018-01-08 18:37:35,472: Using redshift connection "parsely_event_ids".
2018-01-08 18:37:35,472: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:37:35,486: SQL status: SELECT in 0.01 seconds
2018-01-08 18:37:35,487: Using redshift connection "parsely_event_ids".
2018-01-08 18:37:35,487: On parsely_event_ids: BEGIN
2018-01-08 18:37:35,489: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:37:35,490: Using redshift connection "parsely_event_ids".
2018-01-08 18:37:35,490: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:37:37,833: SQL status: SELECT in 2.34 seconds
2018-01-08 18:37:37,834: Using redshift connection "parsely_event_ids".
2018-01-08 18:37:37,834: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-08 18:37:37,973: SQL status: SELECT in 0.14 seconds
2018-01-08 18:37:37,974: Using redshift connection "parsely_event_ids".
2018-01-08 18:37:37,974: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:37:38,085: SQL status: SELECT in 0.11 seconds
2018-01-08 18:37:38,085: Using redshift connection "parsely_event_ids".
2018-01-08 18:37:38,085: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:37:38,197: SQL status: SELECT in 0.11 seconds
2018-01-08 18:37:38,199: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-08 18:37:38,200: Using redshift connection "parsely_event_ids".
2018-01-08 18:37:38,200: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-08 18:37:40,239: SQL status: INSERT 0 943439 in 2.04 seconds
2018-01-08 18:37:40,239: On parsely_event_ids: COMMIT
2018-01-08 18:37:40,239: Using redshift connection "parsely_event_ids".
2018-01-08 18:37:40,240: On parsely_event_ids: COMMIT
2018-01-08 18:37:40,577: SQL status: COMMIT in 0.34 seconds
2018-01-08 18:37:40,577: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a062dd0>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:37:40,634: 18:37:40 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 943439 in 5.14s]
2018-01-08 18:37:40,635: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-08 18:37:40,653: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-08 18:37:40,663: 18:37:40 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-08 18:37:40,663: Compiling model.parsely.parsely_post_content
2018-01-08 18:37:40,686: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-08 18:37:40,688: Acquiring new redshift connection "parsely_post_content".
2018-01-08 18:37:40,688: Re-using an available connection from the pool.
2018-01-08 18:37:40,689: Using redshift connection "parsely_post_content".
2018-01-08 18:37:40,689: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:37:40,704: SQL status: SELECT in 0.02 seconds
2018-01-08 18:37:40,705: Using redshift connection "parsely_post_content".
2018-01-08 18:37:40,705: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:37:40,719: SQL status: SELECT in 0.01 seconds
2018-01-08 18:37:40,721: Using redshift connection "parsely_post_content".
2018-01-08 18:37:40,721: On parsely_post_content: BEGIN
2018-01-08 18:37:40,723: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:37:40,723: Using redshift connection "parsely_post_content".
2018-01-08 18:37:40,723: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:37:59,286: SQL status: SELECT in 18.56 seconds
2018-01-08 18:37:59,287: Using redshift connection "parsely_post_content".
2018-01-08 18:37:59,287: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-08 18:37:59,432: SQL status: SELECT in 0.15 seconds
2018-01-08 18:37:59,433: Using redshift connection "parsely_post_content".
2018-01-08 18:37:59,433: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:37:59,542: SQL status: SELECT in 0.11 seconds
2018-01-08 18:37:59,543: Using redshift connection "parsely_post_content".
2018-01-08 18:37:59,543: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:37:59,651: SQL status: SELECT in 0.11 seconds
2018-01-08 18:37:59,654: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-08 18:37:59,655: Using redshift connection "parsely_post_content".
2018-01-08 18:37:59,655: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-08 18:38:00,011: SQL status: INSERT 0 895 in 0.36 seconds
2018-01-08 18:38:00,012: On parsely_post_content: COMMIT
2018-01-08 18:38:00,012: Using redshift connection "parsely_post_content".
2018-01-08 18:38:00,012: On parsely_post_content: COMMIT
2018-01-08 18:38:00,391: SQL status: COMMIT in 0.38 seconds
2018-01-08 18:38:00,392: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a0aded0>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:38:00,437: 18:38:00 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 895 in 19.73s]
2018-01-08 18:38:00,438: 18:38:00 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-08 18:38:00,438: Compiling model.parsely.parsely_video_content
2018-01-08 18:38:00,448: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-08 18:38:00,450: Acquiring new redshift connection "parsely_video_content".
2018-01-08 18:38:00,450: Re-using an available connection from the pool.
2018-01-08 18:38:00,450: Using redshift connection "parsely_video_content".
2018-01-08 18:38:00,451: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:38:00,465: SQL status: SELECT in 0.01 seconds
2018-01-08 18:38:00,466: Using redshift connection "parsely_video_content".
2018-01-08 18:38:00,467: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:38:00,480: SQL status: SELECT in 0.01 seconds
2018-01-08 18:38:00,482: Using redshift connection "parsely_video_content".
2018-01-08 18:38:00,482: On parsely_video_content: BEGIN
2018-01-08 18:38:00,484: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:38:00,485: Using redshift connection "parsely_video_content".
2018-01-08 18:38:00,485: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:38:18,191: SQL status: SELECT in 17.71 seconds
2018-01-08 18:38:18,192: Using redshift connection "parsely_video_content".
2018-01-08 18:38:18,192: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-08 18:38:18,599: SQL status: SELECT in 0.41 seconds
2018-01-08 18:38:18,599: Using redshift connection "parsely_video_content".
2018-01-08 18:38:18,599: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:38:18,710: SQL status: SELECT in 0.11 seconds
2018-01-08 18:38:18,711: Using redshift connection "parsely_video_content".
2018-01-08 18:38:18,711: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:38:18,822: SQL status: SELECT in 0.11 seconds
2018-01-08 18:38:18,825: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-08 18:38:18,826: Using redshift connection "parsely_video_content".
2018-01-08 18:38:18,826: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-08 18:38:19,170: SQL status: INSERT 0 470 in 0.34 seconds
2018-01-08 18:38:19,171: On parsely_video_content: COMMIT
2018-01-08 18:38:19,171: Using redshift connection "parsely_video_content".
2018-01-08 18:38:19,171: On parsely_video_content: COMMIT
2018-01-08 18:38:19,890: SQL status: COMMIT in 0.72 seconds
2018-01-08 18:38:19,891: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a158150>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:38:19,925: 18:38:19 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 470 in 19.45s]
2018-01-08 18:38:19,925: 18:38:19 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-08 18:38:19,926: Compiling model.parsely.parsely_entry_exit_urls
2018-01-08 18:38:19,935: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-08 18:38:19,937: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-08 18:38:19,937: Re-using an available connection from the pool.
2018-01-08 18:38:19,937: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 18:38:19,937: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:38:19,951: SQL status: SELECT in 0.01 seconds
2018-01-08 18:38:19,954: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-08 18:38:19,967: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 18:38:19,967: On parsely_entry_exit_urls: BEGIN
2018-01-08 18:38:19,969: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:38:19,969: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 18:38:19,969: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-08 18:38:20,187: SQL status: CREATE VIEW in 0.22 seconds
2018-01-08 18:38:20,188: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 18:38:20,188: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-08 18:38:20,191: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:38:20,191: On parsely_entry_exit_urls: COMMIT
2018-01-08 18:38:20,191: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 18:38:20,192: On parsely_entry_exit_urls: COMMIT
2018-01-08 18:38:20,620: SQL status: COMMIT in 0.43 seconds
2018-01-08 18:38:20,620: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a158150>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:38:20,696: 18:38:20 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.69s]
2018-01-08 18:38:20,707: 18:38:20 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-08 18:38:20,707: Compiling model.parsely.parsely_incoming_videoviews
2018-01-08 18:38:20,741: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-08 18:38:20,743: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-08 18:38:20,743: Re-using an available connection from the pool.
2018-01-08 18:38:20,743: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 18:38:20,744: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:38:20,758: SQL status: SELECT in 0.01 seconds
2018-01-08 18:38:20,767: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-08 18:38:20,769: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 18:38:20,769: On parsely_incoming_videoviews: BEGIN
2018-01-08 18:38:20,779: SQL status: BEGIN in 0.01 seconds
2018-01-08 18:38:20,779: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 18:38:20,779: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-08 18:38:21,073: SQL status: CREATE VIEW in 0.29 seconds
2018-01-08 18:38:21,074: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 18:38:21,074: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-08 18:38:21,079: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:38:21,079: On parsely_incoming_videoviews: COMMIT
2018-01-08 18:38:21,079: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 18:38:21,079: On parsely_incoming_videoviews: COMMIT
2018-01-08 18:38:21,299: SQL status: COMMIT in 0.22 seconds
2018-01-08 18:38:21,300: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a158150>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:38:21,352: 18:38:21 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 0.59s]
2018-01-08 18:38:21,354: 18:38:21 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-08 18:38:21,354: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-08 18:38:21,364: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:38:21,364: Re-using an available connection from the pool.
2018-01-08 18:38:21,364: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:38:21,364: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:38:21,379: SQL status: SELECT in 0.01 seconds
2018-01-08 18:38:21,385: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-08 18:38:21,387: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:38:21,387: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:38:21,401: SQL status: SELECT in 0.01 seconds
2018-01-08 18:38:21,401: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:38:21,402: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:38:21,415: SQL status: SELECT in 0.01 seconds
2018-01-08 18:38:21,418: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:38:21,418: On parsely_videoviews_sessionized: BEGIN
2018-01-08 18:38:21,420: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:38:21,420: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:38:21,420: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:40:15,491: SQL status: SELECT in 114.07 seconds
2018-01-08 18:40:15,492: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:40:15,492: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-08 18:40:15,700: SQL status: SELECT in 0.21 seconds
2018-01-08 18:40:15,701: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:40:15,701: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:40:15,811: SQL status: SELECT in 0.11 seconds
2018-01-08 18:40:15,812: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:40:15,812: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:40:15,922: SQL status: SELECT in 0.11 seconds
2018-01-08 18:40:15,928: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-08 18:40:15,929: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:40:15,930: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-08 18:40:17,067: SQL status: INSERT 0 145 in 1.14 seconds
2018-01-08 18:40:17,068: On parsely_videoviews_sessionized: COMMIT
2018-01-08 18:40:17,068: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:40:17,068: On parsely_videoviews_sessionized: COMMIT
2018-01-08 18:40:19,016: SQL status: COMMIT in 1.95 seconds
2018-01-08 18:40:19,016: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a0ade10>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:40:19,089: 18:40:19 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 145 in 117.66s]
2018-01-08 18:40:19,090: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-08 18:40:19,133: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-08 18:40:19,135: 18:40:19 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-08 18:40:19,135: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-08 18:40:19,160: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-08 18:40:19,162: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:40:19,162: Re-using an available connection from the pool.
2018-01-08 18:40:19,163: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:40:19,163: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:40:19,180: SQL status: SELECT in 0.02 seconds
2018-01-08 18:40:19,183: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-08 18:40:19,184: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:40:19,184: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-08 18:40:19,186: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:40:19,186: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:40:19,186: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-08 18:40:20,622: SQL status: CREATE VIEW in 1.44 seconds
2018-01-08 18:40:20,622: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:40:20,623: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-08 18:40:20,626: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:40:20,626: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-08 18:40:20,626: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 18:40:20,626: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-08 18:40:21,448: SQL status: COMMIT in 0.82 seconds
2018-01-08 18:40:21,449: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a113490>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:40:21,500: 18:40:21 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 2.31s]
2018-01-08 18:40:21,501: 18:40:21 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-08 18:40:21,501: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-08 18:40:21,604: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-08 18:40:21,606: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:40:21,606: Re-using an available connection from the pool.
2018-01-08 18:40:21,607: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:40:21,607: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:40:21,626: SQL status: SELECT in 0.02 seconds
2018-01-08 18:40:21,631: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-08 18:40:21,632: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:40:21,632: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-08 18:40:21,635: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:40:21,635: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:40:21,635: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-08 18:40:22,227: SQL status: CREATE VIEW in 0.59 seconds
2018-01-08 18:40:22,228: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:40:22,231: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-08 18:40:22,234: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:40:22,235: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-08 18:40:22,235: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 18:40:22,235: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-08 18:40:22,532: SQL status: COMMIT in 0.30 seconds
2018-01-08 18:40:22,532: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a04c7d0>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:40:22,592: 18:40:22 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 1.03s]
2018-01-08 18:40:22,592: 18:40:22 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-08 18:40:22,593: Compiling model.parsely.parsely_incoming_pageviews
2018-01-08 18:40:22,610: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-08 18:40:22,613: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-08 18:40:22,614: Re-using an available connection from the pool.
2018-01-08 18:40:22,614: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 18:40:22,614: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:40:22,625: SQL status: SELECT in 0.01 seconds
2018-01-08 18:40:22,631: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-08 18:40:22,633: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 18:40:22,633: On parsely_incoming_pageviews: BEGIN
2018-01-08 18:40:22,635: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:40:22,635: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 18:40:22,635: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-08 18:40:23,496: SQL status: CREATE VIEW in 0.86 seconds
2018-01-08 18:40:23,497: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 18:40:23,497: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-08 18:40:23,502: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:40:23,502: On parsely_incoming_pageviews: COMMIT
2018-01-08 18:40:23,502: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 18:40:23,503: On parsely_incoming_pageviews: COMMIT
2018-01-08 18:40:24,331: SQL status: COMMIT in 0.83 seconds
2018-01-08 18:40:24,332: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a04c7d0>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:40:24,387: 18:40:24 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 1.74s]
2018-01-08 18:40:24,388: 18:40:24 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-08 18:40:24,388: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-08 18:40:24,397: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:40:24,397: Re-using an available connection from the pool.
2018-01-08 18:40:24,397: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:40:24,397: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:40:24,408: SQL status: SELECT in 0.01 seconds
2018-01-08 18:40:24,415: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-08 18:40:24,417: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:40:24,417: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:40:24,428: SQL status: SELECT in 0.01 seconds
2018-01-08 18:40:24,428: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:40:24,428: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:40:24,439: SQL status: SELECT in 0.01 seconds
2018-01-08 18:40:24,442: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:40:24,442: On parsely_pageviews_sessionized: BEGIN
2018-01-08 18:40:24,444: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:40:24,444: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:40:24,444: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:46:44,894: SQL status: SELECT in 380.45 seconds
2018-01-08 18:46:44,894: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:46:44,894: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-08 18:46:45,186: SQL status: SELECT in 0.29 seconds
2018-01-08 18:46:45,186: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:46:45,187: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:46:45,310: SQL status: SELECT in 0.12 seconds
2018-01-08 18:46:45,312: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:46:45,312: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:46:45,435: SQL status: SELECT in 0.12 seconds
2018-01-08 18:46:45,442: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-08 18:46:45,443: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:46:45,443: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-08 18:46:48,840: SQL status: INSERT 0 112569 in 3.40 seconds
2018-01-08 18:46:48,841: On parsely_pageviews_sessionized: COMMIT
2018-01-08 18:46:48,841: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:46:48,841: On parsely_pageviews_sessionized: COMMIT
2018-01-08 18:46:50,126: SQL status: COMMIT in 1.29 seconds
2018-01-08 18:46:50,127: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a0b6810>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:46:50,219: 18:46:50 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 112569 in 385.74s]
2018-01-08 18:46:50,223: 18:46:50 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-08 18:46:50,223: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-08 18:46:50,303: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-08 18:46:50,305: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:46:50,306: Re-using an available connection from the pool.
2018-01-08 18:46:50,306: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:46:50,306: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:46:50,329: SQL status: SELECT in 0.02 seconds
2018-01-08 18:46:50,333: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-08 18:46:50,335: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:46:50,335: On parsely_videoview_engagedtime: BEGIN
2018-01-08 18:46:50,337: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:46:50,337: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:46:50,337: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-08 18:46:50,496: SQL status: CREATE VIEW in 0.16 seconds
2018-01-08 18:46:50,497: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:46:50,497: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-08 18:46:50,502: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:46:50,502: On parsely_videoview_engagedtime: COMMIT
2018-01-08 18:46:50,502: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 18:46:50,502: On parsely_videoview_engagedtime: COMMIT
2018-01-08 18:46:50,960: SQL status: COMMIT in 0.46 seconds
2018-01-08 18:46:50,961: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a0b6810>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:46:50,997: 18:46:50 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 0.74s]
2018-01-08 18:46:50,998: 18:46:50 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-08 18:46:50,998: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-08 18:46:51,007: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-08 18:46:51,009: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:46:51,009: Re-using an available connection from the pool.
2018-01-08 18:46:51,009: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:46:51,009: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:46:51,031: SQL status: SELECT in 0.02 seconds
2018-01-08 18:46:51,031: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:46:51,031: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:46:51,053: SQL status: SELECT in 0.02 seconds
2018-01-08 18:46:51,056: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:46:51,056: On parsely_videoview_behavior_workflow: BEGIN
2018-01-08 18:46:51,058: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:46:51,058: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:46:51,058: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:52:22,510: SQL status: SELECT in 331.45 seconds
2018-01-08 18:52:22,510: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:52:22,515: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-08 18:52:22,722: SQL status: SELECT in 0.21 seconds
2018-01-08 18:52:22,722: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:52:22,722: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:52:22,845: SQL status: SELECT in 0.12 seconds
2018-01-08 18:52:22,846: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:52:22,846: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:52:22,971: SQL status: SELECT in 0.12 seconds
2018-01-08 18:52:22,975: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-08 18:52:22,976: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:52:22,976: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-08 18:52:24,125: SQL status: INSERT 0 144 in 1.15 seconds
2018-01-08 18:52:24,125: On parsely_videoview_behavior_workflow: COMMIT
2018-01-08 18:52:24,126: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 18:52:24,126: On parsely_videoview_behavior_workflow: COMMIT
2018-01-08 18:52:25,226: SQL status: COMMIT in 1.10 seconds
2018-01-08 18:52:25,226: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a0b6110>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:52:25,275: 18:52:25 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 144 in 334.23s]
2018-01-08 18:52:25,275: 18:52:25 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-08 18:52:25,276: Compiling model.parsely.parsely_campaigns
2018-01-08 18:52:25,280: Acquiring new redshift connection "parsely_campaigns".
2018-01-08 18:52:25,280: Re-using an available connection from the pool.
2018-01-08 18:52:25,280: Using redshift connection "parsely_campaigns".
2018-01-08 18:52:25,280: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:52:25,303: SQL status: SELECT in 0.02 seconds
2018-01-08 18:52:25,307: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-08 18:52:25,308: Using redshift connection "parsely_campaigns".
2018-01-08 18:52:25,308: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:52:25,330: SQL status: SELECT in 0.02 seconds
2018-01-08 18:52:25,331: Using redshift connection "parsely_campaigns".
2018-01-08 18:52:25,331: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:52:25,352: SQL status: SELECT in 0.02 seconds
2018-01-08 18:52:25,353: Using redshift connection "parsely_campaigns".
2018-01-08 18:52:25,353: On parsely_campaigns: BEGIN
2018-01-08 18:52:25,355: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:52:25,355: Using redshift connection "parsely_campaigns".
2018-01-08 18:52:25,355: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:52:27,126: SQL status: SELECT in 1.77 seconds
2018-01-08 18:52:27,127: Using redshift connection "parsely_campaigns".
2018-01-08 18:52:27,127: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-08 18:52:27,312: SQL status: SELECT in 0.19 seconds
2018-01-08 18:52:27,312: Using redshift connection "parsely_campaigns".
2018-01-08 18:52:27,312: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:52:27,429: SQL status: SELECT in 0.12 seconds
2018-01-08 18:52:27,430: Using redshift connection "parsely_campaigns".
2018-01-08 18:52:27,430: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:52:27,549: SQL status: SELECT in 0.12 seconds
2018-01-08 18:52:27,550: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-08 18:52:27,554: Using redshift connection "parsely_campaigns".
2018-01-08 18:52:27,554: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-08 18:52:27,700: SQL status: INSERT 0 394 in 0.15 seconds
2018-01-08 18:52:27,700: On parsely_campaigns: COMMIT
2018-01-08 18:52:27,700: Using redshift connection "parsely_campaigns".
2018-01-08 18:52:27,700: On parsely_campaigns: COMMIT
2018-01-08 18:52:28,367: SQL status: COMMIT in 0.67 seconds
2018-01-08 18:52:28,367: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a042050>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:52:28,394: 18:52:28 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 394 in 3.09s]
2018-01-08 18:52:28,394: Compiling model.parsely.parsely_incoming_users
2018-01-08 18:52:28,403: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-08 18:52:28,405: 18:52:28 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-08 18:52:28,405: Compiling model.parsely.parsely_users
2018-01-08 18:52:28,411: Acquiring new redshift connection "parsely_users".
2018-01-08 18:52:28,411: Re-using an available connection from the pool.
2018-01-08 18:52:28,411: Using redshift connection "parsely_users".
2018-01-08 18:52:28,411: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:52:28,433: SQL status: SELECT in 0.02 seconds
2018-01-08 18:52:28,474: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-08 18:52:28,476: Using redshift connection "parsely_users".
2018-01-08 18:52:28,476: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:52:28,497: SQL status: SELECT in 0.02 seconds
2018-01-08 18:52:28,498: Using redshift connection "parsely_users".
2018-01-08 18:52:28,498: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:52:28,518: SQL status: SELECT in 0.02 seconds
2018-01-08 18:52:28,521: Using redshift connection "parsely_users".
2018-01-08 18:52:28,521: On parsely_users: BEGIN
2018-01-08 18:52:28,523: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:52:28,523: Using redshift connection "parsely_users".
2018-01-08 18:52:28,523: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:52:31,293: SQL status: SELECT in 2.77 seconds
2018-01-08 18:52:31,294: Using redshift connection "parsely_users".
2018-01-08 18:52:31,294: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-08 18:52:31,474: SQL status: SELECT in 0.18 seconds
2018-01-08 18:52:31,475: Using redshift connection "parsely_users".
2018-01-08 18:52:31,475: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:52:31,594: SQL status: SELECT in 0.12 seconds
2018-01-08 18:52:31,594: Using redshift connection "parsely_users".
2018-01-08 18:52:31,594: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:52:31,711: SQL status: SELECT in 0.12 seconds
2018-01-08 18:52:31,713: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-08 18:52:31,714: Using redshift connection "parsely_users".
2018-01-08 18:52:31,714: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-08 18:52:32,042: SQL status: INSERT 0 54812 in 0.33 seconds
2018-01-08 18:52:32,042: On parsely_users: COMMIT
2018-01-08 18:52:32,043: Using redshift connection "parsely_users".
2018-01-08 18:52:32,043: On parsely_users: COMMIT
2018-01-08 18:52:32,565: SQL status: COMMIT in 0.52 seconds
2018-01-08 18:52:32,566: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a0b6950>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:52:32,596: 18:52:32 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 54812 in 4.16s]
2018-01-08 18:52:32,597: 18:52:32 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-08 18:52:32,597: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-08 18:52:32,629: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-08 18:52:32,630: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:52:32,631: Re-using an available connection from the pool.
2018-01-08 18:52:32,631: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:52:32,631: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:52:32,654: SQL status: SELECT in 0.02 seconds
2018-01-08 18:52:32,657: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-08 18:52:32,658: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:52:32,658: On parsely_pageview_engagedtime: BEGIN
2018-01-08 18:52:32,660: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:52:32,660: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:52:32,660: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-08 18:52:33,084: SQL status: CREATE VIEW in 0.42 seconds
2018-01-08 18:52:33,084: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:52:33,084: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-08 18:52:33,088: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:52:33,088: On parsely_pageview_engagedtime: COMMIT
2018-01-08 18:52:33,089: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 18:52:33,089: On parsely_pageview_engagedtime: COMMIT
2018-01-08 18:52:34,026: SQL status: COMMIT in 0.94 seconds
2018-01-08 18:52:34,026: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a113d10>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:52:34,053: 18:52:34 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 1.43s]
2018-01-08 18:52:34,054: 18:52:34 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-08 18:52:34,054: Compiling model.parsely.parsely_incoming_sessions
2018-01-08 18:52:34,061: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-08 18:52:34,063: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-08 18:52:34,063: Re-using an available connection from the pool.
2018-01-08 18:52:34,063: Using redshift connection "parsely_incoming_sessions".
2018-01-08 18:52:34,063: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:52:34,085: SQL status: SELECT in 0.02 seconds
2018-01-08 18:52:34,088: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-08 18:52:34,089: Using redshift connection "parsely_incoming_sessions".
2018-01-08 18:52:34,089: On parsely_incoming_sessions: BEGIN
2018-01-08 18:52:34,091: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:52:34,091: Using redshift connection "parsely_incoming_sessions".
2018-01-08 18:52:34,091: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-08 18:52:34,882: SQL status: CREATE VIEW in 0.79 seconds
2018-01-08 18:52:34,883: Using redshift connection "parsely_incoming_sessions".
2018-01-08 18:52:34,883: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-08 18:52:34,886: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 18:52:34,886: On parsely_incoming_sessions: COMMIT
2018-01-08 18:52:34,886: Using redshift connection "parsely_incoming_sessions".
2018-01-08 18:52:34,886: On parsely_incoming_sessions: COMMIT
2018-01-08 18:52:35,209: SQL status: COMMIT in 0.32 seconds
2018-01-08 18:52:35,209: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a113f90>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:52:35,237: 18:52:35 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 1.16s]
2018-01-08 18:52:35,238: 18:52:35 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-08 18:52:35,238: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-08 18:52:35,247: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-08 18:52:35,249: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:52:35,249: Re-using an available connection from the pool.
2018-01-08 18:52:35,249: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:52:35,249: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:52:35,271: SQL status: SELECT in 0.02 seconds
2018-01-08 18:52:35,272: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:52:35,272: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:52:35,293: SQL status: SELECT in 0.02 seconds
2018-01-08 18:52:35,295: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:52:35,295: On parsely_pageview_behavior_workflow: BEGIN
2018-01-08 18:52:35,297: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:52:35,297: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:52:35,297: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:56:13,019: SQL status: SELECT in 217.72 seconds
2018-01-08 18:56:13,019: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:56:13,019: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-08 18:56:13,408: SQL status: SELECT in 0.39 seconds
2018-01-08 18:56:13,409: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:56:13,409: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:56:13,533: SQL status: SELECT in 0.12 seconds
2018-01-08 18:56:13,534: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:56:13,534: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:56:13,657: SQL status: SELECT in 0.12 seconds
2018-01-08 18:56:13,661: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-08 18:56:13,662: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:56:13,662: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-08 18:56:17,354: SQL status: INSERT 0 112538 in 3.69 seconds
2018-01-08 18:56:17,355: On parsely_pageview_behavior_workflow: COMMIT
2018-01-08 18:56:17,355: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 18:56:17,355: On parsely_pageview_behavior_workflow: COMMIT
2018-01-08 18:56:18,884: SQL status: COMMIT in 1.53 seconds
2018-01-08 18:56:18,885: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a10ba10>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:56:18,941: 18:56:18 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 112538 in 223.65s]
2018-01-08 18:56:18,941: 18:56:18 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-08 18:56:18,942: Compiling model.parsely.parsely_sessions
2018-01-08 18:56:18,949: Acquiring new redshift connection "parsely_sessions".
2018-01-08 18:56:18,949: Re-using an available connection from the pool.
2018-01-08 18:56:18,949: Using redshift connection "parsely_sessions".
2018-01-08 18:56:18,949: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:56:18,972: SQL status: SELECT in 0.02 seconds
2018-01-08 18:56:18,975: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-08 18:56:18,977: Using redshift connection "parsely_sessions".
2018-01-08 18:56:18,977: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:56:18,999: SQL status: SELECT in 0.02 seconds
2018-01-08 18:56:19,000: Using redshift connection "parsely_sessions".
2018-01-08 18:56:19,000: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:56:19,022: SQL status: SELECT in 0.02 seconds
2018-01-08 18:56:19,025: Using redshift connection "parsely_sessions".
2018-01-08 18:56:19,025: On parsely_sessions: BEGIN
2018-01-08 18:56:19,027: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:56:19,027: Using redshift connection "parsely_sessions".
2018-01-08 18:56:19,027: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:57:02,114: SQL status: SELECT in 43.09 seconds
2018-01-08 18:57:02,114: Using redshift connection "parsely_sessions".
2018-01-08 18:57:02,114: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-08 18:57:02,451: SQL status: SELECT in 0.34 seconds
2018-01-08 18:57:02,451: Using redshift connection "parsely_sessions".
2018-01-08 18:57:02,451: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:57:02,576: SQL status: SELECT in 0.12 seconds
2018-01-08 18:57:02,576: Using redshift connection "parsely_sessions".
2018-01-08 18:57:02,576: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:57:02,699: SQL status: SELECT in 0.12 seconds
2018-01-08 18:57:02,702: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-08 18:57:02,703: Using redshift connection "parsely_sessions".
2018-01-08 18:57:02,703: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-08 18:57:04,423: SQL status: INSERT 0 91392 in 1.72 seconds
2018-01-08 18:57:04,424: On parsely_sessions: COMMIT
2018-01-08 18:57:04,424: Using redshift connection "parsely_sessions".
2018-01-08 18:57:04,424: On parsely_sessions: COMMIT
2018-01-08 18:57:05,812: SQL status: COMMIT in 1.39 seconds
2018-01-08 18:57:05,812: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a0ade10>], 'label': '556027b3-2202-4cc0-9a60-80abf6ab5415'}
2018-01-08 18:57:05,842: 18:57:05 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 91392 in 46.87s]
2018-01-08 18:57:05,879: Using redshift connection "master".
2018-01-08 18:57:05,879: On master: BEGIN
2018-01-08 18:57:05,882: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:57:05,882: On master: COMMIT
2018-01-08 18:57:05,882: Using redshift connection "master".
2018-01-08 18:57:05,882: On master: COMMIT
2018-01-08 18:57:05,884: SQL status: COMMIT in 0.00 seconds
2018-01-08 18:57:05,884: Compiling operation.parsely.parsely-on-run-end-0
2018-01-08 18:57:05,889: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-08 18:57:05,890: Using redshift connection "master".
2018-01-08 18:57:05,890: On master:  select 1 
2018-01-08 18:57:05,892: SQL status: SELECT in 0.00 seconds
2018-01-08 18:57:05,893: 18:57:05 | 
2018-01-08 18:57:05,893: 18:57:05 | Finished running 10 view models, 15 incremental models in 1714.76s.
2018-01-08 18:57:05,893: 
2018-01-08 18:57:05,894: Completed successfully
2018-01-08 18:57:05,894: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-08 18:57:05,894: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a15ee10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a15ef90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7f566a145950>], 'label': 'end'}
2018-01-08 18:57:05,923: Flushing usage events
2018-01-08 18:57:18,401: Tracking: tracking
2018-01-08 18:57:18,401: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d491e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d491f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d491ed0>], 'label': 'start'}
2018-01-08 18:57:18,463: Loading dependency project from /data/virtualenvs/parsely-raw-data/local/lib/python2.7/site-packages/dbt/include
2018-01-08 18:57:18,479: Loading dependency project from /home/annelise/parsely_raw_data/dbt/parsely_dpl/dbt_modules
2018-01-08 18:57:18,480: Parsing core.sql
2018-01-08 18:57:18,492: Parsing etc/get_custom_schema.sql
2018-01-08 18:57:18,497: Parsing schema_tests/relationships.sql
2018-01-08 18:57:18,499: Parsing schema_tests/accepted_values.sql
2018-01-08 18:57:18,502: Parsing schema_tests/not_null.sql
2018-01-08 18:57:18,504: Parsing schema_tests/unique.sql
2018-01-08 18:57:18,506: Parsing materializations/wrapper.sql
2018-01-08 18:57:18,509: Parsing materializations/archive.sql
2018-01-08 18:57:18,537: Parsing materializations/table.sql
2018-01-08 18:57:18,554: Parsing materializations/helpers.sql
2018-01-08 18:57:18,569: Parsing materializations/bigquery.sql
2018-01-08 18:57:18,581: Parsing materializations/view.sql
2018-01-08 18:57:18,595: Parsing materializations/incremental.sql
2018-01-08 18:57:18,620: Parsing adapters/redshift.sql
2018-01-08 18:57:18,637: Parsing adapters/bigquery.sql
2018-01-08 18:57:18,641: Parsing adapters/postgres.sql
2018-01-08 18:57:18,644: Parsing adapters/common.sql
2018-01-08 18:57:18,662: Parsing model.parsely.parsely_audit
2018-01-08 18:57:18,664: Parsing model.parsely.parsely_video_content
2018-01-08 18:57:18,667: Parsing model.parsely.parsely_post_content
2018-01-08 18:57:18,670: Parsing model.parsely.parsely_parent_videostart_keys
2018-01-08 18:57:18,672: Parsing model.parsely.parsely_rawdata
2018-01-08 18:57:18,675: Parsing model.parsely.calendar
2018-01-08 18:57:18,676: Parsing model.parsely.parsely_all_events
2018-01-08 18:57:18,685: Acquiring new redshift connection "parsely_all_events".
2018-01-08 18:57:18,685: Opening a new connection (0 currently allocated)
2018-01-08 18:57:18,698: Using redshift connection "parsely_all_events".
2018-01-08 18:57:18,698: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:18,724: SQL status: SELECT in 0.03 seconds
2018-01-08 18:57:18,730: Parsing model.parsely.parsely_event_ids
2018-01-08 18:57:18,732: Parsing model.parsely.parsely_parent_pageview_keys
2018-01-08 18:57:18,735: Parsing model.parsely.parsely_base_events
2018-01-08 18:57:18,738: Acquiring new redshift connection "parsely_base_events".
2018-01-08 18:57:18,738: Re-using an available connection from the pool.
2018-01-08 18:57:18,738: Using redshift connection "parsely_base_events".
2018-01-08 18:57:18,739: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:18,758: SQL status: SELECT in 0.02 seconds
2018-01-08 18:57:18,759: Parsing model.parsely.parsely_pageview_behavior_workflow
2018-01-08 18:57:18,765: Parsing model.parsely.parsely_pageview_engagedtime
2018-01-08 18:57:18,769: Parsing model.parsely.parsely_videoview_hanging_engagedtime
2018-01-08 18:57:18,771: Parsing model.parsely.parsely_pageview_hanging_engagedtime
2018-01-08 18:57:18,773: Parsing model.parsely.parsely_videoview_engagedtime
2018-01-08 18:57:18,776: Parsing model.parsely.parsely_videoview_behavior_workflow
2018-01-08 18:57:18,782: Parsing model.parsely.parsely_incoming_pageviews
2018-01-08 18:57:18,789: Parsing model.parsely.parsely_pageviews_sessionized
2018-01-08 18:57:18,794: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:57:18,794: Re-using an available connection from the pool.
2018-01-08 18:57:18,795: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 18:57:18,795: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:18,815: SQL status: SELECT in 0.02 seconds
2018-01-08 18:57:18,816: Parsing model.parsely.parsely_incoming_videoviews
2018-01-08 18:57:18,823: Parsing model.parsely.parsely_videoviews_sessionized
2018-01-08 18:57:18,828: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:57:18,828: Re-using an available connection from the pool.
2018-01-08 18:57:18,828: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 18:57:18,828: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:18,847: SQL status: SELECT in 0.02 seconds
2018-01-08 18:57:18,848: Parsing model.parsely.parsely_incoming_users
2018-01-08 18:57:18,851: Parsing model.parsely.parsely_users
2018-01-08 18:57:18,856: Acquiring new redshift connection "parsely_users".
2018-01-08 18:57:18,856: Re-using an available connection from the pool.
2018-01-08 18:57:18,856: Using redshift connection "parsely_users".
2018-01-08 18:57:18,856: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:18,875: SQL status: SELECT in 0.02 seconds
2018-01-08 18:57:18,876: Parsing model.parsely.parsely_errors
2018-01-08 18:57:18,880: Parsing model.parsely.parsely_bot_traffic
2018-01-08 18:57:18,884: Parsing model.parsely.parsely_custom_events
2018-01-08 18:57:18,889: Parsing model.parsely.parsely_incoming_sessions
2018-01-08 18:57:18,893: Parsing model.parsely.parsely_entry_exit_urls
2018-01-08 18:57:18,895: Parsing model.parsely.parsely_sessions
2018-01-08 18:57:18,901: Acquiring new redshift connection "parsely_sessions".
2018-01-08 18:57:18,901: Re-using an available connection from the pool.
2018-01-08 18:57:18,901: Using redshift connection "parsely_sessions".
2018-01-08 18:57:18,901: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:18,921: SQL status: SELECT in 0.02 seconds
2018-01-08 18:57:18,922: Parsing model.parsely.parsely_campaigns
2018-01-08 18:57:18,925: Acquiring new redshift connection "parsely_campaigns".
2018-01-08 18:57:18,926: Re-using an available connection from the pool.
2018-01-08 18:57:18,926: Using redshift connection "parsely_campaigns".
2018-01-08 18:57:18,926: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:18,944: SQL status: SELECT in 0.02 seconds
2018-01-08 18:57:18,950: Parsing operation.parsely.parsely-on-run-end-0
2018-01-08 18:57:18,955: Found 40 macros, 0 analyses, 0 archives, 0 tests, 29 models, 1 operations
2018-01-08 18:57:18,963: 
2018-01-08 18:57:18,966: Acquiring new redshift connection "master".
2018-01-08 18:57:18,966: Re-using an available connection from the pool.
2018-01-08 18:57:18,966: Using redshift connection "master".
2018-01-08 18:57:18,966: On master: select distinct nspname from pg_namespace
2018-01-08 18:57:18,968: SQL status: SELECT in 0.00 seconds
2018-01-08 18:57:18,971: Using redshift connection "master".
2018-01-08 18:57:18,971: On master: BEGIN
2018-01-08 18:57:18,972: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:57:18,972: On master: COMMIT
2018-01-08 18:57:18,972: Using redshift connection "master".
2018-01-08 18:57:18,972: On master: COMMIT
2018-01-08 18:57:18,974: SQL status: COMMIT in 0.00 seconds
2018-01-08 18:57:18,979: 18:57:18 | Concurrency: 1 threads (target='dev')
2018-01-08 18:57:18,980: 18:57:18 | 
2018-01-08 18:57:18,980: Using redshift connection "master".
2018-01-08 18:57:18,980: On master: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:18,999: SQL status: SELECT in 0.02 seconds
2018-01-08 18:57:19,072: 18:57:19 | 1 of 25 START view model blog_dbt_dev.calendar....................... [RUN]
2018-01-08 18:57:19,073: Compiling model.parsely.calendar
2018-01-08 18:57:19,077: Writing injected SQL for node "model.parsely.calendar"
2018-01-08 18:57:19,079: Acquiring new redshift connection "calendar".
2018-01-08 18:57:19,079: Opening a new connection (1 currently allocated)
2018-01-08 18:57:19,092: Using redshift connection "calendar".
2018-01-08 18:57:19,092: On calendar: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:19,117: SQL status: SELECT in 0.03 seconds
2018-01-08 18:57:19,119: Writing runtime SQL for node "model.parsely.calendar"
2018-01-08 18:57:19,120: Using redshift connection "calendar".
2018-01-08 18:57:19,120: On calendar: BEGIN
2018-01-08 18:57:19,122: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:57:19,122: Using redshift connection "calendar".
2018-01-08 18:57:19,122: On calendar: create view "blog_dbt_dev"."calendar__dbt_tmp" as (
    SELECT
    (DATE_PART('y', date_gen.dt)*10000+DATE_PART('mon', date_gen.dt)*100+DATE_PART('day', date_gen.dt))::int AS "id",
    date_gen.dt AS "date",
    DATE_PART('y', date_gen.dt)::smallint AS "year",
    DATE_PART('mon', date_gen.dt)::smallint AS "month",
    DATE_PART('day', date_gen.dt)::smallint AS "day",
    DATE_PART('qtr', date_gen.dt)::smallint AS "quarter",
    DATE_PART('w', date_gen.dt)::smallint AS "week",
    CASE DATE_PART('dow', date_gen.dt)
      WHEN 0 THEN 'Sunday'
      WHEN 1 THEN 'Monday'
      WHEN 2 THEN 'Tuesday'
      WHEN 3 THEN 'Wednesday'
      WHEN 4 THEN 'Thursday'
      WHEN 5 THEN 'Friday'
      WHEN 6 THEN 'Saturday'
      END::VARCHAR(9) AS "day_name",
    CASE DATE_PART('mon', date_gen.dt)::smallint
      WHEN 1 THEN 'January'
      WHEN 2 THEN 'February'
      WHEN 3 THEN 'March'
      WHEN 4 THEN 'April'
      WHEN 5 THEN 'May'
      WHEN 6 THEN 'June'
      WHEN 7 THEN 'July'
      WHEN 8 THEN 'August'
      WHEN 9 THEN 'September'
      WHEN 10 THEN 'October'
      WHEN 11 THEN 'November'
      WHEN 12 THEN 'December'
      END::VARCHAR(9) AS "month_name",
    CASE
      WHEN DATE_PART('dow', date_gen.dt)::smallint IN (0,6) THEN TRUE
      ELSE FALSE
      END::boolean AS "weekend_flag"
    FROM
    (SELECT
      ('2050-01-01' - n)::date AS dt FROM (SELECT row_number() over () AS n FROM stl_scan LIMIT 54787)) date_gen
  );
2018-01-08 18:57:19,712: SQL status: CREATE VIEW in 0.59 seconds
2018-01-08 18:57:19,712: On calendar: COMMIT
2018-01-08 18:57:19,712: Using redshift connection "calendar".
2018-01-08 18:57:19,713: On calendar: COMMIT
2018-01-08 18:57:20,314: SQL status: COMMIT in 0.60 seconds
2018-01-08 18:57:20,314: Using redshift connection "calendar".
2018-01-08 18:57:20,314: On calendar: BEGIN
2018-01-08 18:57:20,316: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:57:20,316: Using redshift connection "calendar".
2018-01-08 18:57:20,317: On calendar: drop view if exists "blog_dbt_dev"."calendar" cascade
2018-01-08 18:57:20,324: SQL status: DROP VIEW in 0.01 seconds
2018-01-08 18:57:20,324: On calendar: COMMIT
2018-01-08 18:57:20,324: Using redshift connection "calendar".
2018-01-08 18:57:20,324: On calendar: COMMIT
2018-01-08 18:57:20,622: SQL status: COMMIT in 0.30 seconds
2018-01-08 18:57:20,623: Using redshift connection "calendar".
2018-01-08 18:57:20,623: On calendar: BEGIN
2018-01-08 18:57:20,625: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:57:20,625: Using redshift connection "calendar".
2018-01-08 18:57:20,625: On calendar: alter table "blog_dbt_dev"."calendar__dbt_tmp" rename to "calendar"
2018-01-08 18:57:20,630: SQL status: ALTER TABLE in 0.01 seconds
2018-01-08 18:57:20,631: On calendar: COMMIT
2018-01-08 18:57:20,631: Using redshift connection "calendar".
2018-01-08 18:57:20,631: On calendar: COMMIT
2018-01-08 18:57:20,848: SQL status: COMMIT in 0.22 seconds
2018-01-08 18:57:20,848: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d37fbd0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 18:57:20,880: 18:57:20 | 1 of 25 OK created view model blog_dbt_dev.calendar.................. [CREATE VIEW in 1.78s]
2018-01-08 18:57:20,880: 18:57:20 | 2 of 25 START incremental model blog_dbt_dev.parsely_rawdata......... [RUN]
2018-01-08 18:57:20,881: Compiling model.parsely.parsely_rawdata
2018-01-08 18:57:20,886: Writing injected SQL for node "model.parsely.parsely_rawdata"
2018-01-08 18:57:20,887: Acquiring new redshift connection "parsely_rawdata".
2018-01-08 18:57:20,887: Re-using an available connection from the pool.
2018-01-08 18:57:20,888: Using redshift connection "parsely_rawdata".
2018-01-08 18:57:20,888: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:20,909: SQL status: SELECT in 0.02 seconds
2018-01-08 18:57:20,909: Using redshift connection "parsely_rawdata".
2018-01-08 18:57:20,909: On parsely_rawdata: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:57:20,928: SQL status: SELECT in 0.02 seconds
2018-01-08 18:57:20,929: Using redshift connection "parsely_rawdata".
2018-01-08 18:57:20,929: On parsely_rawdata: BEGIN
2018-01-08 18:57:20,931: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:57:20,931: Using redshift connection "parsely_rawdata".
2018-01-08 18:57:20,931: On parsely_rawdata: create temporary table "parsely_rawdata__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select
  *,
  CURRENT_TIMESTAMP as insert_timestamp
from parsely_blog_rawdata
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 18:57:51,027: SQL status: SELECT in 30.10 seconds
2018-01-08 18:57:51,028: Using redshift connection "parsely_rawdata".
2018-01-08 18:57:51,028: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata__dbt_incremental_tmp'
2018-01-08 18:57:51,199: SQL status: SELECT in 0.17 seconds
2018-01-08 18:57:51,200: Using redshift connection "parsely_rawdata".
2018-01-08 18:57:51,200: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:57:51,323: SQL status: SELECT in 0.12 seconds
2018-01-08 18:57:51,324: Using redshift connection "parsely_rawdata".
2018-01-08 18:57:51,324: On parsely_rawdata: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_rawdata' AND table_schema = 'blog_dbt_dev'
2018-01-08 18:57:51,446: SQL status: SELECT in 0.12 seconds
2018-01-08 18:57:51,449: Writing runtime SQL for node "model.parsely.parsely_rawdata"
2018-01-08 18:57:51,450: Using redshift connection "parsely_rawdata".
2018-01-08 18:57:51,450: On parsely_rawdata: 
       

       delete
  from "blog_dbt_dev"."parsely_rawdata"
  where (event_id) in (
    select (event_id)
    from "parsely_rawdata__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_rawdata" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_rawdata__dbt_incremental_tmp"
       );
     
2018-01-08 18:58:26,981: SQL status: INSERT 0 1066550 in 35.53 seconds
2018-01-08 18:58:26,982: On parsely_rawdata: COMMIT
2018-01-08 18:58:26,982: Using redshift connection "parsely_rawdata".
2018-01-08 18:58:26,982: On parsely_rawdata: COMMIT
2018-01-08 18:58:29,689: SQL status: COMMIT in 2.71 seconds
2018-01-08 18:58:29,690: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3e9b10>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 18:58:29,784: 18:58:29 | 2 of 25 OK created incremental model blog_dbt_dev.parsely_rawdata.... [INSERT 0 1066550 in 68.81s]
2018-01-08 18:58:29,785: 18:58:29 | 3 of 25 START incremental model blog_dbt_dev.parsely_all_events...... [RUN]
2018-01-08 18:58:29,785: Compiling model.parsely.parsely_all_events
2018-01-08 18:58:29,793: Acquiring new redshift connection "parsely_all_events".
2018-01-08 18:58:29,793: Re-using an available connection from the pool.
2018-01-08 18:58:29,793: Using redshift connection "parsely_all_events".
2018-01-08 18:58:29,793: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:58:29,814: SQL status: SELECT in 0.02 seconds
2018-01-08 18:58:29,824: Writing injected SQL for node "model.parsely.parsely_all_events"
2018-01-08 18:58:29,825: Using redshift connection "parsely_all_events".
2018-01-08 18:58:29,825: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:58:29,847: SQL status: SELECT in 0.02 seconds
2018-01-08 18:58:29,847: Using redshift connection "parsely_all_events".
2018-01-08 18:58:29,847: On parsely_all_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 18:58:29,867: SQL status: SELECT in 0.02 seconds
2018-01-08 18:58:29,870: Using redshift connection "parsely_all_events".
2018-01-08 18:58:29,870: On parsely_all_events: BEGIN
2018-01-08 18:58:29,872: SQL status: BEGIN in 0.00 seconds
2018-01-08 18:58:29,872: Using redshift connection "parsely_all_events".
2018-01-08 18:58:29,872: On parsely_all_events: create temporary table "parsely_all_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with new_events as (

    select *
    from "blog_dbt_dev"."parsely_rawdata"

    
    where insert_timestamp > (
        select coalesce(max(t.insert_timestamp), '0001-01-01') from "blog_dbt_dev"."parsely_all_events" as t
    )
    

),

timezone_convert as (
    SELECT
        *,
--      ts_action
        convert_timezone('America/New_York', ts_action) as ts_action_tz,
--      ts_session_current
        convert_timezone('America/New_York', ts_session_current) as ts_session_current_tz,
--      ts_session_last
        convert_timezone('America/New_York', ts_session_last) as ts_session_last_tz,
--      metadata_pub_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_pub_date_tmsp_tz,
--      metadata_save_date_tmsp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(metadata_save_date_tmsp,10)::bigint
          * INTERVAL '1 Second ')) as metadata_save_date_tmsp_tz,
--      timestamp_info_nginx_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_nginx_ms_tz,
--      session_last_session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_last_session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_last_session_timestamp_tz,
--      session_timestamp
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(session_timestamp,10)::bigint
          * INTERVAL '1 Second ')) as session_timestamp_tz,
--      timestamp_info_pixel_ms
        convert_timezone('America/New_York', (TIMESTAMP 'epoch'
          + left(timestamp_info_pixel_ms,10)::bigint
          * INTERVAL '1 Second ')) as timestamp_info_pixel_ms_tz
    from new_events
),


dedupe as (
  select
      *,
  --  event action dates and times
      DATE_PART('day',ts_action_tz) as day,
      DATE_PART('quarter',ts_action_tz) as quarter,
      DATE_PART('month',ts_action_tz) as month,
      DATE_PART('year',ts_action_tz) as year,
      DATE_PART('week',ts_action_tz) as week,
      (DATE_PART('y', ts_action_tz)*10000+DATE_PART('mon', ts_action_tz)*100+DATE_PART('day', ts_action_tz))::int AS date_id,
      (DATE_PART('y', ts_session_current_tz)*10000+DATE_PART('mon', ts_session_current_tz)*100+DATE_PART('day', ts_session_current_tz))::int AS session_date_id,
  --  transformed fields
      coalesce(metadata_canonical_url,url) as pageview_post_id,
      json_extract_path_text(
          extra_data,
          '_customer_apikey')     as customer_apikey,
      case when referrer = 'http://facebook.com/instantarticles'
        then true else false end as flag_is_fbia,
  --  dedupe field as we can receive duplicate event_ids that can be excluded
      row_number() over (partition by event_id order by ts_action) as n,
  --  counter fields
      case when action = 'pageview' then 1 else 0 end as pageview_counter,
      case when action = 'videostart' then 1 else 0 end as videostart_counter,
  --  hash identifier fields
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(url,'') || '_' ||
        coalesce(metadata_canonical_url,'') || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as videostart_key,
     md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(metadata_canonical_url,url) || '_' ||
        coalesce(referrer,'') || '_' ||
        coalesce(ts_session_current::text,''))         as pageview_key,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(utm_campaign,'') || '_' ||
        coalesce(utm_medium,'') || '_' ||
        coalesce(utm_source ,'') || '_' ||
        coalesce(utm_term,'') || '_' ||
        coalesce(utm_content,'') )               as utm_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(session_id::text,'') || '_' ||
        coalesce(visitor_site_id,'') || '_' ||
        coalesce(session_timestamp::text,''))            as parsely_session_id,
      md5(
        coalesce(apikey,'') || '_' ||
        coalesce(visitor_site_id,''))           as apikey_visitor_id
  from timezone_convert
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:00:21,341: SQL status: SELECT in 111.47 seconds
2018-01-08 19:00:21,341: Using redshift connection "parsely_all_events".
2018-01-08 19:00:21,341: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events__dbt_incremental_tmp'
2018-01-08 19:00:21,520: SQL status: SELECT in 0.18 seconds
2018-01-08 19:00:21,521: Using redshift connection "parsely_all_events".
2018-01-08 19:00:21,521: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:00:21,645: SQL status: SELECT in 0.12 seconds
2018-01-08 19:00:21,649: Using redshift connection "parsely_all_events".
2018-01-08 19:00:21,649: On parsely_all_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_all_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:00:21,775: SQL status: SELECT in 0.13 seconds
2018-01-08 19:00:21,781: Writing runtime SQL for node "model.parsely.parsely_all_events"
2018-01-08 19:00:21,783: Using redshift connection "parsely_all_events".
2018-01-08 19:00:21,783: On parsely_all_events: 
       

       delete
  from "blog_dbt_dev"."parsely_all_events"
  where (event_id) in (
    select (event_id)
    from "parsely_all_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_all_events" ("flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp")
       (
         select "flag_is_fbia", "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "n", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "videostart_counter", "pageview_counter", "session_date_id", "date_id", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "week", "year", "month", "quarter", "day", "ip_lon", "ip_lat", "apikey_visitor_id", "parsely_session_id", "utm_id", "pageview_key", "videostart_key", "customer_apikey", "pageview_post_id", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "ts_session_last", "ts_session_current", "ts_action", "insert_timestamp"
         from "parsely_all_events__dbt_incremental_tmp"
       );
     
2018-01-08 19:00:40,281: SQL status: INSERT 0 946381 in 18.49 seconds
2018-01-08 19:00:40,282: On parsely_all_events: COMMIT
2018-01-08 19:00:40,282: Using redshift connection "parsely_all_events".
2018-01-08 19:00:40,282: On parsely_all_events: COMMIT
2018-01-08 19:00:42,758: SQL status: COMMIT in 2.48 seconds
2018-01-08 19:00:42,758: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d43e810>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:00:42,832: 19:00:42 | 3 of 25 OK created incremental model blog_dbt_dev.parsely_all_events. [INSERT 0 946381 in 132.97s]
2018-01-08 19:00:42,839: 19:00:42 | 4 of 25 START incremental model blog_dbt_dev.parsely_bot_traffic..... [RUN]
2018-01-08 19:00:42,839: Compiling model.parsely.parsely_bot_traffic
2018-01-08 19:00:42,860: Writing injected SQL for node "model.parsely.parsely_bot_traffic"
2018-01-08 19:00:42,862: Acquiring new redshift connection "parsely_bot_traffic".
2018-01-08 19:00:42,862: Re-using an available connection from the pool.
2018-01-08 19:00:42,862: Using redshift connection "parsely_bot_traffic".
2018-01-08 19:00:42,863: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:00:42,892: SQL status: SELECT in 0.03 seconds
2018-01-08 19:00:42,893: Using redshift connection "parsely_bot_traffic".
2018-01-08 19:00:42,893: On parsely_bot_traffic: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:00:42,914: SQL status: SELECT in 0.02 seconds
2018-01-08 19:00:42,917: Using redshift connection "parsely_bot_traffic".
2018-01-08 19:00:42,917: On parsely_bot_traffic: BEGIN
2018-01-08 19:00:42,923: SQL status: BEGIN in 0.01 seconds
2018-01-08 19:00:42,923: Using redshift connection "parsely_bot_traffic".
2018-01-08 19:00:42,923: On parsely_bot_traffic: create temporary table "parsely_bot_traffic__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          --
-- 1 row per null action event



with bot_traffic as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where ua_browser = 'Googlebot' --to be updated to flag_is_bot_traffic

)


select

    -- metrics and counter fields
    1 as bot_traffic_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from bot_traffic
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:02:20,963: SQL status: SELECT in 98.04 seconds
2018-01-08 19:02:20,963: Using redshift connection "parsely_bot_traffic".
2018-01-08 19:02:20,963: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic__dbt_incremental_tmp'
2018-01-08 19:02:21,120: SQL status: SELECT in 0.16 seconds
2018-01-08 19:02:21,121: Using redshift connection "parsely_bot_traffic".
2018-01-08 19:02:21,121: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:02:21,245: SQL status: SELECT in 0.12 seconds
2018-01-08 19:02:21,247: Using redshift connection "parsely_bot_traffic".
2018-01-08 19:02:21,247: On parsely_bot_traffic: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_bot_traffic' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:02:21,371: SQL status: SELECT in 0.12 seconds
2018-01-08 19:02:21,377: Writing runtime SQL for node "model.parsely.parsely_bot_traffic"
2018-01-08 19:02:21,378: Using redshift connection "parsely_bot_traffic".
2018-01-08 19:02:21,378: On parsely_bot_traffic: 
       

       delete
  from "blog_dbt_dev"."parsely_bot_traffic"
  where (event_id) in (
    select (event_id)
    from "parsely_bot_traffic__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_bot_traffic" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "bot_traffic_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_bot_traffic__dbt_incremental_tmp"
       );
     
2018-01-08 19:02:22,450: SQL status: INSERT 0 4 in 1.07 seconds
2018-01-08 19:02:22,450: On parsely_bot_traffic: COMMIT
2018-01-08 19:02:22,450: Using redshift connection "parsely_bot_traffic".
2018-01-08 19:02:22,451: On parsely_bot_traffic: COMMIT
2018-01-08 19:02:23,440: SQL status: COMMIT in 0.99 seconds
2018-01-08 19:02:23,440: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d37fc90>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:02:23,512: 19:02:23 | 4 of 25 OK created incremental model blog_dbt_dev.parsely_bot_traffic [INSERT 0 4 in 100.60s]
2018-01-08 19:02:23,512: 19:02:23 | 5 of 25 START incremental model blog_dbt_dev.parsely_custom_events... [RUN]
2018-01-08 19:02:23,513: Compiling model.parsely.parsely_custom_events
2018-01-08 19:02:23,551: Writing injected SQL for node "model.parsely.parsely_custom_events"
2018-01-08 19:02:23,554: Acquiring new redshift connection "parsely_custom_events".
2018-01-08 19:02:23,554: Re-using an available connection from the pool.
2018-01-08 19:02:23,554: Using redshift connection "parsely_custom_events".
2018-01-08 19:02:23,554: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:02:23,577: SQL status: SELECT in 0.02 seconds
2018-01-08 19:02:23,578: Using redshift connection "parsely_custom_events".
2018-01-08 19:02:23,578: On parsely_custom_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:02:23,600: SQL status: SELECT in 0.02 seconds
2018-01-08 19:02:23,603: Using redshift connection "parsely_custom_events".
2018-01-08 19:02:23,603: On parsely_custom_events: BEGIN
2018-01-08 19:02:23,605: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:02:23,605: Using redshift connection "parsely_custom_events".
2018-01-08 19:02:23,605: On parsely_custom_events: create temporary table "parsely_custom_events__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per custom event

-- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with custom_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action not in ('pageview','heartbeat','videostart','vheartbeat') and action is not null

),

-- derived fields
custom_publish_read_time_xf as (
    select
        event_id,
        (TIMESTAMP 'epoch'
          + left(metadata_pub_date_tmsp_tz,10)::bigint
          * INTERVAL '1 Second ') as publish_time,
        (TIMESTAMP 'epoch'
          + left(timestamp_info_nginx_ms_tz,10)::bigint
          * INTERVAL '1 Second ') as event_time

    from custom_events

)


select

    -- metrics and counter fields
    1 as custom_event_counter,
    -- derived fields
    datediff(hour, publish_time, event_time) as hours_since_publish,
    datediff(day, publish_time, event_time) as days_since_publish,
    datediff(week, publish_time, event_time) as weeks_since_publish,
    publish_time,
    event_time,
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from custom_events
  left join custom_publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:04:02,615: SQL status: SELECT in 99.01 seconds
2018-01-08 19:04:02,616: Using redshift connection "parsely_custom_events".
2018-01-08 19:04:02,616: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events__dbt_incremental_tmp'
2018-01-08 19:04:02,770: SQL status: SELECT in 0.15 seconds
2018-01-08 19:04:02,771: Using redshift connection "parsely_custom_events".
2018-01-08 19:04:02,771: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:04:02,896: SQL status: SELECT in 0.12 seconds
2018-01-08 19:04:02,897: Using redshift connection "parsely_custom_events".
2018-01-08 19:04:02,897: On parsely_custom_events: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_custom_events' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:04:03,024: SQL status: SELECT in 0.13 seconds
2018-01-08 19:04:03,030: Writing runtime SQL for node "model.parsely.parsely_custom_events"
2018-01-08 19:04:03,039: Using redshift connection "parsely_custom_events".
2018-01-08 19:04:03,039: On parsely_custom_events: 
       

       delete
  from "blog_dbt_dev"."parsely_custom_events"
  where (event_id) in (
    select (event_id)
    from "parsely_custom_events__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_custom_events" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "custom_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz", "event_time", "publish_time"
         from "parsely_custom_events__dbt_incremental_tmp"
       );
     
2018-01-08 19:04:03,303: SQL status: INSERT 0 0 in 0.26 seconds
2018-01-08 19:04:03,304: On parsely_custom_events: COMMIT
2018-01-08 19:04:03,304: Using redshift connection "parsely_custom_events".
2018-01-08 19:04:03,304: On parsely_custom_events: COMMIT
2018-01-08 19:04:03,647: SQL status: COMMIT in 0.34 seconds
2018-01-08 19:04:03,648: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d37fc90>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:04:03,707: 19:04:03 | 5 of 25 OK created incremental model blog_dbt_dev.parsely_custom_events [INSERT 0 0 in 100.14s]
2018-01-08 19:04:03,711: 19:04:03 | 6 of 25 START incremental model blog_dbt_dev.parsely_errors.......... [RUN]
2018-01-08 19:04:03,711: Compiling model.parsely.parsely_errors
2018-01-08 19:04:03,740: Writing injected SQL for node "model.parsely.parsely_errors"
2018-01-08 19:04:03,742: Acquiring new redshift connection "parsely_errors".
2018-01-08 19:04:03,742: Re-using an available connection from the pool.
2018-01-08 19:04:03,742: Using redshift connection "parsely_errors".
2018-01-08 19:04:03,742: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:04:03,765: SQL status: SELECT in 0.02 seconds
2018-01-08 19:04:03,766: Using redshift connection "parsely_errors".
2018-01-08 19:04:03,766: On parsely_errors: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:04:03,788: SQL status: SELECT in 0.02 seconds
2018-01-08 19:04:03,790: Using redshift connection "parsely_errors".
2018-01-08 19:04:03,791: On parsely_errors: BEGIN
2018-01-08 19:04:03,793: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:04:03,793: Using redshift connection "parsely_errors".
2018-01-08 19:04:03,793: On parsely_errors: create temporary table "parsely_errors__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per null action event



with error_events as (

    select * from "blog_dbt_dev"."parsely_all_events"
    where action is null

)


select

    -- metrics and counter fields
    1 as error_event_counter,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_action_tz,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    timestamp_info_nginx_ms_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    timestamp_info_pixel_ms_tz,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    engaged_time_inc,
    event_id,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from error_events
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:05:40,874: SQL status: SELECT in 97.08 seconds
2018-01-08 19:05:40,874: Using redshift connection "parsely_errors".
2018-01-08 19:05:40,874: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors__dbt_incremental_tmp'
2018-01-08 19:05:41,164: SQL status: SELECT in 0.29 seconds
2018-01-08 19:05:41,164: Using redshift connection "parsely_errors".
2018-01-08 19:05:41,169: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:05:41,297: SQL status: SELECT in 0.13 seconds
2018-01-08 19:05:41,299: Using redshift connection "parsely_errors".
2018-01-08 19:05:41,299: On parsely_errors: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_errors' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:05:41,429: SQL status: SELECT in 0.13 seconds
2018-01-08 19:05:41,438: Writing runtime SQL for node "model.parsely.parsely_errors"
2018-01-08 19:05:41,439: Using redshift connection "parsely_errors".
2018-01-08 19:05:41,439: On parsely_errors: 
       

       delete
  from "blog_dbt_dev"."parsely_errors"
  where (event_id) in (
    select (event_id)
    from "parsely_errors__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_errors" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "engaged_time_inc", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "error_event_counter", "ip_lon", "ip_lat", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "ts_action", "timestamp_info_pixel_ms_tz", "session_timestamp_tz", "session_last_session_timestamp_tz", "timestamp_info_nginx_ms_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "ts_action_tz"
         from "parsely_errors__dbt_incremental_tmp"
       );
     
2018-01-08 19:05:42,263: SQL status: INSERT 0 2 in 0.82 seconds
2018-01-08 19:05:42,263: On parsely_errors: COMMIT
2018-01-08 19:05:42,263: Using redshift connection "parsely_errors".
2018-01-08 19:05:42,264: On parsely_errors: COMMIT
2018-01-08 19:05:43,173: SQL status: COMMIT in 0.91 seconds
2018-01-08 19:05:43,174: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d375a90>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:05:43,301: 19:05:43 | 6 of 25 OK created incremental model blog_dbt_dev.parsely_errors..... [INSERT 0 2 in 99.46s]
2018-01-08 19:05:43,311: 19:05:43 | 7 of 25 START view model blog_dbt_dev.parsely_base_events............ [RUN]
2018-01-08 19:05:43,311: Compiling model.parsely.parsely_base_events
2018-01-08 19:05:43,318: Acquiring new redshift connection "parsely_base_events".
2018-01-08 19:05:43,318: Re-using an available connection from the pool.
2018-01-08 19:05:43,319: Using redshift connection "parsely_base_events".
2018-01-08 19:05:43,319: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:05:43,353: SQL status: SELECT in 0.02 seconds
2018-01-08 19:05:43,367: Writing injected SQL for node "model.parsely.parsely_base_events"
2018-01-08 19:05:43,369: Using redshift connection "parsely_base_events".
2018-01-08 19:05:43,369: On parsely_base_events: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:05:43,391: SQL status: SELECT in 0.02 seconds
2018-01-08 19:05:43,394: Writing runtime SQL for node "model.parsely.parsely_base_events"
2018-01-08 19:05:43,395: Using redshift connection "parsely_base_events".
2018-01-08 19:05:43,395: On parsely_base_events: BEGIN
2018-01-08 19:05:43,403: SQL status: BEGIN in 0.01 seconds
2018-01-08 19:05:43,403: Using redshift connection "parsely_base_events".
2018-01-08 19:05:43,403: On parsely_base_events: create view "blog_dbt_dev"."parsely_base_events__dbt_tmp" as (
    
  select
      *
  from "blog_dbt_dev"."parsely_all_events"
  where action in ('pageview','heartbeat','videostart','vheartbeat')
--  and event_id not in
--    (select event_id from "blog_dbt_dev"."parsely_event_ids")
  and ua_browser <> 'Googlebot'
  --add in logic for custom:excludebottraffic== 'Yes'

  );
2018-01-08 19:05:43,926: SQL status: CREATE VIEW in 0.52 seconds
2018-01-08 19:05:43,927: On parsely_base_events: COMMIT
2018-01-08 19:05:43,927: Using redshift connection "parsely_base_events".
2018-01-08 19:05:43,928: On parsely_base_events: COMMIT
2018-01-08 19:05:44,132: SQL status: COMMIT in 0.20 seconds
2018-01-08 19:05:44,132: Using redshift connection "parsely_base_events".
2018-01-08 19:05:44,132: On parsely_base_events: BEGIN
2018-01-08 19:05:44,134: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:05:44,134: Using redshift connection "parsely_base_events".
2018-01-08 19:05:44,135: On parsely_base_events: drop view if exists "blog_dbt_dev"."parsely_base_events" cascade
2018-01-08 19:05:45,776: SQL status: DROP VIEW in 1.64 seconds
2018-01-08 19:05:45,777: On parsely_base_events: COMMIT
2018-01-08 19:05:45,777: Using redshift connection "parsely_base_events".
2018-01-08 19:05:45,777: On parsely_base_events: COMMIT
2018-01-08 19:05:46,015: SQL status: COMMIT in 0.24 seconds
2018-01-08 19:05:46,015: Using redshift connection "parsely_base_events".
2018-01-08 19:05:46,015: On parsely_base_events: BEGIN
2018-01-08 19:05:46,018: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:05:46,018: Using redshift connection "parsely_base_events".
2018-01-08 19:05:46,018: On parsely_base_events: alter table "blog_dbt_dev"."parsely_base_events__dbt_tmp" rename to "parsely_base_events"
2018-01-08 19:05:46,023: SQL status: ALTER TABLE in 0.01 seconds
2018-01-08 19:05:46,023: On parsely_base_events: COMMIT
2018-01-08 19:05:46,024: Using redshift connection "parsely_base_events".
2018-01-08 19:05:46,024: On parsely_base_events: COMMIT
2018-01-08 19:05:46,357: SQL status: COMMIT in 0.33 seconds
2018-01-08 19:05:46,357: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3e9810>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:05:46,414: 19:05:46 | 7 of 25 OK created view model blog_dbt_dev.parsely_base_events....... [CREATE VIEW in 3.05s]
2018-01-08 19:05:46,415: 19:05:46 | 8 of 25 START incremental model blog_dbt_dev.parsely_event_ids....... [RUN]
2018-01-08 19:05:46,415: Compiling model.parsely.parsely_event_ids
2018-01-08 19:05:46,432: Writing injected SQL for node "model.parsely.parsely_event_ids"
2018-01-08 19:05:46,435: Acquiring new redshift connection "parsely_event_ids".
2018-01-08 19:05:46,435: Re-using an available connection from the pool.
2018-01-08 19:05:46,435: Using redshift connection "parsely_event_ids".
2018-01-08 19:05:46,436: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:05:46,458: SQL status: SELECT in 0.02 seconds
2018-01-08 19:05:46,458: Using redshift connection "parsely_event_ids".
2018-01-08 19:05:46,459: On parsely_event_ids: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:05:46,480: SQL status: SELECT in 0.02 seconds
2018-01-08 19:05:46,482: Using redshift connection "parsely_event_ids".
2018-01-08 19:05:46,482: On parsely_event_ids: BEGIN
2018-01-08 19:05:46,484: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:05:46,484: Using redshift connection "parsely_event_ids".
2018-01-08 19:05:46,484: On parsely_event_ids: create temporary table "parsely_event_ids__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

-- created to track event_ids for duplicate event_ids that do not need to be processed twice
-- how often should this truncate?
select distinct
  event_id
from "blog_dbt_dev"."parsely_base_events"
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:05:49,062: SQL status: SELECT in 2.58 seconds
2018-01-08 19:05:49,063: Using redshift connection "parsely_event_ids".
2018-01-08 19:05:49,063: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids__dbt_incremental_tmp'
2018-01-08 19:05:49,419: SQL status: SELECT in 0.36 seconds
2018-01-08 19:05:49,420: Using redshift connection "parsely_event_ids".
2018-01-08 19:05:49,420: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:05:49,543: SQL status: SELECT in 0.12 seconds
2018-01-08 19:05:49,544: Using redshift connection "parsely_event_ids".
2018-01-08 19:05:49,544: On parsely_event_ids: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_event_ids' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:05:49,668: SQL status: SELECT in 0.12 seconds
2018-01-08 19:05:49,670: Writing runtime SQL for node "model.parsely.parsely_event_ids"
2018-01-08 19:05:49,671: Using redshift connection "parsely_event_ids".
2018-01-08 19:05:49,671: On parsely_event_ids: 
       

       delete
  from "blog_dbt_dev"."parsely_event_ids"
  where (event_id) in (
    select (event_id)
    from "parsely_event_ids__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_event_ids" ("event_id")
       (
         select "event_id"
         from "parsely_event_ids__dbt_incremental_tmp"
       );
     
2018-01-08 19:05:52,165: SQL status: INSERT 0 946377 in 2.49 seconds
2018-01-08 19:05:52,166: On parsely_event_ids: COMMIT
2018-01-08 19:05:52,166: Using redshift connection "parsely_event_ids".
2018-01-08 19:05:52,166: On parsely_event_ids: COMMIT
2018-01-08 19:05:52,896: SQL status: COMMIT in 0.73 seconds
2018-01-08 19:05:52,897: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3a8990>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:05:52,952: 19:05:52 | 8 of 25 OK created incremental model blog_dbt_dev.parsely_event_ids.. [INSERT 0 946377 in 6.48s]
2018-01-08 19:05:52,959: Compiling model.parsely.parsely_parent_pageview_keys
2018-01-08 19:05:52,981: Writing injected SQL for node "model.parsely.parsely_parent_pageview_keys"
2018-01-08 19:05:52,984: 19:05:52 | 9 of 25 START incremental model blog_dbt_dev.parsely_post_content.... [RUN]
2018-01-08 19:05:52,984: Compiling model.parsely.parsely_post_content
2018-01-08 19:05:53,010: Writing injected SQL for node "model.parsely.parsely_post_content"
2018-01-08 19:05:53,012: Acquiring new redshift connection "parsely_post_content".
2018-01-08 19:05:53,012: Re-using an available connection from the pool.
2018-01-08 19:05:53,013: Using redshift connection "parsely_post_content".
2018-01-08 19:05:53,013: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:05:53,036: SQL status: SELECT in 0.02 seconds
2018-01-08 19:05:53,037: Using redshift connection "parsely_post_content".
2018-01-08 19:05:53,037: On parsely_post_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:05:53,061: SQL status: SELECT in 0.02 seconds
2018-01-08 19:05:53,063: Using redshift connection "parsely_post_content".
2018-01-08 19:05:53,063: On parsely_post_content: BEGIN
2018-01-08 19:05:53,146: SQL status: BEGIN in 0.08 seconds
2018-01-08 19:05:53,146: Using redshift connection "parsely_post_content".
2018-01-08 19:05:53,147: On parsely_post_content: create temporary table "parsely_post_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_posts as (
  select
    pageview_post_id,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by pageview_post_id
),

dedupe as (
  select
    pageview_post_id,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    case
     when metadata_full_content_word_count >= 4000 then '4,000 or Above'
     when metadata_full_content_word_count >= 3000 then '3,000 - 3,999'
     when metadata_full_content_word_count >= 2000 then '2,000 - 2,999'
     when metadata_full_content_word_count >= 1000 then '1,000 - 1,999'
     when metadata_full_content_word_count >= 500 then '500 - 999'
     when metadata_full_content_word_count >= 100 then '100 - 499'
     else '< 100' end as word_count_buckets,
    row_number() over (partition by pageview_post_id order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_posts using (pageview_post_id, ts_action)
)

select
  *
from dedupe
where n=1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:06:14,231: SQL status: SELECT in 21.08 seconds
2018-01-08 19:06:14,232: Using redshift connection "parsely_post_content".
2018-01-08 19:06:14,232: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content__dbt_incremental_tmp'
2018-01-08 19:06:14,490: SQL status: SELECT in 0.26 seconds
2018-01-08 19:06:14,491: Using redshift connection "parsely_post_content".
2018-01-08 19:06:14,491: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:06:14,614: SQL status: SELECT in 0.12 seconds
2018-01-08 19:06:14,616: Using redshift connection "parsely_post_content".
2018-01-08 19:06:14,616: On parsely_post_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_post_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:06:14,739: SQL status: SELECT in 0.12 seconds
2018-01-08 19:06:14,742: Writing runtime SQL for node "model.parsely.parsely_post_content"
2018-01-08 19:06:14,744: Using redshift connection "parsely_post_content".
2018-01-08 19:06:14,744: On parsely_post_content: 
       

       delete
  from "blog_dbt_dev"."parsely_post_content"
  where (pageview_post_id) in (
    select (pageview_post_id)
    from "parsely_post_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_post_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "word_count_buckets", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "pageview_post_id", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_post_content__dbt_incremental_tmp"
       );
     
2018-01-08 19:06:15,138: SQL status: INSERT 0 896 in 0.39 seconds
2018-01-08 19:06:15,138: On parsely_post_content: COMMIT
2018-01-08 19:06:15,138: Using redshift connection "parsely_post_content".
2018-01-08 19:06:15,139: On parsely_post_content: COMMIT
2018-01-08 19:06:15,966: SQL status: COMMIT in 0.83 seconds
2018-01-08 19:06:15,967: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3e0ed0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:06:16,019: 19:06:16 | 9 of 25 OK created incremental model blog_dbt_dev.parsely_post_content [INSERT 0 896 in 22.98s]
2018-01-08 19:06:16,023: 19:06:16 | 10 of 25 START incremental model blog_dbt_dev.parsely_video_content.. [RUN]
2018-01-08 19:06:16,023: Compiling model.parsely.parsely_video_content
2018-01-08 19:06:16,044: Writing injected SQL for node "model.parsely.parsely_video_content"
2018-01-08 19:06:16,046: Acquiring new redshift connection "parsely_video_content".
2018-01-08 19:06:16,046: Re-using an available connection from the pool.
2018-01-08 19:06:16,046: Using redshift connection "parsely_video_content".
2018-01-08 19:06:16,047: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:06:16,081: SQL status: SELECT in 0.03 seconds
2018-01-08 19:06:16,082: Using redshift connection "parsely_video_content".
2018-01-08 19:06:16,082: On parsely_video_content: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:06:16,104: SQL status: SELECT in 0.02 seconds
2018-01-08 19:06:16,106: Using redshift connection "parsely_video_content".
2018-01-08 19:06:16,106: On parsely_video_content: BEGIN
2018-01-08 19:06:16,108: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:06:16,108: Using redshift connection "parsely_video_content".
2018-01-08 19:06:16,108: On parsely_video_content: create temporary table "parsely_video_content__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per content with most recent metdata



with most_recent_incoming_videos as (
  select
    metadata_canonical_url,
    max(ts_action) as ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by metadata_canonical_url
),

dedupe as (
  select
    metadata_canonical_url,
    metadata,
    metadata_authors,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    url,
    row_number() over (partition by metadata_canonical_url order by ts_action) as n
  from "blog_dbt_dev"."parsely_base_events"
  inner join most_recent_incoming_videos using (metadata_canonical_url, ts_action)
)

select
  *
from dedupe
where n  = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:06:34,388: SQL status: SELECT in 18.28 seconds
2018-01-08 19:06:34,389: Using redshift connection "parsely_video_content".
2018-01-08 19:06:34,389: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content__dbt_incremental_tmp'
2018-01-08 19:06:34,558: SQL status: SELECT in 0.17 seconds
2018-01-08 19:06:34,558: Using redshift connection "parsely_video_content".
2018-01-08 19:06:34,559: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:06:34,682: SQL status: SELECT in 0.12 seconds
2018-01-08 19:06:34,682: Using redshift connection "parsely_video_content".
2018-01-08 19:06:34,683: On parsely_video_content: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_video_content' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:06:34,805: SQL status: SELECT in 0.12 seconds
2018-01-08 19:06:34,808: Writing runtime SQL for node "model.parsely.parsely_video_content"
2018-01-08 19:06:34,809: Using redshift connection "parsely_video_content".
2018-01-08 19:06:34,809: On parsely_video_content: 
       

       delete
  from "blog_dbt_dev"."parsely_video_content"
  where (metadata_canonical_url) in (
    select (metadata_canonical_url)
    from "parsely_video_content__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_video_content" ("metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz")
       (
         select "metadata", "n", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "metadata_full_content_word_count", "metadata_duration", "url", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_authors", "metadata_canonical_url", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz"
         from "parsely_video_content__dbt_incremental_tmp"
       );
     
2018-01-08 19:06:35,155: SQL status: INSERT 0 470 in 0.35 seconds
2018-01-08 19:06:35,155: On parsely_video_content: COMMIT
2018-01-08 19:06:35,155: Using redshift connection "parsely_video_content".
2018-01-08 19:06:35,156: On parsely_video_content: COMMIT
2018-01-08 19:06:36,356: SQL status: COMMIT in 1.20 seconds
2018-01-08 19:06:36,357: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3e0e10>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:06:36,403: 19:06:36 | 10 of 25 OK created incremental model blog_dbt_dev.parsely_video_content [INSERT 0 470 in 20.33s]
2018-01-08 19:06:36,411: 19:06:36 | 11 of 25 START view model blog_dbt_dev.parsely_entry_exit_urls....... [RUN]
2018-01-08 19:06:36,411: Compiling model.parsely.parsely_entry_exit_urls
2018-01-08 19:06:36,429: Writing injected SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-08 19:06:36,431: Acquiring new redshift connection "parsely_entry_exit_urls".
2018-01-08 19:06:36,431: Re-using an available connection from the pool.
2018-01-08 19:06:36,443: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 19:06:36,443: On parsely_entry_exit_urls: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:06:36,466: SQL status: SELECT in 0.02 seconds
2018-01-08 19:06:36,470: Writing runtime SQL for node "model.parsely.parsely_entry_exit_urls"
2018-01-08 19:06:36,471: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 19:06:36,471: On parsely_entry_exit_urls: BEGIN
2018-01-08 19:06:36,473: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:06:36,473: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 19:06:36,474: On parsely_entry_exit_urls: create view "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" as (
    with sessions_time_xf as (
  select
      parsely_session_id,
      max(ts_action_tz) as last_ts_action,
      min(ts_action_tz) as first_ts_action
  from "blog_dbt_dev"."parsely_base_events"
  group by parsely_session_id
),

entry_url as (
  SELECT
    st.parsely_session_id,
    url         as entry_url,
    url_clean   as entry_url_clean,
    url_domain  as entry_url_domain,
    url_fragment as entry_url_fragment,
    url_netloc as entry_url_netloc,
    url_params as entry_url_params,
    url_path as entry_url_path,
    url_query as entry_url_query,
    url_scheme as entry_url_scheme,
    ts_action_tz as entry_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.first_ts_action
),



exit_url as (
  SELECT
    st.parsely_session_id,
    url         as exit_url,
    url_clean   as exit_url_clean,
    url_domain  as exit_url_domain,
    url_fragment as exit_url_fragment,
    url_netloc as exit_url_netloc,
    url_params as exit_url_params,
    url_path as exit_url_path,
    url_query as exit_url_query,
    url_scheme as exit_url_scheme,
    ts_action_tz as exit_ts_action
  from "blog_dbt_dev"."parsely_base_events" be
  inner join sessions_time_xf st
    on be.parsely_session_id = st.parsely_session_id
    and be.ts_action_tz = st.last_ts_action

)

SELECT
  *
from sessions_time_xf
join entry_url using (parsely_session_id)
join exit_url using (parsely_session_id)
  );
2018-01-08 19:06:36,811: SQL status: CREATE VIEW in 0.34 seconds
2018-01-08 19:06:36,812: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 19:06:36,812: On parsely_entry_exit_urls: alter table "blog_dbt_dev"."parsely_entry_exit_urls__dbt_tmp" rename to "parsely_entry_exit_urls"
2018-01-08 19:06:36,815: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 19:06:36,815: On parsely_entry_exit_urls: COMMIT
2018-01-08 19:06:36,815: Using redshift connection "parsely_entry_exit_urls".
2018-01-08 19:06:36,815: On parsely_entry_exit_urls: COMMIT
2018-01-08 19:06:37,308: SQL status: COMMIT in 0.49 seconds
2018-01-08 19:06:37,309: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3e0e10>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:06:37,357: 19:06:37 | 11 of 25 OK created view model blog_dbt_dev.parsely_entry_exit_urls.. [CREATE VIEW in 0.90s]
2018-01-08 19:06:37,358: 19:06:37 | 12 of 25 START view model blog_dbt_dev.parsely_incoming_videoviews... [RUN]
2018-01-08 19:06:37,359: Compiling model.parsely.parsely_incoming_videoviews
2018-01-08 19:06:37,394: Writing injected SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-08 19:06:37,396: Acquiring new redshift connection "parsely_incoming_videoviews".
2018-01-08 19:06:37,396: Re-using an available connection from the pool.
2018-01-08 19:06:37,396: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 19:06:37,396: On parsely_incoming_videoviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:06:37,419: SQL status: SELECT in 0.02 seconds
2018-01-08 19:06:37,424: Writing runtime SQL for node "model.parsely.parsely_incoming_videoviews"
2018-01-08 19:06:37,436: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 19:06:37,436: On parsely_incoming_videoviews: BEGIN
2018-01-08 19:06:37,438: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:06:37,438: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 19:06:37,439: On parsely_incoming_videoviews: create view "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" as (
    with videoview_events as (
  SELECT
    *
  FROM  "blog_dbt_dev"."parsely_base_events"
  where action in ('videostart','vheartbeat')
),


incoming_videoviews_aggr as (
  SELECT
    sum(engaged_time_inc) as video_engaged_time,
    sum(videostart_counter) as videoviews,
    case when sum(videostart_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(videostart_counter) end as avg_video_engaged_time,
    videostart_key
  FROM videoview_events
  group by videostart_key
),

publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from videoview_events

),

dedupe_videoviews_sessionized as (
  select
    row_number() over (partition by videostart_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from videoview_events
  left join publish_watch_time_xf using (event_id)
)

select
    video_engaged_time,
    videoviews,
    avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    publish_time,
    watch_time,
    case
      when avg_video_engaged_time > 60 then 'Deep Watch'
      when avg_video_engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_videoviews_sessionized
left join incoming_videoviews_aggr using (videostart_key)
where n = 1
  );
2018-01-08 19:06:37,645: SQL status: CREATE VIEW in 0.21 seconds
2018-01-08 19:06:37,645: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 19:06:37,645: On parsely_incoming_videoviews: alter table "blog_dbt_dev"."parsely_incoming_videoviews__dbt_tmp" rename to "parsely_incoming_videoviews"
2018-01-08 19:06:37,650: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 19:06:37,650: On parsely_incoming_videoviews: COMMIT
2018-01-08 19:06:37,650: Using redshift connection "parsely_incoming_videoviews".
2018-01-08 19:06:37,651: On parsely_incoming_videoviews: COMMIT
2018-01-08 19:06:38,375: SQL status: COMMIT in 0.72 seconds
2018-01-08 19:06:38,376: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3e0e10>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:06:38,429: 19:06:38 | 12 of 25 OK created view model blog_dbt_dev.parsely_incoming_videoviews [CREATE VIEW in 1.02s]
2018-01-08 19:06:38,429: 19:06:38 | 13 of 25 START incremental model blog_dbt_dev.parsely_videoviews_sessionized [RUN]
2018-01-08 19:06:38,430: Compiling model.parsely.parsely_videoviews_sessionized
2018-01-08 19:06:38,439: Acquiring new redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:06:38,450: Re-using an available connection from the pool.
2018-01-08 19:06:38,450: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:06:38,451: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:06:38,474: SQL status: SELECT in 0.02 seconds
2018-01-08 19:06:38,480: Writing injected SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-08 19:06:38,483: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:06:38,491: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:06:38,513: SQL status: SELECT in 0.02 seconds
2018-01-08 19:06:38,514: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:06:38,514: On parsely_videoviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:06:38,535: SQL status: SELECT in 0.02 seconds
2018-01-08 19:06:38,539: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:06:38,539: On parsely_videoviews_sessionized: BEGIN
2018-01-08 19:06:38,541: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:06:38,541: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:06:38,541: On parsely_videoviews_sessionized: create temporary table "parsely_videoviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_videoviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_videoviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_videoviews_sessionized"
    where videostart_key in (select videostart_key from incoming_videoviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_videoviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(video_engaged_time) as engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      case when sum(videoviews) = 0 then 0 else
         sum(video_engaged_time)/sum(videoviews) end as avg_video_engaged_time_unioned,
      videostart_key
    from unioned
    group by videostart_key
),

merged as (
    SELECT
    engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    avg_video_engaged_time_unioned as avg_video_engaged_time,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    watch_category,
    publish_time,
    watch_time,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- derived fields
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    -- keys
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_videoviews
  left join merged_aggr using (videostart_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:08:40,588: SQL status: SELECT in 122.05 seconds
2018-01-08 19:08:40,588: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:08:40,588: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized__dbt_incremental_tmp'
2018-01-08 19:08:40,758: SQL status: SELECT in 0.17 seconds
2018-01-08 19:08:40,760: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:08:40,760: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:08:40,873: SQL status: SELECT in 0.11 seconds
2018-01-08 19:08:40,874: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:08:40,874: On parsely_videoviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:08:40,988: SQL status: SELECT in 0.11 seconds
2018-01-08 19:08:40,994: Writing runtime SQL for node "model.parsely.parsely_videoviews_sessionized"
2018-01-08 19:08:40,995: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:08:40,995: On parsely_videoviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  where (videostart_key) in (
    select (videostart_key)
    from "parsely_videoviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "avg_video_engaged_time", "videoviews", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "watch_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz", "watch_time", "publish_time"
         from "parsely_videoviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-08 19:08:42,152: SQL status: INSERT 0 145 in 1.16 seconds
2018-01-08 19:08:42,152: On parsely_videoviews_sessionized: COMMIT
2018-01-08 19:08:42,152: Using redshift connection "parsely_videoviews_sessionized".
2018-01-08 19:08:42,152: On parsely_videoviews_sessionized: COMMIT
2018-01-08 19:08:43,384: SQL status: COMMIT in 1.23 seconds
2018-01-08 19:08:43,385: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d446cd0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:08:43,443: 19:08:43 | 13 of 25 OK created incremental model blog_dbt_dev.parsely_videoviews_sessionized [INSERT 0 145 in 124.96s]
2018-01-08 19:08:43,444: Compiling model.parsely.parsely_parent_videostart_keys
2018-01-08 19:08:43,570: Writing injected SQL for node "model.parsely.parsely_parent_videostart_keys"
2018-01-08 19:08:43,579: 19:08:43 | 14 of 25 START view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [RUN]
2018-01-08 19:08:43,580: Compiling model.parsely.parsely_pageview_hanging_engagedtime
2018-01-08 19:08:43,615: Writing injected SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-08 19:08:43,617: Acquiring new redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 19:08:43,618: Re-using an available connection from the pool.
2018-01-08 19:08:43,618: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 19:08:43,618: On parsely_pageview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:08:43,631: SQL status: SELECT in 0.01 seconds
2018-01-08 19:08:43,634: Writing runtime SQL for node "model.parsely.parsely_pageview_hanging_engagedtime"
2018-01-08 19:08:43,635: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 19:08:43,635: On parsely_pageview_hanging_engagedtime: BEGIN
2018-01-08 19:08:43,637: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:08:43,637: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 19:08:43,637: On parsely_pageview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('heartbeat')
  and pageview_key not in
    (select distinct pageview_key from __dbt__CTE__parsely_parent_pageview_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    pageview_key
  from hanging_engaged
  group by pageview_key
)

SELECT
  event_id,
  min_ts_flag,
  pageview_key,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (pageview_key, ts_action)
  );
2018-01-08 19:08:44,274: SQL status: CREATE VIEW in 0.64 seconds
2018-01-08 19:08:44,275: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 19:08:44,275: On parsely_pageview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_hanging_engagedtime__dbt_tmp" rename to "parsely_pageview_hanging_engagedtime"
2018-01-08 19:08:44,279: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 19:08:44,279: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-08 19:08:44,279: Using redshift connection "parsely_pageview_hanging_engagedtime".
2018-01-08 19:08:44,279: On parsely_pageview_hanging_engagedtime: COMMIT
2018-01-08 19:08:44,872: SQL status: COMMIT in 0.59 seconds
2018-01-08 19:08:44,872: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d4466d0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:08:44,924: 19:08:44 | 14 of 25 OK created view model blog_dbt_dev.parsely_pageview_hanging_engagedtime [CREATE VIEW in 1.29s]
2018-01-08 19:08:44,931: 19:08:44 | 15 of 25 START view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [RUN]
2018-01-08 19:08:44,931: Compiling model.parsely.parsely_videoview_hanging_engagedtime
2018-01-08 19:08:45,026: Writing injected SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-08 19:08:45,028: Acquiring new redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 19:08:45,028: Re-using an available connection from the pool.
2018-01-08 19:08:45,028: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 19:08:45,028: On parsely_videoview_hanging_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:08:45,043: SQL status: SELECT in 0.01 seconds
2018-01-08 19:08:45,048: Writing runtime SQL for node "model.parsely.parsely_videoview_hanging_engagedtime"
2018-01-08 19:08:45,049: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 19:08:45,049: On parsely_videoview_hanging_engagedtime: BEGIN
2018-01-08 19:08:45,051: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:08:45,052: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 19:08:45,052: On parsely_videoview_hanging_engagedtime: create view "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),hanging_engaged as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_base_events"
  where action in ('vheartbeat')
  and videostart_key not in
    (select distinct videostart_key from __dbt__CTE__parsely_parent_videostart_keys)
),

first_timestamp as (
  SELECT
    min(ts_action) as ts_action,
    TRUE           as min_ts_flag,
    videostart_key
  from hanging_engaged
  group by videostart_key
)

SELECT
  event_id,
  videostart_key,
  min_ts_flag,
  engaged_time_inc
from hanging_engaged
left join first_timestamp using (videostart_key, ts_action)
  );
2018-01-08 19:08:45,347: SQL status: CREATE VIEW in 0.30 seconds
2018-01-08 19:08:45,348: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 19:08:45,348: On parsely_videoview_hanging_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_hanging_engagedtime__dbt_tmp" rename to "parsely_videoview_hanging_engagedtime"
2018-01-08 19:08:45,353: SQL status: ALTER TABLE in 0.01 seconds
2018-01-08 19:08:45,354: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-08 19:08:45,354: Using redshift connection "parsely_videoview_hanging_engagedtime".
2018-01-08 19:08:45,354: On parsely_videoview_hanging_engagedtime: COMMIT
2018-01-08 19:08:45,527: SQL status: COMMIT in 0.17 seconds
2018-01-08 19:08:45,528: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3e0ed0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:08:45,621: 19:08:45 | 15 of 25 OK created view model blog_dbt_dev.parsely_videoview_hanging_engagedtime [CREATE VIEW in 0.60s]
2018-01-08 19:08:45,621: 19:08:45 | 16 of 25 START view model blog_dbt_dev.parsely_incoming_pageviews.... [RUN]
2018-01-08 19:08:45,622: Compiling model.parsely.parsely_incoming_pageviews
2018-01-08 19:08:45,652: Writing injected SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-08 19:08:45,655: Acquiring new redshift connection "parsely_incoming_pageviews".
2018-01-08 19:08:45,655: Re-using an available connection from the pool.
2018-01-08 19:08:45,656: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 19:08:45,656: On parsely_incoming_pageviews: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:08:45,671: SQL status: SELECT in 0.01 seconds
2018-01-08 19:08:45,677: Writing runtime SQL for node "model.parsely.parsely_incoming_pageviews"
2018-01-08 19:08:45,678: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 19:08:45,679: On parsely_incoming_pageviews: BEGIN
2018-01-08 19:08:45,687: SQL status: BEGIN in 0.01 seconds
2018-01-08 19:08:45,687: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 19:08:45,687: On parsely_incoming_pageviews: create view "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" as (
    with pageview_events as (
    select
      *
      FROM  "blog_dbt_dev"."parsely_base_events"
      where action in ('pageview','heartbeat')
),

incoming_pageviews_aggr as (
  SELECT
    sum(engaged_time_inc) as engaged_time,
    sum(pageview_counter) as pageviews,
    case when sum(pageview_counter) = 0 then 0 else
       sum(engaged_time_inc)/sum(pageview_counter) end as avg_engaged_time,
    pageview_key
  FROM  pageview_events
  group by pageview_key
),

incoming_videoviews_aggr as (
  SELECT
    sum(video_engaged_time) as video_engaged_time,
    sum(videoviews) as videoviews,
    pageview_key
  FROM "blog_dbt_dev"."parsely_videoviews_sessionized"
  where pageview_key in
    (select pageview_key from incoming_pageviews_aggr)
  group by pageview_key
),

publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

),

dedupe_pageviews_sessionized as (
  select
    row_number() over (partition by pageview_key order by ts_action) as n,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    publish_time,
    read_time,
    -- event time fields
    DATE_PART('day',ts_session_current_tz) as session_day,
    DATE_PART('quarter',ts_session_current_tz) as session_quarter,
    DATE_PART('month',ts_session_current_tz) as session_month,
    DATE_PART('year',ts_session_current_tz) as session_year,
    DATE_PART('week',ts_session_current_tz) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
)

select
    engaged_time,
    pageviews,
    avg_engaged_time,
    video_engaged_time,
    videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    case
      when avg_engaged_time > 40 then 'Deep Read'
      when avg_engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    -- event time fields
    DATE_PART('day',ts_session_current) as session_day,
    DATE_PART('quarter',ts_session_current) as session_quarter,
    DATE_PART('month',ts_session_current) as session_month,
    DATE_PART('year',ts_session_current) as session_year,
    DATE_PART('week',ts_session_current) as session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
from dedupe_pageviews_sessionized
left join incoming_pageviews_aggr using (pageview_key)
left join incoming_videoviews_aggr using (pageview_key)
where n = 1
  );
2018-01-08 19:08:45,795: SQL status: CREATE VIEW in 0.11 seconds
2018-01-08 19:08:45,796: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 19:08:45,796: On parsely_incoming_pageviews: alter table "blog_dbt_dev"."parsely_incoming_pageviews__dbt_tmp" rename to "parsely_incoming_pageviews"
2018-01-08 19:08:45,801: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 19:08:45,802: On parsely_incoming_pageviews: COMMIT
2018-01-08 19:08:45,802: Using redshift connection "parsely_incoming_pageviews".
2018-01-08 19:08:45,802: On parsely_incoming_pageviews: COMMIT
2018-01-08 19:08:46,028: SQL status: COMMIT in 0.23 seconds
2018-01-08 19:08:46,029: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d478990>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:08:46,082: 19:08:46 | 16 of 25 OK created view model blog_dbt_dev.parsely_incoming_pageviews [CREATE VIEW in 0.41s]
2018-01-08 19:08:46,091: 19:08:46 | 17 of 25 START incremental model blog_dbt_dev.parsely_pageviews_sessionized [RUN]
2018-01-08 19:08:46,091: Compiling model.parsely.parsely_pageviews_sessionized
2018-01-08 19:08:46,114: Acquiring new redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:08:46,114: Re-using an available connection from the pool.
2018-01-08 19:08:46,114: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:08:46,115: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:08:46,130: SQL status: SELECT in 0.02 seconds
2018-01-08 19:08:46,137: Writing injected SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-08 19:08:46,144: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:08:46,144: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:08:46,158: SQL status: SELECT in 0.01 seconds
2018-01-08 19:08:46,159: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:08:46,159: On parsely_pageviews_sessionized: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:08:46,173: SQL status: SELECT in 0.01 seconds
2018-01-08 19:08:46,177: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:08:46,177: On parsely_pageviews_sessionized: BEGIN
2018-01-08 19:08:46,179: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:08:46,179: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:08:46,179: On parsely_pageviews_sessionized: create temporary table "parsely_pageviews_sessionized__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          

with incoming_pageviews as (

  SELECT
    *
  from "blog_dbt_dev"."parsely_incoming_pageviews"


),




relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_pageviews_sessionized"
    where pageview_key in (select pageview_key from incoming_pageviews)

),

-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
      *
    from incoming_pageviews

    union all

    select
      *
    from relevant_existing

),

merged_aggr as (

    select
      sum(engaged_time) as engaged_time_unioned,
      sum(pageviews) as pageviews_unioned,
      case when sum(pageviews) = 0 then 0 else
         sum(engaged_time)/sum(pageviews) end as avg_engaged_time_unioned,
      sum(video_engaged_time) as video_engaged_time_unioned,
      sum(videoviews) as videoviews_unioned,
      pageview_key
    from unioned
    group by pageview_key
),

merged as (
    SELECT
    engaged_time_unioned as engaged_time,
    pageviews_unioned as pageviews,
    avg_engaged_time_unioned as avg_engaged_time,
    video_engaged_time_unioned as video_engaged_time,
    videoviews_unioned as videoviews,
    -- derived fields
    customer_apikey,
    pageview_post_id,
    flag_is_fbia,
    ts_session_current_tz,
    ts_session_last_tz,
    metadata_pub_date_tmsp_tz,
    metadata_save_date_tmsp_tz,
    session_last_session_timestamp_tz,
    session_timestamp_tz,
    read_category,
    hours_since_publish,
    days_since_publish,
    weeks_since_publish,
    -- event time fields
    session_day,
    session_quarter,
    session_month,
    session_year,
    session_week,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    extra_data,
    flags_is_amp,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from incoming_pageviews
  left join merged_aggr  using (pageview_key)
)



select
  *
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:15:09,209: SQL status: SELECT in 383.03 seconds
2018-01-08 19:15:09,210: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:15:09,210: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized__dbt_incremental_tmp'
2018-01-08 19:15:09,417: SQL status: SELECT in 0.21 seconds
2018-01-08 19:15:09,417: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:15:09,417: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:15:09,539: SQL status: SELECT in 0.12 seconds
2018-01-08 19:15:09,541: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:15:09,541: On parsely_pageviews_sessionized: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageviews_sessionized' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:15:09,663: SQL status: SELECT in 0.12 seconds
2018-01-08 19:15:09,669: Writing runtime SQL for node "model.parsely.parsely_pageviews_sessionized"
2018-01-08 19:15:09,671: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:15:09,671: On parsely_pageviews_sessionized: 
       

       delete
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  where (pageview_key) in (
    select (pageview_key)
    from "parsely_pageviews_sessionized__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageviews_sessionized" ("visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "metadata", "flags_is_amp", "display", "flag_is_fbia", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "avg_engaged_time", "pageviews", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "campaign_id", "apikey", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "read_category", "pageview_post_id", "customer_apikey", "ts_session_last", "ts_session_current", "session_timestamp_tz", "session_last_session_timestamp_tz", "metadata_save_date_tmsp_tz", "metadata_pub_date_tmsp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_pageviews_sessionized__dbt_incremental_tmp"
       );
     
2018-01-08 19:15:13,172: SQL status: INSERT 0 112911 in 3.50 seconds
2018-01-08 19:15:13,173: On parsely_pageviews_sessionized: COMMIT
2018-01-08 19:15:13,173: Using redshift connection "parsely_pageviews_sessionized".
2018-01-08 19:15:13,173: On parsely_pageviews_sessionized: COMMIT
2018-01-08 19:15:14,845: SQL status: COMMIT in 1.67 seconds
2018-01-08 19:15:14,846: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d43e4d0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:15:14,918: 19:15:14 | 17 of 25 OK created incremental model blog_dbt_dev.parsely_pageviews_sessionized [INSERT 0 112911 in 388.75s]
2018-01-08 19:15:14,918: 19:15:14 | 18 of 25 START view model blog_dbt_dev.parsely_videoview_engagedtime. [RUN]
2018-01-08 19:15:14,927: Compiling model.parsely.parsely_videoview_engagedtime
2018-01-08 19:15:15,178: Writing injected SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-08 19:15:15,188: Acquiring new redshift connection "parsely_videoview_engagedtime".
2018-01-08 19:15:15,188: Re-using an available connection from the pool.
2018-01-08 19:15:15,188: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 19:15:15,188: On parsely_videoview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:15:15,213: SQL status: SELECT in 0.02 seconds
2018-01-08 19:15:15,217: Writing runtime SQL for node "model.parsely.parsely_videoview_engagedtime"
2018-01-08 19:15:15,218: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 19:15:15,218: On parsely_videoview_engagedtime: BEGIN
2018-01-08 19:15:15,227: SQL status: BEGIN in 0.01 seconds
2018-01-08 19:15:15,227: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 19:15:15,227: On parsely_videoview_engagedtime: create view "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),  __dbt__CTE__parsely_parent_videostart_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    metadata_canonical_url,
    url,
    referrer,
    ts_session_current,
    vs.event_id,
    vs.ts_action,
    LAG(vs.ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
       ORDER BY vs.ts_action) AS previous_videostart_ts_action,
     LAG(vs.ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         metadata_canonical_url,
         url,
         referrer,
         ts_session_current
      ORDER BY vs.ts_action desc) AS next_videostart_ts_action,
--  hash keys
    pv.pageview_key,
    videostart_key
from "blog_dbt_dev"."parsely_base_events" vs
left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key, apikey, session_id, referrer, visitor_site_id, url, ts_session_current)
where action in ('videostart')
and vs.ts_action >= pv.ts_action and (case when pv.next_pageview_ts_action is not null then vs.ts_action < pv.next_pageview_ts_action else true end)
),videostart_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('videostart','vheartbeat')

),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      vs.event_id,
      vhb.videostart_key,
      true as videostart_match,
      false as min_ts_flag,
      sum(vhb.engaged_time_inc) as engaged_time
  from videostart_events vhb
  left join __dbt__CTE__parsely_parent_videostart_keys vs using (videostart_key)
  where vhb.action = 'vheartbeat' and
  vhb.ts_action >= vs.ts_action and
  (case when vs.next_videostart_ts_action is not null
    then vhb.ts_action < vs.next_videostart_ts_action
    else true end)
  group by vs.event_id, vhb.videostart_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      videostart_key
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  group by videostart_key
),

engaged_no_matches as (
  SELECT
    event_id,
    videostart_key,
    false as videostart_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_videoview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (videostart_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
  from videostart_events vs
  left join unioned using (event_id, videostart_key)
  where (vs.action = 'videostart' or min_ts_flag is true)
  and (min_ts_flag is true or videostart_match is true)
  );
2018-01-08 19:15:16,457: SQL status: CREATE VIEW in 1.23 seconds
2018-01-08 19:15:16,458: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 19:15:16,458: On parsely_videoview_engagedtime: alter table "blog_dbt_dev"."parsely_videoview_engagedtime__dbt_tmp" rename to "parsely_videoview_engagedtime"
2018-01-08 19:15:16,586: SQL status: ALTER TABLE in 0.13 seconds
2018-01-08 19:15:16,586: On parsely_videoview_engagedtime: COMMIT
2018-01-08 19:15:16,587: Using redshift connection "parsely_videoview_engagedtime".
2018-01-08 19:15:16,587: On parsely_videoview_engagedtime: COMMIT
2018-01-08 19:15:16,969: SQL status: COMMIT in 0.38 seconds
2018-01-08 19:15:16,970: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d446f90>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:15:17,025: 19:15:17 | 18 of 25 OK created view model blog_dbt_dev.parsely_videoview_engagedtime [CREATE VIEW in 2.04s]
2018-01-08 19:15:17,025: 19:15:17 | 19 of 25 START incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [RUN]
2018-01-08 19:15:17,025: Compiling model.parsely.parsely_videoview_behavior_workflow
2018-01-08 19:15:17,057: Writing injected SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-08 19:15:17,060: Acquiring new redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 19:15:17,060: Re-using an available connection from the pool.
2018-01-08 19:15:17,060: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 19:15:17,060: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:15:17,083: SQL status: SELECT in 0.02 seconds
2018-01-08 19:15:17,083: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 19:15:17,084: On parsely_videoview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:15:17,105: SQL status: SELECT in 0.02 seconds
2018-01-08 19:15:17,109: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 19:15:17,109: On parsely_videoview_behavior_workflow: BEGIN
2018-01-08 19:15:17,111: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:15:17,111: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 19:15:17,111: On parsely_videoview_behavior_workflow: create temporary table "parsely_videoview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per videoview
-- sum engaged time for all heartbeats
-- metrics: videoviews, engaged time



with video_events as (

    select * from "blog_dbt_dev"."parsely_videoview_engagedtime"
),

-- derived fields
publish_watch_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as watch_time
    from video_events

)
select
    -- aggregated fields
    engaged_time as video_engaged_time,
    1 as videostart_counter,
    -- derived fields
    datediff(hour, publish_time, watch_time) as hours_since_publish,
    datediff(day, publish_time, watch_time) as days_since_publish,
    datediff(week, publish_time, watch_time) as weeks_since_publish,
    case
      when engaged_time > 60 then 'Deep Watch'
      when engaged_time > 15 then 'Watch'
      else 'Skim' end as watch_category,
    publish_time,
    watch_time,
    customer_apikey,
    pageview_key,
    videostart_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- event time fields
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from video_events
  left join publish_watch_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:21:15,685: SQL status: SELECT in 358.57 seconds
2018-01-08 19:21:15,686: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 19:21:15,686: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow__dbt_incremental_tmp'
2018-01-08 19:21:15,979: SQL status: SELECT in 0.29 seconds
2018-01-08 19:21:15,980: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 19:21:15,980: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:21:16,104: SQL status: SELECT in 0.12 seconds
2018-01-08 19:21:16,105: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 19:21:16,105: On parsely_videoview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_videoview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:21:16,228: SQL status: SELECT in 0.12 seconds
2018-01-08 19:21:16,232: Writing runtime SQL for node "model.parsely.parsely_videoview_behavior_workflow"
2018-01-08 19:21:16,233: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 19:21:16,233: On parsely_videoview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_videoview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "video_engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "videostart_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "videostart_key", "pageview_key", "customer_apikey", "watch_category", "ts_session_last", "ts_session_current", "ts_action", "watch_time", "publish_time"
         from "parsely_videoview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-08 19:21:17,383: SQL status: INSERT 0 144 in 1.15 seconds
2018-01-08 19:21:17,384: On parsely_videoview_behavior_workflow: COMMIT
2018-01-08 19:21:17,384: Using redshift connection "parsely_videoview_behavior_workflow".
2018-01-08 19:21:17,384: On parsely_videoview_behavior_workflow: COMMIT
2018-01-08 19:21:18,777: SQL status: COMMIT in 1.39 seconds
2018-01-08 19:21:18,778: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3e0ed0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:21:18,815: 19:21:18 | 19 of 25 OK created incremental model blog_dbt_dev.parsely_videoview_behavior_workflow [INSERT 0 144 in 361.75s]
2018-01-08 19:21:18,815: 19:21:18 | 20 of 25 START incremental model blog_dbt_dev.parsely_campaigns...... [RUN]
2018-01-08 19:21:18,816: Compiling model.parsely.parsely_campaigns
2018-01-08 19:21:18,820: Acquiring new redshift connection "parsely_campaigns".
2018-01-08 19:21:18,820: Re-using an available connection from the pool.
2018-01-08 19:21:18,820: Using redshift connection "parsely_campaigns".
2018-01-08 19:21:18,820: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:21:18,842: SQL status: SELECT in 0.02 seconds
2018-01-08 19:21:18,845: Writing injected SQL for node "model.parsely.parsely_campaigns"
2018-01-08 19:21:18,846: Using redshift connection "parsely_campaigns".
2018-01-08 19:21:18,846: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:21:18,868: SQL status: SELECT in 0.02 seconds
2018-01-08 19:21:18,869: Using redshift connection "parsely_campaigns".
2018-01-08 19:21:18,869: On parsely_campaigns: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:21:18,891: SQL status: SELECT in 0.02 seconds
2018-01-08 19:21:18,892: Using redshift connection "parsely_campaigns".
2018-01-08 19:21:18,892: On parsely_campaigns: BEGIN
2018-01-08 19:21:18,894: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:21:18,894: Using redshift connection "parsely_campaigns".
2018-01-08 19:21:18,894: On parsely_campaigns: create temporary table "parsely_campaigns__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per campaign
-- metrics: pageviews, engaged time, videostarts, video engaged time, visitors



with incoming_campaigns as (
  select
    utm_id,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    engaged_time,
    pageviews,
    video_engaged_time,
    videoviews,
--  dedupe field
    row_number() over (partition by utm_id order by ts_session_current) as n
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
),



relevant_existing as (

    select
        *
    from "blog_dbt_dev"."parsely_campaigns"
    where utm_id in (select utm_id from incoming_campaigns)

),

-- left join fields from old data: min_tstamp
unioned as (

    select
      *
    from incoming_campaigns

    union all

    select
        *
    from relevant_existing

),

merged as (

    select
      n,
      utm_id,
      utm_campaign,
      utm_medium,
      utm_source,
      utm_term,
      utm_content,
      sum(engaged_time) as engaged_time,
      sum(pageviews) as pageviews,
      sum(video_engaged_time) as video_engaged_time,
      sum(videoviews) as videoviews
    from unioned
    group by n, utm_id, utm_campaign, utm_medium, utm_source, utm_term, utm_content

),



dedupe as (
    select
      *
    from merged
)

select
  *
from dedupe
where n = 1
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:21:20,551: SQL status: SELECT in 1.66 seconds
2018-01-08 19:21:20,551: Using redshift connection "parsely_campaigns".
2018-01-08 19:21:20,551: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns__dbt_incremental_tmp'
2018-01-08 19:21:20,708: SQL status: SELECT in 0.16 seconds
2018-01-08 19:21:20,709: Using redshift connection "parsely_campaigns".
2018-01-08 19:21:20,709: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:21:20,826: SQL status: SELECT in 0.12 seconds
2018-01-08 19:21:20,826: Using redshift connection "parsely_campaigns".
2018-01-08 19:21:20,826: On parsely_campaigns: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_campaigns' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:21:20,943: SQL status: SELECT in 0.12 seconds
2018-01-08 19:21:20,945: Writing runtime SQL for node "model.parsely.parsely_campaigns"
2018-01-08 19:21:20,946: Using redshift connection "parsely_campaigns".
2018-01-08 19:21:20,946: On parsely_campaigns: 
       

       delete
  from "blog_dbt_dev"."parsely_campaigns"
  where (utm_id) in (
    select (utm_id)
    from "parsely_campaigns__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_campaigns" ("n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id")
       (
         select "n", "videoviews", "video_engaged_time", "pageviews", "engaged_time", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "utm_id"
         from "parsely_campaigns__dbt_incremental_tmp"
       );
     
2018-01-08 19:21:21,091: SQL status: INSERT 0 394 in 0.15 seconds
2018-01-08 19:21:21,092: On parsely_campaigns: COMMIT
2018-01-08 19:21:21,092: Using redshift connection "parsely_campaigns".
2018-01-08 19:21:21,092: On parsely_campaigns: COMMIT
2018-01-08 19:21:21,576: SQL status: COMMIT in 0.48 seconds
2018-01-08 19:21:21,577: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d446dd0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:21:21,605: 19:21:21 | 20 of 25 OK created incremental model blog_dbt_dev.parsely_campaigns. [INSERT 0 394 in 2.76s]
2018-01-08 19:21:21,606: Compiling model.parsely.parsely_incoming_users
2018-01-08 19:21:21,613: Writing injected SQL for node "model.parsely.parsely_incoming_users"
2018-01-08 19:21:21,615: 19:21:21 | 21 of 25 START incremental model blog_dbt_dev.parsely_users.......... [RUN]
2018-01-08 19:21:21,615: Compiling model.parsely.parsely_users
2018-01-08 19:21:21,621: Acquiring new redshift connection "parsely_users".
2018-01-08 19:21:21,621: Re-using an available connection from the pool.
2018-01-08 19:21:21,621: Using redshift connection "parsely_users".
2018-01-08 19:21:21,621: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:21:21,644: SQL status: SELECT in 0.02 seconds
2018-01-08 19:21:21,684: Writing injected SQL for node "model.parsely.parsely_users"
2018-01-08 19:21:21,686: Using redshift connection "parsely_users".
2018-01-08 19:21:21,686: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:21:21,708: SQL status: SELECT in 0.02 seconds
2018-01-08 19:21:21,709: Using redshift connection "parsely_users".
2018-01-08 19:21:21,709: On parsely_users: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:21:21,731: SQL status: SELECT in 0.02 seconds
2018-01-08 19:21:21,734: Using redshift connection "parsely_users".
2018-01-08 19:21:21,734: On parsely_users: BEGIN
2018-01-08 19:21:21,736: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:21:21,736: Using redshift connection "parsely_users".
2018-01-08 19:21:21,736: On parsely_users: create temporary table "parsely_users__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



-- second time: builds temp table; deletes duplicates by unique key, inserts new data
--


with  __dbt__CTE__parsely_incoming_users as (
-- 1 row per visitor_site_Id
-- includes visitor type, returning, new, subscribers, etc
-- first login, last login, etc



with incoming_users_pageviews as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      sum(pageviews) as user_total_pageviews,
      sum(engaged_time) as user_total_engaged_time,
      0 as user_total_videoviews,
      0 as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by 1,2,3
),

incoming_users_videostarts as (
  select
      apikey,
      visitor_site_id,
      --custom fields
      apikey_visitor_id,
      -- metrics
      max(ts_session_current_tz) as last_timestamp,
      0 as user_total_pageviews,
      0 as user_total_engaged_time,
      sum(videoviews) as user_total_videoviews,
      sum(video_engaged_time) as user_total_video_engaged_time
  from "blog_dbt_dev"."parsely_videoviews_sessionized"
  group by 1,2,3
)

select * from incoming_users_pageviews
union all
select * from incoming_users_videostarts
),incoming_users as (
  select
      apikey,
      apikey_visitor_id,
      visitor_site_id,
      -- dates and times
      max(last_timestamp) as last_timestamp,
      date(min(last_timestamp)) as date_first_seen,
      date(max(last_timestamp)) as date_last_seen,
      -- metrics to aggregate
      sum(user_total_pageviews) as user_total_pageviews,
      sum(user_total_engaged_time) as user_total_engaged_time,
      sum(user_total_videoviews) as user_total_videoviews,
      sum(user_total_video_engaged_time) as user_total_video_engaged_time
  from __dbt__CTE__parsely_incoming_users
  group by 1,2,3
),



relevant_existing as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        eu.last_timestamp,
        eu.date_first_seen,
        eu.date_last_seen,
        -- metrics to aggregate
        eu.user_total_pageviews,
        eu.user_total_engaged_time,
        eu.user_total_videoviews,
        eu.user_total_video_engaged_time
    from "blog_dbt_dev"."parsely_users" as eu
    left join incoming_users as iu using
      (apikey_visitor_id, apikey, visitor_site_id)

),

unioned as (

    -- combined pageviews and videostarts
    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from incoming_users

    union all

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        last_timestamp,
        date_first_seen,
        date_last_seen,
        -- metrics to aggregate
        user_total_pageviews,
        user_total_engaged_time,
        user_total_videoviews,
        user_total_video_engaged_time
    from relevant_existing

),

merged as (

    select
        apikey,
        apikey_visitor_id,
        visitor_site_id,
        -- dates and times
        max(last_timestamp) as last_timestamp,
        min(date_first_seen) as date_first_seen,
        max(date_last_seen) as date_last_seen,
        -- metrics
        sum(user_total_pageviews) as user_total_pageviews,
        sum(user_total_engaged_time) as user_total_engaged_time,
        sum(user_total_videoviews) as user_total_videoviews,
        sum(user_total_video_engaged_time) as user_total_video_engaged_time
    from unioned
    group by 1,2,3


)



select
    1 as user_counter,
    apikey,
    apikey_visitor_id,
    visitor_site_id,
    -- dates and times
    last_timestamp,
    date_first_seen,
    date_last_seen,
    -- metrics to aggregate
    user_total_pageviews,
    user_total_engaged_time,
    user_total_videoviews,
    user_total_video_engaged_time,
    -- derived fields
    case when date_first_seen < date(SYSDATE)
      then 'Returning'
      else 'New' end as user_type,
    case when user_total_pageviews>=30
      then 'Loyalty'
      else 'Non-Loyalty' end as user_engagement_level,
    DATEDIFF(day, last_timestamp, SYSDATE) as days_since_last_session
  from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:21:24,975: SQL status: SELECT in 3.24 seconds
2018-01-08 19:21:24,975: Using redshift connection "parsely_users".
2018-01-08 19:21:24,975: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users__dbt_incremental_tmp'
2018-01-08 19:21:25,303: SQL status: SELECT in 0.33 seconds
2018-01-08 19:21:25,304: Using redshift connection "parsely_users".
2018-01-08 19:21:25,304: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:21:25,424: SQL status: SELECT in 0.12 seconds
2018-01-08 19:21:25,424: Using redshift connection "parsely_users".
2018-01-08 19:21:25,424: On parsely_users: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_users' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:21:25,543: SQL status: SELECT in 0.12 seconds
2018-01-08 19:21:25,544: Writing runtime SQL for node "model.parsely.parsely_users"
2018-01-08 19:21:25,546: Using redshift connection "parsely_users".
2018-01-08 19:21:25,546: On parsely_users: 
       

       delete
  from "blog_dbt_dev"."parsely_users"
  where (apikey_visitor_id) in (
    select (apikey_visitor_id)
    from "parsely_users__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_users" ("days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp")
       (
         select "days_since_last_session", "user_total_video_engaged_time", "user_total_videoviews", "user_total_engaged_time", "user_total_pageviews", "user_counter", "user_engagement_level", "user_type", "visitor_site_id", "apikey_visitor_id", "apikey", "date_last_seen", "date_first_seen", "last_timestamp"
         from "parsely_users__dbt_incremental_tmp"
       );
     
2018-01-08 19:21:25,899: SQL status: INSERT 0 54930 in 0.35 seconds
2018-01-08 19:21:25,899: On parsely_users: COMMIT
2018-01-08 19:21:25,899: Using redshift connection "parsely_users".
2018-01-08 19:21:25,899: On parsely_users: COMMIT
2018-01-08 19:21:26,743: SQL status: COMMIT in 0.84 seconds
2018-01-08 19:21:26,743: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3e9ed0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:21:26,780: 19:21:26 | 21 of 25 OK created incremental model blog_dbt_dev.parsely_users..... [INSERT 0 54930 in 5.13s]
2018-01-08 19:21:26,781: 19:21:26 | 22 of 25 START view model blog_dbt_dev.parsely_pageview_engagedtime.. [RUN]
2018-01-08 19:21:26,781: Compiling model.parsely.parsely_pageview_engagedtime
2018-01-08 19:21:26,814: Writing injected SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-08 19:21:26,816: Acquiring new redshift connection "parsely_pageview_engagedtime".
2018-01-08 19:21:26,816: Re-using an available connection from the pool.
2018-01-08 19:21:26,816: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 19:21:26,817: On parsely_pageview_engagedtime: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:21:26,839: SQL status: SELECT in 0.02 seconds
2018-01-08 19:21:26,841: Writing runtime SQL for node "model.parsely.parsely_pageview_engagedtime"
2018-01-08 19:21:26,842: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 19:21:26,842: On parsely_pageview_engagedtime: BEGIN
2018-01-08 19:21:26,844: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:21:26,844: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 19:21:26,844: On parsely_pageview_engagedtime: create view "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" as (
    with  __dbt__CTE__parsely_parent_pageview_keys as (


select
    apikey,
    session_id,
    visitor_site_id,
    pageview_post_id,
    pageview_post_id as url,
    referrer,
    ts_session_current,
    ts_action,
    event_id,
    LAG(ts_action, 1) OVER
      (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
       ORDER BY ts_action) AS previous_pageview_ts_action,
     LAG(ts_action, 1) OVER
       (PARTITION BY
         apikey,
         session_id,
         visitor_site_id,
         pageview_post_id,
         referrer,
         ts_session_current
      ORDER BY ts_action desc) AS next_pageview_ts_action,
--  hash keys
    pageview_key
from "blog_dbt_dev"."parsely_base_events"
where action in ('pageview')
),pageview_events as (

    select * from "blog_dbt_dev"."parsely_base_events"
    where action in ('pageview','heartbeat')

),

videoview_events as (
    SELECT
      sum(videostart_counter) as videoviews,
      sum(video_engaged_time) as video_engaged_time,
      pageview_key
    from "blog_dbt_dev"."parsely_videoview_behavior_workflow"
    group by pageview_key
),

engaged_xf as (

-- join videoviews and vheartbeats when they match up
  select
      pv.event_id,
      hb.pageview_key,
      true as pageview_match,
      false as min_ts_flag,
      sum(hb.engaged_time_inc) as engaged_time
  from pageview_events hb
  left join __dbt__CTE__parsely_parent_pageview_keys pv using (pageview_key)
  where hb.action = 'heartbeat' and
  hb.ts_action >= pv.ts_action and
  (case when pv.next_pageview_ts_action is not null
    then hb.ts_action < pv.next_pageview_ts_action
    else true end)
  group by pv.event_id, hb.pageview_key
),

engaged_no_matches_aggr as (
-- aggregated engaged time when videoviews and vheartbeats do not match up
-- using the ts_action and metadata from the first heartbeat
  select
      sum(engaged_time_inc) as engaged_time,
      pageview_key
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  group by pageview_key
),

engaged_no_matches as (
  SELECT
    event_id,
    pageview_key,
    false as pageview_match,
    min_ts_flag,
    engaged_time
  from "blog_dbt_dev"."parsely_pageview_hanging_engagedtime"
  left join engaged_no_matches_aggr using (pageview_key)
  where min_ts_flag is true
),

unioned as (
  select
    *
  from engaged_xf

  union all

  select
    *
  from engaged_no_matches

)

select
  *
from pageview_events pv
  left join unioned using (event_id, pageview_key)
  left join videoview_events using (pageview_key)
where (pv.action = 'pageview' or min_ts_flag is true)
and (min_ts_flag is true or pageview_match is true)
  );
2018-01-08 19:21:29,574: SQL status: CREATE VIEW in 2.73 seconds
2018-01-08 19:21:29,574: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 19:21:29,574: On parsely_pageview_engagedtime: alter table "blog_dbt_dev"."parsely_pageview_engagedtime__dbt_tmp" rename to "parsely_pageview_engagedtime"
2018-01-08 19:21:29,578: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 19:21:29,578: On parsely_pageview_engagedtime: COMMIT
2018-01-08 19:21:29,578: Using redshift connection "parsely_pageview_engagedtime".
2018-01-08 19:21:29,579: On parsely_pageview_engagedtime: COMMIT
2018-01-08 19:21:30,033: SQL status: COMMIT in 0.45 seconds
2018-01-08 19:21:30,034: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d3e0ed0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:21:30,062: 19:21:30 | 22 of 25 OK created view model blog_dbt_dev.parsely_pageview_engagedtime [CREATE VIEW in 3.25s]
2018-01-08 19:21:30,062: 19:21:30 | 23 of 25 START view model blog_dbt_dev.parsely_incoming_sessions..... [RUN]
2018-01-08 19:21:30,063: Compiling model.parsely.parsely_incoming_sessions
2018-01-08 19:21:30,071: Writing injected SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-08 19:21:30,072: Acquiring new redshift connection "parsely_incoming_sessions".
2018-01-08 19:21:30,073: Re-using an available connection from the pool.
2018-01-08 19:21:30,073: Using redshift connection "parsely_incoming_sessions".
2018-01-08 19:21:30,073: On parsely_incoming_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:21:30,095: SQL status: SELECT in 0.02 seconds
2018-01-08 19:21:30,097: Writing runtime SQL for node "model.parsely.parsely_incoming_sessions"
2018-01-08 19:21:30,099: Using redshift connection "parsely_incoming_sessions".
2018-01-08 19:21:30,099: On parsely_incoming_sessions: BEGIN
2018-01-08 19:21:30,101: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:21:30,101: Using redshift connection "parsely_incoming_sessions".
2018-01-08 19:21:30,101: On parsely_incoming_sessions: create view "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" as (
    -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time

with session_metrics as (
  select
      parsely_session_id,
      sum(pageviews) as pageviews,
      sum(engaged_time) as engaged_time,
      sum(videoviews) as videoviews,
      sum(video_engaged_time) as video_engaged_time
  from "blog_dbt_dev"."parsely_pageviews_sessionized"
  group by parsely_session_id
),

users as (
    select
      apikey_visitor_id,
      user_type,
      user_engagement_level
    from "blog_dbt_dev"."parsely_users"
),

entry_exit as (
  SELECT
    *
  from "blog_dbt_dev"."parsely_entry_exit_urls"
),

session_dedupe_xf as (
  select  --add row number 1=1 here
      row_number() over (partition by parsely_session_id order by pageview_key) as n,
  --  id
      parsely_session_id,
      apikey_visitor_id,
  --  session user dimensions
      user_type as session_user_type,
      user_engagement_level as session_user_engagement_level,
  --  counter field
      1 as session_counter,
  --  derived fields
      flag_is_fbia,
      ts_session_current_tz,
      ts_session_last_tz,
      session_last_session_timestamp_tz,
      session_timestamp_tz,
  --  parsely_entry_exit_urls
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action,
  --  session time fields
      session_day,
      session_quarter,
      session_month,
      session_year,
      session_week,
      session_date_id,
  --  standard fields
      apikey,
      flags_is_amp,
      ip_city,
      ip_continent,
      ip_country,
      ip_lat::FLOAT8,
      ip_lon,
      ip_postal,
      ip_subdivision,
      ip_timezone,
      ip_market_name,
      ip_market_nielsen,
      ip_market_doubleclick,
      session,
      session_id,
      session_initial_referrer,
      session_initial_url,
      session_last_session_timestamp,
      session_timestamp,
      slot,
      sref_category,
      sref_clean,
      sref_domain,
      sref_fragment,
      sref_netloc,
      sref_params,
      sref_path,
      sref_query,
      sref_scheme,
      surl_clean,
      surl_domain,
      surl_fragment,
      surl_netloc,
      surl_params,
      surl_path,
      surl_query,
      surl_scheme,
      ua_browser,
      ua_browserversion,
      ua_device,
      ua_devicebrand,
      ua_devicemodel,
      ua_devicetouchcapable,
      ua_devicetype,
      ua_os,
      ua_osversion,
      user_agent,
      version,
      visitor,
      visitor_ip,
      visitor_network_id,
      visitor_site_id
  from "blog_dbt_dev"."parsely_pageviews_sessionized" as pv
  left join users using (apikey_visitor_id)
  left join entry_exit using (parsely_session_id)
)

select
  *
from session_dedupe_xf
left join session_metrics using (parsely_session_id)
where n = 1
  );
2018-01-08 19:21:30,275: SQL status: CREATE VIEW in 0.17 seconds
2018-01-08 19:21:30,276: Using redshift connection "parsely_incoming_sessions".
2018-01-08 19:21:30,276: On parsely_incoming_sessions: alter table "blog_dbt_dev"."parsely_incoming_sessions__dbt_tmp" rename to "parsely_incoming_sessions"
2018-01-08 19:21:30,279: SQL status: ALTER TABLE in 0.00 seconds
2018-01-08 19:21:30,279: On parsely_incoming_sessions: COMMIT
2018-01-08 19:21:30,279: Using redshift connection "parsely_incoming_sessions".
2018-01-08 19:21:30,279: On parsely_incoming_sessions: COMMIT
2018-01-08 19:21:30,450: SQL status: COMMIT in 0.17 seconds
2018-01-08 19:21:30,451: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d446610>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:21:30,479: 19:21:30 | 23 of 25 OK created view model blog_dbt_dev.parsely_incoming_sessions [CREATE VIEW in 0.39s]
2018-01-08 19:21:30,479: 19:21:30 | 24 of 25 START incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [RUN]
2018-01-08 19:21:30,480: Compiling model.parsely.parsely_pageview_behavior_workflow
2018-01-08 19:21:30,489: Writing injected SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-08 19:21:30,491: Acquiring new redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 19:21:30,491: Re-using an available connection from the pool.
2018-01-08 19:21:30,491: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 19:21:30,491: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:21:30,513: SQL status: SELECT in 0.02 seconds
2018-01-08 19:21:30,513: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 19:21:30,514: On parsely_pageview_behavior_workflow: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:21:30,535: SQL status: SELECT in 0.02 seconds
2018-01-08 19:21:30,536: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 19:21:30,537: On parsely_pageview_behavior_workflow: BEGIN
2018-01-08 19:21:30,539: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:21:30,539: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 19:21:30,539: On parsely_pageview_behavior_workflow: create temporary table "parsely_pageview_behavior_workflow__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per pageview
-- sum engaged time for all heartbeats
-- metrics: pageviews, engaged time



with pageview_events as (

    select * from "blog_dbt_dev"."parsely_pageview_engagedtime"
),

-- derived fields
publish_read_time_xf as (
    select
        event_id,
        metadata_pub_date_tmsp_tz as publish_time,
        timestamp_info_nginx_ms_tz as read_time
    from pageview_events

)

select
    -- aggregated fields
    engaged_time,
    1 as pageview_counter,
    video_engaged_time,
    videoviews,
    -- derived fields
    datediff(hour, publish_time, read_time) as hours_since_publish,
    datediff(day, publish_time, read_time) as days_since_publish,
    datediff(week, publish_time, read_time) as weeks_since_publish,
    case
      when engaged_time > 40 then 'Deep Read'
      when engaged_time > 15 then 'Read'
      else 'Skim' end as read_category,
    publish_time,
    read_time,
    customer_apikey,
    pageview_post_id,
    -- event time fields
    day,
    quarter,
    month,
    year,
    week,
    date_id,
    session_date_id,
    -- keys
    pageview_key,
    parsely_session_id,
    utm_id,
    apikey_visitor_id,
    -- standard fields
    action,
    apikey,
    campaign_id,
    display,
    display_avail_height,
    display_avail_width,
    display_pixel_depth,
    display_total_height,
    display_total_width,
    event_id,
    extra_data,
    flags_is_amp,
    flag_is_fbia,
    ip_city,
    ip_continent,
    ip_country,
    ip_lat::FLOAT8,
    ip_lon,
    ip_postal,
    ip_subdivision,
    ip_timezone,
    ip_market_name,
    ip_market_nielsen,
    ip_market_doubleclick,
    metadata,
    metadata_authors,
    metadata_canonical_url,
    metadata_custom_metadata,
    metadata_duration,
    metadata_data_source,
    metadata_full_content_word_count,
    metadata_image_url,
    metadata_page_type,
    metadata_post_id,
    metadata_pub_date_tmsp,
    metadata_save_date_tmsp,
    metadata_section,
    metadata_share_urls,
    metadata_tags,
    metadata_thumb_url,
    metadata_title,
    metadata_urls,
    ref_category,
    ref_clean,
    ref_domain,
    ref_fragment,
    ref_netloc,
    ref_params,
    ref_path,
    ref_query,
    ref_scheme,
    referrer,
    session,
    session_id,
    session_initial_referrer,
    session_initial_url,
    session_last_session_timestamp,
    session_timestamp,
    slot,
    sref_category,
    sref_clean,
    sref_domain,
    sref_fragment,
    sref_netloc,
    sref_params,
    sref_path,
    sref_query,
    sref_scheme,
    surl_clean,
    surl_domain,
    surl_fragment,
    surl_netloc,
    surl_params,
    surl_path,
    surl_query,
    surl_scheme,
    timestamp_info,
    timestamp_info_nginx_ms,
    timestamp_info_override_ms,
    timestamp_info_pixel_ms,
    ts_action,
    ts_session_current,
    ts_session_last,
    ua_browser,
    ua_browserversion,
    ua_device,
    ua_devicebrand,
    ua_devicemodel,
    ua_devicetouchcapable,
    ua_devicetype,
    ua_os,
    ua_osversion,
    url,
    url_clean,
    url_domain,
    url_fragment,
    url_netloc,
    url_params,
    url_path,
    url_query,
    url_scheme,
    utm_campaign,
    utm_medium,
    utm_source,
    utm_term,
    utm_content,
    user_agent,
    version,
    visitor,
    visitor_ip,
    visitor_network_id,
    visitor_site_id
  from pageview_events
  left join publish_read_time_xf using (event_id)
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:25:24,788: SQL status: SELECT in 234.25 seconds
2018-01-08 19:25:24,788: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 19:25:24,788: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow__dbt_incremental_tmp'
2018-01-08 19:25:25,077: SQL status: SELECT in 0.29 seconds
2018-01-08 19:25:25,078: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 19:25:25,078: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:25:25,203: SQL status: SELECT in 0.13 seconds
2018-01-08 19:25:25,204: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 19:25:25,204: On parsely_pageview_behavior_workflow: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_pageview_behavior_workflow' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:25:25,329: SQL status: SELECT in 0.13 seconds
2018-01-08 19:25:25,333: Writing runtime SQL for node "model.parsely.parsely_pageview_behavior_workflow"
2018-01-08 19:25:25,334: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 19:25:25,334: On parsely_pageview_behavior_workflow: 
       

       delete
  from "blog_dbt_dev"."parsely_pageview_behavior_workflow"
  where (event_id) in (
    select (event_id)
    from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_pageview_behavior_workflow" ("visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time")
       (
         select "visitor", "ua_devicetouchcapable", "timestamp_info", "slot", "session", "metadata", "flag_is_fbia", "flags_is_amp", "display", "timestamp_info_pixel_ms", "timestamp_info_override_ms", "timestamp_info_nginx_ms", "session_timestamp", "session_last_session_timestamp", "metadata_save_date_tmsp", "metadata_pub_date_tmsp", "weeks_since_publish", "days_since_publish", "hours_since_publish", "videoviews", "video_engaged_time", "engaged_time", "version", "session_id", "metadata_full_content_word_count", "metadata_duration", "display_total_width", "display_total_height", "display_pixel_depth", "display_avail_width", "display_avail_height", "session_date_id", "date_id", "pageview_counter", "ip_lon", "ip_lat", "week", "year", "month", "quarter", "day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "utm_content", "utm_term", "utm_source", "utm_medium", "utm_campaign", "url_scheme", "url_query", "url_path", "url_params", "url_netloc", "url_fragment", "url_domain", "url_clean", "url", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "referrer", "ref_scheme", "ref_query", "ref_path", "ref_params", "ref_netloc", "ref_fragment", "ref_domain", "ref_clean", "ref_category", "metadata_urls", "metadata_title", "metadata_thumb_url", "metadata_tags", "metadata_share_urls", "metadata_section", "metadata_post_id", "metadata_page_type", "metadata_image_url", "metadata_data_source", "metadata_custom_metadata", "metadata_canonical_url", "metadata_authors", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "extra_data", "event_id", "campaign_id", "apikey", "action", "apikey_visitor_id", "utm_id", "parsely_session_id", "pageview_key", "pageview_post_id", "customer_apikey", "read_category", "ts_session_last", "ts_session_current", "ts_action", "read_time", "publish_time"
         from "parsely_pageview_behavior_workflow__dbt_incremental_tmp"
       );
     
2018-01-08 19:25:28,810: SQL status: INSERT 0 112891 in 3.48 seconds
2018-01-08 19:25:28,811: On parsely_pageview_behavior_workflow: COMMIT
2018-01-08 19:25:28,811: Using redshift connection "parsely_pageview_behavior_workflow".
2018-01-08 19:25:28,811: On parsely_pageview_behavior_workflow: COMMIT
2018-01-08 19:25:30,771: SQL status: COMMIT in 1.96 seconds
2018-01-08 19:25:30,772: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d446610>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:25:30,873: 19:25:30 | 24 of 25 OK created incremental model blog_dbt_dev.parsely_pageview_behavior_workflow [INSERT 0 112891 in 240.29s]
2018-01-08 19:25:30,874: 19:25:30 | 25 of 25 START incremental model blog_dbt_dev.parsely_sessions....... [RUN]
2018-01-08 19:25:30,874: Compiling model.parsely.parsely_sessions
2018-01-08 19:25:30,880: Acquiring new redshift connection "parsely_sessions".
2018-01-08 19:25:30,880: Re-using an available connection from the pool.
2018-01-08 19:25:30,880: Using redshift connection "parsely_sessions".
2018-01-08 19:25:30,880: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:25:30,903: SQL status: SELECT in 0.02 seconds
2018-01-08 19:25:30,906: Writing injected SQL for node "model.parsely.parsely_sessions"
2018-01-08 19:25:30,908: Using redshift connection "parsely_sessions".
2018-01-08 19:25:30,908: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:25:30,930: SQL status: SELECT in 0.02 seconds
2018-01-08 19:25:30,930: Using redshift connection "parsely_sessions".
2018-01-08 19:25:30,930: On parsely_sessions: select tablename as name, 'table' as type from pg_tables
        where schemaname in ('blog_dbt_dev')
        union all
        select viewname as name, 'view' as type from pg_views
        where schemaname in ('blog_dbt_dev')
2018-01-08 19:25:30,952: SQL status: SELECT in 0.02 seconds
2018-01-08 19:25:30,955: Using redshift connection "parsely_sessions".
2018-01-08 19:25:30,955: On parsely_sessions: BEGIN
2018-01-08 19:25:30,957: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:25:30,957: Using redshift connection "parsely_sessions".
2018-01-08 19:25:30,957: On parsely_sessions: create temporary table "parsely_sessions__dbt_incremental_tmp" as (
        with dbt_incr_sbq as (
          -- 1 row per session
-- Join from the parsely_pageviews and parsely_videovideos
-- aggregated: pageviews, engaged time, videoviews, video engaged time
-- should also have session visitor type, returning, new, subscribers, etc (what was true at the time of the session)
-- metrics: sessions, pageviws, videoviews, engaged time, video watch time




with incoming_sessions as (
  select
    *
  from "blog_dbt_dev"."parsely_incoming_sessions"
),




relevant_existing_entry as (

    select
      parsely_session_id,
      entry_url,
      entry_url_clean,
      entry_url_domain,
      entry_url_fragment,
      entry_url_netloc,
      entry_url_params,
      entry_url_path,
      entry_url_query,
      entry_url_scheme,
      entry_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),

relevant_existing_exit as (

    select
      parsely_session_id,
      exit_url,
      exit_url_clean,
      exit_url_domain,
      exit_url_fragment,
      exit_url_netloc,
      exit_url_params,
      exit_url_path,
      exit_url_query,
      exit_url_scheme,
      exit_ts_action
    from "blog_dbt_dev"."parsely_sessions"
    where parsely_session_id in (select parsely_session_id from incoming_sessions)

),
-- left join fields from old data: min_tstamp
unioned as (

    -- combined pageviews and videostarts
    select
    --  session_metrics
        pageviews,
        engaged_time,
        videoviews,
        video_engaged_time,
    --  id
        parsely_session_id,
        apikey_visitor_id,
    --  session user dimensions
        session_user_type,
        session_user_engagement_level,
    --  counter field
        1 as session_counter,
    --  derived fields
        flag_is_fbia,
        ts_session_current_tz,
        ts_session_last_tz,
        session_last_session_timestamp_tz,
        session_timestamp_tz,
    --  entry/exit update logic
      case when entry.entry_ts_action < id.entry_ts_action
        then entry.entry_url else id.entry_url_path end as entry_url,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_clean else id.entry_url_clean end as entry_url_clean,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_domain else id.entry_url_domain end as entry_url_domain,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_fragment else id.entry_url_fragment end as entry_url_fragment,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_netloc else id.entry_url_netloc end as entry_url_netloc,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_params else id.entry_url_params end as entry_url_params,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_path else id.entry_url_path end as entry_url_path,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_query else id.entry_url_query end as entry_url_query,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_url_scheme else id.entry_url_scheme end as entry_url_scheme,
        case when entry.entry_ts_action < id.entry_ts_action
          then entry.entry_ts_action else id.entry_ts_action end as entry_ts_action,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url else id.exit_url end as exit_url,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_clean else id.exit_url_clean end as exit_url_clean,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_domain else id.exit_url_domain end as exit_url_domain,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_fragment else id.exit_url_fragment end as exit_url_fragment,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_netloc else id.exit_url_netloc end as exit_url_netloc,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_params else id.exit_url_params end as exit_url_params,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_path else id.exit_url_path end as exit_url_path,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_query else id.exit_url_query end as exit_url_query,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_url_scheme else id.exit_url_scheme end as exit_url_scheme,
        case when exit.exit_ts_action > id.exit_ts_action
          then exit.exit_ts_action else id.exit_ts_action end as exit_ts_action,
    --  session time fields
        session_day,
        session_quarter,
        session_month,
        session_year,
        session_week,
        session_date_id,
        apikey,
        flags_is_amp,
        ip_city,
        ip_continent,
        ip_country,
        ip_lat::FLOAT8,
        ip_lon,
        ip_postal,
        ip_subdivision,
        ip_timezone,
        ip_market_name,
        ip_market_nielsen,
        ip_market_doubleclick,
        session,
        session_id,
        session_initial_referrer,
        session_initial_url,
        session_last_session_timestamp,
        session_timestamp,
        slot,
        sref_category,
        sref_clean,
        sref_domain,
        sref_fragment,
        sref_netloc,
        sref_params,
        sref_path,
        sref_query,
        sref_scheme,
        surl_clean,
        surl_domain,
        surl_fragment,
        surl_netloc,
        surl_params,
        surl_path,
        surl_query,
        surl_scheme,
        ua_browser,
        ua_browserversion,
        ua_device,
        ua_devicebrand,
        ua_devicemodel,
        ua_devicetouchcapable,
        ua_devicetype,
        ua_os,
        ua_osversion,
        user_agent,
        version,
        visitor,
        visitor_ip,
        visitor_network_id,
        visitor_site_id,
        n
    from incoming_sessions id
    left join relevant_existing_entry entry using (parsely_session_id)
    left join relevant_existing_exit exit using (parsely_session_id)
),

merged as (

    select
      * -- and aggregated min,max,sums
    from unioned


)



select
    * --and derviced fields
from merged
        )
        select * from dbt_incr_sbq
        where (TRUE)
          or (TRUE) is null
        );
2018-01-08 19:26:16,335: SQL status: SELECT in 45.38 seconds
2018-01-08 19:26:16,335: Using redshift connection "parsely_sessions".
2018-01-08 19:26:16,335: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions__dbt_incremental_tmp'
2018-01-08 19:26:16,885: SQL status: SELECT in 0.55 seconds
2018-01-08 19:26:16,886: Using redshift connection "parsely_sessions".
2018-01-08 19:26:16,886: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:26:17,024: SQL status: SELECT in 0.14 seconds
2018-01-08 19:26:17,025: Using redshift connection "parsely_sessions".
2018-01-08 19:26:17,025: On parsely_sessions: select column_name, data_type, character_maximum_length
        from information_schema.columns
        where table_name = 'parsely_sessions' AND table_schema = 'blog_dbt_dev'
2018-01-08 19:26:17,163: SQL status: SELECT in 0.14 seconds
2018-01-08 19:26:17,166: Writing runtime SQL for node "model.parsely.parsely_sessions"
2018-01-08 19:26:17,167: Using redshift connection "parsely_sessions".
2018-01-08 19:26:17,167: On parsely_sessions: 
       

       delete
  from "blog_dbt_dev"."parsely_sessions"
  where (parsely_session_id) in (
    select (parsely_session_id)
    from "parsely_sessions__dbt_incremental_tmp"
  );

       insert into "blog_dbt_dev"."parsely_sessions" ("visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz")
       (
         select "visitor", "ua_devicetouchcapable", "slot", "session", "flags_is_amp", "flag_is_fbia", "video_engaged_time", "videoviews", "engaged_time", "pageviews", "session_timestamp", "session_last_session_timestamp", "n", "version", "session_id", "session_date_id", "session_counter", "ip_lon", "ip_lat", "session_week", "session_year", "session_month", "session_quarter", "session_day", "visitor_site_id", "visitor_network_id", "visitor_ip", "user_agent", "ua_osversion", "ua_os", "ua_devicetype", "ua_devicemodel", "ua_devicebrand", "ua_device", "ua_browserversion", "ua_browser", "surl_scheme", "surl_query", "surl_path", "surl_params", "surl_netloc", "surl_fragment", "surl_domain", "surl_clean", "sref_scheme", "sref_query", "sref_path", "sref_params", "sref_netloc", "sref_fragment", "sref_domain", "sref_clean", "sref_category", "session_initial_url", "session_initial_referrer", "ip_market_doubleclick", "ip_market_nielsen", "ip_market_name", "ip_timezone", "ip_subdivision", "ip_postal", "ip_country", "ip_continent", "ip_city", "apikey", "exit_url_scheme", "exit_url_query", "exit_url_path", "exit_url_params", "exit_url_netloc", "exit_url_fragment", "exit_url_domain", "exit_url_clean", "exit_url", "entry_url_scheme", "entry_url_query", "entry_url_path", "entry_url_params", "entry_url_netloc", "entry_url_fragment", "entry_url_domain", "entry_url_clean", "entry_url", "session_user_engagement_level", "session_user_type", "apikey_visitor_id", "parsely_session_id", "exit_ts_action", "entry_ts_action", "session_timestamp_tz", "session_last_session_timestamp_tz", "ts_session_last_tz", "ts_session_current_tz"
         from "parsely_sessions__dbt_incremental_tmp"
       );
     
2018-01-08 19:26:19,377: SQL status: INSERT 0 91637 in 2.21 seconds
2018-01-08 19:26:19,378: On parsely_sessions: COMMIT
2018-01-08 19:26:19,378: Using redshift connection "parsely_sessions".
2018-01-08 19:26:19,378: On parsely_sessions: COMMIT
2018-01-08 19:26:20,432: SQL status: COMMIT in 1.05 seconds
2018-01-08 19:26:20,433: Sending event: {'category': 'dbt', 'action': 'run_model', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d48b2d0>], 'label': 'a723b6b0-5f7a-4155-9096-2b1dc6ef281f'}
2018-01-08 19:26:20,482: 19:26:20 | 25 of 25 OK created incremental model blog_dbt_dev.parsely_sessions.. [INSERT 0 91637 in 49.56s]
2018-01-08 19:26:20,557: Using redshift connection "master".
2018-01-08 19:26:20,558: On master: BEGIN
2018-01-08 19:26:20,560: SQL status: BEGIN in 0.00 seconds
2018-01-08 19:26:20,560: On master: COMMIT
2018-01-08 19:26:20,560: Using redshift connection "master".
2018-01-08 19:26:20,560: On master: COMMIT
2018-01-08 19:26:20,562: SQL status: COMMIT in 0.00 seconds
2018-01-08 19:26:20,562: Compiling operation.parsely.parsely-on-run-end-0
2018-01-08 19:26:20,567: Writing injected SQL for node "operation.parsely.parsely-on-run-end-0"
2018-01-08 19:26:20,568: Using redshift connection "master".
2018-01-08 19:26:20,568: On master:  select 1 
2018-01-08 19:26:20,571: SQL status: SELECT in 0.00 seconds
2018-01-08 19:26:20,571: 19:26:20 | 
2018-01-08 19:26:20,571: 19:26:20 | Finished running 10 view models, 15 incremental models in 1741.58s.
2018-01-08 19:26:20,571: 
2018-01-08 19:26:20,572: Completed successfully
2018-01-08 19:26:20,572: 
Done. PASS=25 ERROR=0 SKIP=0 TOTAL=25
2018-01-08 19:26:20,572: Sending event: {'category': 'dbt', 'action': 'invocation', 'context': [<snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d491e10>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d491f90>, <snowplow_tracker.self_describing_json.SelfDescribingJson object at 0x7fc27d478950>], 'label': 'end'}
2018-01-08 19:26:20,611: Flushing usage events
